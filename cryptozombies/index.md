# Cryptozombies




{{< admonition quote>}}
[크립토 좀비](https://cryptozombies.io/)에서 `Solidity`를 학습해보자.
{{< /admonition >}}

<!--more-->
<br/>

## Solidity Path: Beginner to Intermediate Smart Contracts

- [x] ch01 Making the Zombie Factory
- [x] ch02 Zombies Attack Their Victims
- [ ] ch03 Advanced Solidity Concepts
- [ ] ch04 Zombie Battle System
- [ ] ch05 ERC721 & Crypto-Collectibles
- [ ] ch06 App Front-ends & Web3.js

## CH01 Making the Zombie Factory
> 챕터1을 통과하게 되면 [나만의 좀비](https://share.cryptozombies.io/ko/lesson/1/share/leoo?id=Y3p8MTcwMTU4)를 가질 수 있다. :)

솔리디티 코드는 `Contract`안에 싸여져 있다. 컨트랙트는 이더리움 app의 기본 구성 요소로, 모든 변수/함수는 하나의 컨트랙트안에 속해 있어야 한다.
즉 컨트랙트는 모든 프로젝트의 시작 지점이라고 할 수 있다.

```sol
contract ZombieFactory {
}
```

모든 솔리디티 코드는 솔리디티의 버전을 선언 해주어야 한다. 이를 통해 새로운 컴파일러 버전이 나오더라도 코드가 깨지지 않도록 한다.

```sol
pragma solidity ^0.4.19;

contract ZombieFactory {
}
```

솔리디티에서 `state variable`는 컨트랙트 저장소에 영구적으로 저장된다. 즉 이더리움 블록체인에 기록이 된다. 
`uint`는 unsigned 즉 부호가 없는 정수로, **음이 아닌 정수**이다.  (<-> `int`)
`uint`는 `uint256`를 의미하며, 256비트 정수를 표현한다.

```sol
pragma solidity ^0.4.19;

contract ZombieFactory {
    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;
}
```

솔리디티는 c++과 마찬가지롤 `struct`를 제공한다.

```sol
pragma solidity ^0.4.19;

contract ZombieFactory {
    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;
}
```

array안에 크기를 주지 않으면 동적할당 가능하다.

```sol
// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;
```

public으로 배열을 선언할 수 있으며 `솔리디티`는 이런 배열을 위해 getter 메소드를 자동적으로 생성해준다.

```sol
Person[] public people;
```

함수의 경우 `param명`을  `언더스코어(_)`로 시작해서 전역 변수와 구별하는 것이 관례이다. 마찬가지로 `private 함수명` 또한 _를 쓰는 것이 convention이다.

```sol
    function _createZombie(string _name, uint _dna) private {
    }

    function createRandomZombie(string _name) public {
    }
```

참고로 솔리디티에서 함수는 기본적으로 public이다.
  - 누구나 또는 다른 컨트랙트가 나의 컨트랙트 함수를 호출하고 코드를 실행할 수 있다.

솔라디티는 함수가 데이터를 read만 하고 state change를 하지 않을 때 
`view 함수`를 사용한다.

```sol
function sayHello() public view returns (string) {
}
```


또한 `pure 함수`도 가지고 있는데, 이는 함수가 앱에서 어떤 데이터도 접근하지 않는(read, write둘다 하지 x) 것을 의미한다.

```sol
function _multiply(uint a, uint b) private pure returns (uint) {
  return a * b;
}
```


이더리움은 `SHA3`의 버전 중 하나인 `keccak256`를 내장 해시 함수로 가지고 있다. 해시 함수는 기본적으로 입력 스트링을 `랜덤 256bit 16진수`로 매핑한다.

{{< admonition question>}}
블록체인에서 **안전한 의사 난수 발생기**는 어려운 문제라고 한다고 하는데 `hash collision`과 관련해서 어렵다고 하는 걸까? 아니면 안전하다고 하는게 `Oracle`?과 관련이 있는 걸까?
{{< /admonition >}}

```sol
//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256("aaaab");
//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256("aaaac");
```

`event`는 생성한 컨트랙트가 블록체인 상에서 앱에 접근하는 사용자 layer에서 액션이 발생했을 때, 통신하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는지 "listen"하며, 그 이벤트가 발생하면 `action`을 취한다.

```sol
// 이벤트를 선언한다
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다:
  IntegersAdded(_x, _y, result);
  return result;
}
```

### Summary

지금까지의 과정을 정리하면 아래와 같은 코드가 최종적으로 만들어진다.

```sol
pragma solidity ^0.4.19;

contract ZombieFactory {

    event NewZombie(uint zombieId, string name, uint dna);


    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }

    Zombie[] public zombies;

    function _createZombie(string _name, uint _dna) private {
        uint id = zombies.push(Zombie(_name, _dna)) - 1; // push returns length
        NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
    }

    function createRandomZombie(string _name) public {
        uint randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }

}
```

```js
// 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.

// 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
  ZombieFactory.createRandomZombie(name)
})

// `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// 좀비 DNA 값을 받아서 이미지를 업데이트한다
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
    // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
    // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 셔츠 타입에는 6가지가 있다:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}
```

## Zombies Attack Their Victims

### `Mappings` and `Addresses`

이더리움 블록체인은 은행계좌와 같은 `account`를 사용해서 유저를 식별합니다. 
이때 각 `account`들은 이더리움 블록체인상의 coin인 `ether`를 단위로 `balance`를 가지게 됩니다.
이를 `통화`를 통해 각 계정은 송금/인출 등의 은행과 같은 기능들을 할 수 있습니다. 이를 위해 이더리움에서 각 계정은 은행 계좌 번호와 같은 `address`를 가지고 있으며, 

여기서 말하는 `address`는 `EOA`(Extenally Owned Account)의 address입니다. 보통은 `EOA`간의 메세지는 이더를 보내지만, EOA는 컨트랙트 어카운트에 메세지를 보내 해당 코드를 실행 시킬 수 도 있습니다. 

`Mapping`은 기본적으로 python의 `dict`와 같은 key-value 저장소입니다.

```sol
contract ZombieFactory {

    ...
    mapping (uint => address) public zombieToOwner;
    mapping (address => uint) ownerZombieCount;

    ...
}
```

### `Msg.sender`

`solidity`에는 모든 함수에서 이용 가능한 특정 전역 변수들이 있는데, 그 중의 하나가 **현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소**를 가리키는 `msg.sender`이다.


{{< admonition tip>}}
`solidity`에서 함수 실행은 항상 `external caller`(외부 호출자)가 시작하며, 컨트랙트는 외부에서 함수를 호출  하기 전까지 블록체인 상에서 아무것도 하지 않는다.

즉 스마트 컨트랙트는 `msg.sender`(호출자)가 항상 존재합니다.
{{< /admonition >}}

```sol
mapping (address => uint) favoriteNumber;

function setMyNumber(uint _myNumber) public {
  favoriteNumber[msg.sender] = _myNumber;
}

function getMyNumber() public view returns (uint) {
  return favoriteNumber[msg.sender];
}
```

### `Require` 
특정 조건이 True가 아닐 경우, 에러를 발생시키고 함수를 벗어나게 됩니다. 

```sol
function sayHiToLeoo(string _name) public returns (string) {
  // solidity는 고유의 스트링 비교 기능이 없다. 그러므로 keccak256 해시값을 
  // 비교해 스트링이 같은 값인지 판단하는 코드
  require(keccak256(_name) == keccak256("Leoo.j"));
  
  return "Hi";
}
```

### `Inheritance`

```sol
contract Animal {
  function cry() public returns (string) {
    return "Default cry";
  }
}

contract Dog is Animal {
  function cry() public returns (string) {
    return "Bark";
  }
}
```

### `Import`

파일들로 코드를 분리하고, 다른 파일에 있는 코드를 불러오고 싶을 때, 솔리디티는 `import`라는 keyword를 사용합니다.

```sol
import "./someothercontract.sol"; // SomeOtherContract

contract newContract is SomeOtherContract {

}
```

### Storage vs Memory

`solidity`가 변수를 저장할 수 있는 공간에는 2가지 종류가 있습니다.

- `storage`
- `memory`

`Storage`는 블록체인 상에 영구적으로 저장되는 변수들입니다. `state variable`(함수 외부에 선언된 변수)인 경우 초기 설정상 `Storage`로 관리되어 블록체인 상에 영구적으로 저장됩니다.

이와 반대로 함수 내부에 선언된 변수는 `memory`로 자동 선언되어 함수 호출 종료시 사라지게 됩니다.

단 명시적으로 `storage`, `memory` 키워드들을 사용해주어야 하는 상황이 존재하는데, 바로 함수 내에서 `struct`, `배열`을 처리할 때 입니다.


```sol
contract SandwichFactory {
  struct Sandwich {
    string name;
    string status;
  }

  Sandwich[] sandwiches; // state variable (storage)

  function eat(uint _idx) public {
    string defaultState = "NOT EATEN"; // implicit memory
    Sandwich storage mySandwich = sandwiches[_idx]; // arr should explict

    Sandwich memory anotherSandwich = sandwiches[_idx + 1];
    sandwiches[_idx + 1] = anotherSandwich;
  }
}
```

```sol
pragma solidity ^0.4.19;

import "./zombiefactory.sol";

contract ZombieFeeding is ZombieFactory {

  function feedAndMultiply(uint _zombieId, uint _targetDna) public {
      require(msg.sender == zombieToOwner[_zombieId]);
      Zombie storage myZombie = zombies[_zombieId];
  }

}
```

### Extra Function Visibility

`solidity`에는 public과 private 이외에도 `internal`과 `external`이라는 함수 접근 제어자가 있다.

- `internal`
  - 상속하는 컨트랙트에서도 접근 가능 (java protected와 비슷해 보임?)
  - 나머지는 private과 동의
- `external`
  - 컨트랙트 바깥에서만 호출 될 수 있음
  - 컨트랙트 내의 다른 함수에 의해 호출될 수 없다.
  - 나머지는 public과 동의

`internal`은 상속하는 컨트랙트에서도 접근 가능하다는 점을 제외하면 private과 같다. 느낌 상 java의 `protected`와 유사해 보이며, `state variable`은 default로 internal 접근자를 가진다.

`external`은 **함수가 컨트랙트 바깥에서만 호출** 될 수 있고 **컨트랙트 내의 다른 함수에 의해서 호출 될 수 없다**는 부분만 제외하면 public과 같다.

```sol
contract Sandwich {
  uint private sandwichesEaten = 0;

  function eat() internal {
    sandwichesEaten++;
  }
}

contract BLT is Sandwich {
  uint private baconSandwichesEaten = 0;

  function eatWithBacon() public returns (string) {
    baconSandwichesEaten++;
    // eat 함수가 internal로 선언되었기 때문에 여기서 호출이 가능하다 
    eat();
  }
}
```

### interface
