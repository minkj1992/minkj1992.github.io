[{"categories":[""],"content":"Core Components Tracking, tracking server Log training statics Log retrieval register a model, to enable deployment Model Registry, versioning LLM deployment Evaluate Prompt engineering UI Recipes, guided scenarios Projects, packagin ml code, workflow, artifact ","date":"2024-04-06","objectID":"/mlflow_doc/:0:0","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"1. MLflow Tracking https://mlflow.org/docs/latest/tracking.html The MLflow Tracking is an API and UI for logging parameters, code versions, metrics, and output files when running your machine learning code and for later visualizing the results. MLflow Tracking provides Python, REST, R, and Java APIs. ","date":"2024-04-06","objectID":"/mlflow_doc/:1:0","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"Concepts Tracking에는 Experiments와 Run 총 2가지의 개념이 존재합니다. Runs: script execution에 대한 tracking 단위 with mlflow.start_run():을 통해서 mlflow.start_run() + mlflow.end_run()를 자동으로 실행합니다. mlflow.autolog()를 통해서 세팅할 수도 있습니다. Experiments: Group of Runs import mlflow with mlflow.start_run(): mlflow.log_param(\"lr\", 0.001) # Your ml code ... mlflow.log_metric(\"val_loss\", val_loss) 위와 같은 코드를 실행시키면 1번의 run이 실행생성되며, 이때 별다른 Backend Stores 와 Artifact Stores 를 설정하지 않았으면 local의 ./mlruns로 backend stores 그리고 artifact stores가 지정됩니다. 좀더 상세히 설명하자면, Tracking run을 실행하게되면 그 결과로 artifact들과 run의 metadata들이 생성됩니다. 이를 저장하는 방식에 따라서 mlflow에서는 총 2가지로 구분합니다. Backend Store: persist metadata for each run, experiment i.e run ID, start ~ end time parameter, metrics Artifact Store: run을 실행하고 생성된 artifact 일반적으로 model, model weight, images, data files(parquet)와 같이 large file을 관리합니다. ","date":"2024-04-06","objectID":"/mlflow_doc/:1:1","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"Tracking server 생성된 metadata(backend store)와 artifact(artifact store)들을 UI 상에서 보여주고 싶으면 mlflow tracking server를 실행시켜야 합니다. # 1. default 127.0.0.1:5000 mlflow server # 2. ui is alias of server $ mlflow ui # 3. explictly notate host and post $ mlflow server --host 127.0.0.1 --port 8080 FYI, 아래 코드 참조하면 mlflow ui는 mlflow server의 alias입니다. # mlflow/cli.py class AliasedGroup(click.Group): def get_command(self, ctx, cmd_name): # `mlflow ui` is an alias for `mlflow server` cmd_name = \"server\" if cmd_name == \"ui\" else cmd_name return super().get_command(ctx, cmd_name) tracking server를 실행하게 되면, ./mlruns의 artifact들을 읽어들입니다. 이를 도식화해보면 아래와 같습니다. 만약 python api를 통해서 tracking server를 실행시키고 싶다면 아래와 같이 할 수 있습니다. # search for runs that has the best validation loss among all runs in the experiment. client = mlflow.tracking.MlflowClient() experiment_id = \"0\" best_run = client.search_runs( experiment_id, order_by=[\"metrics.val_loss ASC\"], max_results=1 )[0] print(best_run.info) # {'run_id': '...', 'metrics': {'val_loss': 0.123}, ...} ","date":"2024-04-06","objectID":"/mlflow_doc/:1:2","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"2. LLMs https://mlflow.org/docs/latest/llms/index.html MLflow also support for LLMs aims to abstract(with unified interface) inticating processes while building and deploying llm products. ","date":"2024-04-06","objectID":"/mlflow_doc/:2:0","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"2.1. Concepts MLflow가 현재(2.11.3) LLM관련 제공하는 feture들을 group화 시키면 아래와 같습니다. Deployment Server LLM Evaluate Prompt Engineering UI LLM Tracking System ","date":"2024-04-06","objectID":"/mlflow_doc/:2:1","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"2.2. Deployments Server previously known as AI Gateway, learn more Benefit Deployments Server simplifies interactions with multiple llm providers. It has a lot of benefits such as following below. Unified endpoint: Don’t have to juggle between multiple provider APIs. Simplified intefrations Secure credential Management Manges API keys in centralized storage No more hard-coded cert keys Seamless provider swapping Swap providers without change codes. Zero downtime provider, model or route swapping. Deep dive to deployments server $ poetry add 'mlflow[genai]' export OPENAI_API_KEY=your_api_key_here 위의 세팅을 한 뒤, 아래 config.yaml을 생성하여 LLM deployment server의 스펙을 정의해줍니다. # config.yamlendpoints:- name:completionsendpoint_type:llm/v1/completionsmodel:provider:openainame:gpt-3.5-turboconfig:openai_api_key:$OPENAI_API_KEYlimit:renewal_period:minutecalls:10- name:chatendpoint_type:llm/v1/chatmodel:provider:openainame:gpt-3.5-turboconfig:openai_api_key:$OPENAI_API_KEY- name:embeddingsendpoint_type:llm/v1/embeddingsmodel:provider:openainame:text-embedding-ada-002config:openai_api_key:$OPENAI_API_KEY 이후 mlflow deployments cli를 실행시켜줍니다. mlflow deployments start-server --config-path config.yaml --port 8080 --host localhost --workers 2 cli 명령어가 실행되면 아래 코드가 동작하게 되며 worker를 지정해 준 만큼 uvicorn 객체가 실행됩니다. # mlflow/deployments/server/runner.py def start(self) -\u003e None: self.process = subprocess.Popen( [ sys.executable, \"-m\", \"gunicorn\", \"--bind\", f\"{self.host}:{self.port}\", \"--workers\", str(self.workers), \"--worker-class\", \"uvicorn.workers.UvicornWorker\", f\"{app.__name__}:create_app_from_env()\", ], env={ **os.environ, MLFLOW_DEPLOYMENTS_CONFIG.name: self.config_path, }, ) uvicorn은 ASGI를 구현한 구현체이며, 내부적으로 uvloop를 사용하고 있습니다. uvloop는 Cython과 libuv(v8 engine event loop)를 사용해 구현되어있습니다. 보통 uvicorn을 multi process (core, parallel)에서 사용할 때는 gunicorn을 사용하며, uvicorn 내부적으로 uvicorn.workers.UvicornWorker라는 gunicorn과 compatible한 worker 구현체를 가지고 있어 이를 사용합니다. FYI, pyhton 3.12 부터는 sub interpreters가 도입되어, startup에대한 속도를 끌어올렸다고 하는데 더 자세한 내용은 아래를 참고하시면 됩니다. Running Python Parallel Applications with Sub Interpreters . 이걸 보다보면 Ray core나 dask parallel 같은 프레임워크는 GIL을 어떤 방식으로 우회하는지 궁금하네요. 이제 http://127.0.0.1:8080/docs로 이동하게되면 아래와 같은 swagger를 확인할 수 있습니다. 만약 config.yaml을 수정하고 save 한다면, deployemnt server의 swagger 또한 변경 된것을 확인할 수 있을 겁니다. # mlflow/deployments/server/runner.py def run_app(config_path: str, host: str, port: int, workers: int) -\u003e None: config_path = os.path.abspath(os.path.normpath(os.path.expanduser(config_path))) with Runner( config_path=config_path, host=host, port=port, workers=workers, ) as runner: for _ in monitor_config(config_path): _logger.info(\"Configuration updated, reloading workers\") runner.reload() 이는 deployment server를 실행하게 되면, 아래 gunicorn으로 실행되는 runner 객체가 생성되고 난 뒤, monitor_config(config_path)를 호출 하면서, config file을 계속 watch하고 있기 때문입니다. 만약 아래와 같은 에러가 도중에 발생한다면, known issue(psutil을 따로 관리하는 게 의도된)이므로, 그냥 pip install psutil 또는 poetry add psutil을 통해서 다운로드 받으시면 됩니다. ``` File \"/Users/minwook/code/personal/mlflow-demo/.venv/lib/python3.11/site-packages/mlflow/gateway/utils.py\", line 71, in kill_child_processes import psutil ModuleNotFoundError: No module named 'psutil' ``` class Runner: ... def reload(self) -\u003e None: kill_child_processes(self.process.pid) 만약 file에 변경이 일어나게되면 runner.reload()를 통해서 process의 child들인 uvicorn.workers.UvicornWorker들이 종료되게 됩니다. 하지만 parent인 gunicorn은 종료되지 않았기 때문에, 새로운 config를 읽어서 uvicorn worker들이 재실행됩니다. from watchfiles import watch def monitor_config(config_path: str) -\u003e Generator[None, None, None]: with open(config_path) as f: prev_config = f.read() for changes in watch(os.path.dirname(config_path)): if not any((path == config_path) for _, path in changes): continue if not os.path.exists(config_path): _logger.warning(f\"{config_path}deleted\") continue with open(config_path) as f: config = f.read() if config == prev_config: continue try: _load_route_config(config_path) except Exception as e: _logger.warning(\"Invalid configuration: %s\", e) c","date":"2024-04-06","objectID":"/mlflow_doc/:2:2","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"LLM Tracking ","date":"2024-04-06","objectID":"/mlflow_doc/:2:3","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"3. Evaluate","date":"2024-04-06","objectID":"/mlflow_doc/:3:0","tags":["dev"],"title":"Mlflow Document","uri":"/mlflow_doc/"},{"categories":[""],"content":"go channel and scheduler 1. Go channels Understanding Channels ","date":"2024-03-04","objectID":"/go-channel/:0:0","tags":["dev"],"title":"(WIP) Go Channel and Scheduler","uri":"/go-channel/"},{"categories":[""],"content":"Make channel G1, G2 channel has mutex copy elements ","date":"2024-03-04","objectID":"/go-channel/:1:0","tags":["dev"],"title":"(WIP) Go Channel and Scheduler","uri":"/go-channel/"},{"categories":[""],"content":"If full? P: context for scheduling P는 context를 들고 있으며, channel buffer가 full 되면 full된 버퍼로 task를 send하는 goroutine은 pausing되며 (receiver goroutine이 pause되는게 아니다.) go runtime scheduler로 gopark이 호출하여, pause를 진행한다. sender goroutine은 waiting state가 되며, 해당 고루틴의 os thread (M)과의 association을 지운다. Q. wait되는 goroutine은 어디에 저장되는가? (https://www.linkedin.com/pulse/golang-how-does-goroutine-parks-chung-yi-kao/ ) gobuf는 g struct안의 sched에서 사용된다. P가 들고있던 run queue에서 runnable goroutine을 pop한다. 2. Go scheduler Go scheduler: Implementing language with lightweight concurrency ","date":"2024-03-04","objectID":"/go-channel/:2:0","tags":["dev"],"title":"(WIP) Go Channel and Scheduler","uri":"/go-channel/"},{"categories":[""],"content":"Refs 원본 유튜브 영상 한글: go scheduler Schduling In Go Illustrated Tales of Go Runtime Scheduler. Go Concurrency Series: Deep Dive into Go Scheduler(I) c.f Understanding the python GIL https://dabeaz.blogspot.com/2010/02/revisiting-thread-priorities-and-new.html ","date":"2024-03-04","objectID":"/go-channel/:3:0","tags":["dev"],"title":"(WIP) Go Channel and Scheduler","uri":"/go-channel/"},{"categories":["dev","go","computer science"],"content":"Learn about Multithreading, Concurrency \u0026 Parallel programming with practical and fun examples in Google’s Go Lang. ","date":"2024-02-19","objectID":"/concurrency-go/:0:0","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"1. Introduction Concurrency의 세계에서는 thread 수를 아무리 높이더라도, 일정 수준이 지나면 병목현상이 생긴다. ","date":"2024-02-19","objectID":"/concurrency-go/:1:0","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"Amdal’s law Focus on latency (speed up) 암달의 법칙은 컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는 데 사용된다. 1 / ((1-p) + (p/s)) 작업의 portion이 낮은 작업을 아무리 개선시키더라도, 시스템 전체에 미치는 영향은 미미하다. 즉 전체 작업의 효율을 최대한 증가시키고 싶다면 그 중에 가장 비중이 큰 작업부터 초점을 맞추는 것이 좋다. (도표와 같이) 아무리 병렬작업이 늘어나더라도, 병렬화가 불가능한 작업들에 의해 병목현상이 발생하여 speedup의 한계가 정해지게 된다. from pprint import pprint def amdahl(p,s): \"\"\" Amdahl's law p is the proportion of execution time that the part benefiting from improved resources originally occupied. s is the speedup of the part of the task that benefits from improved system resources. \"\"\" return 1 / ((1-p) + (p/s)) def simulate(): # represents p in amdahl's law portion = [95/100, 90/100, 75/100, 50/100] # represents s in amdahl's law number_of_processors = [1,2,4,8,16,32,64,128,256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536] for s in number_of_processors: print(f'##################number_of_processors:{s}#############') for p in portion: pprint(f'parallel portion:{p}, speedup: {amdahl(p,s)}') simulate() \"\"\" ##################number_of_processors:1############# 'parallel portion:0.95, speedup: 1.0' 'parallel portion:0.9, speedup: 1.0' 'parallel portion:0.75, speedup: 1.0' 'parallel portion:0.5, speedup: 1.0' ##################number_of_processors:2############# 'parallel portion:0.95, speedup: 1.9047619047619047' 'parallel portion:0.9, speedup: 1.8181818181818181' 'parallel portion:0.75, speedup: 1.6' 'parallel portion:0.5, speedup: 1.3333333333333333' ##################number_of_processors:4############# 'parallel portion:0.95, speedup: 3.478260869565217' 'parallel portion:0.9, speedup: 3.0769230769230775' 'parallel portion:0.75, speedup: 2.2857142857142856' 'parallel portion:0.5, speedup: 1.6' ##################number_of_processors:8############# 'parallel portion:0.95, speedup: 5.925925925925925' 'parallel portion:0.9, speedup: 4.7058823529411775' 'parallel portion:0.75, speedup: 2.909090909090909' 'parallel portion:0.5, speedup: 1.7777777777777777' ##################number_of_processors:16############# 'parallel portion:0.95, speedup: 9.142857142857139' 'parallel portion:0.9, speedup: 6.400000000000001' 'parallel portion:0.75, speedup: 3.3684210526315788' 'parallel portion:0.5, speedup: 1.8823529411764706' ##################number_of_processors:32############# 'parallel portion:0.95, speedup: 12.54901960784313' 'parallel portion:0.9, speedup: 7.8048780487804885' 'parallel portion:0.75, speedup: 3.657142857142857' 'parallel portion:0.5, speedup: 1.9393939393939394' ##################number_of_processors:64############# 'parallel portion:0.95, speedup: 15.421686746987941' 'parallel portion:0.9, speedup: 8.767123287671234' 'parallel portion:0.75, speedup: 3.8208955223880596' 'parallel portion:0.5, speedup: 1.9692307692307693' ##################number_of_processors:128############# 'parallel portion:0.95, speedup: 17.414965986394545' 'parallel portion:0.9, speedup: 9.343065693430658' 'parallel portion:0.75, speedup: 3.9083969465648853' 'parallel portion:0.5, speedup: 1.9844961240310077' ##################number_of_processors:256############# 'parallel portion:0.95, speedup: 18.618181818181803' 'parallel portion:0.9, speedup: 9.66037735849057' 'parallel portion:0.75, speedup: 3.9536679536679538' 'parallel portion:0.5, speedup: 1.9922178988326849' ##################number_of_processors:512############# 'parallel portion:0.95, speedup: 19.284369114877574' 'parallel portion:0.9, speedup: 9.827255278310943' 'parallel portion:0.75, speedup: 3.9766990291262134' 'parallel portion:0.5, speedup: 1.996101364522417' ##################number_of_processors:1024############# 'parallel portion:0.95, speedup: 19.635666347075723' 'parallel portion:0.9, speedup: 9.912875121006778' 'parallel portion:0.75, speedup: 3.988315481986368' 'parallel portion:0.5, speedup: 1.9980487804878049' ##################number_of_processors:2048############# 'parallel portion:0.95, speedup: 19.816158684083195' 'parallel portion:0.9, speedup: 9.956246961594557' 'parallel porti","date":"2024-02-19","objectID":"/concurrency-go/:1:1","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"Gustafson’s law Focus on Throughput S(P)=P−a(P−1) P: 프로세서의 갯수 a: 병렬화되지 않는 부분의 비율 S(P): 이론상 성능 향상 비율 성능 향상은 같은 시간 동안 처리하는 데이터량의 비율을 의미한다. Useful refs ","date":"2024-02-19","objectID":"/concurrency-go/:1:2","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"2. Creating and using thread ","date":"2024-02-19","objectID":"/concurrency-go/:2:0","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"process vs thread vs green thread 먼저 process는 memory space를 isolate하게 관리하며, fork()를 통해서 복사된다. thread는 memory space를 공유하기 때문에 isolate하지 않으며, thread간 context switch에 따른 overhead가 발생한다. 아래는 single processor에서 multi thread를 표현한 그림이다. context switch의 오버헤드는 스레드 수가 많지 않다면 큰 비중을 차지 하지 않지만, 스레드 수가 커짐에 따라 문제가 발생한다. 이에 대한 대안으로 green thread가 사용되는데, green thread는 쉽게 말해 user level thread로 kernel level thread(흔히 우리가 말하는 thread)과 1:n관계를 가진다. 하나의 kernel thread안에서 여러 green thread가 존재하기 때문에, 연산중이 kernel thread안에 존재하는 특정 green thread에서 IO 연산이 필요하여 Interrupt가 발생할 경우, io 연산이 불필요한 green thread들 까지 불필요하게 cpu연산을 하지 못하게 된다. kernel thread의 green thread중 일부에서 io interrupt이 발생하면 나머지 kernel thread에 존재하는 다른 green thread들도 cpu연산이 block되어서 java나 python계열에서 g-thread를 사용하려면 asnyc로 io를 처리해야 한다. “When a green thread executes a blocking system call, not only is that thread blocked, but all of the threads within the process are blocked. To avoid that problem, green threads must use asynchronous I/O operations, although the increased complexity on the user side can be reduced if the virtual machine implementing the green threads spawns specific I/O processes (hidden to the user) for each I/O operation.” Wikipedia 이를 해결하기 위해 golang에서는 hybrid 방식의 green thread를 사용한다. 즉 io가 필요한 green trhead가 발생할 경우, 동일한 방식으로 io interrupt를 시키면서 새로운 kernel level thread를 만들어주어, io연산이 불필요한 green thread들을 새로운 스레드로 넣어주어 효과적으로 동작하도록 한다. ","date":"2024-02-19","objectID":"/concurrency-go/:2:1","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"Boids algorithm https://en.wikipedia.org/wiki/Boids Boids is an ai program, developed by Craig Reynolds in 1986, which simulates the flocking behavior of birds. The rules applied in the simplest Boids world are as follows separation: 무리가 붐비지 않도록 반대 방향으로 이동(steer to avoid crowding local flockmates) alignment: 무리의 평균 방향으로 이동 (steer towards the average heading of local flockmates) cohesion: 무리의 평균 위치를 향해 이동 (steer to move towards the average position, which is center of mass of local flockmates) ","date":"2024-02-19","objectID":"/concurrency-go/:2:2","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go","computer science"],"content":"From Gorang docs https://go.dev/tour/concurrency/1 https://gobyexample.com/goroutines Goroutines run in the same address space, so access to shared memory must be synchronized. By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables. A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression Channels aren’t like files; you don’t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop. A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. ","date":"2024-02-19","objectID":"/concurrency-go/:3:0","tags":["dev","concurrency"],"title":"Concurrency Go","uri":"/concurrency-go/"},{"categories":["dev","go"],"content":"Real implementation of value parts type in golang ","date":"2024-02-12","objectID":"/go-value-parts/:0:0","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"Value Parts https://go101.org/article/value-part.html 하나의 value가 하나의 메모리 block을 차지하는 C와 달리, golang은 몇몇 types들이 하나 이상의 memory block에 할당될 수도 있습니다. 이렇게 다른 메모리 블록들에서 part되어 분포되는 value의 구성요소들을 value parts라고 칭합니다. 하나 이상의 메모리 블록에 hosting되는 value는 direct value part와 여러개의 underlying indirect parts로 구성됩니다. go101 문서가 비약이 좀 많은 것 같습니다. 예를 들면 “Each C value in memory occupies one memory block (one continuous memory segment).” 라는 주장에 대해서 아래와 같이 반박할 수 있습니다. C 언어에서도 모든 값이 단일 메모리 블록에 저장된다는 주장은 정확하지 않습니다. 구조체, 배열, 포인터와 같은 데이터 타입들은 여러 메모리 블록에 걸쳐 저장될 수 있습니다. 예를 들어, 구조체는 각 멤버 변수가 서로 다른 메모리 위치에 저장될 수 있고, 큰 배열은 여러 블록에 분포될 수 있으며, 포인터가 가리키는 변수는 별도의 메모리 블록에 저장됩니다. 따라서 Go 언어와 마찬가지로 C 언어에서도 값의 복잡성에 따라 메모리 분포가 다양할 수 있다. https://github.com/go101/go101/issues/270 에 관련된 doc fix issue를 넣었습니다. Solo Direct Value Part는 단일 메모리 블록에 저장되는 값을 의미합니다. 즉, 값 전체가 하나의 연속된 메모리 공간에 존재합니다. Direct value part: 포인터의 value처럼 reference 하는 address value serveral underlying indirect parts: 여러 메모리 블록에 분산되어 있는 값의 각 부분 아래는 golang에서 지원하는 type을 multiple value parts 여부 (메모리 블록 갯수)로 나눈 테이블입니다. Types whose values each is only hosted on one single memory block (solo direct value part) Types whose values each may be hosted on multiple memory blocks (direct part -\u003e underlying direct part) boolean typesnumeric typespointer typesunsafe pointer typesstruct typesarray types slice typesmap typeschannel typesfunction typesinterface typesstring types * Note 인터페이스와 문자열 값에 기본 부분이 포함될 수 있는지 여부는 컴파일러에 따라 다릅니다. 표준 Go 컴파일러 구현의 경우 인터페이스 및 문자열 값에 기본 부분이 포함될 수 있습니다. 함수 값에 기본 부분이 포함될 수 있는지 여부를 증명하는 것은 거의 불가능합니다. 어째서 101문서에서 pointer, unsafe pointer를 solo direct value part로 구분했는지 모르곘다. 관련된 문의 pr을 올렸다. https://github.com/go101/go101/issues/269 ","date":"2024-02-12","objectID":"/go-value-parts/:1:0","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"Internal definitions 그럼 이제 실제 2번째 type들의 내부 definitions들을 살펴보겠습니다. ","date":"2024-02-12","objectID":"/go-value-parts/:2:0","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"map, channel and function types // map types // map types type _map *hashtableImpl // channel types type _channel *channelImpl // function types type _function *functionImpl 3가지 유형은 내부적으로 그냥 포인터 유형입니다. ","date":"2024-02-12","objectID":"/go-value-parts/:2:1","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"slice type _slice struct { // referencing underlying elements elements unsafe.Pointer // number of elements and capacity len, cap int } 슬라이스 유형은 pointer wrapper struct types입니다. Unsafe Pointer Go의 unsafe 패키지에 정의된 Unsafe Pointer는 언어의 타입 안전성 시스템을 우회하여 직접 메모리 접근을 수행할 수 있게 해줍니다. 이를 통해 성능 최적화, 시스템 레벨 프로그래밍, interfacing with non-Go 코드 등에 필요할 수 있습니다. 또한 일반 pointer 타입이 형변환이 불가한 것과 달리, 타입 시스템을 우회하는 unsafe pointer는 형변환이 가능합니다. (물론 일반 pointer도 reflect을 사용해서 runtime에 형변환을 시키는 방법도 있습니다.) ","date":"2024-02-12","objectID":"/go-value-parts/:2:2","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"string type _string struct { elements *byte // referencing underlying bytes len int // number of bytes } string 또한 pointer wrapper struct type입니다. ","date":"2024-02-12","objectID":"/go-value-parts/:2:3","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"interface blank interface type type _interface struct { dynamicType *_type // the dynamic type dynamicValue unsafe.Pointer // the dynamic value } standard go compiler에서 위의 정의를 blank interface types에만 사용합니다. Blnak interface types are the interface types which don’t specify any methods. non-blacnk interface type type _interface struct { dynamicTypeInfo *struct { dynamicType *_type // the dynamic type methods []*_function // method table } dynamicValue unsafe.Pointer // the dynamic value } ","date":"2024-02-12","objectID":"/go-value-parts/:2:4","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev","go"],"content":"copy Underlying Value Parts Are Not Copied in Value Assignments Golang에서 parameter passing을 포함한 value Assignments는 shallow value copy입니다. (단, destination과 source value의 타입이 같을 경우에만) 만약 타입이 다른 value끼리의 value assignment는 implicitly converted 되어 assignment가 진행됩니다. 일반적인 값 할당 (shallow copy) direct part만 복사됩니다. underlying value part은 참조만 복사됩니다. 결과적으로 원본 값과 복사된 값은 underlying value part을 공유하게 됩니다. 문자열과 인터페이스의 특수 케이스: 위의 shallow copy와 달리 Go FAQ 에 따르면, 인터페이스 value가 copy될 때,underlying value part 또한 copy되어야 한다고 합니다. 이론적으로는 underlying value part도 함께 복사되어야 하지만, 내부적으로는 그렇지 않습니다. 실제 동작에서는 인터페이스의 dynamic value는 read only이기 때문에, Go 컴파일러/런타임은 최적화를 위해 underlying value part를 복사하지 않습니다. 이는 string또한 똑같이 적용됩니다. 결론: 표준 Go 컴파일러/런타임에서 모든 타입의 값 할당은 direct part만 복사하고, underlying value part은 공유합니다. 문자열과 인터페이스는 컴파일러 최적화로 인해 이론과 약간 차이가 있습니다. unsafe.Sizeof 함수는 direct part의 크기만 반환하며, underlying value part은 포함하지 않습니다. ","date":"2024-02-12","objectID":"/go-value-parts/:3:0","tags":["dev","golang","go"],"title":"Go Value Parts","uri":"/go-value-parts/"},{"categories":["dev"],"content":"How typescript api compiles ts to js? I’ve already wrote a simple typescript compiler blog post before, this is the more deeper version of typescript compiler api. ","date":"2024-02-06","objectID":"/compiler/:0:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"Reference How the TypeScript Compiler Compiles - understanding the compiler internal Typescript Compiler API ","date":"2024-02-06","objectID":"/compiler/:1:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"Program typescript/src/compiler/program.ts import * as ts from \"typescript\"; const program = ts.createProgram(fileNames, options); // code -\u003e ast const checker = program.getTypeChecker(); // binding, type check program.emit() // ast -\u003e code typescript는 program을 생성하고, type check를 한 뒤, emit하는 방식으로 컴파일이 진행됩니다. ms doc에 따르면 아래 helper function을 사용하면 더 쉽게 컴파일이 가능합니다. import * as ts from \"typescript\"; const source = \"let x: string = 'string'\"; let result = ts.transpileModule(source, { compilerOptions: { module: ts.ModuleKind.CommonJS }}); console.log(JSON.stringify(result)); 이를 real world로 예를 든다면 아래 와 같이 isolated 환경에서 dynamic하게 custom code를 받아서 transpile 후 실행 시킬 수 있습니다. import { Script, createContext } from \"node:vm\"; import ts from \"typescript\"; import AuthorDbWrapper from './dbwrapper.js' // \"import dayjs from \\\"dayjs\\\"; // import timezone from \\\"dayjs/plugin/timezone.js\\\"; // import utc from \\\"dayjs/plugin/utc.js\\\"; // export default async (input: Input): Promise\u003cRecord\u003cstring, any\u003e\u003e =\u003e { // dayjs.extend(timezone); // dayjs.extend(utc); // interface People { // name: string; // email: string; // age: number; // birth: Date | null; // } // // imported from context // const authors: People[] = AuthorDbWrapper.select( // { // deleted_at: undefined // } // ) // return { authors } // }\" const customCode = \"import dayjs from \\\"dayjs\\\";\\nimport timezone from \\\"dayjs/plugin/timezone.js\\\";\\nimport utc from \\\"dayjs/plugin/utc.js\\\";\\n\\nexport default async (input: Input): Promise\u003cRecord\u003cstring, any\u003e\u003e =\u003e {\\n dayjs.extend(timezone);\\n dayjs.extend(utc);\\n\\n interface People {\\n name: string;\\n email: string;\\n age: number;\\n birth: Date | null;\\n }\\n // imported from context\\n const authors: People[] = AuthorDbWrapper.select(\\n {\\n deleted_at: undefined, name:input.name\\n }\\n )\\n return { authors }\\n}\" const exportTargets = { AuthorDbWrapper, // ... } const logContainer = new LogContainer(); const output = ts.transpileModule(customCode, { compilerOptions: { module: ts.ModuleKind.CommonJS, esModuleInterop: true, sourceMap: true, }, }); const transpiled = output.outputText; // Instances of the `vm.Script` class contain precompiled scripts that can be executed in specific contexts. const script = new Script(transpiled); const context = createContext({ require, exports: {}, module: { exports: {}, }, console: logContainer, setTimeout, ...exportTargets, // already compiled codes }); const func = script.runInNewContext(context); // result const authors = await func(\"minwook\"); 자 이제 그럼 다시 compiler로 들어가보도록 하겠습니다. 앞서 3줄의 코드에서 보였듯, ts program은 3가지 단계에 거쳐 진행됩니다. Source Code to Data (syntax tree) Type Checking (bind / check) Creating Files (emit) ","date":"2024-02-06","objectID":"/compiler/:2:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"1. Source Code to Data Source code에서 의미있는 data로 변경하기 위해서는 syntax tree 개념이 존재합니다. Compiler는 frontend와 backend로 나눠지고, frontend에서 input code를 받아, 의미 있는 내부 형태로 구성하며 이를 기반으로 backend를 통해서 target output으로 변경을 합니다. 이런 구조를 취하는 이유는 adptor pattern 처럼 원하는 target language에 따라서 편하게 새로운 backend 또는 frontend를 갈아 끼우기 위해서 입니다. 또한 이런 유연한 구조를 위해서 내부적으로 AST (abstract syntax tree)를 도입하였습니다. Syntax tree는 크게 2가지로 나뉩니다. Scanner (src/compiler/scanner.ts), aka Lexer Parser (src/compiler/parser.ts) Scanner은 text를 syntax tokens으로 변경합니다. Parsesr은 syntax tokens를 tree로 변경합니다. 실제 코드를 보면 parser가 source code를 받음 parser가 scanner instance 생성 parser가 scanner의 textToToken 를 통해 source code의 text 청크들 syntax token으로 변환 parser가 syntax token의 stream들을 tree 형식으로 구성 parseJsonText 정리하면 Scanner: 소스코드를 컴파일러가 이해할 수 있는 토큰 시퀀스로 변환합니다. Parser: 토큰 스트림을 분석하여 AST를 생성합니다. 함수 선언, 변수 선언, 조건문, 반복문 등의 구조를 식별합니다. ","date":"2024-02-06","objectID":"/compiler/:3:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"2. Type Checking Checking the syntax tree Parsing process를 통해 stream of Syntax tree가 생성되면 Binder, Syntax -\u003e Symbols Converts identifiers in syntax tree to symbols Type Check, Use binder and syntax tree to look for issues in code. ","date":"2024-02-06","objectID":"/compiler/:4:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"2.1. Type Checking: Binder Binder, post-parser grab bag는 아래와 같은 역할을 수행합니다. identifiers가 정의되어있는 Symbol Tables 생성 Sets up ‘parent’ on all syntax tree nodes Make flow node for narrowing Validate script vs module conformance 1번에서 symbol이란 scope에 따른 identifier를 말합니다. 2번이 무슨말인지 찾아보니, AST는 비록 트리구조이지만, parser에 의해 생성된 AST는 아직 각 노드에 부모 노드에 대한 정보가 없어 상위 context를 파악하기 어렵다고 합니다. Binder는 AST를 방문(매우 무거운 작업)하면서 각 노드에 대한 부모 노드 정보를 설정할 수 있습니다. 3번의 flow nodes는 위에서 설명한 대로 scope를 찾아가면서 if conditional, functional scope 처럼 flow를 파악하는 것을 뜻합니다. 이렇게 flow graph가 만들어지게 되면 나중에 type check시에 typescript는 scope를 narrow하면서 check할 수 있습니다. 이 덕분에 typeof 같은 Type Guard가 typescript 타입 체크에 영향을 줄 수 있습니다. Binder가 Symbols table를 생성하면 Program.emit()을 호출하여 Emit worker가 AST가 javascript source code로 변환될 수 있도록 합니다. Emitter가 running할때 getDiagnostics()를 호출하며, 이 함수를 통해 Type Checker (src/compiler/checker.ts)가 실행됩니다. Emitter는 AST를 traverse(walk)하며 each node에 상응하는 check function를 실행합니다. ","date":"2024-02-06","objectID":"/compiler/:4:1","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"2.2. Type Checking: Type Checker 모든 syntax tree node에는 그에 상응하는 check function이 정의되어 있습니다. 이를 통해서 syntax tree에 정의되어있는 node들을 타고 가면서 type check가 가능합니다. 타입스크립트는 source, target로 타입을 구분하는데, const greet: string = “Hello World’의 경우에 string은 source, ‘Hello World’는 target이 되어 각각에 대해 check됩니다. 방대한 양의 type check이다 보니, 이번 post에서는 여기까지만 파악하고 다음으로 넘어가도록 하겠습니다. ","date":"2024-02-06","objectID":"/compiler/:4:2","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["dev"],"content":"3. Creating Files Syntax tree -\u003e JS TS에는 여러 transformers가 존재하며, 지정된 버전에 따라서 실행되는 transformers가 달라집니다. 이 과정을 거쳐서 typescript는 *.js, *.map, *.d.t를 만들어냅니다. ","date":"2024-02-06","objectID":"/compiler/:5:0","tags":["dev","ts","typescript","compiler"],"title":"Typescript Compiler","uri":"/compiler/"},{"categories":["mlflow","mlops"],"content":"Let’s analize mlflow source code ","date":"2024-01-31","objectID":"/mlflow/:0:0","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"1. Initialize mlflow/init.py LazyLoader Mlflow uses so many large sized 3rd party libs, so it imports lazily when module is called. (singleton of global context) # __init__ # Lazily load mlflow flavors to avoid excessive dependencies. catboost = LazyLoader(\"mlflow.catboost\", globals(), \"mlflow.catboost\") diviner = LazyLoader(\"mlflow.diviner\", globals(), \"mlflow.diviner\") fastai = LazyLoader(\"mlflow.fastai\", globals(), \"mlflow.fastai\") gluon = LazyLoader(\"mlflow.gluon\", globals(), \"mlflow.gluon\") LazyLoader inherits types.ModuleType to initialize instance as module type. class LazyLoader(types.ModuleType): def __init__(self, local_name, parent_module_globals, name): self._local_name = local_name self._parent_module_globals = parent_module_globals self._module = None super().__init__(str(name)) def _load(self): \"\"\"Load the module and insert it into the parent's globals.\"\"\" if self._module: # If already loaded, return the loaded module. return self._module # Import the target module and insert it into the parent's namespace module = importlib.import_module(self.__name__) self._parent_module_globals[self._local_name] = module sys.modules[self._local_name] = module # Update this object's dict so that if someone keeps a reference to the `LazyLoader`, # lookups are efficient (`__getattr__` is only called on lookups that fail). self.__dict__.update(module.__dict__) return module def __getattr__(self, item): module = self._load() return getattr(module, item) def __dir__(self): module = self._load() return dir(module) def __repr__(self): if not self._module: return f\"\u003cmodule '{self.__name__}(Not loaded yet)'\u003e\" return repr(self._module) __init__에서 global() namespace를 받아 저장하고, module.__name__을 init하게 되고 LazyLoader 타입으로 부모 context(global context)에 모듈이 등록됩니다. getattr 시점에, _load를 호출하여, 모듈이 import되지 않았을 경우, dynamic하게 import하여, global context에 이 module을 등록합니다. 이때 부모의 global context에 LazyLoader로 등록되어있던 모듈을 실제 import한 모듈로 overwrite합니다. 이를 통해서 최초 getattr 이후로는 실제 import된 module이 LazyLoader를 대체하게 됩니다. sys.modules는 Python이 모든 로드된 모듈을 추적하는 데 사용하는 내부 캐시입니다. 모듈이 로드될 때, 이 캐시에 모듈을 등록하면, Python은 동일한 모듈을 재로드하는 대신 이미 로드된 모듈을 재사용합니다. 문득 코드를 읽다, self._module를 저장하는 이유가 궁금해서 (내가 생각할 때는 불필요한 것 같은데) discussion을 남겨두었다. MLFLOW: Question on LazyLoader Implementation ","date":"2024-01-31","objectID":"/mlflow/:1:0","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"2. Run mlflow/main.py mlflow/cli.py init 이후, __main__.py을 통해서 호출된 cli 모듈을 통해서 명령어에 대한 처리가 시작됩니다. cli.py에서는 크게 4가지의 명령어가 존재하며, 다음과 같습니다. run(): Run an MLflow project from the given URI. server(): Run the MLflow tracking server. gc(): Permanently delete runs in the deleted lifecycle stage. doctor(): Prints out useful information for debugging issues with MLflow. 기능 적인 측면에서 보면 크게 run, server 2가지만 파악하면 될 것같습니다. 이외에도 import를 통해서 나머지 명령어들을 불러옵니다. 최종적인 mlflow의 cli는 아래와 같습니다. load additional cli cli.add_command(mlflow.deployments.cli.commands) cli.add_command(mlflow.experiments.commands) cli.add_command(mlflow.store.artifact.cli.commands) cli.add_command(mlflow.runs.commands) cli.add_command(mlflow.db.commands) # We are conditional loading these commands since the skinny client does # not support them due to the pandas and numpy dependencies of MLflow Models try: import mlflow.models.cli cli.add_command(mlflow.models.cli.commands) except ImportError: pass try: import mlflow.recipes.cli cli.add_command(mlflow.recipes.cli.commands) except ImportError: pass try: import mlflow.sagemaker.cli cli.add_command(mlflow.sagemaker.cli.commands) except ImportError: pass with contextlib.suppress(ImportError): import mlflow.gateway.cli cli.add_command(mlflow.gateway.cli.commands) FYI, suppress는 에러 ignore를 한줄로 사용하기 위해 사용됩니다. \u003e mlflow --help Commands: artifacts Upload, list, and download artifacts from an MLflow... db Commands for managing an MLflow tracking database. deployments Deploy MLflow models to custom targets. doctor Prints out useful information for debugging issues with MLflow. experiments Manage experiments. gc Permanently delete runs in the `deleted` lifecycle stage. models Deploy MLflow models locally. recipes Run MLflow Recipes and inspect recipe results. run Run an MLflow project from the given URI. runs Manage runs. sagemaker Serve models on SageMaker. server Run the MLflow tracking server. ","date":"2024-01-31","objectID":"/mlflow/:2:0","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"2.2. Start a Local Mlflow Server Mlflow 코드를 분석하기 위해서는, 실제 UI상에서 experiment들이 어떻게 진행되어야 하는지 파악하는게 우선이라 생각되어 local에서 mlflow pull 받아서 확인해보았습니다. Locally Run MLflow tracking server ","date":"2024-01-31","objectID":"/mlflow/:2:1","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"2.3. Getting Started with MLflow 대략 mlflow를 local에서 실행해보고 났으니, 구체적으로 mlflow의 구성요소들을 정리해 보겠습니다. Getting Started with Mlflow MLflow Tracking Quickstart ","date":"2024-01-31","objectID":"/mlflow/:2:2","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"3. Concepts Tracking Concepts ","date":"2024-01-31","objectID":"/mlflow/:3:0","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"3.1. MLflow Tracking Runs: Executions of some piece of code Each run records metrics, parameter, start ~ end times, artifacts(model weights, images, etc) Experiments: Group of runs, for a specific task # UI browser mlflow ui --port 5000 # mlflow server mlflow server --host 127.0.0.1 --port 50 Tracking Components Tracking APIs: Tracking Server와 interact할 수 있는 인터페이스 내 생각에는 이게, python, REST등의 client형식으로 관리 될 것 같다.(auth가 필요하니) Backend Store: metadata for each Run (i.g. run ID, metrics ..) Default /mlruns/** (file based) Databaed-based (db …) Artifact Store: input data files, model weight, images 따위 svn과 연동한다면 Artifact에서 작업이 되어야 할 것. Parquet, S3 등으로 대체 가능 Tracking Server standalone HTTP server that provides REST API for accessing backend/artifact store. Deployment 코드를 보다가 아래와 같은 패턴을 발견습니다. 이렇게 데코레이터에서 원본으로 wraps을 하는 이유는 __name__, __module__ 함수 이름/모듈 보존: 로깅 / 디버깅 시 wrapper func가 원본 함수 이름을 물려 받을 수있음 __doc__ repr 보존: 원본 함수의 주석이 그대로 보존 될 수 있어, wrapper가 되더라도 주석을 wrapper에 쓰는 것이 아니라, 실제 기능하는 코드에 주석을 넣어둘 수 있습니다. 오픈소스에서 @functools.wraps(fn)를 쓰는 이유는 딱 위의 2가지 이유 정도 있을 것 같습니다. @cache_return_value_per_process def get_or_create_nfs_tmp_dir(): \"\"\" Get or create a temporary NFS directory which will be removed once python process exit. \"\"\" from mlflow.utils.databricks_utils import get_repl_id, is_in_databricks_runtime from mlflow.utils.nfs_on_spark import get_nfs_cache_root_dir nfs_root_dir = get_nfs_cache_root_dir() ... def cache_return_value_per_process(fn): \"\"\" A decorator which globally caches the return value of the decorated function. But if current process forked out a new child process, in child process, old cache values are invalidated. Restrictions: The decorated function must be called with only positional arguments, and all the argument values must be hashable. \"\"\" @functools.wraps(fn) def wrapped_fn(*args, **kwargs): if len(kwargs) \u003e 0: raise ValueError( \"The function decorated by `cache_return_value_per_process` is not allowed to be \" \"called with key-word style arguments.\" ) if (fn, args) in _per_process_value_cache_map: prev_value, prev_pid = _per_process_value_cache_map.get((fn, args)) if os.getpid() == prev_pid: return prev_value new_value = fn(*args) new_pid = os.getpid() _per_process_value_cache_map[(fn, args)] = (new_value, new_pid) return new_value return wrapped_fn ","date":"2024-01-31","objectID":"/mlflow/:3:1","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"3.2. Mlflow Projects https://mlflow.org/docs/latest/projects.html Mlflow Project란 소스 코드를 재사용 가능하게 패키징화 시킨 컴포넌트입니다. API, CLI entrypoint를 가지고 있습니다. chainning으로 multi-step workflows에 추가시킬 수 있습니다. Conda env나 MLproject (yaml file)를 통해서 properties들을 추가할 수 있습니다. Project는 Git URI 또는 local directory에서 mlflow run command를 사용해서 실행 가능합니다. 코드 상에서는 mlflow.projects.run()을 통해 python api로 실행가능합니다. 이 api는 k8s나 databricks 환경에서 remote로 실행 가능합니다. Project가 실행되는 환경을 구성하기 위해서는 아래 4가지 구성이 옵션들이 가능합니다. Virtualenv (preferred) Docker container Conda System environment 여기에서는 Viertualenv 세팅 위주로 살펴보겠습니다. MLflow Project (Virtualenv) 이 세팅을 구성한다면, mlflow는 pyenv를 활용해 isolated environment를 만들고, virtualenv를 통해 dependencies들을 포함시킵니다. 또한 mlflow 코드를 실행시키기 전에(prior to running the project code), 이 isolated env를 activate 시킵니다. 이 세팅을 활용하기 위해서는 2개의 파일 세팅이 필요합니다. MLproject: 시작 지점 python_env.yaml: virtualenv environment description MLProject example name: llm_summarization python_env: python_env.yaml entry_points: main: command: python summarization.py python_env example python:\"3.10\"build_dependencies:- pipdependencies:- langchain\u003e=0.0.244- openai\u003e=0.27.2- evaluate\u003e=0.4.0- mlflow\u003e=2.4.0 이후 project를 실행하기 위해서는, MLproject 파일이 있는 디렉토리에서 아래 코들르 사용하면 됩니다. \u003e mlflow run . 이렇게 명령어를 `작성하게 되면 cli상에서 mlflow는 projects 패키지를 호출하며, 실제 코드에서는 아래 부분이 호출 됩니다. load_project에서 python_env.yaml을 읽어, Project 객체를 생성합니다. Project는 Entrypoint와 Parameter를 init하고 이를 통해 source code 파일들을 link 또는 remote의 경우 storage_dir로 download합니다. 이후 projects.run을 통해 아래 코드가 호출되어 local 또는 databricks 같은 remote에 존재하는 코드들을 실행합니다. code 이후 projects.backend.local.py의 run이 호출되어 새로운 process가 동작합니다. 코드 mlflow project를 실행해보다가, examples/llms/summarization을 실행해보는데, dep 에러가 발생해서 contribute했다. langchain이 워낙 빠르게 변화하는 open source다 보니까, dependency 관리가 쉽지 않나 보다. FIx llm example tiktoken dependency error #10989 ","date":"2024-01-31","objectID":"/mlflow/:3:2","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":["mlflow","mlops"],"content":"3.3. MLflow LLMs https://mlflow.org/docs/latest/llms/index.html Mlflow introduce Deployment(previously AI Gateway) that simplifies interactions with multiple LLM provides. Support multiple llm providers Integrate to mlflow model serving Centralized scattered API keys Seamless Provider swapping Mlflow LLM는 아래와 같은 core concept들을 가지고 있습니다. Deployments Evaluation Prompt UI Flavors OpenAI Langchain Transformer / BERT Tracking 문득 Document를 보다가, 현재 페이지를 tracking 제대로 하지 못해, 이 부분 고쳐서 pr 올렸는데, [pr] MLflow doc page가 현재 current doc을 제대로 표시하지 못해, 불편했었는데, 이 부분 fix하여 pr을 올렸다. https://github.com/mlflow/mlflow/pull/10999 ci 쪽 에러들이 block되어 추가로 2개 pr들을 더 올렸다. [pr] MLflow 오픈소스가 여러모로 dependency 버그가 좀 있었는데, 이 부분에 MLflow의 dev dependency 관련된 세팅을 처리했고, bug fix를 contribute했다. https://github.com/mlflow/mlflow/pull/10998 [pr] https://github.com/mlflow/mlflow/pull/11003 , keras related build fix. 말은 open source인데, contributor들에게 여러모로 너무 불편한 상황인듯. pr을 아무도 관리하지 않는다는거나, issue관리 그리고 ci/cd 파이프라인이 막혀있는데 몇일째 아무도 신경 쓰지 않았다는 것 등;; Databricks분들은 바로 바로 merge 시키는데, 이걸 보면 그냥 기업 코드를 오픈시킨 databricks 홍보용 레포 같다. 24.02.07, 5일이 지나고 나서야 드디어 merge되었다. 다행이다. https://github.com/mlflow/mlflow/pull/11001 https://github.com/mlflow/mlflow/pull/10989 https://github.com/mlflow/mlflow/pull/10999 ","date":"2024-01-31","objectID":"/mlflow/:3:3","tags":["dev"],"title":"MLflow code analysis","uri":"/mlflow/"},{"categories":[""],"content":"How to manage openai rate limit on production? ","date":"2023-12-03","objectID":"/openai_rate_limit/:0:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"TL;DR 아래는 rate limit을 도식화 해본 그림입니다. ","date":"2023-12-03","objectID":"/openai_rate_limit/:1:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"Rate Limits Openai는 rate limit을 통해 organization별로 api access를 관리합니다. 이때 openai의 rate limit은 총 5가지 방법으로 measure됩니다. RPM (Requests per minute, requests / 1min) RPD (requests / 1day) TPM (tokens / 1min) TPD (tokens / 1day) IPM (images / 1min) 추가로 5개중 1개만 할당량에 걸려도 rate limit가 발생합니다. Rate limit은 user가 아닌 organization 기준으로 관리됩니다. 위의 5가지 quota는 model별로 다르게 관리됩니다. 예를들어 하나의 API key를 통해 서로 다른 model을 사용할 때, 둘 중 하나의 model이 rate limit에 걸리더라도, 다른 model은 영향을 받지 않습니다. 물론 이 또한 organization의 max usage limit을 넘어가지 말아야 합니다. Openai의 rate limit은 organization level로 관리됩니다. 이 때문에 하나의 organization에 속해있는 여러 api_key를 사용하더라도 특정 model이 rate limit에 걸리게 되면 다른 api key에서도 에러가 생깁니다. 이를 방지하기 위해서, organization을 여러개 생성해서 api_token을 관리하는 방법이 있습니다. FYI, openai는 하나의 account당 하나의 organization만 만들 수 있습니다. ","date":"2023-12-03","objectID":"/openai_rate_limit/:2:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"Tiers Rate limit 정책은 앞서 말했듯, organization과 model에 따라 달라집니다. Organization (Tier) Models (Rate Limit) 먼저 orgranization은 tier에 따라서 또는 usage limit (bucket per month)설정에 따라서 다른 limit을 가집니다. 마찬가지로 2번째의 model에 따라서도 tier별로 그리고 model별로 다른 rate limit 정책을 따릅니다. 아래는 tier3의 예시입니다. 실제 production에서 rate limit을 관리한다면 현재 tier에 대한 RPM, RPD들을 티어별로 저장해야 할 것 같습니다. ","date":"2023-12-03","objectID":"/openai_rate_limit/:3:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"Rate Limit Headers 개발에서 현재 Rate limit을 확인하는 방법은 HTTP 요청을 통해 받은 response의 header를 통해서만 확인 가능합니다. (물론 UI를 통해서도 가능) 세계적인 기업에서 token, model별로 현재 rate limit metric을 알려주는 api endpoint가 하나도 없다는게 충격적입니다. x-ratelimit-limit-requests: 남은 최대 요청 수 x-ratelimit-limit-tokens: 남은 최대 토큰 수 x-ratelimit-remaining-requests: 남은 허용 요청 수 x-ratelimit-remaining-tokens: 남은 허용 요청 수 x-ratelimit-reset-requests: request rate limit이 초기화 되기 까지 남은 시간 x-ratelimit-reset-tokens: token rate limit이 초기화 되기 까지 남은 시간 사실 remaing과 limit의 차이점은 현재 진행하고 있는 request를 포함시키는지 여부입니다. 즉 만약 x-ratelimit-limit-requests가 60이고 x-ratelimit-remaining-requests가 59라면, 후자는 현재 진행되고 있는 request를 포함시켰기 때문에 1차이가 나는 것 같습니다. ","date":"2023-12-03","objectID":"/openai_rate_limit/:4:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"TODO; production managing architecture. source codes How to handle rate limits.ipynb openai/api_requests_parallel_preprocessor.py ","date":"2023-12-03","objectID":"/openai_rate_limit/:5:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":[""],"content":"Refs Rate limit advice openai Q\u0026A openai rate limit strategy openai docs ","date":"2023-12-03","objectID":"/openai_rate_limit/:6:0","tags":["dev"],"title":"Openai Rate Limit","uri":"/openai_rate_limit/"},{"categories":["mlops"],"content":" MLOps for ALL 1. Introduction fdlkajfdlks ","date":"2023-11-27","objectID":"/mlops/:0:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"What is MLOps? Continuous Tranning pipeline Model CI / CD ","date":"2023-11-27","objectID":"/mlops/:1:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"Levels of MLOps 0단계: 수동 process ML -model-\u003e Ops, 즉 model을 통해 ops팀과 ml팀이 소통하는 방식 model codes 학습된 weight and bias environment 1단계: ML 파이프라인 자동화 Trainning Pipeline Continuous Training 2단계: CI/CD 파이프라인 자동화 ","date":"2023-11-27","objectID":"/mlops/:2:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"Componenet of MLOps Experimentation, prototype (ml engineer) jupyter notebook Data, Hyper parameter, eval metrics Visualization Data Processing 크게 3가지에서 사용됩니다. ML model develop phase COntinuous Training pipeline API deployment 다양한 데이터 소스와 서비스에 호환되는 데이터 connector feature Encoder / Decoder 데이터 변환과 Feature engineering 학습과 서빙을 위한 scale-out 가능한 Batch / Stream data feature Model Training ML framework 실행을 위한 env GPU 분산 학습을 위한 환경 제공 Hyper parameter tunning 그리고 최적화 기능 (Hyper parameter? 모델링시 사용자가 직접 세팅해주는 값들, top_p, top_k, token_length …) Model Evaluation 모델 performance 측정 CT 결과의 성능 지속적인 추적 Visualization Model Serving low latency, high availability (HA) 다양한 ML 모델 프레임워크 지원 복잡한 형태의 모델간, 스텝별 flow 서빙 (preprocess, postprocess, 모델간 통신) autoscaling logging, 특히 llm을 직접 관리한다면, CT를 위해 agent의 logging들이 필수 Online Experimentation A/B testing 새로운 모델 생성 시, 해당 모델을 배포하면 어느 정도의 성능을 보일지 검증하는 기능 Multi-armed bandit testing, 한정된 리소스(시간, 트래픽)에서 여러개의 테스트 그룹 중 가장 좋은 그룹 선택 Model Monitoring model 성능 측정 ML Pipeline 다양한 이벤트들을 통한 실행 기능 Model REgistry 모델 lifecycle관리하는 중앙 저장소 versioning, metadata Dataset and Feature Repository Dataset sharing, search, versioning Event streaming 및 온라인 추론 작업에 대한 실시간 처리 및 서빙 기능 사진 / 텍스트 / 테이블 등 다양한 형태의 데이터 지원 ML metadata and Artifact Tracking ML 산출물 ML artifacts history관리 기능 ","date":"2023-11-27","objectID":"/mlops/:3:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"Why Kubernetes? Container를 통한 소통 편리성 phase 분리 용이성 등 node 리소스 효율적 관리 GPU 등. 2. Setup Kubernetes kustomize istio, service mesh CSI Argo Helm k3s 3. Kubeflow ","date":"2023-11-27","objectID":"/mlops/:4:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"Kubeflow Concepts Component Component contents Component wrapper, kubeflow로 component가 전달 Artifacts, Componenet를 통해 생산 Pipeline Run ","date":"2023-11-27","objectID":"/mlops/:5:0","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"1.1. Component contents 컴포넌트 콘첸츠를 구성하는 것은 총 3가지로 Environment Python code w\\ Config Generates Artifacts import dill import pandas as pd from sklearn.svm import SVC train_data = pd.read_csv(train_data_path) train_target= pd.read_csv(train_target_path) clf= SVC( kernel=kernel ) clf.fit(train_data) with open(model_path, mode=\"wb\") as file_writer: dill.dump(clf, file_writer) ","date":"2023-11-27","objectID":"/mlops/:5:1","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"1.2. Component Wrapper 컴포넌트 래퍼는 컴포넌트 콘텐츠에 필요한 config를 전달하고 실행시키는 작업을 합니다. ","date":"2023-11-27","objectID":"/mlops/:5:2","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"2. Artifacts Model 파이썬 코드 학습된 weights network 구조 실행시키기 위한 환경 Data 전처리된 feature 모델의 예측값 Metric Dynamic metric, train loss와 같이 epoch마다 계속 변화하는 값 Stataic Metric, 학습이 끝난 뒤 최종적으로 모델을 평가하는 정확도 등 ","date":"2023-11-27","objectID":"/mlops/:5:3","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"3. Pipeline 파이프라인은 컴포넌트의 집합과 이를 실행시키는 순서도로 구성되어있습니다. 순서도는 DAG 이뤄져 있으며 조건문을 포함시킬 수 있습니다. 또한 컴포넌트를 실행시키기 위해서는 Config가 필요한데, Pipeline을 구성하는 컴포넌트의 Config들을 모아 둔 것이 파이프라인 Config 입니다. ","date":"2023-11-27","objectID":"/mlops/:5:4","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"4. Run Kubeflow에서는 실행된 파이프라인을 Run이라고 부릅니다. 파이프라인이 실행되면, 각 컴포넌트들이 아티팩트들을 생성하고, Kubeflow pipeline에서는 Run하나당 고유한 ID를 생성한 뒤, Run에서 생성되는 모든 아티팩트들을 저장합니다. ","date":"2023-11-27","objectID":"/mlops/:5:5","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["mlops"],"content":"5. Experiment Experiment란 Kubeflow 에서 실행되는 Run을 논리적으로 관리하는 단위입니다. ","date":"2023-11-27","objectID":"/mlops/:5:6","tags":["dev","mlops"],"title":"MLops pipeline","uri":"/mlops/"},{"categories":["dev"],"content":"What is this, categorize all this cases.","date":"2023-11-19","objectID":"/this_in_js/","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"Q. What on earth, this is interpretated in js? ","date":"2023-11-19","objectID":"/this_in_js/:0:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"TL;DR this는 동적으로 해석된다. 일반적으로 호출하는 주체가 parameter로 전달된다. 즉 obj.method(...)는 method(this=obj, ...)로 해석 Global context commonJS: this === globalThis (window or global) type=\"module\": this는 언제나 undefined Function: method로 활용되지 않는 일반적인 함수에서 this는 2가지로 해석됩니다. use strict: undefined non strict: globalThis Arrow functions: outer scope의 this를 reference하는 변수를 closure로 보존(lexical scoping)한다. Callback: 일반적으로 this가 전달되지 않아 function과 동일하게 처리되지만, 일부 API (JSON.parse(text, reviver))들은 내부적으로 this를 넣어준다. Constructor (new): new를 통해 호출되는 constructor는 내부적으로 this에 생성될 instance를 할당한다. super: 부모의 context가 아닌, super.method()를 호출한 context의 this가 적용된다. Class static vs instance derived class constructor에서 super()를 호출하지 않거나, return object하지 않는 이상 this는 생성되지 않는다. EventHandler 대부분 브라우저는 addEventListener의 경우, handler에 현재 element를 this에 bind시켜서 줍니다. 인라인 이벤트 핸들러에서도 this에 현재 이벤트 리스닝되는 element가 바인드됩니다. \u003cbutton onclick=\"alert(this);\"\u003eShow this\u003c/button\u003e ","date":"2023-11-19","objectID":"/this_in_js/:1:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"0. this intro MDN: this Javascript에서 this 키워드는, 일반적으로 instance에 bind되는 대부분 언어와 달리, 동적으로 해석되며 호출한 방법에 의해 결정됩니다. 즉 동적으로 해석되는 this는 아래와 같이 호출되는 주체에 따라서 다르게 해석됩니다. function getThis() { return this; } const o1 = { name: \"o1\"}; const o2 = { __proto__: o1, name: \"o2\", }; // 1. o1을 통해서 호출 되었을 때 o1.getThis = getThis; console.log(o1.getThis()); // { name: 'o1', getThis: [Function: getThis] } // 2. o2를 통해서 호출되었을 때 console.log(o2.getThis()); // { name : 'o2' } 전형적인 function 호출에서, this는 function's prefix(dot 앞에 있는 part)를 통해 implicitly하게 parameter로 전달됩니다. o1.getThis(); // getThis(this=o1, ...나머지 args); 물론 explicitly하게 this를 지정하여 전달할 수도 있습니다. Function.prototype.call() Function.prototype.apply() Reflect.apply() 또는 this를 bind시켜서 function을 새롭게 생성할 수도 있습니다. Funciton.prototype.bind() 이제 차근차근 this가, context에 따라서 어떻게 다르게 해석되는지 알아보도록 하겠습니다. ","date":"2023-11-19","objectID":"/this_in_js/:2:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"1. Global context strict mode 상관없이 globalThis property를 의미하며, 이는 실행환경에 따라서 2가지로 해석됩니다. node: global browser: window console.log(this === window) // true a = 1 console.log(this.a) // 1 console.log(window.a) // 1 this.b = 2 console.log(window.b) // 2 console.log(b) // 2 ","date":"2023-11-19","objectID":"/this_in_js/:3:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"2. Function declaration의 context use strict를 사용하는지에 따라서 2가지 경우가 발생합니다. function f1() { return this; } function f2() { \"use strict\"; return this } // 1. non-strict // 브라우저 f1() === window; // true // Node.js f1() === global; // true // 2. strict f2() === undefined; // true ","date":"2023-11-19","objectID":"/this_in_js/:4:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"3. Callbacks iterative array methods, Promise constructor case 일반적으로 callback으로 함수를 넘겨준다면 this는 bind되지 않았기 때문에 “strict”: undefined “non-strict”: globalThis function print() { \"use strict\"; console.log(this); } [1,2,3].forEach(print); // undefined, undefined, undefined // 몇몇의 API들을 thisArg를 통해 this를 전달하도록 해줍니다. const thisObj = { name: \"john\" } [1,2,3].forEach(print, thisObj) // {name: 'john'}, {name: 'john'}, {name: 'john'} 가끔 어떤 API들은 this를 넣어주는 경우도 있습니다. JSON.parse(text, reviver?) JSON.stringify(value, replacer?) The reviver is called with the object containing the property being processed as this. JSON.parse는 reviver 함수에 parse처리된 상태를 this로 넣어서 실행시켜준다. function print(a,b) { \"use strict\"; console.log(this); } print(1,2,) // undefined JSON.parse('{\"result\":true, \"count\":42}', print) // { result: true, count: 42 } // { count: 42 } // { '': {} } ","date":"2023-11-19","objectID":"/this_in_js/:5:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"4. Arrow functions Arrow function은 lexical context의 this를 유지합니다. 다른 말로 일반 function과 달리 호출 방식에 따라서 dynamic하게 this가 변경되지 않습니다. lexical context, a.k.a static context, 동적으로 this가 처리되는 것이 아닌, 코드 작성 위치에서 this가 지정됨. Arrow function는 closure처럼 구현되어 this value를 감싸고 있는 scope에서 들고 있다고 생각하면 됩니다. (auto-bound). 또한 arrow function은 call(), bind(), apply()를 통해서 this를 동적으로 묶어주더라도 무시합니다. const a = { hi: () =\u003e { return this } } a.hi() // window object literal은 아래와 같이 this값이 그 자체로 없기 때문에, outer scope의 this인 globalThis를 받습니다. const t = { who: this } t.who // window 경험상에 따르면 마치 arrow function이 static하게 this를 지정하고 있는 것으로 이해되고 있지만, 사실 arrow function은 outer scope의 this를 가리키는 reference를 closure로 들고 있는 것입니다. outer의 this를 가리키는 reference를 closure로 들고 있다는 것이, 무슨 뜻인지는 아래 예시를 보면 더 확실해집니다. // function declaration은 호출되는 .에 따라서 this가 parameter로 전달됨. const a1 = { hi: function() { return this } } a1.hi() // {hi: ƒ} 만약 arrow function이 function declaration안에 존재한다면? arrow function의 this는 function declaration의 this를 가리키게 됩니다. const a2 = { hi: function() { const f = () =\u003e { return this } return f() } } a2.hi() // 1. {hi: ƒ} // 2. 🧐 what the fuck? why chnaged? const hi = a2.hi hi() // undefined (use strict) 2번 케이스를 보면 arrow function의 this값이 변경되는 것처럼 보입니다. hi property는 function declaration을 가지고 있으며, function declaration은 dot앞의 주체를 this로 하여 param에 전달되는 것처럼 동작합니다. 하지만 const hi는 dot앞의 주체가 없기 때문에 strict mode에서는 this가 undefined로 할당되게 됩니다. arrow function은 외부 scope의 function의 this를 reference하고 있기 때문에, 해당 function의 this가 undefined이기 때문에, 마치 변경된 것 처럼 동적으로 변화되어 undefined을 return합니다. 그러므로 arrow function의 this 또한 동적으로 호출 방법에 따라서 변경되는 것처럼 동작가능합니다. 이런 현상 때문에 위에서 arrow function의 this는 lexical scope의 outer scope의 this를 closure의 this로 reference하고 있다고 표현한 것입니다. arrow function의 this인 reference는 여전히 변경되지 않았기 때문입니다. ","date":"2023-11-19","objectID":"/this_in_js/:6:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"5. Constructors (new operator) function이 new를 통해 constructor로 사용되면, js는 내부적으로 constructor 함수 안의 this를 생성되는 instance로 할당합니다 function Person(name) { this.name = name; } const p = new Person(\"John\"); p.name // John 즉 원래 function declaration이 global context에서 사용되면, this가 window 또는 undefined로 해석되지만, new operator를 사용하게 될 경우 내부적으로 this를 instance로 할당해서 처리하게 됩니다. ","date":"2023-11-19","objectID":"/this_in_js/:7:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"6. super 자녀에서 super의 method를 호출했을 때, super의 method안에 this는, super의 값과 상관없이 super.method()를 감싸고 있는 context의 this로 처리됩니다. class Parent { constructor() { this.name = \"parent\" } getName() { // 여기서 this는 child return this.name } } class Child extends Parent { constructor() { super(); this.name = \"child\"; } } (new Child()).getName() // child 즉 위와 같은 경우 Parent의 메서드안에 this는 Parent가 아니라, child의 this를 따릅니다. 왜냐하면 super.getName을 감싸고 있는 child.getName의 this는 child를 가리키고 있기 때문입니다. ","date":"2023-11-19","objectID":"/this_in_js/:8:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"7. Class static context: this = Class static method static field (initializer / block) instance context: this = instance constructor method instance field class C { static staticField = this; instanceField = this; } const c = new C(); console.log(C.staticField === C); // true console.log(c.instanceField === c); // true ","date":"2023-11-19","objectID":"/this_in_js/:9:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"Derived class(child) constructor(extends) 파생 클래스 생성자: 파생 클래스(자식 클래스) 생성자는 기본 클래스(부모 클래스) 생성자와 달리 초기에 this 바인딩이 없습니다. class Base {} class Child extends Base { name =\"child\" constructor() { console.log(this.name) } } const c = new Child() // Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor super()를 호출하면 생성자 내에 this 바인딩이 생성되고, 이것은 사실상 this = new Base();라는 코드를 실행하는 것과 같은 효과를 가집니다. 여기서 Base는 기본 클래스를 의미합니다. 주의 사항: super()를 호출하기 전에 this를 참조하려고 하면 오류가 발생합니다(당연히 this가 없으니), 그러므로 생성자안에서 this를 사용한다면, 그 보다 더 위에 super()가 존재해야 합니다. class Base { name = \"Base\" } class Child extends Base { constructor() { super(); console.log(this.name); } } const c = new Child(); // Base super() 호출 규칙: 파생 클래스의 constructor는 super()를 호출하지 않고 반환해서는 안 됩니다. 단, 생성자가 객체를 반환하여 this 값을 덮어쓰는 경우나 클래스에 생성자가 전혀 없는 경우는 예외입니다. class Good extends Base { constructor() { return { a: 5 }; } } class Bad extends Base { constructor() {} } JS의 child class에서 constructor를 명시적으로 작성하지 않으면, 내부적으로 constructor를 생성하고, 이 생성자에서는 super()를 자동으로 호출합니다. class AlsoGood extends Base {} ","date":"2023-11-19","objectID":"/this_in_js/:9:1","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"8. DOM Event Handler ","date":"2023-11-19","objectID":"/this_in_js/:10:0","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"8.1. 함수 이벤트 핸들러 대부분의 브라우저에서, 이벤트 핸들러로 사용되는 함수의 this는 리스너가 부착된 DOM 요소에 바인딩 시킵니다. function bluify(e) { \"use strict\" // 원래라면 undefined이지만, addEventListener는 target을 this로 bind시킨다. this.style.backgroundColor = \"#A5D9F3\"; console.log(this === e.currentTarget) // true console.log(this === e.target) // currentTarget과 target이 같은 객체일 때 true } const elements = document.getElementsByTagName(\"*\"); for (const ele of elements) { ele.addEventListener(\"click\", bluify, false); } ","date":"2023-11-19","objectID":"/this_in_js/:10:1","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"8.2. 인라인 이벤트 핸들러 인라인에서 사용되는 this는 이벤트 리스너가 부착된 element 입니다. \u003c!-- [object HTMLButtonElement] --\u003e \u003cbutton onclick=\"alert(this);\"\u003eShow this\u003c/button\u003e 하지만, 내부 scope를 추가로 가지게 된다면, global context로 해석됩니다. \u003c!-- undefined --\u003e \u003cbutton onclick=\"alert((function () { 'use strict'; return this; })());\"\u003e 즉 이는 다른말로, function을 정의해서 인라인에 집어넣더라도 동일하게 global context로 해석된다는 뜻입니다. \u003cbutton onclick=\"print()\"\u003e \u003cscript\u003e \"use strict\"; function print() { // undefined alert(this); } \u003c/script\u003e 지금까지 내용들을 정리하면 아래와 같은 테스트 코드를 작성해볼 수 있습니다. \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eEvent Handler Reference Test\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 1. use outside function --\u003e \u003c!-- 1.1. just function: undefined --\u003e \u003c!-- 1.2. addEventListener: [object HTMLButtonElement] --\u003e \u003cbutton id=\"btn1\" onclick=\"print()\"\u003e Show inner this (print Function) \u003c/button\u003e \u003chr /\u003e \u003c!-- 2. [object HTMLButtonElement] --\u003e \u003cbutton onclick=\"alert(this);\"\u003eShow this\u003c/button\u003e \u003chr /\u003e \u003c!-- 3. undefined --\u003e \u003cbutton onclick=\"alert((function () { 'use strict'; return this; })());\"\u003e Show inner this (Anonymous Function, Nothing Happen!) \u003c/button\u003e \u003cscript\u003e \"use strict\"; // 1.1. just function function print() { alert(this); // undefined } // 1.2. addEventListener document .getElementById(\"btn1\") .addEventListener(\"click\", printHandler, false); function printHandler(e) { console.log(this); // [object HTMLButtonElement] console.log(this === e.currentTarget); // true } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e - 끝 -","date":"2023-11-19","objectID":"/this_in_js/:10:2","tags":["js","this"],"title":"this, javascript","uri":"/this_in_js/"},{"categories":["dev"],"content":"Concurrent marking in V8 의 내용을 참조해서 v8의 garbage collection의 원리를 정리합니다. 이 GC는 Chrome 64 및 Node.js v10 부터 적용 되어 있습니다. minor gc vs major gc concurrent gc 동작 방식 thread local에 들어가있는 방식 ","date":"2023-11-18","objectID":"/v8_garbage_collection/:0:0","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":" Minor GC (Scavenge) 1번 GC이후 살아있는 object은 nursery -\u003e Intermediate로 generation 변경 2번째 GC이후 Intermediate -\u003e Old space로 이동 Young generation의 1/2는 언제나 empty (half-empty)해야한다. (To영역) 왜냐하면 살아남은 객체들 evacuation(배설)해야하는 영역이 필요하니까. evacuation이후 기존의 reference들은 새로운 영역으로 update이 필요하다. Major GC ","date":"2023-11-18","objectID":"/v8_garbage_collection/:1:0","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":"기존 GC in JS (v8) 자바스크립트는 reachability(도달 가능성) 개념으로 메모리 관리를 수행합니다. 즉 도달 가능한 값은 메모리에서 삭제되지 않습니다. mark-and-sweep, 루트들로 부터 시작해서 reach하는 영역들 마크하고, 마크되지 않은 영역 sweep generational collection, 오래된 객체와 새로운 객체를 나눠서 관리하는 방법 이전 JS의 GC는 주로 메인 스레드에서 동작했습니다. 당연히 marking 알고리즘의 마킹이 진행되는 동안, application은 일시 중지 된 경우에만 동작하기 떄문에 stop-the-world가 발생하게 됩니다. 마킹 상태는 3가지 상태로 구분되며, 최초 root에서 출발합니다. (grey로 색칠) white(00): 초기 상태 grey(10): gc collector가 발견하여, marking worklist로 push한 상태 black(11): worklist에서 pop하여 Object의 모든 필드를 visit한 상태 더이상 grey object가 없게되면 마킹은 중단되고, 남아있는 white node들은 unreachable로 간주되어 제거됩니다. ","date":"2023-11-18","objectID":"/v8_garbage_collection/:2:0","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":"incremental collection 가비지 컬렉션의 검사해야 하는 heap을 여러 부분으로 분리한 다음, 각 부분들을 별도로 수행하는 방법. Stop-the-World 시간을 줄이기 위해서 v8은 2011년 incremental collection을 도입했습니다. 이를 통해 GC는 더 작은 청크로 분할하고 애플리케이션이 청크 사이에서 실행될 수 있도록 합니다. 단, Incremental marking은 공짜로 이뤄지지 않습니다. application은 object graph (heap에서 root 부터 존재하는 instance들의 graph)가 변경될 때마다, GC에 notify해줘야 합니다. v8은 이 notification을 Dijkstra-style의 write-barrier를 통해 구현했습니다. 아래 코드는 object.field = value와 같은 할당이 일어나게 될 경우, object의 색깔을 grey로 변경시키고, worklist에 다시 push하는 코드를 나타냅니다. // Called after `object.field = value`. write_barrier(object, field_offset, value) { if (color(object) == black \u0026\u0026 color(value) == white) { set_color(value, grey); marking_worklist.push(value); } } write-barrier는 black object는 모든 필드가 검사된 상태이기 때문에, 흰색 entity를 가리키지 않는다는 사실에 근거해 있습니다. ","date":"2023-11-18","objectID":"/v8_garbage_collection/:2:1","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":"idle-time colleciton 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해, cpu가 idle 상태일 때만 GC를 실행하는 방법 v8의 incremental collection으로 쪼개진 chunk단위로 gc가 이뤄지는 것은 cpu idle time에 gc가 스케쥴링 되도록 하는 idle-time collection 기법과 매우 효과적으로 작동합니다. ","date":"2023-11-18","objectID":"/v8_garbage_collection/:2:2","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":"2. 새로운 v8 마킹 방법 2018년 v8에서는 새로운 접근방식인 Concurrent marking in V8 을 발표했습니다. (Chrome 64 및 Node.js v10에 적용) 이 접근방식은 크게 2가지로 진행됩니다. Parallel Marking Concurrent Marking Parallel Marking은 main thread와 모든 worker thread를 중단 시킨 뒤, parallel하게 mark작업을 진행하는 방식입니다. Concurrent Marking은 마킹을 주로 worker thread에 위임하고 marking이 되더라도, main thread에서는 application을 지속적으로 실행하는 방식입니다. @TODO CONTINUE https://v8.dev/blog/concurrent-marking#parallel-marking ","date":"2023-11-18","objectID":"/v8_garbage_collection/:3:0","tags":["js","gc","v8","node10"],"title":"JS garbage collection (2018 v8)","uri":"/v8_garbage_collection/"},{"categories":["dev"],"content":"모던 Javascript 튜토리얼 ","date":"2023-11-18","objectID":"/core_js/:0:0","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"1. JS 기본 ","date":"2023-11-18","objectID":"/core_js/:1:0","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"변수 typeof 연산자는 값의 자료형을 반환해줍니다. 그런데 두 가지 예외 사항이 있습니다. typeof null == \"object\" // 언어 자체의 오류 typeof function(){} == \"function\" // 함수는 특별하게 취급됩니다. ","date":"2023-11-18","objectID":"/core_js/:1:1","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"함수 함수 default 파라미터로 expression(표현식)을 넘겨줄 수도 있습니다. function showMessage(from, text = anotherFunction()) { // anotherFunction()은 text값이 없을 때만 호출됨 // anotherFunction()의 반환 값이 text의 값이 됨 } 또한 python과 달리, default가 나오고, default를 주지 않더라도 에러가 나지 않습니다. \u003e function F(a=\"yes\", b) {return `${a}, ${b}`} undefined \u003e F() 'yes, undefined' 이런 점에서는 a는 default를 쓰면서, b에 인자를 주고 싶다면 F(a=undefined, b=\"yes\")처럼 해야하는 불편한 상황이 생길 수 있을 것 같아서 python처럼 강제해서 관리하는게 더 좋아보이네요. 함수 parameter(매개변수) 기본값 평가 시점 자바스크립트에선 함수를 호출 때마다, argument가 없을 경우에만 default parameter를 평가합니다. 만약 해당 argument가 전달된다면 default의 expression은 호출되지 않습니다. return문이 없거나 return 지시자만 있는 함수는 undefined를 반환합니다. ","date":"2023-11-18","objectID":"/core_js/:1:2","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"함수 선언문 vs 함수 표현식 function sum(a, b) { return a + b; } const sum = function(a,b) { return a + b; }; 둘의 큰 차이점은 함수 선언문: 자바 스크립트는 스크립트 실행 전, 준비단계에서 선언된 함수 선언문들을 모두 찾아, 해당 함수를 생성합니다. 그렇기 때문에 함수 선언문은 함수 선언문이 정의되기 전에도 호출 가능합니다. 함수 표현식: 실제 코드 흐름이 해당 함수에 도달했을 때 함수를 생성합니다. 또 한가지 중요한 점은, 함수 선언문은 선언된 블록 내 어디서든 접근할 수 있지만, 블록 밖에서는 함수에 접근하지 못합니다. 다시 말해서 const booooooolean = true; switch (booooooolean) { case \"unreachable\": function greet() { console.log(\"unreachable\"); } greet(); break; } greet(); // TypeError: greet is not a function greet이 undefined이기 때문에, is not a function 에러가 발생합니다. ","date":"2023-11-18","objectID":"/core_js/:1:3","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"3. 객체:기본 ","date":"2023-11-18","objectID":"/core_js/:2:0","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"3.1. 객체 상수 객체는 수정될 수 있습니다. const user = { name: \"John\", }; user.name = \"Pete\"; // ok 단, property flag를 사용하면 immutable하게 처리할 수 있습니다. 물론 이 또한 user가 let인지 const인지와는 상관없습니다. use strict; // 엄격 모드에서만 가능합니다. let user = { name: \"John\" }; Object.defineProperty(user, \"name\", { writable: false }); user.name = \"Pete\"; // Error: Cannot assign to read only property 'name' 계산된 프로퍼티(computed property) 대괄호로 쌓여진 property는 computed property를 나타냅니다. const fruit = 'apple'; const bag = { [fruit + 'Computers']: 5 // bag.appleComputers = 5 }; 문자형, 심볼형이 아닌 key값은 문자열로 자동형변환 됩니다. // 선언시 7은 문자열로 \"7\"로 자동-형변환이 일어납니다. const o = { 7: \"hi\", }; console.log(o[7]); // 문자 또는 심볼이 아니기 때문에 \"7\"로 접근합니다. console.log(o[\"7\"]); 자바스크립트 객체의 중요한 특징: 존재하지 않는 프로퍼티에 접근하려 해도 에러가 발생하지 않고 undefined를 반환합니다. let user = {} console.log(user.alkdjfklcvjixc === undefined) //true 이를 해결하기 위해서 in 연산자를 사용해서 property가 들어있는지 확인합니다. let user = { name: \"John\", age: 30 }; alert( \"age\" in user ); // 1. true alert( \"blabla\" in user ); // 2. false let key = \"age\" alert( key in user) // 3. true, 문제 상황 위의 3번쨰 문제 상황 발생 가능하니, 그냥 ““를 사용해서 key를 체크하는게 좋습니다. 또한 property를 검사할 때는, 아래와 같은 이유로 === undefined로 체크하는 것 대신, in을 사용해야 합니다. property를 undefined로 선언한 경우 let o = { a: undefined }; console.log(o.a); // undefined, a라는 property key가 있든 없든, undefined가 나오기 때문에 비교문이 의미없다. console.log(\"a\" in o) // true for … in 반복문 object의 모든 property key를 순회가능합니다. 이건 array를 loop도는 for(;;)와는 본질적으로 다른 기능입니다. (많이 헷갈렸었음.) let user = { name: \"John\", age: 30, isAdmin: true, }; for (let k in user) { console.log(k); // name, age, isAdmin console.log(user[k]); // John, 30, true } 참고로 for (let k in user)에서 let을 지워도 동작하는데, 이는 js가 변수 선언 키워드(var, const, let)이 없으면 전역변수로 사용하기 때문이다. 그러니 변수에 키워드 무조건 넣는게 좋다고 생각합니다. 또한 use strict에서는 이를 허용하지 않습니다. property 정렬 순서 정수 프로퍼티(integer property)는 자동으로 정렬 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬됩니다. 따라서 아래 코드에서, 선언된 나라 순서가 중요하다면 주의해야합니다. let codes = { \"49\": \"독일\", \"41\": \"스위스\", \"44\": \"영국\", // .., \"1\": \"미국\" }; for (let code in codes) { alert(code); // 1, 41, 44, 49 } // 해결방법 let codes = { \"+49\": \"독일\", \"+41\": \"스위스\", \"+44\": \"영국\", // .., \"+1\": \"미국\" }; for (let code in codes) { alert( +code ); // 49, 41, 44, 1 } ","date":"2023-11-18","objectID":"/core_js/:2:1","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"3.2. by reference 참조에 의한 객체 복사 객체와 primitive type의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것입니다. reference copy대신 Shallow copy를 하고 싶다면 Object.assin()를 사용하면 됩니다. let user = { name: \"John\", sizes: { height: 182, width: 50 } }; let clone = Object.assign({}, user); shallow copy이기 때문에 user.sizes와 clone.sizes는 동일한 객체를 가리킵니다. @TODO CONTINUE https://ko.javascript.info/object-methods ","date":"2023-11-18","objectID":"/core_js/:2:2","tags":["js"],"title":"Core Javscript","uri":"/core_js/"},{"categories":["dev"],"content":"What is difference between .__proto__, .prototype, [[Prototype]]","date":"2023-11-18","objectID":"/prototype_in_js/","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"What is difference between __proto__, prototype, [[Prototype]] ","date":"2023-11-18","objectID":"/prototype_in_js/:0:0","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"TL;DR .__proto__: getter of [[Prototype]] [[Prototype]]: Internal Property .prototype function 정의: js는 자동으로 함수 정의할때, 함수.prototype에 { constructor: 함수 }인 object를 넣어준다. Constructor: js는 자동으로 constructor로 instance를 생성(new operator)할 때, const f = new F() 라고 한다면, f.__proto__ = F.prototype를 시행한다. FYI, __proto__를 직접적으로 활용하는 방식은 (deprecated)되었습니다. function F() {} // 1. Function 정의 시 F.prototype = { constructor: F, } // 이때 js는 위와 같이 prototype property를 추가하고, 이 property안에 constructor라는 property를 지닌, object를 추가하고, // constructor property는 함수 그자체를 가리킵니다. // 2. Constructor (new 사용) 시 const f = new F(); f.__proto__ = F.prototype // instance의 [[Prototype]]에 constructor.prototype에 대한 reference를 추가합니다. ","date":"2023-11-18","objectID":"/prototype_in_js/:1:0","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"__proto__ vs prototype vs [[Prototype]] ","date":"2023-11-18","objectID":"/prototype_in_js/:2:0","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"Function Javscript에서 Function은 사실 Object입니다. 더 정확히 말하자면 Function이란 키워드는 Object에 [[Call]](ECMA-262) internal property를 추가한 object입니다. 여기서 말하는 Function은 function이라는 함수를 생성할 때, 사용하는 예약어가 아닌 위 콘솔에서 확인할 수 있는 미리 생성되어있는(Built-in) object를 뜻합니다. 즉, 모든 function들은 Function(Built-in Function Object)의 instance입니다. 쉽게 설명해서 function = new Function() 라고 생각할 수 있습니다. 또한 JS에서 function F() {}처럼 function을 정의할 때, 내부적으로 prototype이라는 property를 추가하고, 이 값으로 { constructor: self }인 object를 추가합니다. JS의 Built-in들은 native source code로 정의되어있어, 매우 빠릅니다. (c++) function F() { } // js는 아래코드를, 자동으로 실행합니다. F.prototype = { constructor: F } ","date":"2023-11-18","objectID":"/prototype_in_js/:2:1","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"3 Functions compare function declaration(함수 선언식)외에도 추가로 2가지의 함수에 대해서도 동일하게 동작하는지 확인해보겠습니다. 함수를 생성하는 방법은 3가지입니다. Function declaration (function a() {}) Function expression (const f = function() {}) Arrow function (const f = () =\u003e {}) 먼저 Function expression입니다. 결론부터 말씀드리면, function declaration과 동일하게 동작합니다. const a = function() {} a.prototype \u003e {constructor: ƒ} a.__proto__ \u003e ƒ () { [native code] } const b = new a() b.prototype \u003e undefined b.__proto__ \u003e {constructor: ƒ} 다음으로는 Arrow Function입니다. 결론부터 말씀드리면, .prototype을 받지 못해 constructor필드가 존재하지 않게되어 생성자(Constructor)로서의 기능을 하지 못합니다. 그렇기 때문에 new 연산을 통해서 instance를 생성할 수 없습니다. const a = () =\u003e {} \u003e undefined a.prototype \u003e undefined a.__proto__ \u003e ƒ () { [native code] } function compare() {} \u003e undefined a.__proto__ === compare.__proto__ \u003e true new a(); \u003e VM1104:1 Uncaught TypeError: a is not a constructor at \u003canonymous\u003e:1:1 다만 __proto__, 즉 [[Prototype]] property는 기존의 function declaration의 [[Prototype]]과 동일한 property를 가지고 있습니다. 정리하면, function declaration방식과 function expression 방식은 차이가 없이 동작하며, arrow function는 prototype을 받지 못해, constructor가 존재하지 않습니다. ","date":"2023-11-18","objectID":"/prototype_in_js/:2:2","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"Constructor 모든 function들은 new라는 operator를 통해서 constructor의 기능을 할 수 있습니다. new키워드를 통해서 instance가 생성될 때, js에서는 추가적으로 constructor.property를 instance.__proto__안에 넣어줍니다. function F() {} const f = new F() // JS는 아래코드를 자동으로 실행합니다. f.__proto__ = F.prototype 즉 아래 2가지로 해석가능합니다. 이때 2번째 경우는 F === F.prototype.constructor이기 때문에 가능합니다. instance.__proto__ === F.prototype instance.__proto__ === F.prototype.constructor.prototype instance의 __proto__는 F.prototype을 가리키고, F.prototype.constructor는 F와 같기 때문에, instance.__proto__는 F.prototype과 F.prototype.constructor.prototype과 같습니다. instance.constructor === instance.__proto__.constructor js에서는 instance가 생성될 때, constructor라는 property를 추가시켜, F.prototype.constructor를 가리키고 있습니다. \u003e function F() {} undefined \u003e const f = new F() undefined \u003e f.constructor [Function: F] \u003e F.prototype.constructor === F true \u003e F.prototype.constructor === f.__proto__.constructor true \u003e F.prototype.constructor === f.constructor true \u003e f.constructor = undefined undefined \u003e f.constructor undefined \u003e F.prototype.constructor [Function: F] 즉 instance의 constructor property는 reference타입이라는 것을 알 수 있습니다. ","date":"2023-11-18","objectID":"/prototype_in_js/:2:3","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"The prototype chain js는 Built-in Object가 존재하며, User Defined Object들은 결국 빌트인 Object까지 chain을 타고 올라가며, 최종적으로 Object.[[Prototype]] === null에서 chainning이 마무리됩니다. The chain of objects connected by the __proto__ property is called the prototype chain. 즉 js는 상속을 __proto__ 필드를 사용해서 구현했으며, 실제로는 reference로 저장되기 때문에, singleton object들을 공유해서 상속하는 방식으로 되어있습니다. 아래는 위의 다이어그램을 js코드로 간단하게 표현해봤습니다. // 1. Built-in Objects in Javascript function Object() { prototype: { constructor: function Object(), __proto__: null // Object.prototype.__proto__ === null } // Object Internal Property // ecma: https://262.ecma-international.org/5.1/#sec-8.6.2 [[Prototype]]:{ constructor: function Function(), __proto__: Object.prototype } get __proto__() { return this.[[Prototype]] } [[Call]]: ... } function Function() { prototype: Object.__proto__ [[Prototype]]: Object.__proto__ get __proto__() { return this.[[Prototype]] } [[Call]]: ... } // 2. User-defined Objects // new를 사용하면 o.[[Prototype]] property에 포인터 of Constructor.prototype // 즉 o.__proto__ === Object.prototype const o = new Object() function Polygon() { // 함수 생성시, js엔진은 prototype property를 추가해준다. 이 property는 object로 constructor로 self를 가리키는 property를 지니고 있다. prototype: { constructor: function Polygon(), // self __proto__: Object.prototype // {}(literal object)로 생성할 때, __proto__에 Object.prototype의 reference가 담긴다. } __proto__: Function.prototype } ","date":"2023-11-18","objectID":"/prototype_in_js/:2:4","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"__proto__ vs [[Prototype]] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/proto 주의: 객체의 [[Prototype]]을 변경하는 것은 최신 JavaScript 엔진이 속성 접근을 최적화하는 방식의 특성상 모든 브라우저 및 JavaScript 엔진에서 매우 느린 작업입니다. 상속 구조를 변경하는 것이 성능에 미치는 영향은 미묘하고 광범위하며, obj.__proto__ = ... 문에 소요되는 시간 뿐만 아니라 [[Prototype]]이 변경된 객체에 접근할 수 있는 모든 코드들에 대해서도 영향을 줄 수 있습니다. 성능에 관심이 있다면 객체의 [[Prototype]] 설정을 피해야 합니다. 대신 Object.create()를 사용하여 원하는 [[Prototype]]으로 새 객체를 만드세요. 주의: Object.prototype.__proto__는 오늘날 대부분의 브라우저에서 지원되지만, 그 존재와 정확한 동작은 오직 웹 브라우저와의 호환성을 보장하기 위한 레거시 기능으로서 ECMAScript 2015 사양에서 비로소 표준화되었습니다. 더 나은 지원을 위해 대신 Object.getPrototypeOf()를 사용하세요. 그러니, 직접적인 __proto__ 보다는 Object.getPrototypeOf()를 사용하는 것이 권장된다. ","date":"2023-11-18","objectID":"/prototype_in_js/:3:0","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["dev"],"content":"Conclusion __proto__: getter of [[Prototype]]. prototype: 함수에서는 constructor기능을 위해, 사용되며, object는 inheritance를 위해 사용되는 필드. [[Prototype]]: proto chain을 사용한 상속(코드 공유)를 위해 사용되는 internal property. ","date":"2023-11-18","objectID":"/prototype_in_js/:4:0","tags":["dev","js"],"title":"Prototype in Javascript","uri":"/prototype_in_js/"},{"categories":["life"],"content":"How to practice memorizing and flow (Csikszentmihalyi) ","date":"2023-11-15","objectID":"/memory_and_flow/:0:0","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"Part1: 기억 ","date":"2023-11-15","objectID":"/memory_and_flow/:1:0","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"기억 1부 기억은 감정, 기억이 풍부하면 감정이 풍부해진다. (공감) Q. 점점 기억이 많아지면 머리가 복잡해지지 않나요? No, 기억의 양이 많아지면 임계치를 넘어가면 “질\"이 바뀐다. 방법 장소법 3의 법칙 (3개를 연결 시켜라, 결합의 법칙) 책을 읽고나서, 정보의 핵심을 도표로 바꾸고, 3개씩 연결한다. 정리하면, 3의 법칙 도표화 인출단서 (인출될 수있는 시작점) 기억 3원칙 유용한가 확장 가능한가? 쉬운가? (대모순) 쉽게 만드는 3원칙 대칭화: 1517(루터종교개혁) -\u003e 1571(레판토) 모듈화 순서화: 분리해서 쉽게 외우도록 (3개씩), (), (), () ","date":"2023-11-15","objectID":"/memory_and_flow/:1:1","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"기억 2부 “습관을 바꾸거나 모든 것은 상황을 절박하게 만들어라. 그럼 우리는 행동한다” =\u003e 기억할 시간을 많이 주지마라. (샤워하는 시간동안 3가지를 기억하겠다.) 기억은 곧 창의성이고, 창의성의 원재료가 된다. (남송) 질문의 힘, “뭐가 중요한데?” (결정적 지식 = 일이관지) 절차의 힘, “최소의 단위가 뭔데?” (최소의 단위 -\u003e 자가 발전) ","date":"2023-11-15","objectID":"/memory_and_flow/:1:2","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"Part2: 몰입(Flow) ","date":"2023-11-15","objectID":"/memory_and_flow/:2:0","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"몰입 5단계 50시간 몰입의 법칙 몰입은 마라톤입니다. 호흡부터 연습을 해봅시다. 생각하기 연습: 20분씩, 하루에 5번 2주간 (11/15 - 11/29) 천천히 생각하기: Slow thinking(명상), 조급함(힘을 빼기)을 버리고 행위에만 집중 / 평일 2시간, 2주간 최상의 컨디션: 주말을 하루종일, 주중에 2시간씩 그리고 매일 땀흘리고 운동 두뇌활동 극대화: 이제 일주일(전문가의 뇌)간 생각하기 연습 가치관의 변화: 한달이상(천재의 뇌), 이제 이 활동이 일상이됨 ","date":"2023-11-15","objectID":"/memory_and_flow/:2:1","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"몰입 실천법 내가 해결해야 하는 문제를 정한다. 이완해서 편안하게 상상, 걸으면서 이동하면서. ","date":"2023-11-15","objectID":"/memory_and_flow/:2:2","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["life"],"content":"황농문, 몰입 영어 “암묵기억을 이용해 자전거 배우듯 몸으로 영어를 몰입하여 배워라” 외현기억과 암묵기억. 영어는 암묵기억(듣기 / 말하기)로 영어를 배우고, 외현기억(읽고 쓰기)로 유지하라. 하루 1시간씩 한달보다, 하루 10시간씩 3일 몰입하여 임계점을 넘기는 것이 중요. ","date":"2023-11-15","objectID":"/memory_and_flow/:2:3","tags":["memory"],"title":"Memory And Flow","uri":"/memory_and_flow/"},{"categories":["dev"],"content":"Typescript Better Enum ","date":"2023-11-10","objectID":"/typescript_enum/:0:0","tags":["dev","typescript"],"title":"Typescript Better Enum","uri":"/typescript_enum/"},{"categories":["dev"],"content":"TL;DR TS버전 5.*.*미만일 경우에는 Enum을 사용하지 말자, 대신 as const 사용하자. v5 부터는 enum 사용 const PostState = { Draft: \"DRAFT\", Scheduled: \"SCHEDULED\", Published: \"PUBLISHED\" } as const; type PostStateType = typeof PostState[keyof typeof PostState]; // Usage const x: PostStateType = PostState.Draft const y: PostStateType = \"SCHEDULED\" 다만 TS version5부터는, All enums Are Union enums enum의 기존 문제점들이 해결되었습니다. ","date":"2023-11-10","objectID":"/typescript_enum/:1:0","tags":["dev","typescript"],"title":"Typescript Better Enum","uri":"/typescript_enum/"},{"categories":["dev"],"content":"Enum의 문제점과 v5의 변화 기존의 타입스크립트에서 enum은 기본적으로 숫자 기반 enum이었습니다. 이는 각 enum 멤버가 숫자 값을 가지며, 이 숫자들은 컴파일 타임에 할당됩니다. 그러나 타입스크립트의 타입 체킹 시스템은 enum 타입으로 선언된 변수에 어떠한 숫자도 할당할 수 있게 허용했습니다. 이는 enum이 숫자의 집합으로 간주되었기 때문입니다. 예를 들어, 다음과 같은 enum이 있다고 가정해보겠습니다: enum PostState { Draft, // 0 Published, // 1 Private, // 2 } 여기서 PostState 타입의 함수에 숫자를 전달하는 것은 허용되었습니다: function handlePost(state: PostState) {} handlePost(0); // Draft를 의미합니다. handlePost(1); // Published를 의미합니다. handlePost(9999); // 타입 체크를 통과합니다. handlePost(9999)가 허용되는 이유는 타입스크립트가 enum 타입을 숫자의 서브타입으로 간주했기 때문입니다. 즉, PostState 타입은 실제로 숫자 타입에 할당 가능한 모든 값을 포함하고 있었습니다. (모든 숫자값을 허용하는 문제) 이는 타입 안전성을 저해하는 문제로 인식되었고, 코드의 의도를 명확하게 표현하는 데에도 문제가 있었습니다. 타입스크립트 2.0에서 도입된 enum 리터럴 타입은 이 문제를 부분적으로 해결했습니다. 각 enum 멤버는 리터럴 타입을 가지게 되어, PostState 타입은 실제로 0 | 1 | 2와 같은 유니언 타입이 되었습니다. 그러나 계산된 멤버가 있는 경우에는 여전히 문제가 발생할 수 있었습니다. 타입스크립트 5.0에서는 모든 enum 멤버가 고유한 타입을 가지게 되어, 이러한 문제를 완전히 해결했습니다. 이제 handlePost(9999)와 같은 호출은 타입 에러를 발생시키게 되어, 타입 안전성이 향상되었습니다. 타입스크립트 5.0에서의 변화: 타입스크립트 5.0에서는 모든 enum 멤버가 고유한 타입을 가지게 되어, enum은 멤버 타입들의 유니언이 됩니다. 이로 인해 각각의 enum 멤버를 더 명확하게 다룰 수 있게 되며, 타입 안전성이 향상됩니다. // 타입스크립트 version 5.*.* enum PostState { Draft, // 이제 'PostState.Draft' 타입을 가짐 Published, // 'PostState.Published' 타입 Private, // 'PostState.Private' 타입 } // 이 함수는 이제 'PostState'의 특정 멤버만을 받을 수 있습니다. function handlePost(state: PostState.Draft | PostState.Published) {} handlePost(PostState.Draft); // ✅ handlePost(PostState.Private); // ❌ 타입 체크 해줌 handlePost(999); // ❌ 값 체크 해줌 이제 handlePost 함수는 PostState의 모든 멤버를 받는 것이 아니라, 오직 Draft 또는 Published 상태의 포스트만을 처리할 수 있습니다. 이는 타입스크립트가 더 엄격한 타입 체크를 할 수 있게 해주어, 잘못된 값이 함수에 전달되는 것을 방지합니다. 또한, 계산된 값을 가진 enum 멤버에 대해서도 고유한 타입을 생성하여, 이전에는 타입스크립트가 처리하지 못했던 경우에도 타입 안전성을 제공합니다. enum PostState { Draft = \"DRAFT\", Published = \"PUBLISHED\", Private = Math.random() // 계산된 값 } // 이전 버전에서는 'Private' 멤버의 타입이 계산될 수 없었지만, // 타입스크립트 5.0에서는 'Private'도 고유한 타입을 가집니다. 이러한 변화는 코드의 명확성과 타입 안전성을 크게 향상시키며, 타입스크립트를 사용하는 개발자들에게 더 나은 개발 경험을 제공합니다. ","date":"2023-11-10","objectID":"/typescript_enum/:2:0","tags":["dev","typescript"],"title":"Typescript Better Enum","uri":"/typescript_enum/"},{"categories":["dev"],"content":"Deep dive into typescript tsc and ts-node ","date":"2023-11-07","objectID":"/typescript/:0:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"tsc(Typescript Compiler) tsc는 타입스크립트 공식 컴파일러로 Typescript 코드를 Javascript 코드로 변환합니다. 이 과정에서 타입 검사를 수행하고 설정된 대상 버전의 JS 코드를 생성합니다. ","date":"2023-11-07","objectID":"/typescript/:1:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"ts-node ts-node는 TypeScript 코드를 직접 실행할 수 있는 Node.js의 런타임입니다. 기본적으로 Node.js는 .js 파일만 실행 할 수 있지만, ts-node를 사용하면 Node.js의 런타임을 확장하여 .ts 파일을 직접 실행할 수 있는 기능을 추가합니다. 일반적으로 ts-node는 개발환경에서 TS코드를 신속하게 실행하고 테스트하기 위해 사용되기 때문에 production 의존성에서는 제외시키는 것이 좋습니다. ","date":"2023-11-07","objectID":"/typescript/:2:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"tsc vs ts-node 개발자는 ts-node를 사용해 빠른 피드백을 얻고 프로덕션 빌들르 생성할 때는 tsc를 사용해 최적화된 Javascript 코드를 생성할 수 있습니다. eslint, tslint, prettier 2019년 tslint는 deprecated되었고, eslint는 코딩 컨벤션을 위배하거나 안티 패턴을 자동 검출하는 Linting(소스코드를 분석하여 프로그램 오류, 버그, 스타일 오류등을 찾아내는 도구다.) tool입니다. 공식문서에서는 타입스크립를 위한 eslint로 tslint대신 typescript-eslint 를 추천합니다. prettier는 코딩 스타일 교정을 위한 포맷터입니다. 광범위한 scope이다 보니, eslint와 prettier이 충돌되는 경우가 있습니다. (예를 들면 tab옵션) 충돌되지 않도록 하기 위해서는 일반적으로 Prettier를 먼저 실행하고 eslint를 실행하는 것이 좋습니다. Code -\u003e prettier -\u003e eslint --fix -\u003e Formatted Code Prettier로 코드를 Formatting한 뒤(prettier) ESLint로 수정(eslint --fix)한 것과 같은 결과물을 출력한다. LogRocket: Linting in Typescript using eslint and prettier TypeScript ESLint + Prettier 함께 사용하기 on vscode CommonJS vs ES6(ESM) Kakao: CommonJS에서 ESM으로 전환하기 Node.js가 js파일을 어떤 모듈 방식으로 구문분석할지 결정하는 방식입니다. ","date":"2023-11-07","objectID":"/typescript/:3:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"CommonJS CommonJS는 자바스크립트를 위한 모듈 표준 중 하나입니다. Node.js는 이 CommonJS 모듈 시스템을 사용해 파일과 모듈을 관리하며, 대표적으로 require, module.exports 구문을 사용해 모듈을 가져오고 내보내는 것이 표준의 특징입니다. require()는 ESM 파일을 가져올 수 없습니다. (ERR_REQUIRE_ESM 에러 발생) 파일 확장자를 작성하지 않아도 됩니다. const module = require('./moduleFile'); import() ESM 모듈을 CJS에서 비동기적으로 불러오기 위한 표현식입니다. 반드시 파일 확장자를 지정해주어야 합니다. import('./moduleFile.js').then(module =\u003e ) ","date":"2023-11-07","objectID":"/typescript/:4:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"ES6 (ECMAScript 2015) ES6는 import, export 구문을 사용하는 모듈 시스템을 도입한 버전입니다. import문: 구문 분석 단계에 모듈을 불러오기 때문에 런타임인 데이터(동적인 값)을 사용할 수 없습니다. CJS, ESM 모듈 모두 불러올 수 있으며, 반드시 파일 확장자를 지정해주어야 합니다. // export default export default { something: 123 } export const namedSomething = 123 // export from export otherModuel import { funcName } from './moduleFile.js' // 사용 불가 import {AorB_Module} from condition ? './A_module.js' : './B_module.js'; // 동적으로 모듈을 불러오기 위해서는 import 표현식(Expr)을 사용해야 합니다. const module = await import(condition ? './A_module.js' : './B_module.js'); ","date":"2023-11-07","objectID":"/typescript/:5:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"ESM에서 CJS 모듈 사용하기 cjs의 module.exports로 내보내진 모듈은 default attribute에 담겨서 내보내집니다. 모듈 또한 instance로 취급되며, module객체 안에 default라는 attribute가 존재합니다. // 1. module객체안의 default attribute를 cjsModule이라는 이름으로 // cjsModule === { a: 1, b: 2 } import { default as cjsModule } from 'cjs'; // 2. 1과 동일한 sugar syntax import cjsSugar from 'cjs'; // 3. module 객체를 cjsNamespace로 할당 import * as cjsNamespace from 'cjs'; /* [Module: null prototype] { __esModule: undefined, default: { a: 1, b: 2 } } */ ","date":"2023-11-07","objectID":"/typescript/:5:1","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"ESM 동작 원리 mozila hacks ","date":"2023-11-07","objectID":"/typescript/:6:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":["dev"],"content":"ESM, CJS 트리쉐이킹 CJS 모듈은 런타임에 require()를 통해 모듈을 로드하기 때문에 동적 특성상 빌드 시스템이 어떤 코드가 실제로 사용될지를 정적으로 분석하기 어렵게 합니다. 이는 모듈의 일부만 사용되더라도 전체 모듈을 번들에 포함해야 할 수 있음을 뜻합니다. 이와 반대로 ESM은 모듈의 import, export를 조건부안에 넣을 수 없기 때문에(물론 await import가 있지만 동적 import는 트리쉐이킹 불가), 빌드타임에 import문을 분석가능하게 합니다. 이를 통해서 의존성 그래프를 번들러가 모듈을 실행하기 전에 알 수 있으며, 이를 통해 사용하지 않는 모듈들을 제거할 수 있습니다. 하지만 최근 번들러들은 esm 만큼 효과적이지는 않더라도 일정수준의 트리쉐이킹을 cjs에서도 수행할 수 있습니다. \u003cscript/ \u003e defer vs async https://ko.javascript.info/script-async-defer \u003cscript type=\"module\"\u003e https://ko.javascript.info/modules-intro 브라우저에서 import, export 지시자를 사용하려면 type=module이 필요합니다. 모듈은 defer처럼 처리됩니다. \u003cscript async type=\"module\" /\u003e를 사용하면 async처럼 사용가능합니다. 보안을 위해, 외부 오리진에서 스크립트를 불러오려면 서버가 Access-Control-Allow-Origin: 헤더 제공해야합니다. 모듈은 자신만의 scope를 가집니다. 모듈은 1번만 실행되고, import \u0026 export로 모듈간 공유됩니다. 항상 use strict로 실행됩니다. lexical scoping 렉시컬 scope(lexical scope)이란 호출되는 시점에 따라 상위 스코프를 결정하는 dynamic scoping과 반대되는 개념으로, 선언되는 시점에 따라 상위 스코프를 결정하는 정적 스코핑을 의미합니다. 다시말해 함수가 어디서 호출되었는지가 아닌, 어디에 선언되었는지가 중요합니다. this scope Arrow function Bundler 번들러는 웹 개발에서 사용되는 여러 자바스크립트 파일과 리소스를 하나 또는 여러개의 최적화된 파일로 결합하는 도구입니다. 이를 통해 웹 애플리케이션의 로딩 시간을 줄이고 성능을 향상시키며, 브라우저 간 호환성 문제를 해결하는데 도움을 줍니다. (FE) 성능 최적화: 사용자가 웹사이트에 접속할떄, 모든 js파일을 개별적으로 로드하는 것은 많은 시간이 소요되기 때문에, 번들러는 하나의 파일로 결합하여 네트워크 요청의 수를 줄이고 결과적으로 페이지 로딩시간을 단축시킵니다. 코드 최적화: 번들러는 타입스크립트를 순수 js로 컴파일하고 사용되지 않는 코드(트리 쉐이킹)를 제거하여 최종 파일 크기를 줄입니다. 보안 / 유지보수: 번들러는 소스코드를 압축하고 난독화하여 보안을 강화합니다. 환경 일관성: 다양한 브라우저와 장치에서 애플리케이션을 동일하게 실행하기 위해, 번들러는 필요한 폴리필과 트랜스파일링을 적용하여 호환성을 보장합니다. 트랜스파일링: 호환성을 위해 최신 js 문법 -\u003e 구 버전 JS문법 변환 폴리필: 특정 브라우저가 지원하지 않는 기능을 구현하는 코드 조각. 예를 들어 구형 브라우저에서 Promise나 fetch API를 사용할 수 있게함. env: ENV 주입, phase관리(dev, sandbox, prod) 대표적으로 아래와 같은 번들러들이 존재합니다. Webpack: 매우 강력하고 유연한 플러그인 시스템을 가지고 있으며, 대규모 프로젝트와 복잡한 구성에 적합합니다. 많은 커뮤니티 지원과 풍부한 플러그인 생태계를 가지고 있습니다. Vite: 최신 프론트엔드 도구로, esbuild를 사용하여 매우 빠른 cold start와 HMR을 제공합니다. 간단한 설정과 빠른 빌드 속도로 인기를 얻고 있습니다. Rollup: 특히 라이브러리 개발에 적합하며, 효율적인 트리 쉐이킹과 코드 분할 기능을 제공합니다. 또한, 결과물이 깔끔하고 작은 번들을 생성합니다. Parcel: 설정이 필요 없는 번들러로, 빠른 설정과 개발 시작이 가능합니다. 작은 프로젝트나 간단한 웹 애플리케이션에 적합합니다. esbuild: Go로 작성되어 매우 빠른 빌드 속도를 자랑합니다. 대규모 프로젝트의 빌드 시간을 단축시키는 데 유용합니다. TS Compile process TypeScript / How the compiler compiles https://www.nextree.io/typescript-compile-process/ 높은 차원에서 타입스크립트 컴파일러는 .ts파일을 *.js, *.d.ts, *.map로 생성합니다. 이제 좀 더 자세히 알아보겠습니다. 내부적으로 컴파일 프로세스는 아래와 같은 과정들을 포함합니다. $ tsc command Read tsconfig.json tsc는 src/compiler/program.ts에 정의되어있는 Program 객체로 컴파일 컨텍스트를 생성한 뒤 tsconfig에 정의된 모든 입력파일과 import를 로드합니다. 이후 각각의 파일을 AST(Abstract Syntax Tree)로 변환시키기 위해 Parser(src/compiler/parser.ts)를 호출합니다. 내부적으로 Parser는 Scanner(src/compiler/scanner.ts) 인스턴스를 생성합니다. Scanner 인스턴스는 소스코드를 스캔하여 스트림형태의 토큰(SyntaxKind라고 불림)을 생성합니다. 정리하면 Scanner가 타입스크립트로 입력된 코드 문자열은 각각 예약어, 콜론, 부호등의 토큰으로 분리시키고, Parser는 Scanner가 분리해준 토큰을 구문의 구조에 따라 트리 구조로 만들어냅니다. 그러면서 추가로 코드가 올바른 문법인지 분석하여 구문 오류를 잡아냅니다. Scanner: tokenize Parser: Build AST 이후 Binder(src/compiler/binder.ts)는 AST 즉 Tree를 traverse하면서, Symbols table인 HashMap을 생성합니다. 바인더는 AST의 각 노드를 방문하여 식별자(변수, 함수, 클래스, 인터페이스 등)를 수집하며, 이 식별자를 key로 하는 value인 symbol을 생성합니다. (아래 그림의 키값이 잘못됨 실제로는 string타입인 identifier로 저장됨) 심볼에는 해당 식별자의 타입, 스코프, 선언 위치 등의 메타데이터를 포함합니다. Binder의 Symbol테이블을 통해 식별자 네이밍 컬리션을 방지할 수 있으며, HashMap 특성상 상수시간에 식별자에 대한 symbol에 접근하여 효율적으로 컴파일이 진행될 수 있습니다. 앞서 AST가 tree라고 하였는데, Binder는 symbol table이외에도 AST 트리를 타고 가면서 flow nodes를 생성해 추적합니다. flow nodes(flow container)는 flow conditional(조건식)을 기준으로 분기가 나눠집니다. (FYI, flow nodes는 이후 타입 체킹과정에서 Type Guards, Type Inference와 같은곳에서 사용됩니다.) 즉 binder는 AST를 통해서 symbol table과 flow nodes를 생성합니다. Binder: Create Symbol table and Flow Nodes 이후 타입스크립트의 핵심이 Type Check단계가 진행됩니다. (Type Checker, src/compiler/types.ts) 여기에서 타입 추론과 타입체크 등이 발생합니다. TypeChecker: type checking 이후 AST와 type Checker를 통해 자바스크립트 코드로 변환하는 emitter가 실행되며 emitter는 크게 2가지가 존재합니다. emitter.ts (.js): 자바스크립트 소스코드와 source map을 생성합니다. declarationEmitter.ts (.d.ts): 타입 정의 파일을 생성합니다. 이를 emitter과정이 끝나면 최종적으로 3가지 파일형태가 생성됩니다. *.js: transpile된 js *.d.ts: 타입스크립트 타입 정보 *.map: 소스맵 파일, 주로 js파일의","date":"2023-11-07","objectID":"/typescript/:7:0","tags":["dev","typescript"],"title":"Deep dive into Typescript","uri":"/typescript/"},{"categories":[""],"content":"Golang Pointer Receiver를 사용할 때 발생할 수 있는 문제점 ","date":"2023-11-02","objectID":"/go-receiver-race-condition/:0:0","tags":["dev"],"title":"Go Receiver Race Condition","uri":"/go-receiver-race-condition/"},{"categories":[""],"content":"Receiver Golang에서는 총 2가지의 receiver가 있습니다. Value Receiver Pointer Receiver Pointer Receiver를 사용하게 될 경우, instance의 pointer에 접근이 가능하기 때문에, 원본 값의 데이터를 변경할 수 있기 때문에 POST/ UPDATE 같은 메서드의 경우 pointer receiver를 사용하는 것이 현명합니다. // DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeControllerManagerConfiguration. func (in *KubeControllerManagerConfiguration) DeepCopy() *KubeControllerManagerConfiguration { if in == nil { return nil } out := new(KubeControllerManagerConfiguration) in.DeepCopyInto(out) return out } 이외에도 큰 struct의 경우, 복사본 대신 포인터를 전달하면 효율적이기 때문에 위와 같이 pointer receiver를 사용해서 불변일 값도 전달합니다. 그럼 value receiver를 언제 사용해야될까 고민해보겠습니다. 먼저 당연하게도 일반적인 type의 데이터이면서 modify가 필요없을 경우에 value receiver를 사용하면 될 것 같습니다. 추가로 이외에도 value receiver를 언제 사용하면 좋을지 개인적으로 생각해봤습니다. ","date":"2023-11-02","objectID":"/go-receiver-race-condition/:1:0","tags":["dev"],"title":"Go Receiver Race Condition","uri":"/go-receiver-race-condition/"},{"categories":[""],"content":"Race condition on Pointer Receiver 생각하보면 pointer receiver는 특정 변수의 pointer를 전달하기 때문에 race condition이 발생할 수 있습니다. 만약 아래와 같은 Counter가 있다고 할때 package main import ( \"fmt\" \"sync\" ) type Counter struct { Value int } func (c *Counter) Increment() { c.Value++ } 1000개의 waitgroup에서 counter를 increment할 경우, 결과는 예측 불가합니다. func main() { var wg sync.WaitGroup counter := Counter{} for i := 0; i \u003c 1000; i++ { wg.Add(1) go func() { defer wg.Done() counter.Increment() // Race Condition! }() } wg.Wait() fmt.Println(\"Counter:\", counter.Value) // 결과는 예측 불가 } 즉 pointer receiver는 당연하게도 race condition을 유발합니다. 이와 반대로 value receiver는 복사본을 넘기기 때문에 접근하는 go routine은 당연히 각각 복사된 value에 접근하기 때문에 race condition이 발생하지 않습니다. ","date":"2023-11-02","objectID":"/go-receiver-race-condition/:2:0","tags":["dev"],"title":"Go Receiver Race Condition","uri":"/go-receiver-race-condition/"},{"categories":[""],"content":"Shallow Copy 기본적으로 golang의 struct는 Call by value이지만, 슬라이스, 맵, 채널, 함수등의 참조타입들을 Call by reference로 동작합니다. slice가 call by reference가 될 수 밖에 없는 이유 참고로 Golang의 slice값은 pointer, length, capacity를 가진 struct입니다. 그렇기 때문에 slice를 복사하더라도 내부적으로 array에 대한 pointer는 여전히 같은 array를 가리키고 있기 때문에, slice를 복사하더라도, array는 여전히 원본을 가리키고 있는 shallow copy가 일어나게 됩니다. type slice struct { array unsafe.Pointer // 실제 배열 요소들의 포인터 len int // 슬라이스의 길이 cap int // 슬라이스의 용량 } 다시 본론으로 돌아와서 Value Receiver를 사용하더라도 Referce type들을 사용할 경우 여전히 race condition이 발생할 수 있습니다. package main import ( \"fmt\" \"sync\" ) type Counter struct { Slice []int } // 값 리시버를 사용하는 메서드. // Slice는 참조 타입이므로, 이 메서드는 Slice의 shallow copy를 다룹니다. func (c Counter) Increment(index int) { c.Slice[index]++ } func main() { var wg sync.WaitGroup counter := Counter{Slice: make([]int, 2)} for i := 0; i \u003c 1000; i++ { wg.Add(1) go func() { defer wg.Done() counter.Increment(0) // 여기서 경쟁 상태 발생 가능 }() } wg.Wait() fmt.Println(\"Counter:\", counter.Slice[0]) // 결과는 예측 불가 } ","date":"2023-11-02","objectID":"/go-receiver-race-condition/:3:0","tags":["dev"],"title":"Go Receiver Race Condition","uri":"/go-receiver-race-condition/"},{"categories":[""],"content":"Conclusion 이상으로 golang의 2가지 타입의 receiver를 살펴보았습니다. 정리하면, call by value인 작은 타입의 불변의 데이터인 경우 value receiver를 사용하고, 나머지의 경우 call by reference를 race condition을 조심하면서 사용하면 될 것 같습니다. ","date":"2023-11-02","objectID":"/go-receiver-race-condition/:4:0","tags":["dev"],"title":"Go Receiver Race Condition","uri":"/go-receiver-race-condition/"},{"categories":["database"],"content":"Design efficient database structures with PostgreSQL ","date":"2023-10-15","objectID":"/postgresql/:0:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"How to build a ‘Like’ System Instagram의 ‘Like’ System을 만들 때, user \u003c-\u003e likes \u003c-\u003e posts 관계를 생각해볼 수 있습니다. 이 경우 like는 아래의 Rule이 필요합니다. 각 유저는 특정 post에 한번만 like를 해야합니다. 자신의 게시물은 like 할 수 없습니다. 유저는 unlike할 수 있어야 합니다. 얼마나 많은 유저들이 post를 like했는지 셀 수 있어야 합니다. 어떤 유저들이 Like했는지 볼 수 있어야 합니다. 어쩌면 post이외에도 like할 수 있어야 합니다. (i.e 댓글) 어쩌면 하트/빈하트가 아니라, 이모티콘 처럼 여러 종류의 Reaction을 관리할 수도 있습니다. ","date":"2023-10-15","objectID":"/postgresql/:1:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"1st approach 가장 단순하게 like system을 생각해본다면, posts 테이블안에 likes 필드를 두어 관리하는 방법을 생각해볼 수 있습니다. 이 경우, 다음과 같은 문제점들이 생깁니다. 어떤 유저가 like했는지 기록하지 않아, 한번만 like 하도록 강제할 수 없습니다. 특정 유저가 unlike할 때, 자신이 한 like를 unlike하는건지 알 수 없습니다. 누가 어떤 post를 like하는지 알 방법이 없습니다. 유저가 탈퇴하면 어떤 포스트의 like 수를 낮춰야 하는지 알 수 없습니다. ","date":"2023-10-15","objectID":"/postgresql/:1:1","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"2nd approach 다음 방법은, likes 테이블을 따로 두어, user_id와 post_id를 기록하는 방식입니다. 이렇게 할 경우, 아래 4가지 경우를 모두 알 수 있습니다. 특정 post의 # of likes 특정 post에 누가 like 했는지 like 순으로 post들 정렬가능 특정 user가 like한 post들 이때 한 유저는 한번만 post에 like를 해야하니, unique(user_id, post_id)로 관리합니다. 하지만 여기서 만약 post이외에도 댓글에 대해서 like를 해야하는 요구사항이 생기면 어떻게 관리되어야 할까요? ","date":"2023-10-15","objectID":"/postgresql/:1:2","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"3rd, Polymorphic association post와 comment의 like를 쉽게 관리할 수 있는 첫번째 방법은 다음과 같습니다. likes 테이블에 post_id 또는 comment_id를 기록하는 like_id와 post/comment에 대한 like_type을 추가하는 방식입니다. 이 방법을 Polymorphic association이라고 칭합니다. 이 경우에 가장 큰 문제점은 ’like_id’가 fk로 관리될 수 없고 일반 int필드로 관리되기 때문에, constraint와 관리에서 큰 문제가 발생할 수 있습니다. ","date":"2023-10-15","objectID":"/postgresql/:1:3","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"4th Polymorphic Association을 피하는 가장 쉬운 방법은 2개의 fk (post, comment)를 관리하던 like_id를 나누면 됩니다. post_id와 comment_id를 나눈뒤, fk로 관리하면 문제를 해결 할 수 있습니다. 이때 post_id와 comment_id가 동시에 값을 가지거나, 동시에 null인 경우를 처리하기 위해서 COALESCE((post_id)::BOOLEAN::INTEGER,0) + COALESCE((comment_id)::BOOLEAN::INTEGER,0)를 사용해 constraint를 걸어줍니다. 하지만 이 방법 또한 like를 post와 comment이외에도 여러곳에서 사용해야한다면 관리가 복잡해진다는 단점이 존재합니다. ","date":"2023-10-15","objectID":"/postgresql/:1:4","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"5th 이전의 방식의 문제점은 하나의 테이블에서 서로 다른 형태의 like를 관리하려 했기 때문이기 때문에, 이를 해결하기 위해서 like테이블을 각각 나눠서 관리하면 됩니다. 이 경우 장점은 like가 여러곳에서 사용되더라도, 여러 테이블로 관리하면 되기 때문에 테이블 복잡도를 낮출 수 있습니다. 또한 트래픽 차원에서도 만약 post-like에 대한 접근과 comment에 대한 like 접근이 8:2라면, 이전 방식에서는 하나의 테이블에서 부하를 모두 감당했지만, 나눠진 테이블에서는 분리해서 관리하기 때문에 관리가 더 편합니다. 또한 Reaction 타입의 like를 Post에 도입한다 하더라도, col한개만 추가하면 되기 때문에 간편합니다. 다만 정규화를 할 수록 join에 대한 요구가 더 많아질 수 있기 때문에, 이에 대해서는 trade-off가 존재합니다. 만약 post와 comment 외에 like가 필요없다면 기획적으로 사용할 예정이라면, 이전 방법도 좋은 방법입니다. ","date":"2023-10-15","objectID":"/postgresql/:1:5","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"How to build a ‘Mention’ System `@user_id`` 다음은 mention에 대해서 db를 디자인 해봅니다. 가장 먼저 post안의 @renan_ozturk나, @stepenwikes와 같이 멘션들을 넣을 수 있습니다. 또한 post를 생성 시, Tag People를 하여, 사용자를 태그할 수 있으며, Image의 특정 x,y 좌표에 mention을 할수도 있습니다. 이외에도 post에 대한 좌표를 저장해야 합니다. 우선 여기에선 photo에 대한 tag와 post안에 들어있는 caption_tag에 대한 schema를 디자인 해보자면 다음과 같은 2가지 방식이 존재할 수 있습니다. 첫번째 방식은 photo mention인 경우에는 x,y를 저장하고, 그렇지 않으면 x,y를 Null로 관리하는 방식이고 두번째 방식은 2개의 테이블로 나눠서 관리하는 방식입니다. ","date":"2023-10-15","objectID":"/postgresql/:2:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"How to build a ‘HashTag’ System 다음은 인스타그램 hashtag 시스템입니다. 여러 곳에서 hashtag가 사용되고 있으며 이에 대해서 기록하면 스키마는 다음과 같습니다. 하지만 실제로 hashtag는 post에 대한 검색만을 제공해주고 있기 때문에 rdb에는 post에 대한 hashtag만 저장해두면 될 것 같습니다. 다른 곳에서 사용되는 hashtag들은 rdb가 아닌 분석을 위해, preprocess 단계를 거쳐 데이터웨어하우스에 저장하는 방식으로 저장될 수는 있어 보입니다. 결국 추가적으로 관리해야 하는 table은 hashtag \u003c-\u003e post에 대한 테이블입니다. 그럼 이 hashtag를 어떻게 효율적으로 저장할 수 있을까요? ","date":"2023-10-15","objectID":"/postgresql/:3:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"hash tag table 해시태그는 그 성격상 중복이 많을 수 있기 때문에, 위의 테이블과 같이 저장하게 되면 매우 비효율적으로 테이블이 관리되게 됩니다. 또한 hashtags: posts = n:m 관계인 것을 고려하면, 중간에 매핑 테이블로 저장해서 관리하면 됩니다. 이떄 hashtags 테이블의 title을 unique로 저장하면 중복관리에도 좋습니다. ","date":"2023-10-15","objectID":"/postgresql/:3:1","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"How to build a ‘Follow’ System 인스타그램에서는 총 follwer 숫자, following 숫자 그리고 누구를 follow 또는 following되는지를 저장하고 있습니다. 이는 아래와 같은 스키마로 저장합니다. ","date":"2023-10-15","objectID":"/postgresql/:4:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Final Schema 최종적으로 schema는 아래의 diagram을 따릅니다. 아래는 table statement입니다. 이때 null, default는 아래 기준으로 정의했습니다. value가 주어지든 아니든 상관없다 -\u003e 비워둠 100% 유저 또는 engineer가 값을 주어야 한다 -\u003e NOT NULL 언제나 값이 테이블에 존재하길 원하지만, 생성될 때 optional로 처리되어도 된다 -\u003e NOT NULL + DEFAULT CREATETABLEusers(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,updated_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,usernameVARCHAR(30)NOTNULLUNIQUE,bioVARCHAR(400),avatarVARCHAR(200),phoneVARCHAR(25),emailVARCHAR(40),passwordVARCHAR(50),statusVARCHAR(15),CHECK(COALESCE(phone,email)ISNOTNULL));CREATETABLEposts(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,updated_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,urlVARCHAR(200)NOTNULL,captionVARCHAR(240),latREALCHECK(latISNULLOR(lat\u003e=-90ANDlat\u003c=90)),lngREALCHECK(lngISNULLOR(lng\u003e=-180ANDlng\u003c=180)),user_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE);CREATETABLEcomments(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,updated_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,contentsVARCHAR(240)NOTNULL,user_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,post_idINTEGERNOTNULLREFERENCESposts(id)ONDELETECASCADE);CREATETABLElikes(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,user_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,post_idINTEGERREFERENCESposts(id)ONDELETECASCADE,comment_idINTEGERREFERENCEScomments(id)ONDELETECASCADE,CHECK(COALESCE((post_id)::BOOLEAN::INTEGER,0)+COALESCE((comment_id)::BOOLEAN::INTEGER,0)=1),UNIQUE(user_id,post_id,comment_id));CREATETABLEphoto_tags(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,updated_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,user_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,post_idINTEGERNOTNULLREFERENCESposts(id)ONDELETECASCADE,xINTEGERNOTNULL,yINTEGERNOTNULL,UNIQUE(user_id,post_id));CREATETABLEcaption_tags(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,user_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,post_idINTEGERNOTNULLREFERENCESposts(id)ONDELETECASCADE,UNIQUE(user_id,post_id));CREATETABLEhashtags(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,titleVARCHAR(20)NOTNULLUNIQUE);CREATETABLEhashtags_posts(idSERIALPRIMARYKEY,hashtag_idINTEGERNOTNULLREFERENCEShashtags(id)ONDELETECASCADE,post_idINTEGERNOTNULLREFERENCESposts(id)ONDELETECASCADE,UNIQUE(hashtag_id,post_id));CREATETABLEfollowers(idSERIALPRIMARYKEY,created_atTIMESTAMPWITHTIMEZONEDEFAULTCURRENT_TIMESTAMP,leader_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,follower_idINTEGERNOTNULLREFERENCESusers(id)ONDELETECASCADE,UNIQUE(leader_id,follower_id)); ","date":"2023-10-15","objectID":"/postgresql/:5:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"The internals of PostgreSQL Postgresql에서 데이터들은 어떻게 저장될까요? 한번 알아보도록 하겠습니다. 먼저 pgAdmin에서 data_directory를 요청하면, postgresql이 데이터를 저장하고 있는 dir을 알려줍니다. 해당 디렉토리에 들어가면 여러 폴더들이 존재하는데, 그 중에서 ./base 폴더에 들어가보면 oid로 구분된 디렉토리에 데이터들이 저장되어있는 것을 확인할 수 있습니다. 이를 pgAdmin에서 dataname에 대한 oid를 찾아보면, instagram은 22442로 저장되어있는 것을 확인할 수 있습니다. ./base/22442안에 들어가게 되면 여러 파일들로 disk에 데이터가 저장되어있는 것을 확인할 수 있습니다. 이때 pg_class로 instagram과 관련된 table의 oid를 얻어내면, 아래와 같이 저장된 것을 확인가능합니다. users 테이블은 22445 posts 테이블은 22459 comments 테이블은 22476 그럼 postgreSQL는 어떤 구조로 이렇게 disk에 데이터를 저장하고 있을까요? ","date":"2023-10-15","objectID":"/postgresql/:6:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Heaps, Blocks and Tuples PostgreSQL는 다음 3가지로 데이터를 disk에 저장합니다. Heap (File) Pages (Block) Tuple (Item) 하나의 Heap 단위 즉 file단위로 테이블의 data(rows)를 저장해둡니다. 이때 저장되는 row(tuple)은 page단위로 group화 되어있으며, i/o의 단위가 됩니다. 즉 하나의 row를 찾더라도 최소한 하나의 page를 i/o 해야 한다는 뜻입니다. 앞서 user 테이블을 담고있는 22445 파일을 예시로 보자면, 22445라는 heap file로 디렉토리에 저장되어있으며, user row들은 Page 단위로 구분되어있습니다. 하나의 page는 8kb로 구성되어있습니다. PostgreSQL 공식 홈페이지의 Page Layout 를 살펴보면 8kb인 페이지의 레이아웃은 크게 4가지로 구성되어있습니다. 헤더 데이터 24bytes long pd_lower LocationIndex 2 bytes Offset to start of free space pd_upper LocationIndex 2 bytes Offset to end of free space 아이템 id(페이지내의 tuple의 위치를 가리키는 포인터)들 4byte per item Free Space Items 헤더 데이터 안에는 free space의 시작 지점에 대한 포인터와 free space가 끝나는 지점에 대한 포인터값이 존재합니다. 페이지 레이아웃을 추상적으로 도식화 해보자면 아래와 같습니다. 물론 물리적으로는 2진수(실제로는 16진수)로 저장되어 있기 때문에 page(block)은 실제로는 다음과 같은 형태가 됩니다. 실제 22445 heap 파일의 첫번째 page를 vs code에서 꺼내보면 다음과 같이 보입니다. (with extension hex editor by ms) 이 값을 postgresql의 구조에 따라 decode해보자면 아래와 같습니다. ","date":"2023-10-15","objectID":"/postgresql/:6:1","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Index ","date":"2023-10-15","objectID":"/postgresql/:7:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Full Scan pk 또는 uniq 키 또는 secondary index를 적용시키지 않은 경우 postgresql은 full scan을 합니다. Disk에 있는 heap 파일을 찾아서, 메모리에 해당 heap에 존재하는 모든 tuple들을 memory에 올린뒤, 하나하나 찾습니다. ","date":"2023-10-15","objectID":"/postgresql/:7:1","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Index Scan 성능을 높이기 위해서는 index를 사용하면 됩니다. B+ Tree 형태로 관리되는 index는 index의 크기에 따라 level이 다르긴 하지만, root \u003c-\u003e leaf node 사이즈의 index를 기준으로 tree를 그려보면 아래와 같습니다. Root 또는 branch node를 통해서, 검색 조건을 O(logn) 성능으로 타고 내려가서, leaf node에서 검색 결과에 맞는 CTID(=ROWID) 즉 (page number, row id)를 찾습니다. 이를 기반으로 index가 처리된 table의 heap파일에서 page 위치에 있는 row_id를 찾습니다. 다만 index 또한 trade-off가 존재합니다. 예를 들어 880kb 사이즈의 user table에 대해서 username에 대한 index를 생성하면 184kb의 index 파일을 추가로 저장해야합니다. RDB는 클라우드상에서 기본적으로 비싼 값을 내고 관리되어야 하니, 대규모 시스템에서는 상당한 규모의 index 관리를 위해 돈을 지불해야합니다. index의 단점을 정리하면 총 3가지입니다. 추가 disk 요구 (큰 disk 사이즈) B+-Tree를 유지 관리해야 하기 때문에 insert / update / delete에 대한 추가 오버헤드 필요 Postgresql planner에 의해서 index를 실제로는 사용안할 수도 있다. (성능과 돈을 들였는데, index를 사용하지 않기 때문에 최악의 경우라고 할 수 있음) ","date":"2023-10-15","objectID":"/postgresql/:7:2","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Default Index Secondary Index를 생성하지 않더라도, 기본적으로 index를 생성해주는 index가 존재합니다. (FYI, postgresql의 모든 index는 secondary index입니다. innodb와 달리 pk가 클러스터링 index가 아닙니다.) 기본적으로 PK와 uniq키는 index를 생성해서 관리됩니다. 이들은 pgAdmin의 index 섹션에 보이지 않기 때문에, query로 찾아보면 아래와 같습니다. ","date":"2023-10-15","objectID":"/postgresql/:7:3","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Index in detail 인덱스를 좀 더 상세히 살펴보자면, index는 table과 마찬가지로 Heap으로 disk에 저장되며, heap안에는 여러 pages들로 구분됩니다. Heap안에 page들을 memory에 올려 O(logn) scan을 실시합니다. 이제 그럼 pgAdmin으로 실제 index가 어떻게 생겼는지 확인해보록 하겠습니다. 먼저 index를 상세히 보기위해서 extension을 하나 설치해줍니다. CREATEEXTENSIONpageinspect; 그 뒤, users 테이블에 존재하는 username에 대한 index 형태를 확인해줍니다. users_username_idx 인덱스에 대해서 3번째 page를 확인해보면 아래와 같습니다. 이때 가장 첫번째 row를 확인하면 이 page가 root(or branch) page인지, leaf page인지 알 수 있습니다. 만약 첫번째 row의 data가 비워져있다면, 이는 root 또는 branch page이며, data가 존재한다면 이는 leaf page입니다. 참고로 B+Tree에서 leaf node끼리는 연결되어있는데, 이를 표현한 것이 leaf page의 첫번째 row입니다. 해당 row의 data는 다음 leaf node의 index col 데이터를 의미하며, ctid를 찾아서 가게되면 다음 leaf page로 이동할 수 있습니다. 위의 다이어그램을 봐서 알듯이, page 3는 root page입니다. 이제 page 1번을 확인해보자면 첫번쨰 row의 data가 채워져있는 것을 확인할 수 있습니다. 2번째 row부터는 leaf page에 들어있는 element들입니다. 여기에서는 크게 (ctid, 특정 username) 정도가 들어있다 생각하면 됩니다. (33,43)을 타고 들어가보면 실제 Users 테이블의 ctid와 동일하다는 것을 알 수 있습니다. 마지막으로 relkind = ‘i’ (index타입) 찾아보면 22713 이라는 heap 파일에 index가 저장된 것을 확인가능하며, 이 heap파일은 이전 table 파일과 마찬가지로 page단위로 섹션이 구분된 것을 알 수 있습니다. User 테이블은 그 숫자가 적어, index의 B+tree가 높이 2로 존재했지만, 더 큰 likes 테이블의 경우 아래와 같이 더 깊이 있는 tree로 구성됩니다. ","date":"2023-10-15","objectID":"/postgresql/:7:4","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Planner EXPLAIN, Query Plan + Show EXPLAIN ANALYZE, Query Plan + Run + Show 쿼리 플랜에서 해석할 때, 밑에서 부터 위로 올라오는 순으로 쿼리가 실행되는 순서라고 생각하면 됩니다. 또한 -\u003e이 들어 있는 문장 또는 가장 위에 존재하는 문장은 plan node로 해석되며, query plan들은 plan node의 순서로 진행됩니다. SELECTusername,contentsFROMusersJOINcommentsONcomments.user_id=users.idWHEREusername='Alyson14'; 위의 다이어 그램은 실제 query plan을 표현한 그림으로, 아래에서 위로 올라오면서 paln node들이 진행된다고 생각하면 됩니다. WHERE = ‘Alyson14’인 users_username_idx 인덱스를 scan하여 users를 가져옵니다. 9kB 버킷을 메모리에 올려 Hash를 생성합니다. Comments 테이블을 Full Scan(=Seq Scan)하여 60410(guess)개의 row를 memory에 올리고 Hash join 하여 comments.user_id = users.id인 row들을 뽑아냅니다. 가장 상위의 plan node를 분석하면 아래와 같습니다. return할 데이터를 어떤 방식으로 plan했는지 plan과 execute에 대한 소요시간 추측 생성될 row 수를 추측 row의 평균 byte를 추측 이처럼 postgresql은 실제로 planning할 때, 시간 및 row 수를 guess할 수 있는데, 이에 필요한 메타데이터들은 pg_stats에서 확인가능합니다. ","date":"2023-10-15","objectID":"/postgresql/:8:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"View ","date":"2023-10-15","objectID":"/postgresql/:9:0","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Common Table Expression (CTE) Common Table Expression(CTE)란 set of a query로 쿼리 가독성을 위해서 긴 쿼리문을 tmp하게 변수로 관리하는 것을 뜻합니다. Recursive common table Expression은 CTE에서 recursive하게 참조해서 복잡한 쿼리문을 간단하게 표현하는 방식입니다. 특히 graph관계나 tree 관계에서 유용한데, 예를들어서 user와 follow 테이블이 존재할 때, 연결 관계가 4 depth까지인 모든 user들을 찾고 싶을 때와 같은 상황에서 유용하게 관리될 수 있습니다. 예를 들어 tag가 많이된 username, 태그된 수를 태그순으로 정렬해서 보여주려 할 때, 사진에 들어있는 tag와 post를 작성시 caption에서 태그한 사용자들을 모아서 user와 join한 뒤 count하는 방식으로 아래와 같은 query를 만들 수 있습니다. SELECTusername,COUNT(*)FROMusersJOIN(SELECTuser_idFROMphoto_tagsUNIONALLSELECTuser_idFROMcaption_tags)AStagsONtags.user_id=users.idGROUPBYusernameORDERBYCOUNT(*)DESC; 이를 CTE를 활용하면, 좀 더 가시성 있게 쿼리를 만들 수 있습니다. WITHtagsAS(SELECTuser_idFROMphoto_tagsUNIONALLSELECTuser_idFROMcaption_tags)SELECTusername,COUNT(*)FROMusersJOINtagsONtags.user_id=users.idGROUPBYusernameORDERBYCOUNT(*)DESC; ","date":"2023-10-15","objectID":"/postgresql/:9:1","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"View 하지만 CTE는 오직 선언된 다음의 SQL 쿼리에 국한되어 사용됩니다. 즉 이후의 다른 쿼리에서 해당 tags CTE를 사용하고 싶어도 사용할 수 없습니다. 이를 위해서 view를 사용합니다. 메모리에 임시로 존재하는 CTE와 달리, VIEW는 쿼리 텍스트를 disk에 저장해서 관리합니다. 즉 위의 경우 tag가 많이 된 user에 대한 쿼리를 매번 작성하기 보다, view를 사용해서 간편하게 쿼리를 실행할 수 있습니다. (view의 결과값은 disk에 저장되는게 아니라, 쿼리문 그 자체가 저장됨) tag에 대한 view를 생성하려면 아래와 같습니다. CREATEVIEWtagsAS(SELECTid,created_at,user_id,post_id,'photo_tag'AStypeFROMphoto_tagsUNIONALLSELECTid,created_at,user_id,post_id,'caption_tag'AStypeFROMcaption_tags); ","date":"2023-10-15","objectID":"/postgresql/:9:2","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["database"],"content":"Materialized Views 하지만 view의 경우, 매번 refer될 떄마다 execute해야 한다는 단점이 있습니다. 이를 해결하기 위해서 Materialized Views라는 개념이 도입됩니다. View와 달리 Materialized View는 만들어지는 시점에 snapshot으로 쿼리된 데이터를 disk에 저장합니다. 다만 만들어지는 시점의 snapshot을 만들기 때문에, table이 변화될 때마다 refresh를 해주어야 합니다. 만약 매주, post와 comment에 대한 like 수를 테이블로 표현하고 싶은 경우, 쿼리문의 경우 아래와 같이 표현할 수 있습니다. SELECTdate_trunc('week',COALESCE(posts.created_at,comments.created_at))ASweek,COUNT(posts.id)ASnum_post_likes,COUNT(comments.id)ASnum_comment_likesFROMlikesLEFTJOINpostsONposts.id=likes.post_idLEFTJOINcommentsONcomments.id=likes.comment_idGROUPBYweekORDERBYweek 이때 이를 Materialized View로 생성하면 아래와 같습니다. CREATEMATERIALIZEDVIEWweekly_likesAS([[쿼리문]])WITHDATA; CREATEMATERIALIZEDVIEWweekly_likesAS(SELECTdate_trunc('week',COALESCE(posts.created_at,comments.created_at))ASweek,COUNT(posts.id)ASnum_post_likes,COUNT(comments.id)ASnum_comment_likesFROMlikesLEFTJOINpostsONposts.id=likes.post_idLEFTJOINcommentsONcomments.id=likes.comment_idGROUPBYweekORDERBYweek)WITHDATA; Materialized Views는 snapshot이기 때문에 참조하는 table에 변경이 있을 경우, REFRESH를 해주어야 최신 데이터를 얻을 수 있습니다. 대체로 이는 2가지 방식으로 구현합니다. 주기적 -\u003e Cron job으로 REFRESH MATERIALIZED VIEW 뷰이름 Trigger -\u003e 특정 테이블의 값이 변경될 때마다 trigger를 사용해 REFRESH MATERIALIZED VIEW 뷰이름를 실행 2번의 경우에는 데이터 변경이 자주 일어날 경우, 성능 부하를 크게 줄 위험이 있기 때문에 실시간 sync를 포기해도 되는 경우 cronjob으로 관리하는게 일반적일 것 같습니다. ","date":"2023-10-15","objectID":"/postgresql/:9:3","tags":["dev","database"],"title":"PostgreSQL","uri":"/postgresql/"},{"categories":["dev"],"content":"All Basic Computer Science","date":"2023-10-06","objectID":"/interview/","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":" Let’s prepare basic computer science interview questions. Network ","date":"2023-10-06","objectID":"/interview/:0:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"1. HTTP의 GET과 POST 비교 get과 post는 http 프로토콜의 가장 기본적인 메소드들 중 2개입니다. ","date":"2023-10-06","objectID":"/interview/:1:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"GET 조회 기능 http request message(1. request line, 2. header, 3. body)중 request line에 url (쿼리 포함)로 전송 웹 브라우저나 중간의 프록시 서버 (의도치 않게) cache 가능성 존재 길이 제한, 안정성 ","date":"2023-10-06","objectID":"/interview/:1:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"POST 서버로 데이터를 전송하여 리소스 생성 기능 http reqeust message의 body에 데이터를 담아 전송하여, GET과 비교해 더 많은 양의 데이터 전송 가능 ","date":"2023-10-06","objectID":"/interview/:1:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"2. TCP vs UDP TCP UDP 연결방식 연결형서비스 비 연결형 서비스 패킷 교환 방식 가상 회선 방식 데이터그램 방식 전송 순서 전송 순서 보장 전송 순서가 바뀔 수 있음 수신 여부 확인 수신 여부를 확인함 수신 여부를 확인하지 않음 통신 방식 1:1 통신만 가능 1:1 / 1:N / N:N 통신 모두 가능 신뢰성 높음 낮음 속도 느림 빠름 TCP 연결 신뢰성, 패킷 손실 또는 순서 다를 경우 -\u003e 패킷 재전송 또는 순서 재정렬 순서 보장, 데이터는 송신한 순서대로 수신됨 흐름 제어, 슬라이딩 윈도우를 통해 받을 buffer 양 계산하여 전송 UDP 비연결, 데이터 바로 전송 신뢰성 x, 재전송 하지 않고, 패킷 순서 보장 x 흐름 제어 x 최소한의 오버헤드 DNS, 온라인 게임, VoIP(voice call), 미디어 스트리밍 그리고 http3 (QUIC) ","date":"2023-10-06","objectID":"/interview/:2:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"3. TCP 흐름제어 (sliding window) 패킷의 흐름과 오류를 제어하는 TCP 클라와 서버는 각각 데이터를 담을 수 있는 버퍼를 가지고 있고, window라는 일종의 마스킹 도구를 가지고 있다. 서버측의 윈도우 크기는 3way handshake를 통해, 마지막 클라이언트 측에서 보내준 버퍼 크기를 사용하여 서버측 윈도우 크기를 정하게 된다. localhost.initiator \u003e localhost.receiver: Flags [S], seq 1487079775, win 65535 localhost.receiver \u003e localhost.initiator: Flags [S.], seq 3886578796, ack 1487079776, win 65535 localhost.initiator \u003e localhost.receiver: Flags [.], ack 1, win 6379 최초 SYN과 SYN+ACK에서 버퍼 크기를 65535로 이야기 한 뒤, 1/10 크기인 6379로 윈도우 사이즈를 정했다. 그 뒤 서버가 클라이언트에게 데이터를 전송할 때 마다 응답값인 ack에 window size와 ack number를 주어서 수신 가능한 버퍼 공간과 다음에 받기 원하는 바이트의 번호를 요청할 수 있습니다. 또한 데이터가 전송되는 서버 측 버퍼는 아래와 같은 3가지 구조로 존재하게 될 것입니다. 전송완료 \u0026 ACK 응답 받음| 전송완료 \u0026 ACK 응답 받지 못함| 전송 대기 중 서버는 클라이언트의 window size에 따라 window를 이동시키고, 해당 패킷들을 전송하게 됩니다. 만약 이때 서버에서 전송한 패킷들 중 특정 데이터가 유실되거나 잘못 보낼 경우들을 처리하기 위해서 총 2가지 방식이 존재합니다. Go Back N Selective Repeat Go Back N은 오류가 발생한 패킷 넘버부터 새롭게 패킷을 보내는 것으로, 기존의 보내졌던 패킷들 중 오류 패킷 이후의 정상적으로 수신받은 모든 데이터들도 패기합니다. Selective Repeat은 에러가 난 패킷만 재전송해주는 방식이며, 이 경우에는 클라 측 버퍼의 패킷 순서가 꼬일 수 있기 때문에, 손실된 세그먼트들을 저장하는 버퍼(reordering buffer)를 따로 두어, 패킷들을 담아두고 기존의 버퍼가 해당 reordering buffer에 들어있는 데이터들이 기존 receiver buffer에 정렬되도록 합니다. $ sysctl net.inet.tcp | grep sack: net.inet.tcp.sack: 1 ","date":"2023-10-06","objectID":"/interview/:3:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"4. DNS lookup 브라우저에서 naver.com을 입력하면 /hosts 파일에서 dns: ip에 대한 매핑 확인 (없을 경우) local pc dns cache 확인 (없을 경우) /resolv.conf에서 local dns server ip 확인 Local DNS Server란? ISP provider(skt, kt, 등) 또는 Public DNS(google, cloudflare)등이 역할 가능하며, 주요 역할은 DNS name을 IP 주소로 변환하는 것 local dns server의 cache에서 확인 (없을 경우) local dns server - (recursive query) -\u003e ROOT DNS SERVER TLD DNS server IP 획득 TLD (.com, .kr 등) local dns server -\u003e TLD DNS SERVER Second domain dns의 authoritative server ip 획득 local dns server –\u003e authoritative server Authoritative dns -\u003e subdomain(3rd level domain) 체크 예를들면 ftp.naver.com, blog.naver.com에서 ftp.* 또는 blog.* 와 매핑된 Ip 주소 ip 획득, cache 저장 ","date":"2023-10-06","objectID":"/interview/:4:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"5. 웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일 키워드: dhcp, dns, nat, isp, 3-way / 4-way handshake, ssl (ssl handshake) (pre-step) 노트북 기준 wifi 연결시, IP주소를 얻기 위해 DHCP 요청하며 이를 통해 라우터(또는 wifi 공유기)를 통해 사설 IP주소, 서브넷 마스크, 게이트웨이 주소등을 전달받아둔 상태입니다. 먼저 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. DNS lookup, /hosts -\u003e cache 를 확인해서 IP 주소가 없을 경우 DNS lookup을 실시합니다. NAT, 노트북에 할당된 사설 IP주소를 라우터/wifi공유기가 실행하여 public IP주소로 변환합니다. 라우터의 라우팅 테이블을 통해 패킷 다음 목적지 선택 ISP의 라우터로 전달 후 다음 목적지 선택 google.com의 데이터 센터로 전달 3way handshake 패킷 전달 (keep-alive 이후) 4way handshake ","date":"2023-10-06","objectID":"/interview/:5:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"6. DNS round robin 방식 DNS round robin이란 부하 분산 기술로, Authoritative Nameserver는 여러 IP 주소를 순차적으로 반환하여 RR방식으로 부하 분산하는 것입니다. FYI, DNS RR은 (DNS lookup에도 영향)을 주는 IP 주소에 대한 load balancing이다. ","date":"2023-10-06","objectID":"/interview/:6:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DNS RR 문제점 cache에 의해 균등하게 분산되지 못함 health check이 존재하지 않음 ","date":"2023-10-06","objectID":"/interview/:6:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"7. handshakes ","date":"2023-10-06","objectID":"/interview/:7:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"3-way handshake syn \u003e syn-ack \u003e ack ","date":"2023-10-06","objectID":"/interview/:7:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"4-way handshake fin \u003e ack(close wait) \u003e fin(last_ack) \u003e ack ","date":"2023-10-06","objectID":"/interview/:7:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"TLS handshake(RSA) # RSA 키 교환 알고리즘 1. client -\u003e server: client hello (protocol version, 암호 알고리즘, 압축 방식, 클라 난수) 2. server -\u003e client: server hello (세션 ID, ca 인증서, 서버난수) 3. client -\u003e client: verify ca and get public key 4. client -\u003e server: 클라는 난수(pre master secret) 생성 후 public key로 암호화 후 서버 전달 5. both: 클라 세션키 생성 및 서버는 난수를 private key로 복호화 하여 대칭키(세션 키) 생성 6. client -\u003e server: 클라는 세션키(대칭키)로 암호화한 fin message를 서버로 전달 7. server -\u003e client: 서버 또한 세션키로 암호화한 fin message를 전달 8. 이후 세션키(master key, 대칭키)를 통해 통신 계속 진행 tls/ssl 좀 더 자세한 과정 설명 ","date":"2023-10-06","objectID":"/interview/:7:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Web Socket Handshake web socket mdn 클라와 서버가 서로 TCP/IP 4계층 레이어에서 통신한다. 즉 conneciton을 들고 있다. http 요청 이후, client가 서버로 upgrade요청하고 101응답 ping을 지속적으로 쏴서, health-check ","date":"2023-10-06","objectID":"/interview/:7:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"8. Nginx가 c10k problem을 해결한 방식 c10k problem( connection 10k problem )은 한 시스템이 동시에 수천개의 네트워크 연결을 효율적으로 처리해야하는 용어로 nginx는 이 문제를 해결하기 위해 event driven arch를 도입하였습니다. 기존 방식은 request당 하나의 process 또는 thread를 사용해서 요청들을 처리했습니다. 이에 반해 nginx는 worker pool을 두고 request가 들어올 때 마다, async하게 worker(default cpu 당 1)에게 task를 위임합니다. 이렇게 하게 될 경우 process/thread에 비해, pcb/tcb를 만드는데 들어가는 비용을 줄일 수 있으며 또한 사용자의 요청이 많아질 경우, 상대적으로 context switching에 사용되는 비용을 줄일 수 있습니다. 마지막으로 os가 스케쥴링에 들어가는 비용이 줄어듭니다. 즉 지정된 갯수의 미리생성된 process(thread) 워커를 사용함으로써, 기존의 request가 늘어날 때마다, os 리소스가 급격히 늘어나는 것을 방지하여, 이에 대한 side effect(스케쥴링, context-switching등에 대한 오버헤드를 막아줍니다.) 또한 워커에 필요한 리소스들을 미리 생성해두기 때문에 Process 생성에 들어가는 오버헤드를 줄여줍니다. Further reading Database ","date":"2023-10-06","objectID":"/interview/:8:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB 트랜잭션이란? 트랜잭션은 데이터베이스의 데이터를 조작하는 논리적인 작업의 단위(unit of work)입니다. 트랜잭션은 ACID Atomicity all or nothing (rollback) db transaction, rollback으로 보장 Consistency transaction이 commit 되어도 DB의 여러 제약 조건에 맞는 상태를 보장하는 성질이다. 송금하는 사람의 계좌 잔고가 0보다 작아지면 안 된다. Isolation transaction이 진행되는 중간 상태의 데이터를 다른 transaction이 볼 수 없도록 보장하는 성질이다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 아직 들어가지 않은 DB 상황을 다른 transaction이 읽으면 안 된다. lock 또는 mvcc(snapshot in postgre)로 구현 Durability transaction이 Commit했을 경우 해당 결과가 영구적으로 적용됨을 보장하는 성질이다 ","date":"2023-10-06","objectID":"/interview/:9:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"트랜잭션과 lock에 대해서 isolation과 연결 지어 설명해주세요 DB엔진은 ACID 원칙을 희생하여 동시성을 얻을 수 있는 방법을 제공합니다. Row level lock shared lock: read lock exclusive lock: write lock Record lock s lock: read index lock x lock: write index lock Gap lock: db index record의 gap에 걸리는 lock (gap = db에 실제 record가 없는 부분) lock은 모두 transaction이 commit 되거나 rollback 될 때 함께 unlock Consistent read Isolation https://s1107.tistory.com/45 http://labs.brandi.co.kr/2019/06/19/hansj.html https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/ index https://idea-sketch.tistory.com/43?category=547413 https://idea-sketch.tistory.com/45 ","date":"2023-10-06","objectID":"/interview/:10:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"optimistic lock vs pessimistic lock Pessimistic lock은 비관적 상황을 고려해 먼저 lock을 걸고 자원을 사용하는 것입니다. Optimistic Lock은 update가 실행될 때만 lock을 시도합니다, 충돌이 일어나면 collision을 통해서 처리하는 방식입니다. 충돌 검사를 위해 버전 번호나 타임스탬프 사용합니다. InnoDB는 SELECT … FOR UPDATE를 통해, PostgreSQL은 Serializable level에서 optimistic lock을 사용합니다. ","date":"2023-10-06","objectID":"/interview/:11:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB index에 대해 설명해주세요 https://idea-sketch.tistory.com/43?category=547413 데이터를 빠르게 검색하고 액세스 할 수 있도록 도와주는 자료구조입니다. 대부분의 RDB에서는 B+ Tree를 사용해 Balanced Tree를 유지하며 이를 통해 O(logn)의 검색 성능을 보장합니다. 크게 클러스터링 인덱스와 비클러스터링 인덱스(Secondary Index)로 나눌 수 있습니다. innodb의 경우 PK가 기본적으로 제공되어 클러스터링 Index에 사용됩니다. pk값을 기준으로 데이터를 빠르게 검색할 수 있습니다. Secondary Index는 개발자가 설정한 index로 별도의 공간에 생성되는 인덱스입니다. postgresql의 경우에는 pk를 포함한 모든 인덱스들이 secondary index로 취급되며, heap과는 별도의 파일에 저장됩니다. Secondary Index를 통한 검색은 먼저 index를 검색하여 O(logN)의 성능으로 조건에 맞는 여러 클러스터링 인덱스의 주소들을 가져옵니다. 그 다음 이 주소들을 사용해 클러스터링 인덱스를 검색하고, 각 주소에 해당하는 실제 데이터를 포함하는 leaf node들을 찾아 데이터를 검색합니다. ","date":"2023-10-06","objectID":"/interview/:12:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB Join ","date":"2023-10-06","objectID":"/interview/:13:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Join 유형 데이터 베이스는 크게 4가지로 Inner, Outer, Cross Join, Self Join이 있습니다. Outer Join은 left Outer join, right outer, Full Outer join으로 나뉩니다. Inner Join은 두 테이블에서 조인 조건에 일치하는 레코드만 반환합니다. Left Join은 왼쪽 테이블의 모든 레코드와 오른쪽 테이블에서 조인 조건에 일치하는 레코드를 반환하며, 오른쪽 테이블에 일치하는 레코드가 없으면 NULL값을 반환합니다. Right Join, 이하 생략 Full Outer Join은 합집합으로 A와 B테이블의 모든 데이터를 보여줍니다. Cross Join은 Product Join으로 모든 경우의 수를 표현해줍니다. A테이블 row당 B테이블 전체 join Self Join은 자기 자신과 조인 ","date":"2023-10-06","objectID":"/interview/:13:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Join 연산 시 성능 최적화 전략 조인할 테이블 크기를 최소화하기 위해 필요한 컬럼만 선택합니다. 조인 조건에 사용되는 컬럼에 인덱스를 생성합니다. 조인 조건에 인덱스가 있을 경우, 옵티마이저는 가장 효율적인 방법을 사용합니다. 예를들어 full scan을 피하고, 조인 조건에 있는 인덱스를 활용해 테이블 스캔을 최소화할 수 있습니다. WHERE 절을 사용할 수 있으면 조인 전에 레코드를 필터링합니다. 가능한 경우, 더 작은 테이블을 먼저 조인합니다. Nested Loop Join의 경우 한 테이블의 각 행에 대해 다른 테이블의 모든 행을 검색하므로 작은 테이블을 외부 테이블로 사용하면 반복 횟수를 줄일 수 있습니다. ","date":"2023-10-06","objectID":"/interview/:13:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Join 전략: Nested Loop Join, Hash Join, Merge Join NHM Nested Loop Join(NL Join), 적은량, 조회의 범위가 적을 때, 2 for-loop outer loop를 돌면서 inner 테이블에 적합한 레코드를 찾는다. DB는 Page단위로 I/O를 수행하는데, 하나의 레코들르 읽으려고 page를 통째로 읽는 비효율이 존재한다. 또한 join 조건에 index가 들어있다면 랜덤 access로 Disk에 비효율적인 랜덤 I/O가 발생한다. Hash Join, equal, 하나의 테이블을 hash table로 바꿔 메모리에 올리고 equal 연산으로 찾습니다. Merge Join, 대용량, 조회의 범위가 많을 때, 두 테이블의 Join key를 기반으로 sort 이후(또는 기존에 정렬된 상태), 동시에 스캔하여 조인 조건에 맞는 레코드를 찾아 비교하며 머지합니다. 물론 row 추출 시, 각 테이블 검색 조건에 해당하는 대상 집합들을 찾을 때 index를 사용한 random access가 발생할 수 있다. 많야 random access가 많다면 merge join의 이점이 사라질 수 있다. Nested Join의 경우, 인덱스에 의한 랜덤 액세스를 기반으로 하기 때문에 대량의 데이터 처리 시 적합하지 않습니다. DB에서 Sequential access가 아닌 Index를 통한 랜덤 access가 비싼이유는 I/O에 의해서 HDD 디스크 헤더를 계속 옮겨야 하는 오버헤드가 발생하기 때문입니다. ","date":"2023-10-06","objectID":"/interview/:13:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"카디널리티와 조인 두 테이블의 카디널리티(집합의 크기, unique한 원소의 갯수)가 다르면, 작은 테이블을 먼저 읽고 큰 테이블과 조인하는 것이 일반적으로 효율적입니다. ","date":"2023-10-06","objectID":"/interview/:13:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["cs"],"content":"Learn ACID, Indexing, Partitioning, Sharding, Concurrency control, Replication, DB Engines, Best Practices and More! 2. ACID ","date":"2023-10-04","objectID":"/db/:0:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.1 What is Transaction? A Collection of a queries One unit of work ","date":"2023-10-04","objectID":"/db/:1:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Transaction Lifespan BEGIN COMMIT (opt) Rollback ","date":"2023-10-04","objectID":"/db/:1:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.2. Atomicity 트랜잭션안의 모든 쿼리들을 succeed 되어야한다. 트랜잭션안의 한 쿼리가 실패하면, 이전의 모든 성공적인 쿼리들은 rollback 되어야 한다. 트랜잭션이 commit 되기 전에, db가 crash (went down)되면, 모든 트랜잭션 안의 successful queries는 rollback 되어야 한다. 꺼진 db가 다시 켜지게 되면, should clean this up 해야 한다. ","date":"2023-10-04","objectID":"/db/:2:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.3. Isolation 실행되고 있는 트랜잭션이, 다른 실행되고 있는 트랜잭션이 변경 시킨 change를 볼 수있을까? Read Phenomena (읽기 이상 현상) Isolation Levels (격리 수준) Impl of isolation ","date":"2023-10-04","objectID":"/db/:3:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.3.1. Read Phenomena dnpl Dirty reads Non-repeatable reads Phantom reads Lost updates 2.3.1.1. Dirty Reads middle update 동시에 진행되고 있는 다른 트랜잭션(아직 커밋하지 않은 상태)에서 변경한 데이터를 현재 진행 중인 트랜잭션에서 읽어 들이는 것을 뜻합니다. 2.3.1.2. Non-repeatable reads middle update commit 하나의 트랜잭션 중 읽어 들였던 특정 row의 값을 같은 트랜잭션 내에서 다시 읽어 들이는데 중간에 변경사항이 생겨 (실제로 COMMIT이 된 변경사항) 결괏값이 다르게 나오는 현상 2.3.1.3. Phantom reads insert Phantom read란, 트랜잭션 시작 시점 데이터를 읽었을 때 존재하지 않았던 데이터가 다시 같은 조건으로 데이터를 읽어 들였을 때 존재해 (유령처럼) INCONSISTENT 한 결괏값을 반환하는 현상 2.3.1.4. Lost updates duplicate update Lost Update란, 한 트랜잭션에서 데이터를 변경한 뒤 아직 커밋을 하지 않은 상태에서 읽어 들일 때, 다른 트랜잭션으로 인해 내가 작성한 변경사항이 덮어씌워지는 현상을 뜻합니다. ","date":"2023-10-04","objectID":"/db/:3:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.3.2. Isolation Level Read uncommitted, No isolation Read committed, tx only sees commited changed by other tx Repeatable Read, make sure query read unchanged while tx running 트랜잭션안에 있는 여러 쿼리들이 같은 row를 참조할 때, 항상 같은 값을 주도록 한다. lock 또는 snapshot으로 구현시킬 수 있다. PostgreSQL은 (4) Snapshot으로 구현하여 phantom read 방지 InnoDB는 MVCC (multi version concurrency control), 즉 undo 백업을 관리함. Snapshot, snapshot으로 version 관리 phantom read 없음 Serializable, no concurrency ","date":"2023-10-04","objectID":"/db/:3:2","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.3.3. Implementation of Isolation Pessimistic, lock (row, table, page level) Optimistic, no lock (track and 충돌 발생시 뒤의 요청은 에러) version, hashcode, timestamp등의 col 추가해서 충돌을 예방 Serializable은 주로 Optimistic concurrency control로 구현된다. Pessimistic하게 구현하기 위해서는 SELECT FOR UPDATE ","date":"2023-10-04","objectID":"/db/:3:3","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.4. Consistency 2.4.1. Consistency in Data 개발자 테이블 설계 관련 문제 2.4.2. Consistency in Read tx 커밋된 변화를, 새로운 tx가 곧바로 참조할 수 있을까? Sharding된 db1,db2에서 db1에 update x to a를 했고, db2에서 select x를 할 경우에 Inconsistency가 발생한다. scale horizontally한 또는 caching을 도입한, RDB 그리고 NoSQL 모두 이에 대해서 suffer하고 있다. 이를 해결하기 위해서 Eventual consistency 전략이 도입되었다. or 무시 가능한 경우(예를들어 좋아요 수), inconsistent를 허용하는 방법. ","date":"2023-10-04","objectID":"/db/:4:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.5. Durability Commit된 tx의 변화는 durable, non-volatile storage에 persisted 되어야한다. Durability techniques WAL - Write ahead log segments Async snapshot, memory -\u003e background snapshot AOF ","date":"2023-10-04","objectID":"/db/:5:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"WAL 연산에 사용되는 모든 데이터를 Disk에 저장하는 건 비싸다. WAL (Compressed version of the change)은 변화 segments를 compress해서 version 관리를 한다. ","date":"2023-10-04","objectID":"/db/:5:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"OS Cache Os에서 write request는 대부분 os cache로 들어간다. 예를들어 file 저장을 요구했고, os가 succeed 되었다고 하지만, 알고보니 os cache memory에 기록되었고, os crush 상황에서 이 데이터는 유실될 수 있다는 뜻입니다. (os는 cache에 모아두었다가 batch로 처리해서 i/o 사용을 줄이는 전략을 취하기 때문에) 이를 해결하는 방법은 fsync command를 사용해서, write되는 데이터가 항상 go to disk 하도록 할 수 있습니다. 하지만 trade-off는 expensive하고 commit을 느려지게 할 수 있다는 점입니다. ","date":"2023-10-04","objectID":"/db/:5:2","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6. Practical Exercise ACID docker run --name pgacid -d -e POSTGRES_PASSWORD=postgres postgres:13 docker exec -it pgacid psql -U postgres create table products ( pid serial primary key, name text, price float, inventory integer ); create table sales ( saleid serial primary key, pid integer, price float, quantity integer ); insert into products(name, price, inventory) values('phone', 999.99, 100); ","date":"2023-10-04","objectID":"/db/:6:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6.1 Atomicity postgres=# begin transaction; BEGIN postgres=*# select * from products; pid | name | price | inventory -----+-------+--------+----------- 1 | phone | 999.99 | 100 (1 row) postgres=*# update products set inventory = inventory - 10; UPDATE 1 postgres=*# select * from products; pid | name | price | inventory -----+-------+--------+----------- 1 | phone | 999.99 | 90 (1 row) postgres=*# exit; \u003e docker exec -it pgacid psql -U postgres psql (13.12 (Debian 13.12-1.pgdg120+1)) Type \"help\" for help. postgres=# select * from products; pid | name | price | inventory -----+-------+--------+----------- 1 | phone | 999.99 | 100 (1 row) ","date":"2023-10-04","objectID":"/db/:6:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6.2 Isolation mvcc postgres=*# begin transaction isolation level repeatable read; ","date":"2023-10-04","objectID":"/db/:6:2","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6.3. Durability TV를 insert하고 tx commit 시점에 docker stop 하더라도, durability 로 TV 정보가 남아있다. ","date":"2023-10-04","objectID":"/db/:6:3","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6.4 phantom read postgres=*# begin transaction isolation level serializable; 다른 tx에서 commit 하더라도 phantom read가 일어나지 않는다. postgres=*# begin transaction isolation level repeatable read; 하지만 PostgreSQL serializable보다 더 낮은 레벨인 repeatable read level에서도 tx안에서의 query에 대한 snapshot을 관리하기 때문에, phantom read를 방지 가능하다. ","date":"2023-10-04","objectID":"/db/:6:4","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"2.6.5. Serializable vs Non-Repeatable reapeatable read level인 경우 a a b b 테이블에서 a-\u003eb (where not b), b-\u003ea (where not a)하는 2개의 tx(reapeatable read level)에서 동시에 commit을 할 경우, b b a a 가 발생한다. 만약 이를 원하지 않는 경우에는, Serializable level을 사용하면 된다. Serializable level인 경우 1. start tx1, tx2 (tx1) select * from test; 1 a 2 a 3 b 4 b (tx1) update test set t = 'a' where t = 'b'; 1 b 2 b 3 b 4 b (tx1) commit (tx2) update test set t = 'a' where t = 'b'; ERROR: could not serialize access due to read/write dependencies among transactions (tx2) rollback 하고 다시 commit하면 성공 backend 개발자는 에러 처리에 대해서 어떻게 동작할지를 서비스에 적용해 둬야한다. 3. Understanding Database Internals ","date":"2023-10-04","objectID":"/db/:6:5","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"3.1. How tables and Indexes are stored on disk 인덱스와 테이블이 disk에 저장되는 방식 그리고 query 어떻게 되는지 Storage Concepts Table Row_id Page IO Heap data structure Index data structure b-tree Example of a query ","date":"2023-10-04","objectID":"/db/:7:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Row id 내부 시스템에서 관리되는 row 아이디 innodb는 pk와 같지만, postgres는 row_id(tuple_id)가 따로 관리된다. ","date":"2023-10-04","objectID":"/db/:7:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Page “고정된 크기의 block으로, disk에서 데이터와 인덱스를 저장하고 관리하는 기본 단위. innoDB(16KB) postgres(8KB) db는 single row를 읽는 것이 아닌, 한번의 IO에서 page or more을 읽는다. 1001 rows가 존재하고, 각 page가 3rows를 가진다면, 333 ~ pages를 가지게 된다. 한편 Postgresql에서는 Heap안에 여러 page들로 데이터를 disk에 저장한다. ","date":"2023-10-04","objectID":"/db/:7:2","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"IO input/output request to the disk IO는 expensive operation이기 때문에, 개발자들은 io를 최대한 최소화 하려고 노력 한번의 IO는 1page 이상을 fetch한다. 몇몇의 IO는 os에 따라서, disk가 아닌 os system cache에 접근한다. (i.e. postgresql) ","date":"2023-10-04","objectID":"/db/:7:3","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Heap 페이지들을 담고 있는 heap data structure. Heap 안에서 효율적으로 데이터를 search하기 위해 index 필요. ","date":"2023-10-04","objectID":"/db/:7:4","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Index Heap과 분리된 data structure로 heap에 대한 pointer들을 가지고 있다. Index는 Heap의 어떤 page에서 정보를 가져와야할지 알려준다. 인덱스도 page로 관리되고, index entries들을 가져오기 위해 IO가 소요된다. Index가 작으면 작을 수로 memory에 fit되고 search가 빨라진다. 여기서 마지막 문장이 모호하게 들려, 좀 더 자세히 풀어보겠습니다. index의 크기가 작으면 작을 수록 memory에 fit하다는 뜻은, Index가 작을 수록 RAM의 Virtual Memory에서의 page 하나 또는 적은수의 페이지에 포함되게 되며, 이를 통해 페이징 작업이 줄어들게 됩니다. 또한 페이지 fault시에도 적은 데이터로 인해 디스크 I/O작업을 최소화 시켜 페이지 폴트 처리 시간을 줄일 수 있습니다. 사실 index도 page로 저장되기 때문에 disk에 저장되지만, buffer pool(innodb), shared Buffer Cache(postgre)같이 RAM 메모리 내의 buffer pool에 데이터를 cache할 수 있기 때문에 적용되는 내용이라 생각된다. ","date":"2023-10-04","objectID":"/db/:7:5","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"3.2. Row vs Column oriented Databases ","date":"2023-10-04","objectID":"/db/:8:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Row Databases Optimal for read / writes OLTP Compression isn’t efficient Aggregation isn’t efficient aggr에 필요하지 않은 필드들도 mem에 올라와서 더 많은 page들을 뒤져서 aggr함 Efficient queries w/multi-columns 칼럼형은 row데이터를 얻기 위해서는, column 갯수 만큼 io 해서 찾아야 하기 때문에. ","date":"2023-10-04","objectID":"/db/:8:1","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Columnar Databases Writes are slower OLAP (online analytical Processing) Google Bigquery, parquet Compress greatly 칼럼형의 값들은 같은 타입의 값들이기 때문에 row형은 여러 타입들의 데이터가 저장되어있음. 또한 col 값마다 중복된 값이 더 많을 수 있으므로 압축효율이 높음 Amazing for aggregation (i.e. SUM() …) Inefficient queries w/multi-columns ","date":"2023-10-04","objectID":"/db/:8:2","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"3.3. Primary key vs Secondary Key pk는 clustering과 관련 되어 있습니다. Mysql 인덱스 - 클러스티드 인덱스와 논클러스티드 인덱스 개념편 참조 기본적으로 table은 ordering하지 않고 있지만 oracle의 IOT(Index organized Table), Postgres의 Clustered Index 따위가 있고, InnoDB는 Primary Key 클러스터링 인덱싱이 default입니다. InnoDB 기준 Primary key는 자동으로 clustered index가 되기 때문에 PK = clustered index로 생각하겠습니다. B Tree 구조에서 table이 저장될 때, PK(Clustered index)로 정렬되어 저장되어 tree형식으로 page들이 저장됩니다. Secondary Index(non clustered index)는 Index Page를 따로 생성하여 관리되며, CREATE INDEX로 생성된 index에 대한 B-tree를 생성하여 관리합니다. 즉 non clustered index는 index table이 따로 관리되며, B-Tree로 관리되기 때문에, Read 효율을 얻는 대신, CUD를 trade off로 가집니다. ","date":"2023-10-04","objectID":"/db/:9:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"3.4. Databases Pages - Deep dive 데이터 베이스 페이지란? 어떻게 Disk에 write 되는가? 어떻게 Disk에 store 되는가? Postgres의 page layout은 어떻게 되는가? 4. Database Index ","date":"2023-10-04","objectID":"/db/:10:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["cs"],"content":"Bitmap Index Scan vs Index Scan vs Table Scan","date":"2023-10-04","objectID":"/db/:11:0","tags":["database","cs"],"title":"Fundamentals of Database Engineering","uri":"/db/"},{"categories":["llm","databricks","lmops","mlops"],"content":"Based on Databrick’s LLM application github edx 1. LLM Module 0 ","date":"2023-09-27","objectID":"/llm/:0:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.2 Why LLMs Introduction to LLMs (Large Language Models): LLMs are revolutionizing industries involving human-computer interaction and language data. They’re more than just hype and are impacting businesses, like Chegg, which saw a drop in site shares due to users using ChatGPT. LLMs are enhancing existing tools, such as GitHub co-pilot, which now can fix code errors, generate tests, and more, thanks to advanced language models. The core of an LLM is a statistical model that predicts words in text. It’s trained on vast amounts of data, with some models being trained on data equivalent to tens of millions of books. LLMs can automate tasks that involve imprecise language or knowledge about the world, helping in software development, democratizing AI, generating content, and reducing development costs. When considering LLM applications, it’s essential to evaluate the model’s quality, serving cost, latency, and customizability. The course aims to bridge the gap between black-box solutions and academic principles, providing practical knowledge for real-world applications. ","date":"2023-09-27","objectID":"/llm/:1:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.3 Primer Introduction to NLP: Natural Language Processing (NLP) is the study of understanding and modeling natural language for computational applications. It’s used daily in tasks like autocomplete, spelling checks, and more. Applications of NLP: NLP can be applied to various tasks such as sentiment analysis, language translation, chatbots, similarity searching, document summarization, and text classification. Key Definitions in NLP: Tokens: The building blocks of NLP, which can be words, characters, or sub-words. Sequence: A collection of tokens in a specific order. Vocabulary: The entire set of tokens available for a model. Classifying NLP Tasks: Tasks can be categorized based on their input and output, e.g., translation is a sequence-to-sequence task, while sentiment analysis might be a sequence-to-non-sequence prediction. Scope of the Course: While NLP encompasses more than just text (e.g., speech recognition, image captioning), this course focuses on text-based problems due to their inherent complexity and challenges. ","date":"2023-09-27","objectID":"/llm/:2:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.4 Language Model Language Models (LMs): Computational models that predict text based on a given sequence, determining the most likely word by calculating a probability distribution over a vocabulary. Two Types of LMs: Generative: Predicts the next word in a sequence. Classification-based: Predicts a masked (or blanked out) word in a sequence. Large Language Models (LLMs): LMs that have significantly more parameters, ranging from billions compared to earlier models with 10 to 50 million parameters. Transformers: A type of architecture introduced around 2017 that has since dominated the natural language processing field due to its computational efficiency. Pre-Transformer Era: Earlier language models, some with deep neural network architectures, had fewer parameters and were not considered “large” but still required significant computational resources. Post-2017 Shift: The introduction of Transformers led to a surge in the development and popularity of LLMs. ","date":"2023-09-27","objectID":"/llm/:3:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.5 Tokenization Tokenization in NLP: Tokenization is the process of converting text into a format suitable for computation. Depending on the design choice, tokens can be words, characters, or pieces of words. Word-based Tokenization: This method involves creating a vocabulary from training data, assigning each word a unique number. However, it has limitations like out-of-vocabulary errors, inability to handle misspellings, and a large vocabulary size due to different word forms (e.g., fast, faster, fastest). Character-based Tokenization: By breaking text into individual characters, this method offers a small vocabulary size and can handle new words or misspellings. However, it loses the context of words and results in long sequence lengths. Subword Tokenization: A middle ground between word and character tokenization, subword tokenization breaks words into smaller meaningful parts (e.g., “sub” and “ject” from “subject”). Techniques like byte pairing coding, sentence piece, and wordpiece are used to achieve this. It offers a good balance between vocabulary size and flexibility. Next Steps: After tokenization, the challenge is to incorporate meaning and context into these tokens, which will be discussed in the context of word embeddings in the subsequent video. ","date":"2023-09-27","objectID":"/llm/:4:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.6 Word Embeddings Word embeddings aim to capture the context and intrinsic meaning of words within a vocabulary. By tokenizing sentences, we can numerically represent words and compare sentences or documents for similarities and differences. Traditional methods, like counting word frequency, result in sparse vectors, which aren’t efficient for large vocabularies. Word embedding methods, like Word2Vec, represent words as vectors based on surrounding words in training data, capturing contextual relationships. These embedding vectors can be visualized in 2D, showing clusters of words with similar meanings, although the exact meanings of vector dimensions aren’t always clear. ","date":"2023-09-27","objectID":"/llm/:5:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"1.7 Recap Natural language processing (NLP) focuses on studying natural language, especially text. NLP encompasses more than just text; it includes speech, video-to-text, image-to-text, and other concepts where natural language plays a role. NLP is valuable for tasks like translation, summarizing text, and classification problems with natural language inputs and outputs. Language models create a probability distribution over vocabulary tokens; large language models use the Transformer architecture with millions to billions of parameters. Tokens are the smallest units in language models, converting text to indices and then to n-dimensional word embeddings to capture context and meaning. 2. Applications with LLMs ","date":"2023-09-27","objectID":"/llm/:6:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.1 Introduction to LLM Applications Introduction to LLM Applications: The module begins with a humorous note on the urgency among CEOs to adopt LLMs. Ease of Use: LLMs can be quickly integrated into various applications with minimal initial effort, allowing for continuous improvement. Common Applications: The module will explore standard natural language processing tasks where pre-trained, often open-source, LLMs excel and can be fine-tuned for specific applications. Tools and Techniques: Hugging Face will be introduced as a framework for LLMs, along with prompt engineering as a method to adapt general LLMs for diverse tasks. Common tasks like summarization, review classification, and Q\u0026A will be discussed. Understanding Trade-offs: The module will emphasize the balance between the effort in implementing LLMs and the resulting quality and performance, guiding learners on the potential and limitations of LLMs in various applications. ","date":"2023-09-27","objectID":"/llm/:7:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.2 Module Overview LLM Module 1 Overview: The module focuses on understanding and applying pre-trained LLMs (Language Learning Models). By the end, learners will know how to interact with LLMs using Hugging Face’s APIs, datasets, pipelines, tokenizers, and models. The module emphasizes finding the right model for specific applications, especially given the vast number of models available on Hugging Face Hub as of April 2023. A key topic is prompt engineering, with a real-world example of generating summaries for news articles to be showcased. The module also touches upon the broader NLP ecosystem, mentioning both classical and deep learning-based tools, including proprietary ones and newcomers like LangChain. ","date":"2023-09-27","objectID":"/llm/:8:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.3 Hugging Face Hugging Face Overview: Hugging Face is a company and community known for open-source machine learning projects, especially in NLP. It hosts models, datasets, and spaces for demos and code, available under various licenses. Libraries provided include “datasets” for data downloading, “Transformers” for NLP pipelines, and “evaluate” for performance assessment. Transformers and Pipelines: Transformers library simplifies NLP tasks, such as summarization, by providing easy-to-use pipelines. The process involves prompt construction, tokenization (encoding text as numbers), and model inference. The library offers “Auto” classes that automatically configure based on the provided model or tokenizer name. Tokenization Details: Tokenizers output encoded data as “input IDs” and an “attention mask” which is metadata about the text. Adjustments can be made for input text length, padding, truncation, and tensor return type. Model Inference: Sequence-to-sequence language models transform variable-length text sequences, like articles, into summaries. Parameters like “num beams” for beam search and output length constraints can be specified. (beam search) Why beam? beam search라는 이름은 “beam of hypotheses\"의 약자에서 유래했습니다. beam은 광선이나 빔을 의미하며, 동시에 여러 가지 가능한 후보를 고려하는 방법을 의미합니다. Datasets Library: Offers one-line APIs for loading and sharing datasets, including NLP, audio, and vision. Datasets are hosted on the Hugging Face Hub, allowing users to filter by various criteria and find related models. ","date":"2023-09-27","objectID":"/llm/:9:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.4 Model Selection Model Selection for Tasks: When selecting a model for tasks like summarization, one must decide between extractive (selecting pieces from the original text) and abstractive (generating new text) methods. Filtering Models on Hugging Face: With thousands of models available, users can filter by task, license, language, and model size. It’s also essential to consider the model’s popularity, update frequency, and documentation. Model Variants and Fine-tuning: Famous models often come in different sizes (base, small, large). Starting with the smallest model can be cost-effective. Fine-tuned models, adjusted for specific tasks, may perform better for related tasks. Importance of Examples and Datasets: Not all models are well-documented, so looking for usage examples can be beneficial. It’s crucial to know if a model is a generalist or fine-tuned for specific tasks and which datasets were used for its training. Recognizing Famous Models: Many well-known models belong to model families, varying in size and specificity. While size can indicate power, other factors like architecture, training datasets, and fine-tuning can significantly impact performance. ","date":"2023-09-27","objectID":"/llm/:10:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.5 NLP tasks NLP Tasks Overview: The module introduces various NLP tasks, some of which overlap, and are frequently mentioned in literature and platforms like Hugging Face Hub. Text Generation \u0026 Summarization: Text generation can encompass many tasks, including summarization. Some summarization models are labeled as text generation due to their multifunctional nature. Sentiment Analysis: This task determines the sentiment of a given text, such as identifying whether a tweet about a stock is positive, negative, or neutral. LLMs can also provide a confidence score for their sentiment predictions. Translation \u0026 Zero-Shot Classification: LLMs can be fine-tuned for specific language translations, like English to Spanish. Zero-shot classification allows for categorizing content without retraining the model every time categories change, leveraging the LLM’s inherent language understanding. Few-Shot Learning: This is more of a technique than a task. Instead of fine-tuning a model for a specific task, a few examples are provided to guide the model. This is useful when there isn’t a specific model available for a task and limited labeled training data. ","date":"2023-09-27","objectID":"/llm/:11:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.6 Prompts Prompts in LLMs: Prompts serve as the primary method for interacting with large language models (LLMs) and are especially prevalent in instruction-following LLMs. Foundation Models vs. Instruction Following Models: While Foundation models are trained for general text generation tasks like predicting the next token in a sequence, instruction-following models are tuned to adhere to specific instructions or prompts, such as generating ideas or writing stories. Nature of Prompts: Prompts can be natural language sentences, questions, code, emojis, or even outputs from other LLM queries. Their purpose is to elicit specific responses from the LLMs, guiding their behavior. Complex Dynamic Interactions: LLMs can handle nested or chained prompts, allowing for intricate interactions. An example mentioned is “few-shot learning,” where the prompt provides an instruction, examples to guide the LLM, and then the actual query. Power of Prompt Engineering: Effective prompt engineering can lead to structured outputs suitable for downstream data pipelines. The complexity of prompts can range from simple instructions to detailed formats with multiple components, showcasing the versatility and potential of LLMs. ","date":"2023-09-27","objectID":"/llm/:12:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.7 Prompt Engineering Prompt Engineering Specifics: Prompt engineering is model-specific; what works for one model might not work for another. Effective prompts are clear and specific, often including an instruction, context, input/question, and desired output format. Techniques to improve model responses include instructing the model not to make things up, not to assume sensitive information, and using chain of thought reasoning. Prompt Formatting and Security: Proper formatting, using delimiters, can help distinguish between instructions, context, and user input. There are vulnerabilities like prompt injection (overriding real instructions), prompt leaking (extracting sensitive info), and jailbreaking (bypassing moderation). Developers need to be aware and constantly update to counteract these vulnerabilities. Countermeasures and Resources: Techniques to reduce prompt hacking include post-processing, filtering, repeating instructions, enclosing user input with random strings, and selecting different models. Various guides and tools are available to assist in writing effective prompts, some specific to OpenAI and others more general. ","date":"2023-09-27","objectID":"/llm/:13:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.8 Recap LLMs have a wide variety of applications and use cases. Hugging Face offers numerous NLP components, a hub for models, datasets, and examples. When selecting a model, consider the task, constraints, and model size. There are many tips for model selection, but it’s essential to tailor choices to specific applications. Prompt engineering is vital for generating valuable responses, combining both art and engineering techniques. ","date":"2023-09-27","objectID":"/llm/:14:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"2.9. Notebook democratizing Especially focused on search and sampling. Search \u0026 Sampling: Large Language Models (LLMs)에서 토큰을 생성할 때는 주로 두 가지 주요 방법, 즉 “검색(Search)“과 “샘플링(Sampling)“이 사용됩니다. 이 두 방법은 모델이 다음 토큰을 어떻게 선택할지를 결정하는 방식에 따라 구분됩니다. 연관관계: “Search\"와 “Sampling\"은 서로 다른 목적과 상황에 따라 선택될 수 있습니다. 예를 들어, 일관된 및 고품질의 출력이 필요한 경우 “Search\"를 사용할 수 있으며, 다양한 및 창의적인 출력이 필요한 경우 “Sampling\"을 사용할 수 있습니다. 실제 응용 프로그램에서는 “Search\"와 “Sampling” 전략을 결합하여 사용하는 경우도 많습니다. 예를 들어, “Beam Search” 동안 일부 확률적 “Sampling\"을 적용하여 다양한 결과를 얻을 수 있습니다. 결론적으로, “Search\"와 “Sampling\"은 시퀀스 생성 모델의 출력을 결정하는 데 사용되는 전략으로, 서로 다른 접근 방식을 제공하며, 특정 응용 프로그램의 요구 사항에 따라 선택 및 조합될 수 있습니다. Note. Can beam search be used with sampling? Search: “Search\"는 가능한 모든 토큰 시퀀스 중에서 최적의 시퀀스를 찾는 것을 목표로 합니다. 예를 들어, “Greedy Search\"는 각 단계에서 확률이 가장 높은 토큰을 선택하는 방법입니다. “Beam Search\"는 여러 가능한 경로를 동시에 탐색하여 전체적으로 최적의 시퀀스를 찾습니다. “Search\"는 일반적으로 더 일관된 및 결정론적인 결과를 생성합니다. Sampling: “Sampling\"은 확률 분포에 따라 토큰을 무작위로 선택하는 방법입니다. 이 방법은 다양한 결과를 생성할 수 있으며, 모델의 확률 분포를 직접 활용합니다. “Top-k Sampling” 또는 “Top-p Sampling\"과 같은 변형은 완전한 무작위 선택의 위험을 줄이기 위해 토큰 선택의 범위를 제한합니다. Greedy Search (탐욕 검색): 이 방법은 각 단계에서 가장 확률이 높은 토큰을 선택합니다. 결과적으로 가장 확률이 높은 단일 시퀀스를 생성하지만, 때로는 지역적으로 최적화된 선택으로 인해 전체적으로는 최적이 아닌 결과를 얻을 수 있습니다. Beam Search: 여러 경로를 동시에 탐색하면서 가장 확률이 높은 시퀀스를 찾습니다. “빔 크기(Beam Size)“라는 매개변수를 사용하여 한 번에 탐색할 경로의 수를 지정합니다. 빔 크기가 크면 더 많은 경로를 탐색하지만, 계산 비용이 증가합니다. Sampling: 다음 토큰을 확률적으로 선택하여 다양한 시퀀스를 생성합니다. 이 방법은 다양한 결과를 생성할 수 있지만, 때로는 의미 없는 결과를 생성할 수도 있습니다. Top-k Sampling: 다음 토큰을 선택할 때 가장 확률이 높은 상위 k개의 토큰만을 고려합니다. 이 방법은 샘플링의 임의성을 유지하면서 완전히 무작위 선택의 위험을 줄입니다. Top-p (nucleus) Sampling: 확률이 높은 토큰들의 누적 확률이 p를 초과할 때까지 토큰을 선택합니다. 이 방법은 동적으로 선택 범위를 조정하여 토큰의 다양성과 임의성 사이의 균형을 찾습니다. 3. Embeddings, Vector Databases and Search ","date":"2023-09-27","objectID":"/llm/:15:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"3.1 Overview Title: LLM Module 2 - Embeddings, Vector Databases, and Search | 2.2 Module Overview Purpose of LLMs: Large Language Models (LLMs) act as reasoning engines, processing information to return meaningful outputs. The module focuses on using embeddings, vector databases, and search to enhance question-answering systems. Knowledge Incorporation: There are two primary methods for LLMs to learn knowledge: Training a model from scratch or fine-tuning an existing one. Passing knowledge as model inputs, often referred to as context or prompt engineering. Context Limitations: While passing context helps in precision, there’s a limitation to the length of context that can be passed. For instance, OpenAI’s GPT-3.5 model has a limit of 4,000 tokens. Workarounds include summarizing documents or splitting them into chunks. Rise of Vector Databases: 2023 is dubbed the year of vector databases, which are essential for converting various unstructured data types (text, images, audio) into embedding vectors. These vectors can be used for a range of tasks, from object detection to music transcription. QA System Workflow: Convert a knowledge base of documents into embedding vectors. Store these vectors in a vector index, either through a vector library or database. Convert user queries into embedding vectors. Search the vector index to find relevant document vectors. Use the retrieved documents as context for the language model to generate a response. This module provides a comprehensive understanding of how embeddings and vector databases can be utilized to improve search and retrieval performance in question-answering systems. ","date":"2023-09-27","objectID":"/llm/:16:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"3.2. How does Vector Search work Vector Search Overview: Two main strategies: exact search (brute force, little room for error) and approximate search (less accurate but faster). Common indexing algorithms produce a data structure called a vector index, which aids in efficient vector search. Methods range from tree-based, clustering, to hashing. Similarity between vectors is determined using distance or similarity metrics, such as L1 Manhattan distance, L2 Euclidean distance, or cosine similarity. When used on normalized embeddings, L2 distance and cosine similarity produce equivalent ranking distances. Dense embedding vectors can be memory-intensive. Product quantization (PQ) compresses vectors by segmenting them into subvectors, which are then quantized and mapped to the nearest centroid, reducing memory usage. Note, Product Quantization Specific Vector Indexing Algorithms: FAISS (Facebook AI Similarity Search): A clustering algorithm that computes L2 Euclidean distance between vectors. It optimizes the search process using Voronoi cells, computing distances between a query vector and centroids first, then finding similar vectors within the same Voronoi cells. HNSW (Hierarchical Navigable Small Worlds): Uses Euclidean distance but is a proximity graph-based approach. It employs a linked list/skip list structure, skipping nodes or vertices as layers increase. If there are too many nodes, hierarchy is introduced to traverse through the graph efficiently. Significance of Vector Search: Vector search allows for more flexible and expansive use cases compared to exact matching rules. Traditional SQL filter statements are restrictive, but vector databases offer more dynamic search capabilities. ","date":"2023-09-27","objectID":"/llm/:17:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"(+) L1, L2 L1 Manhattan 거리 (L1 Norm 또는 Taxicab Norm): 두 점 P(x_1, y_1) 및 Q(x_2, y_2) 사이의 Manhattan 거리는 그들 사이의 수평 및 수직 경로에 따라 계산됩니다. 계산식: $$ |x_1 - x_2| + |y_1 - y_2| $$ 이 거리는 그 이름에서 알 수 있듯이 도시의 격자 패턴 블록을 따라 두 점 사이의 거리를 측정하는 것과 유사합니다. 장점: 이 거리는 각 차원에서의 차이를 개별적으로 고려합니다. 이로 인해 이상치에 덜 민감하게 됩니다. 사용 사례: 특히 고차원 데이터에서 이상치의 영향을 최소화하려는 경우나, 각 차원의 차이가 중요한 경우에 사용됩니다. L2 유클리드 거리 (L2 Norm): 두 점 사이의 “직선” 거리입니다. 2차원 평면에서 두 점 사이의 직선 거리를 계산하는 것과 동일하며, 고차원에서도 확장됩니다. 계산식 (2차원의 경우): $$ \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$ 유클리드 거리는 가장 직관적인 두 점 사이의 거리 측정 방법입니다. 장점: 직관적이며, 두 점 사이의 실제 “직선” 거리를 제공합니다. 이로 인해 많은 알고리즘과 기술에서 기본 거리 측정 방법으로 사용됩니다. 사용 사례: k-평균 클러스터링, SVM, k-최근접 이웃 알고리즘과 같은 기계 학습 알고리즘에서 널리 사용됩니다. 코사인 유사도: 두 벡터 간의 코사인 각도를 사용하여 유사도를 측정합니다. 이 값은 -1에서 1 사이입니다. 값이 1에 가까울수록 두 벡터는 매우 유사하며, -1에 가까울수록 매우 다릅니다. 0은 두 벡터가 직교하다는 것을 의미합니다. 계산식: $$ \\frac{A \\cdot B}{|A| |B|} $$ 여기서 A.B 는 두 벡터의 내적이고, ||A|| 및 ||B||는 각 벡터의 크기입니다. 코사인 유사도는 텍스트 분석 및 문서 유사도 측정과 같은 많은 응용 분야에서 널리 사용됩니다. 장점: 벡터의 크기가 아닌 방향에 중점을 둡니다. 따라서 두 벡터가 얼마나 유사한 방향을 가지고 있는지 측정할 때 유용합니다. 특히 텍스트 데이터와 같이 크기보다 방향이 더 중요한 경우에 유용합니다. 사용 사례: 텍스트 문서의 유사도 측정, 추천 시스템, 텍스트 분류 등에서 널리 사용됩니다. L2 거리와 코사인 유사도의 동등성: 정규화된 임베딩에서 L2 거리와 코사인 유사도는 기능적으로 동등한 순위 거리를 생성합니다. 이는 두 측정 방법 모두 벡터 간의 방향성을 측정하기 때문입니다. 정규화된 벡터에서는 유클리드 거리가 작을수록 코사인 유사도가 높아집니다. 따라서 많은 응용 분야에서 두 측정 방법 중 하나를 선택하여 사용할 수 있습니다. ","date":"2023-09-27","objectID":"/llm/:18:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"3.3. Filtering Filtering in vector databases is challenging and varies among different databases. There are three main categories of filtering strategies: post-query, in-query, and pre-query. Post-query filtering involves applying filters after identifying the top-K nearest neighbors, but it can lead to unpredictable results. In-query filtering combines ANN and filtering simultaneously, demanding more system memory as filters increase. Pre-query filtering limits similarity search within a specific scope but is less performant than the other methods due to its brute-force approach. 4. Multi-stage Reasoning 5. Fine-tuning and Evaluating LLMs ","date":"2023-09-27","objectID":"/llm/:19:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["llm","databricks","lmops","mlops"],"content":"5.2. Fine-tuning and Evaluating LLMs Module 4 Overview: Fine-tuning and Evaluating Large Language Models (LLMs) The module explores the customization of LLMs for specific applications, emphasizing the process of fine-tuning. Participants will learn how to use tools like DeepSpeed and Hugging Face for fine-tuning specific use cases and evaluating the performance of LLMs. LLMs are frequently released in various sizes, with different sequence lengths, and may come with pre-fine-tuned versions for specific tasks. Developers must balance accuracy, speed, and task-specific performance when choosing and using LLMs. The module will guide participants in building an application that summarizes news articles and converts them into riddles. 6. Society and LLMs: Bias and Safety 7. LLMOps ","date":"2023-09-27","objectID":"/llm/:20:0","tags":["dev"],"title":"Databricks: Large Language Models: Application through Production","uri":"/llm/"},{"categories":["dev"],"content":"Elder.js: an SEO first Svelte Framework \u0026 Static Site Generator Elder.js https://elderguide.com/tech/elderjs ","date":"2023-07-26","objectID":"/elderjs/:0:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"cli pnpm start npm run build # preview npx sirv-cli public # To Run in SSR Mode for Production: npm run serve ","date":"2023-07-26","objectID":"/elderjs/:1:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Elder.js의 Markdown-plugin Getting all Markdown For a Route data.markdown data.markdown.blog By default, if there is a date field in your frontmatter it will sort all of the markdown for that route by it. If there is a slug field in your frontmatter it will use that for the slug, if not it falls back to the filename. If draft: true is in a file’s frontmatter or a slug is prefixed with draft- these markdown files will be hidden when process.env.NODE_ENV === 'production'. They will also be prefixed with DRAFT: [Post Title Here] to make this functionality more obvious. markdown 플러그인이 data hook때, 어떤 데이터들을 추가하는지 나타내는 코드 markdown plugin data hook elder js data hook // https://github.com/Elderjs/plugins/blob/f7e8fd8f2503881342220baf9df6b2d535427f24/packages/markdown/src/index.ts#L222 { hook: 'data', name: 'addFrontmatterAndHtmlToDataForRequest', description: 'Adds parsed frontmatter and html to the data object for the specific request.', priority: 50, run: async ({ request, data }) =\u003e { if (data.markdown \u0026\u0026 data.markdown[request.route]) { const markdown = data.markdown[request.route].find((m) =\u003e m.slug === request.slug); if (markdown) { await markdown.compileHtml(); const { html, frontmatter, data: addToData } = markdown; return { data: { ...data, ...addToData, html, frontmatter, }, }; } } }, }, ","date":"2023-07-26","objectID":"/elderjs/:2:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Markdown plugin's Ecosystem Markdown plugin markdown remarkjs (Markdown Abstract Syntax Tree format -\u003e unified) remark-frontmatter: 마크다운 frontmatter 처리 remark-gfm: github flavored markdown 형식 변환 remark-slug : (Deprecated) html tag id 채워주기 remark-html serializing HTML unified와 remark 그리고 rehype를 이어준다. 복수의 (unified, rehype) markdown -\u003e html 컴파일러가 필요한 이유 remark unified, remark-parse, and remark-stringify, useful when input and output are markdown unified transform markdown -\u003e HTML rehype: Markdown -\u003e HTML (uses hast) 즉 unified와 rehype는 같은 기능(md -\u003e html)을 하는 녀석들이지만, 서로 보충해주는 역활을 한다. 이유는 markdown의 문법이 여러 경우의 수가 있어서 html 전환을 할때 경우의 수가 많기 때문이다. 보통 .use(remarkRehype).use(rehypeStringify)를 사용한다. ","date":"2023-07-26","objectID":"/elderjs/:2:1","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Route.js all -\u003e pass requests -\u003e permalink transforms links Skinny request objects. Fat data functions Fetching, preparing, and processing data should be done in your data function. it is recommended that you only include the bare minimum required to query your database, api, file system, or data store on the request object. all: async ({ settings, query, data, helpers }): Array\u003cObject\u003e =\u003e { // settings: this describes the Elder.js settings at initialization. // query: an empty object that is usually populated on the 'bootstrap' hook with a database connection or api connection. This is sharable throughout all hooks, functions, and shortcodes. // data: any data set on the 'bootstrap' hook. return Array\u003cObject\u003e; } permalink: ({ request, settings, helpers }): String =\u003e { // NOTE: permalink must be sync. Async is not supported. // request: this is the object received from the all() function. Generally, we recommend passing a 'slug' parameter but you can use any naming you want. // settings: this describes the Elder.js bootstrap settings. // helpers: Elder.js helpers and user helpers from the ./src/helpers/index.js` file. // NOTE: You should avoid using helpers here as helpers.permalinks default helper (see below) doesn't support it. return String; }; data: async ({ data, // any data set by plugins or hooks on the 'bootstrap' hook helpers, // Elder.js helpers and user helpers from the ./src/helpers/index.js` file. allRequests, // all of the `request` objects returned by a route's all() function. settings, // settings of Elder.js request, // the requested page's `request` object. errors, // any errors perf, // the performance helper. query, // search for 'query' in these docs for more details on it's use. }): Object =\u003e { // data is any data set from plugins or hooks. return Object; }; ","date":"2023-07-26","objectID":"/elderjs/:3:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Pages.ts Elder js에서 page에서 사용할 수 있는 props ","date":"2023-07-26","objectID":"/elderjs/:4:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Hooks.ts About hooks ","date":"2023-07-26","objectID":"/elderjs/:5:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Elder.js x Svelte Svelte Components ./src/components/ folder Svelte Templates and Svelte Layouts 에서 호출 Svelte Templates for each route (eg: ./src/routes/blog/Blog.svelte) only rendered on the server because they receive props of data, helpers, request, and settings. Svelte Layouts ./src/layouts/ folder only rendered on the server because they receive props of data, helpers, request, settings, and templateHtml. 대부분의 Svelte 파일은 ./src/components/ 폴더에 있으며 아래에 정의된 대로 Svelte 템플릿 또는 Svelte 레이아웃 내에서 파일을 hydrate(ssr or csr) 해서 사용할 수 있다. Sveltekit에서 hydrate이 뭐야? A: SvelteKit에서 “hydrate\"는 서버에서 렌더링된 HTML을 클라이언트에서 동적으로 활성화하는 과정을 의미합니다. 이 과정은 서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR) 사이의 간극을 메우는 중요한 단계입니다. 서버에서 페이지가 렌더링되면, 그 결과는 정적 HTML로 클라이언트에 전송됩니다. 이 HTML은 브라우저에서 빠르게 렌더링되어 사용자에게 페이지를 즉시 보여줄 수 있습니다. 그러나 이 HTML은 초기에는 정적이므로, 사용자의 상호작용에 반응하기 위해서는 JavaScript가 필요합니다. 이때 “hydration” 단계가 시작됩니다. SvelteKit는 이 단계에서 서버에서 렌더링된 HTML을 가져와서 Svelte 컴포넌트로 “hydrate\"하거나 활성화합니다. 이렇게 하면 페이지가 동적으로 반응하고 사용자의 상호작용에 응답할 수 있게 됩니다. 이 과정은 사용자에게 빠른 초기 로딩 시간을 제공하면서도, 페이지가 완전히 인터랙티브하게 동작할 수 있도록 하는 데 중요합니다. 이것이 SvelteKit와 같은 프레임워크에서 SSR과 CSR을 결합하는 이유입니다. ","date":"2023-07-26","objectID":"/elderjs/:6:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Partial Hydration 어떤 것이 hydrate되어야 하고 어떤 것이 hydrate되지 않아야 하는지 확실하지 않은 경우, 일반적인 규칙은 if a component needs to be interactive on the client, you need to hydrate it. ","date":"2023-07-26","objectID":"/elderjs/:6:1","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Shorcodes 현재 굳이 필요없어 패스 link ","date":"2023-07-26","objectID":"/elderjs/:7:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Elder.js Data flow link route.js module export 실행 Elder의 bootstrap hook 실행 all function in routes are called allRequests hook run allows users to modify the allRequests array. Full request Objects are Built 이는 추후 data func의 파라미터로 들어간다. 또한 Svelte templates, Svelte layouts 파일로 전달된다. i.g request = { slug: `why-kittens-rock`, // ... any other keys from the `request` object returned from the `all` function. // below is then added by Elder.js permalink: \"/blog/why-kittens-rock\", route: \"blog\", type: \"build\", // server or build. }; 남은 Hooks들이 실행된다. (Until the Route's data function) 즉 위의 그림에서middleware, request 실행됨 The ‘data’ hook is Executed The data Object is passed to the Svelte template // i.g Blog.svelte \u003cscript\u003e export let data; // here is the 'data' object we've been following. export let settings; // Elder.js settings export let helpers; // Elder.js helpers and user helpers. export let request; // 'request' object from above. .... \u003c/script\u003e The HTML returned by Blog.svelte is passed into Layout.svelte svelte layout도 svelte template과 같은 props를 받는다. 추가로 templateHtml props도 받는다. Page Generation Completes All further hooks are run until the ‘request’ has been completed. This includes user hooks, system hooks, and plugin hooks. ","date":"2023-07-26","objectID":"/elderjs/:8:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"Elder.js vs Sveltekit Elder와 SvelteKit을 비교하는 방법은 매우 일반적인 질문입니다. 주요 차이점은 Elder.js가 SEO를 염두에 두고 설계되었으며 대규모 정적 사이트를 보다 쉽게 ​​구축할 수 있는 도구를 제공한다는 것. ","date":"2023-07-26","objectID":"/elderjs/:9:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":["dev"],"content":"더 읽어볼거리 자바스크립트 검색엔진 최적화의 기본사항 이해하기 Google hydration guide ","date":"2023-07-26","objectID":"/elderjs/:10:0","tags":["dev"],"title":"Elderjs","uri":"/elderjs/"},{"categories":[""],"content":"CSS: Cascadubg Style Sheets ","date":"2023-07-18","objectID":"/mdn-css/:0:0","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"1. CSS first steps list-style-type @counter-style display: list-item li { list-style-type: none; } @counter-style thumbs { system: cyclic; symbols: \"\\1F44D\"; suffix: \" \"; } ul { list-style: thumbs; } 여러개 동시에 적용시킬 때, , li.special, span.special { color: orange; font-weight: bold; } element 하위요소안에 적용할 때 (space) li em { color: rebeccapurple; } sibling h1, p 둘다 font 200% h1 바로 뒤에 나오는 p에 대해서 적용된다. \u003cstyle\u003e h1 + p { font-size: 200%; } \u003c/style\u003e \u003ch1\u003eI am a\u003cp\u003eminwook\u003c/p\u003e level one heading\u003c/h1\u003e \u003cp\u003eThis is a paragraph of text. In the text is a \u003cspan\u003espan element\u003c/span\u003e and also a \u003ca href=\"http://example.com\"\u003elink\u003c/a\u003e.\u003c/p\u003e a:hover { text-decoration: none; } ","date":"2023-07-18","objectID":"/mdn-css/:1:0","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"CSS의 구조 계단식 및 상속 https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance cascade Importance 우선 순위 소스 순서 ID \u003e .(class) \u003e tag 일부 속성은 상속되지 않습니다. 너비 (위에서 언급 한 것처럼), 마진, 패딩 및 테두리와 같은 것은 상속되지 않습니다. 상속 제어하기 inherit: 부모 영향 받기 initial: 기본 브라우저 스타일 unset: 상속값 무시 Properties and Value { properties: value } @rules “at-rules” @media @import ","date":"2023-07-18","objectID":"/mdn-css/:1:1","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"CSS 작동 방식 브라우저는 HTML (예: 네트워크에서 HTML 을 수신) 을 로드합니다. HTML 을 DOM (Document Object Model) 로 변환합니다. DOM 은 컴퓨터 메모리의 문서를 나타냅니다. DOM 은 다음 섹션에서 좀 더 자세히 설명됩니다. 그런 다음 브라우저는 포함된 이미지 및 비디오와 같은 HTML 문서에 연결된 대부분의 리소스와 연결된 CSS 를 가져옵니다! JavaScript 는 작업에서 나중에 처리되므로 더 간단하게 하기위해 여기에서는 다루지 않습니다. 브라우저는 가져온 CSS 를 구문 분석하고 선택자 유형별로 다른 규칙을 다른 “buckets” 으로 정렬합니다. 예: 요소, class, ID 등 찾은 선택자를 기반으로 DOM 의 어느 노드에 어떤 규칙을 적용해야 하는지 결정하고, 필요에 따라 스타일을 첨부합니다 (이 중간 단계를 render tree 라고 합니다). render tree 는 규칙이 적용된 후에 표시되어야 하는 구조로 배치됩니다. 페이지의 시각적 표시가 화면에 표시됩니다 (이 단계를 painting 이라고 함). ","date":"2023-07-18","objectID":"/mdn-css/:1:2","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"2. CSS 구성 블록 https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks ","date":"2023-07-18","objectID":"/mdn-css/:2:0","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"CSS 선택자 유형 type class id 속성 선택자 a[title] { } Pseudo-classes 및 pseudo-elements /* \u003carticle\u003e 요소의 모든 자식 요소 중에서 첫 번째 자식 요소에 스타일을 적용 */ article :first-child { font-weight: bold; } /* article :first-child와 같음. */ article *:first-child {} /* \u003carticle\u003e 요소가 부모 요소의 첫 번째 자식으로 있을 때에만 스타일이 적용됩니다. 즉, \u003carticle\u003e 요소가 문서 내에서 최상위 요소가 되거나, 다른 요소들 사이에서 첫 번째로 등장하는 경우에만 스타일이 적용 */ article:first-child {} p::first-line { } // pseudo-elements ","date":"2023-07-18","objectID":"/mdn-css/:2:1","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"’ ’ vs ‘\u003e’ 하위 결합자 (Descendant combinator)와 자식 결합자 (Child combinator)는 CSS에서 요소를 선택하는 데 사용되는 두 가지 다른 방식입니다. 하위 결합자 ( ): 이 결합자는 한 요소의 모든 하위 요소를 선택하는 데 사용됩니다. 예를 들어, article p는 article 요소 안에 있는 모든 p 요소를 선택합니다. 이는 중첩된 p 요소가 있더라도 해당 p가 어디에 위치하든 간에 모든 p 요소를 선택합니다. 자식 결합자 (\u003e): 이 결합자는 바로 아래에 있는 자식 요소만을 선택합니다. article \u003e p라는 선택자는 article 요소의 직접적인 자식인 p 요소만을 선택합니다. 만약 p 요소가 더 깊게 중첩되어 있으면, 그 요소는 선택되지 않습니다. 즉, 이 둘의 주요한 차이는 article p가 article 내의 모든 수준에서 p 요소를 선택하는 반면, article \u003e p는 오직 article의 직접적인 자식인 p 요소만을 선택한다는 것입니다. ","date":"2023-07-18","objectID":"/mdn-css/:2:2","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"2이상 클래스 적용 \u003cstyle\u003e .notebox { border: 4px solid #666; padding: .5em; } .notebox.warning { border-color: orange; font-weight: bold; } .notebox.danger { border-color: red; font-weight: bold; } \u003c/style\u003e \u003cdiv class=\"notebox\"\u003e This is an informational note. \u003c/div\u003e \u003cdiv class=\"notebox warning\"\u003e This note shows a warning. \u003c/div\u003e \u003cdiv class=\"notebox danger\"\u003e This note shows danger! \u003c/div\u003e \u003cdiv class=\"danger\"\u003e This won't get styled — it also needs to have the notebox class \u003c/div\u003e ","date":"2023-07-18","objectID":"/mdn-css/:2:3","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"Attribute Selector https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Attribute_selectors#presence_and_value_selectors 선택자 예 설명 [attr] a[title] attr 속성(이름은 대괄호 안의 값임)이 있는 요소와 일치합니다 . [attr=value] a[href=“https://example.com”] 값이 정확히 value (따옴표 안의 문자열) 인 attr 속성이 있는 요소와 일치합니다 . [attr~=value] p[class~=“special”] 값이 정확히 value 인 attr 속성이 있는 요소와 일치하거나 (공백으로 구분된) 값 목록에 있는 값을 포함합니다 . [attr|=value] div[lang|=“zh”] 값이 정확히 value 이거나 바로 뒤에 하이픈이 오는 value 로 시작하는 attr 속성 이 있는 요소와 일치합니다 . /* li에 class가 있는 요소만 */ li[class] { font-size: 200%; } /* li의 class 이름이 정확히 a */ /* 적용되지 않음: \u003cli class=\"a b\"\u003eItem 2\u003c/li\u003e */ li[class=\"a\"] { background-color: yellow; } /* a를 포함 */ /* 적용됨 \u003cli class=\"a b\"\u003eItem 2\u003c/li\u003e */ /* 적용되지 않음 \u003cli class=\"ab\"\u003eItem 4\u003c/li\u003e */ li[class~=\"a\"] { color: red; } 대소문자 구분하지 않음 (i) li[class^=\"a\" i] { color: red; } ","date":"2023-07-18","objectID":"/mdn-css/:2:4","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"Pseudo Class (:) Pseudo Class는 특정 상태에 있는 요소를 선택하는 선택기입니다 :hover :first-child article p:first-child { font-size: 120%; font-weight: bold; } ","date":"2023-07-18","objectID":"/mdn-css/:2:5","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"Pseudo Element (::) 기존 요소에 클래스를 적용하는 것이 아니라 완전히 새로운 HTML 요소를 마크업에 추가한 것처럼 작동합니다. ","date":"2023-07-18","objectID":"/mdn-css/:2:6","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"Cascade Layer https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_layers ","date":"2023-07-18","objectID":"/mdn-css/:2:7","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":[""],"content":"REFS css 디버깅 ","date":"2023-07-18","objectID":"/mdn-css/:3:0","tags":["dev"],"title":"CSS (MDN)","uri":"/mdn-css/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"The Ledger canister from internet computer docs ","date":"2023-04-07","objectID":"/ledger_canister/:0:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"TL;DR Ledger canister는 IC principals에 속한 accounts의 집합입니다. 각 account들은 token balance와 관련되어있으며, account owner들은 다른 account로 토큰 transfer를 진행할 수 있습니다. 모든 transfer 실행은 append-only transaction ledger로 기록됩니다. Ledger canister의 interface는 token의 minting과 burning을 지원합니다. ","date":"2023-04-07","objectID":"/ledger_canister/:1:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"1. Accounts 1.1 용어 IC principal: account = 1: n account : owner = 1:1 (no joint accounts) 모든 account들은 한개의 principal에 속하며, principal은 1개이상의 account를 관리할 수 있습니다. subaccount_identifier를 통해 principal내에서 account를 구별합니다. 그러므로 논리적으로 각 ledger account는 (account_owner, subaccount_identifier) pair값과 상응합니다. account identifier는 32-byte string으로 저장되며, 계산식은 아래와 값습니다. account_identifier(principal, subaccount_identifier) = CRC32(h) || h h = sha224(“\\x0Aaccount-id” || principal || subaccount_identifier) ","date":"2023-04-07","objectID":"/ledger_canister/:2:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"2. Types type Tokens=record{e8s: nat64;};// Account identifier is a 32-byte array. // The first 4 bytes is big-endian encoding of a CRC32 checksum of the last 28 bytes type AccountIdentifier=blob;//There are three types of operations: minting tokens, burning tokens \u0026 transferring tokens type Transfer=variant{Mint: record{to: AccountIdentifier;amount: Tokens;};Burn: record{from: AccountIdentifier;amount: Tokens;};Send: record{from: AccountIdentifier;to: AccountIdentifier;amount: Tokens;};};type Memo=u64;// Timestamps are represented as nanoseconds from the UNIX epoch in UTC timezone type TimeStamp=record{timestamp_nanos: nat64;};Transaction=record{transfer: Transfer;memo: Memo;created_at_time: Timestamp;};Block=record{parent_hash: Hash;transaction: Transaction;timestamp: Timestamp;};type BlockIndex=nat64;//The ledger is a list of blocks type Ledger=vecBlock amount: 전송할 토큰의 양 fee: 송금 시 지불해야 하는 수수료 from_subaccount: ICP가 발생해야 하는 호출자의 계정을 지정하는 하위 계정 식별자입니다. 이 매개변수는 선택 사항입니다. — 호출자가 지정하지 않으면 모두 0 벡터로 설정됩니다. to: 토큰을 전송해야 하는 계정 식별자 memo: 발신자가 선택한 64비트 숫자입니다. 예를 들어 특정 전송을 식별하기 위해 다양한 방법으로 사용할 수 있습니다. ","date":"2023-04-07","objectID":"/ledger_canister/:3:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"Burning token minting account로 토큰을 transfer하는 것은, 토큰을 간단히 remove시키는 방식입니다. 즉 token을 burn하는 것입니다. Burn transaction은 ledger에 (Burn(from, amout))형태로 저장되며, burn transaction fee는 0입니다. 대신 burn되어져야 할 token의 amount는 standard_fee를 초과해야 transaction이 동작합니다. burning transaction A burning transaction is the process of “burning” ICP, whereby a certain amount of ICP are destroyed. The main use case is that of purchasing cycles, through which ICP are destroyed while at the same time a corresponding amount of cycles is created, using the current exchange rate between ICP and ( SDR), in such a way that one SDR corresponds to one trillion (10E12) cycles. It is represented as a transaction from the source account to the ICP supply account. ","date":"2023-04-07","objectID":"/ledger_canister/:3:1","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"3. Ledger block 확장성을 위해 ledger canister는 entire ledger transactions들을 저장하지 않습니다. 대신 ledger canister는 가장 최근 블록으로 구성된 suffix of the ledger를 저장하고 있습니다. 그리고 나머지 블록들은 모두 archive canisters에 저장됩니다. ","date":"2023-04-07","objectID":"/ledger_canister/:4:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["blockchain","dfinity","icp","internet computer"],"content":"4. Conclusion Ledger canister는 ICP token관련된 block들을 저장하며, 아래 3가지 기능을 interface로 제공합니다. transfer() burn() / mint() balance() 또한 확장성을 위해 archive canisters에 나머지 블록들을 저장해두고, 최신 블록의 suffix만을 저장해두어 light weight합니다. 아마 이게 가능한 이유는 icp만의 특별한 encryption 덕분이며 더 자세한 암호화 방식은 추후 공부해야 할 것 같습니다. 최근에 완성된 invoice canister는 이 ledger canister위에서 동작하는 high level canister이며, BTC / ETH / ICP 각 canister들의 payment를 추상화시켜줘 더 편리하게 처리할 수 있습니다. plug, infinityWallet, stoic등의 wallet들은 이런 ledger의 transfer기능을 추상화시켜서 처리해주는 것 같습니다. ","date":"2023-04-07","objectID":"/ledger_canister/:5:0","tags":["dev"],"title":"The Ledger canister","uri":"/ledger_canister/"},{"categories":["rust","thread_local","macro","dfinity"],"content":"A brief summary about std::thread_local! ","date":"2023-04-04","objectID":"/threadlocal/:0:0","tags":["dev"],"title":"std::thread_local!","uri":"/threadlocal/"},{"categories":["rust","thread_local","macro","dfinity"],"content":"thread_local! thread_local!은 rust의 std 매크로이며, thread_local 내부에 선언된 변수를 wrap한뒤 std:🧵:LocalKey를 제공합니다. pub과 #[](attribute)가 허용됩니다. ","date":"2023-04-04","objectID":"/threadlocal/:1:0","tags":["dev"],"title":"std::thread_local!","uri":"/threadlocal/"},{"categories":["rust","thread_local","macro","dfinity"],"content":"std:🧵:LocalKey thread_local storage에 들어있는 값에 접근할 수 있는 key입니다. .with()는 thread_local에 들어있는 변수에 대한 reference를 yield합니다. 이 값은 sent across threads 할 수 없고, given closure를 escape할 수 없습니다. Drop을 통해서 escape될 때 destruct됩니다. ","date":"2023-04-04","objectID":"/threadlocal/:2:0","tags":["dev"],"title":"std::thread_local!","uri":"/threadlocal/"},{"categories":["rust","thread_local","macro","dfinity"],"content":"예시1 rust docs의 예시1 usestd::cell::RefCell;usestd::thread;thread_local!(staticFOO: RefCell\u003cu32\u003e=RefCell::new(1));FOO.with(|f|{assert_eq!(*f.borrow(),1);*f.borrow_mut()=2;});// each thread starts out with the initial value of 1 lett=thread::spawn(move||{FOO.with(|f|{assert_eq!(*f.borrow(),1);*f.borrow_mut()=3;});});// wait for the thread to complete and bail out on panic t.join().unwrap();// we retain our original value of 2 despite the child thread FOO.with(|f|{assert_eq!(*f.borrow(),2);}); thread_local! 매크로를 거친 FOO는 LocalKey\u003cRefCell\u003cu32\u003e\u003e 타입입니다. with() 매서드에 |f| {}라는 anonymous function을 넣어줍니다. thread::spawn()이 없는 경우는 main thread이다. main thread에서 spawn 한 쓰레드에서 borrow_mut()를 3으로 변경하더라도, main_thread의 FOO 변수값은 2 그대로이다. ","date":"2023-04-04","objectID":"/threadlocal/:3:0","tags":["dev"],"title":"std::thread_local!","uri":"/threadlocal/"},{"categories":["rust","thread_local","macro","dfinity"],"content":"예시2: icp nft usestd::mem;thread_local!{staticSTATE: RefCell\u003cState\u003e=RefCell::default();}#[pre_upgrade]fn pre_upgrade(){letstate=STATE.with(|state|mem::take(\u0026mut*state.borrow_mut()));...}// init or update #[init]fn init(args: InitArgs){STATE.with(|state|{letmutstate=state.borrow_mut();state.custodians=args.custodians.unwrap_or_else(||HashSet::from_iter([api::caller()]));state.name=args.name;state.symbol=args.symbol;state.logo=args.logo;});}// retrieve #[query(name = \"balanceOfDip721\")]fn balance_of(user: Principal)-\u003e u64 {STATE.with(|state|{state.borrow().nfts.iter().filter(|n|n.owner==user).count()asu64})} thread_local에 wrap된 변수를 변경하기 위해서는 RefCell에 접근하는 borrow_mut()메서드가 필요하다. Read만 할 경우에는 .borrow()를 사용하면 된다. ","date":"2023-04-04","objectID":"/threadlocal/:4:0","tags":["dev"],"title":"std::thread_local!","uri":"/threadlocal/"},{"categories":["rust"],"content":"You need to write intro in here ","date":"2023-04-03","objectID":"/cell/:0:0","tags":["dev"],"title":"Cell and RefCell","uri":"/cell/"},{"categories":["rust"],"content":"TL;DR 참고로 Cell과 RefCell는 thread-safe하지 않다. 즉 single-threaded way에서만 safe를 보장한다. Cell: immutable한 타입을 명시적으로 런타임에 mutable하게 사용할 수 있고 value를 return한다. RefCell: Cell의 Reference버전 차이점 Cell provides you values, RefCell with references Cell never panics, RefCell can panic panic이 없는 Cell을 선호하게 짜는게 유리하며, 몇몇 operation에서는 Cell을 사용할 수 없으니 그때 RefCell을 사용한다. ","date":"2023-04-03","objectID":"/cell/:1:0","tags":["dev"],"title":"Cell and RefCell","uri":"/cell/"},{"categories":["rust"],"content":"1. Cell Interior mutability Cell mut 키워드 없이, mutable하게 변수를 변경할 수 있는 방법이 뭐가 있을까? 러스트에서는 몇가지 방법을 제공하는데 그 중 가장 simple한 방법은 Cell이다. 언제 사용할까? 예를 들어 immutable struct에서 특정 필드만 mutable하게 관리하고 싶을 때. before struct PhoneModel{company_name: String,model_name: String,screen_size: f32,memory: usize,date_issued: u32,on_sale: bool,}fn main(){letsuper_phone_3000=PhoneModel{company_name: \"YY Electronics\".to_string(),model_name: \"Super Phone 3000\".to_string(),screen_size: 7.5,memory: 4_000_000,date_issued: 2020,on_sale: true,};} after usestd::cell::Cell;struct PhoneModel{company_name: String,model_name: String,screen_size: f32,memory: usize,date_issued: u32,on_sale: Cell\u003cbool\u003e,}fn main(){letsuper_phone_3000=PhoneModel{company_name: \"YY Electronics\".to_string(),model_name: \"Super Phone 3000\".to_string(),screen_size: 7.5,memory: 4_000_000,date_issued: 2020,on_sale: Cell::new(true),};// 10 years later, super_phone_3000 is not on sale anymore super_phone_3000.on_sale.set(false);} Cell은 value를 return하기 때문에 Copy types에 가장 적홥하다. ","date":"2023-04-03","objectID":"/cell/:2:0","tags":["dev"],"title":"Cell and RefCell","uri":"/cell/"},{"categories":["rust"],"content":"2. RefCell RefCell Cell과 마찬가지로 mut없이 value를 change할 수 있지만, RefCell는 Copy 대신 reference를 사용한다. usestd::cell::RefCell;#[derive(Debug)]struct User{id: u32,year_registered: u32,username: String,active: RefCell\u003cbool\u003e,// Many other fields }fn main(){letuser_1=User{id: 1,year_registered: 2020,username: \"User 1\".to_string(),active: RefCell::new(true),};println!(\"{:?}\",user_1.active);} RefCell은 총 2가지 메서드를 통해 RO(read only), RW(Read/Write) 를 처리한다. 이는 \u0026와 \u0026mut 각각과 대응된다. .borrow() .borrow_mut() 당연히 borrow_mut()는 최대 1개만 사용되어야 한다. 또한 readonly인 borrow()는 여러개 사용되어도 상관없다. 마지막으로 borrow()와 borrow_mut()는 동시에 사용할 수 없다. replace() user_1.active.replace(false); replace_with(): 조건을 통한 replace // 🚧 letdate=2020;user_1.active.replace_with(|_|ifdate\u003c2000{true}else{false});println!(\"{:?}\",user_1.active); 또한 Cell과 마찬가지로 Runtime에 동작하기 때문에 panic이 일어날 수 있다. 예를들면 borrow_mut()를 2번사용하게 되면 컴파일 타임에러가 아닌 런타임에 에러가 난다. ...fn main(){letuser_1=User{id: 1,year_registered: 2020,username: \"User 1\".to_string(),active: RefCell::new(true),};letborrow_one=user_1.active.borrow_mut();// first mutable borrow - okay letborrow_two=user_1.active.borrow_mut();// second mutable borrow - not okay }// thread 'main' panicked at 'already borrowed: BorrowMutError', C:\\Users\\mithr\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\src\\libcore\\cell.rs:877:9 // note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace // error: process didn't exit successfully: `target\\debug\\rust_book.exe` (exit code: 101) ","date":"2023-04-03","objectID":"/cell/:3:0","tags":["dev"],"title":"Cell and RefCell","uri":"/cell/"},{"categories":[""],"content":"dfinity/ic 코드를 보다 이해되지 않는 코드들이 있어, Cow를 왜 사용하는지 정리하려 합니다. ","date":"2023-04-03","objectID":"/cow/:0:0","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"TL;DR pubenum Cow\u003c'a,B\u003ewhereB: 'a +ToOwned+?Sized,{Borrowed(\u0026'aB),Owned(\u003cBasToOwned\u003e::Owned),} Cow의 약어 뜻은 clone-on-write로 read가 아닌 write시 clone시킬 수 있는 기능을 가지고 있습니다. Cow는 Borrowed, Owned를 구분하는 enum 타입입니다. 제너릭 B는 ‘a와, ToOwned, ?Sized로 바운드 되어있습니다. ToOwned trait borrowed 데이터의 Clone에 대한 일반화 clone시켜서, Owned 타입을 만들어 낼 수 있다. ?Sized trait 컴파일 타임에 constant size를 알 수 있는 타입 모든 타입 파라미터는 implicit bound로 Sized를 보유하고 있다. ?를 사용하면 이 bound를 remove시켜줄 수 있다. 즉 Cow는 Borrowed 또는 Owned 둘 모두를 사용하고 싶을 때 사용한다. 예를 들면 \u0026str, String타입 모두 사용하길 원하는 경우. #[derive(CandidType, Deserialize, Clone)]struct LogoResult{logo_type: Cow\u003c'static,str\u003e,data: Cow\u003c'static,str\u003e,}// ... constDEFAULT_LOGO: LogoResult=LogoResult{data: Cow::Borrowed(include_base64!(\"logo.png\")),//\u0026str logo_type: Cow::Borrowed(\"image/png\"),//\u0026str }; ","date":"2023-04-03","objectID":"/cow/:1:0","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"Cow를 사용하는 이유 6 thing you can do with the 🐄 in 🦀 ","date":"2023-04-03","objectID":"/cow/:2:0","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"1. A function rarely modifying the data 불필요하게 clone을 하게되는 경우를 막기 위해서 cow를 사용할 수 있습니다. FYI to_string()은 복사본을 전달한다. before fn remove_whitespaces(s: \u0026str)-\u003e String {s.to_string().replace(' ',\"\")}fn main(){letvalue=remove_whitespaces(\"Hello world!\");println!(\"{}\",value);} after usestd::borrow::Cow;fn remove_whitespaces(s: \u0026str)-\u003e Cow\u003cstr\u003e{ifs.contains(' '){Cow::Owned(s.to_string().replace(' ',\"\"))}else{Cow::Borrowed(s)}}fn main(){letvalue=remove_whitespaces(\"Hello world!\");println!(\"{}\",value);} ","date":"2023-04-03","objectID":"/cow/:2:1","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"2. A struct optionally owning the data ","date":"2023-04-03","objectID":"/cow/:2:2","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"3. A clone on write struct ","date":"2023-04-03","objectID":"/cow/:2:3","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"4. Keep your own type inside it ","date":"2023-04-03","objectID":"/cow/:2:4","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"5. Borrow the type as dyn Trait ","date":"2023-04-03","objectID":"/cow/:2:5","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"6. Implement safe wrapper over FFI type","date":"2023-04-03","objectID":"/cow/:2:6","tags":["dev"],"title":"COW 🐄 in Rust 🦀","uri":"/cow/"},{"categories":[""],"content":"How can I create an transparent donation system based on blockchain DAO concepts, in a practical way. What is ICP’s SNS (Service Nervous System) Where can I use SNS? ","date":"2023-03-09","objectID":"/icp_dao/:0:0","tags":["dev"],"title":"ICP DAO","uri":"/icp_dao/"},{"categories":[""],"content":"sns faq summary sns faq How unique are SNS DAOs in Web3? ICP is unique in that it can host fully-on chain dapps (frontend, backend application logic, and data), so SNS DAOs are unique in that they can fully control (via voting) every aspect of a dapp, since everything is on-chain. Having fully on-chain DAOs is important because it enables all decisions to be executed on the blockchain. This is in contrast to existing DAOs on other blockchains where voting takes place on-chain but the execution of the results are often carried out by developers off-chain. This facilitates true decentralization. What are the advantages of SNS DAOs? Community Engagement: as co-owners of the product, users become core contributors, developers deliver on value proposition. Speedy User Adoption: As co-owners, users become the biggest advocates of the product. Funding: projects are funded through a community-driven decentralization sale. ","date":"2023-03-09","objectID":"/icp_dao/:1:0","tags":["dev"],"title":"ICP DAO","uri":"/icp_dao/"},{"categories":["about"],"content":"About Minwook","date":"2023-02-26","objectID":"/about/","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":" Minwook Je GitHub | LinkedIn | Website Blog KakaoTalk Hi I'm minwook. I want to be a conscientious person weighing my love and justice. 🐋 ","date":"2023-02-26","objectID":"/about/:0:0","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1. Experience 💻 ","date":"2023-02-26","objectID":"/about/:1:0","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-1. Bear Robotics 2022.03 - 2022.09 Headquarters: Redwood City, California HomePage | Linkedin ","date":"2023-02-26","objectID":"/about/:1:1","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-2. Kakao 2020.07 - 2022.03 Headquarters: Jeju, Korea HomePage | Linkedin Software Engineer Joined Blockchain task force(Krust) and developed front page and API server that issues Klaytn NFT based certification cards for Korea National Human Resources certification system Kakako Wallet : Developed a B2B cloud service that manages web identification cards for the membership of client companies. Deployed Kakao cloud services with Kubernetes and RabbitMQ. ","date":"2023-02-26","objectID":"/about/:1:2","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-3. SEMES - Samsung Electronics 2020.01 - 2020.06 HomePage | Linkedin Embedded Software Engineer(S3) Developed a thread scheduling software for a distributed semiconductor etching system using C++ ","date":"2023-02-26","objectID":"/about/:1:3","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-4. Nexters 2020.11 - 2022.12 Homepage | Github Management Staff Instructed software development project teams of 64 members, provided feedbacks throughout sprints and organized team building events. Software Developer Led a backend development of a couple’s date planner web service using NestJS, typescript, GraphQL, mongoDB and Kakao-place API ","date":"2023-02-26","objectID":"/about/:1:4","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-5. LIKELION 2018.01 - 2019.12 Homepage Student Developer Launched an official website for Ajou University Festival using Django and AWS EC2 ","date":"2023-02-26","objectID":"/about/:1:5","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"1-6. Ajou University LINK+ 2018.03 - 2018.12 Student Developer Developed a Sentiment Analysis model using Python Keras, presenting it at the Academic Conference of Nanyang Technological University in Singapore. Developed a deep-learning based Android app that quantifies eight facial characteristics of users. ","date":"2023-02-26","objectID":"/about/:1:6","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"2. Side Projects 🚋 2-1. Youtube music playlist 22.07 - 22.10 2-2. Exchange diary 22.02 - 22.03 2-3. Bookmark share 21.07 - 21.08 2-4. Couple dating map record 21.04 - 21.07 ","date":"2023-02-26","objectID":"/about/:2:0","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"🏄‍♂️ Skills language: Rust, Golang, Python, Kotlin, Typescript frontend: Svelte, React, Tailwind Css backend: Fiber, Gin, FastAPI, NestJs ,Django, Spring db: mongo, mysql, postgreSQL infra: kubernetes, docker, gcp, aws, nginx, heroku, rabbitmq etc: REST/gRPC/GraphQL, monorepo, DDD, TDD, OOP, FP ","date":"2023-02-26","objectID":"/about/:3:0","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"🎓 Education Ajou University Major : B.S. Digital Media 3.64 Coursework : Data Structures, Algorithms, Operating System, Database System, Data Science, Media Analytics and others const lottie1 = bodymovin.loadAnimation({ container: document.getElementById('lottie1'), renderer: 'svg', loop: true, autoplay: true, path: 'https://raw.githubusercontent.com/minkj1992/love/main/assets/68658-creative-3d-visual-animation-website-development.json', }); const lottie2 = bodymovin.loadAnimation({ container: document.getElementById('lottie2'), renderer: 'svg', loop: true, autoplay: true, path: 'https://raw.githubusercontent.com/minkj1992/love/main/assets/127763-computer-window-animation.json', }); const lottie3 = bodymovin.loadAnimation({ container: document.getElementById('lottie3'), renderer: 'svg', loop: true, autoplay: true, path: 'https://raw.githubusercontent.com/minkj1992/love/main/assets/125009-gibli-tribute.json', }); const lottie4 = bodymovin.loadAnimation({ container: document.getElementById('lottie4'), renderer: 'svg', loop: true, autoplay: true, path: 'https://raw.githubusercontent.com/minkj1992/love/main/assets/69164-marketing-campaign-creative-3d-animation.json', }); ","date":"2023-02-26","objectID":"/about/:4:0","tags":["about"],"title":"About Minwook Je","uri":"/about/"},{"categories":["about"],"content":"About Minwook","date":"2023-02-26","objectID":"/detail/","tags":["about"],"title":"About Minwook Je","uri":"/detail/"},{"categories":["about"],"content":"Minwook Je ","date":"2023-02-26","objectID":"/detail/:0:0","tags":["about"],"title":"About Minwook Je","uri":"/detail/"},{"categories":["about"],"content":"제 민 욱 ","date":"2023-02-26","objectID":"/detail/:0:1","tags":["about"],"title":"About Minwook Je","uri":"/detail/"},{"categories":["about"],"content":"Experience Bear robotics / 풀스택 개발자 자율주행 서빙 로봇, 자율주행 방역 로봇 카카오 블록체인 / 서버 개발자 카카오콘, 카카오 팬템, 카카오 국가기술자격증, 디지털 카드, Krust SEMES / 임베디드 소프트웨어 개발 반도체 에치 공정 로봇 SW ","date":"2023-02-26","objectID":"/detail/:1:0","tags":["about"],"title":"About Minwook Je","uri":"/detail/"},{"categories":["about"],"content":"Extra Curricular NEXTERS 운영진 / 19기 CTO, 18- 21기 개발자 멋쟁이사자처럼 운영진 1. Kakao Con (카카오콘) 카카오를 쓰는 만큼 돌려받을 수 있는 암호화폐 리워드 카카오 내부에서 동작하는 프라이빗 블록체인에서, 사용자들이 카카오콘이라는 암호화폐를 얻을 수 있도록 하는 화폐 시스템 발행 조건 예시 신규 사용자 / 생일 멜론 음악 사용자 카카오 계정 통합 등 2. Kakao Fantem (응원보드 / 팬템) 자신이 좋아하는 아티스트를 응원할 수 있는 팬 아이템 NFT 자신이 응원하고 싶은 아티스트와 그 아티스트를 좋아하는 팬의이름 그리고 메시지를 넣어, NFT로 발행합니다. NFT가 발행된 팬은 아티스트 응원보드에 자신의 닉네임을 노출 시킬 수 있으며, 가장 먼저 아티스트의 소식을 톡으로 접할 수 있습니다. 3. 국가기술 자격증 한국산업인력공단의 국가자격 전자증명 서비스 NFT 한국 산업인력공단에서 제공하는 자격증을 NFT화 정보처리기사·한식조리기능사 등 495종의 국가기술자격증을 NFT로 구현 4. 카카오 디지털카드 시중 플라스틱 카드 및 종이티켓 디지털 카드로 대체하는 ESG 서비스 신분증, 자격증, 멤버십, 입장권, 보증서 등 아우르는 디지털카드와 발급 시스템 개발 출입키 전문업체 모카 시스템과 기술제휴로 디지털 사원증 서비스 5. 카카오 Krust 카카오 CTO 함께, 카카오에서 블록체인을 이끌었던 모든 개발자 Krust회사 창업 이로 인해 카카오에 남아있는 암호화폐 서비스, 디지털 카드, 국가 자격증 서비스 등 모두 전임 운영 5-1. 클레이튼 노드 운영 대표적으로 카카오, 카카오 엔터프라이즈, 카카오 VX의 클레이튼 노드 서버를 전부 관리 6. 카카오 지갑 블록체인 팀 분사이후, 카카오 지갑으로 부서 이동하여 디지털 카드 플랫폼 개발 / 운영 후 이직 ","date":"2023-02-26","objectID":"/detail/:2:0","tags":["about"],"title":"About Minwook Je","uri":"/detail/"},{"categories":["crypto","whitepaper"],"content":"About STEPN with it's white paper","date":"2023-02-01","objectID":"/stepn/","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"About Whitepaper.stepn . Tokenomics는 ‘Token+Ecomomics’를 합친 용어로 토큰의 사용과 획득 이에 대한 인센티브 구조를 통칭 하는 용어입니다. 대표적으로 P2E(Play to Earn), M2E(Move to Earn)가 있으며 이를 통칭하여 X2E(X하면서 돈 벌기)라고 부릅니다. 오늘은 STEPN이라는 solana 기반의 프로젝트를 소개합니다. ","date":"2023-02-01","objectID":"/stepn/:0:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"Overview STEPN is a Web3 lifestyle app with inbuilt Game-Fi and Social-Fi elements Stepn is the first project to effectively bring to life a functioning move\u0026earn concept, finishing 4th out of 500+ projects at the Solana Ignition Hackathon 2021. 스테픈은 2021년 솔라나 해커톤에서 4th을 차지하여 StepN은 Dual Tokenomics를 기반으로 설계되었습니다. GMT(Green Metaverse Token): 거버넌스 토큰 공급량 한정 거버넌스 토큰 스테이킹 하여 더 많은 투표권(거버넌스)을 받을 수 있습니다. 운동화 레벨업 (유저 레벨 시스템), 보석 레벨업에 반드시 필요한 토큰으로 이를 통해 소각을 구현 GST(Green Satoshi Token): 유틸리티 토큰 공급량 제한 없음. 운동화 수리, 레벨 업, 보석함 오픈 등에 필요한 토큰으로 사용시 소각됩니다. 유저의 운동량을 통해 채굴할 수 있습니다. ","date":"2023-02-01","objectID":"/stepn/:1:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"스테픈에 대한 생각 스테픈의 whitepaper를 보면서 3가지 입니다. 조잡하다. 중앙화: 중앙화된 솔라나 base layer 1. 불투명 구조: source code 사용자들이 초기 신발 투자금을 평균적으로 몇개월에 회수 하는지? 피라미드 구조 스테픈은 신발 / Gem / HP / Fusion / Enhancement 등 엄청 복잡한 시스템으로 유저가 계속해서 자금을 투입하게 하고, Solana, Binance, Eth(Ape)등으로 예금을 하도록 하는 시스템을 가지고 있습니다. 스테픈의 유저 유입의 핵심은 “운동\"이 아니라, “돈\"을 벌 수 있다는 것인데 유입된 사용자들이 자신이 “일\"을 한다고 느끼는게 아닌 “재미\"를 느끼도록 하는 것이 핵심인 것 같습니다. 그리고 복잡하게 여러 아이템을 나눠두었는데, 이를 통해서 사용자들이 수익에 대한 계산을 복잡하게 만들고 있습니다. 결국 “걷는다\"라는 핵심 가치라고 주장하는 가치는 사실 의미가 없고, 돈을 버는 개념만 존재하는 프로젝트라고 생각됩니다. 또한 이게 재미있을까라고 했을때는 잘 모르겠습니다. 이에 대한 생각은 Game Fi와 연동해서 더 작성해보겠습니다. 그럼 2번과 3번 관련해서 스테픈을 투자관점으로 생각해보자면, 어떨지 생각해보았습니다. 결국 Realm같은 요소는 게임의 길드를 만드는 것이고, 이 개념의 핵심은 멋지게 말하지만 수익적으로 다단계 피라미드 구조라고 생각됩니다. 2번의 관점 또한 투자로 접근한다면, 실제 후기 를 본다면 알 수 있습니다. 결국 스테픈을 통해서 누가 제일 큰 돈을 벌까? 라고 생각해보면 스테픈 임직원 solana Binance 먼저 참여한 사람 순으로 후발주자들은 점점 더 확률이 적어짐 입니다. 사용자는 들어오자 마자, Binance 같은 거래소를 통해 최소 10만원 이상의 금액을 투자해야 하고, 이 돈은 solana로 전환해야 하며 이를 마켓에서 아이템을 구입한 뒤, GMT로 돈벌기 위해서 스테이킹을 합니다. 일부는 solana로 들어가고, 일부는 Binance로 들어가고, 일부는 스테이킹되어 Binance 자금으로 들어갑니다. 제가 개인적으로 스테픈이 불쾌한 이유는 “운동을 하면서 돈을 벌어라” 라는 모토가 부정직해 보이기 때문입니다. 중앙화된 솔라나, 바이낸스 스테이킹 개념, 탄소 배출에 기여한다는 모든 모습이 그저 돈을 벌기 위해 사용자들을 많이 끌어오려는 것 외에는 없어 보입니다. 스테픈 참여자들 중에서 대체 어떤 운동에 대한 욕구를 찾아볼 수 있을까요? 솔직히 다 돈을 벌고 싶어서 들어오는 것인데. ","date":"2023-02-01","objectID":"/stepn/:2:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"Game Fi에 대한 생각 인지도: 현실에서 특정 아이템의 인지도가 있는 경우 컨텐츠: 게임 컨텐츠가 있는 경우 교육: 인강 회사 또는 인강 강사 ","date":"2023-02-01","objectID":"/stepn/:3:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"1번: 이미 인지도가 회사 1번의 경우, 시장에서 어느정도 지지층이 있는 특정 회사가 사용자의 제품에 대한 충성심을 유지하게 또는 새로운 사용자 시장을 키우기 위해 사용할 수 있습니다. 예를 들면 파워리프팅 기업에서 파워리프팅 제품에 GameFi요소를 넣어, 사용자들의 랭킹에 따라 수익을 내도록 하면 파워 리프터들은 경쟁을 할 것이고, 스테픈 처럼 우겨넣기 식으로 제품을 만들어낸 것이 아니기 때문에 돈을 벌지 않아도 된다는 사용자들이 강박을 가지지 않아도 됩니다. 이는 나이키 같은 경우도 마찬가지로 nike의 경우에는 스테픈과 달리, 어차피 신발을 사는 유저들은 있을 것이고, nike의 경우에는 시장 점유율을 높이기 위해 GameFI가 연동되는 나이키 신발을 시리즈로 런칭하게 된다면 새로운 사용자 시장을 개척할 수 있습니다. ","date":"2023-02-01","objectID":"/stepn/:3:1","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"2번: 컨텐츠 2번의 경우, 게임 컨텐츠이며 대표적으로 라이엇 게임즈가 있습니다. 라이엇게임즈의 발로란트는 현재 GameFI의 1위 기업으로, 이렇게 된다면 참여자들은 탄탄한 게임 스토리를 즐기면서 한편으로 Game FI 시합, NFT 아이템 판매등으로 정말 돈을 벌 수 있습니다. 앞으로는 리니지 같은 게임들이 “채굴” 즉 몬스터 사냥을 매개체로 돈을 벌 수 있을 것으로 보입니다. 하지만 2번의 경우에 과연 “게임\"의 본질을 유지할 수 있을지는 모르겠습니다. 게임의 본질이 즐기기 위해서 라고 한다면, 이게 돈을 버는 수단이 되버린다고 해도 우리가 롤을 하듯이 즐길 수 있을지는 미래가 되어 봐야 알 것 같습니다. ","date":"2023-02-01","objectID":"/stepn/:3:2","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"3번: 교육 앞으로 메가스터디, 이투스 같은 곳에서 토큰과 NFT를 찍어낼지도? 마지막으로 3번의 경우에는 가장 최고의 케이스입니다. 즉 “전문성\"을 원하는 사용자들이 경쟁을 하게 되고, 경쟁에서 순위권이 된다면 reward로 돈을 받는 구조가 가능합니다. 예를 들면 인강 플렛폼 과목을 자체 민팅한 암호화폐 베이스인 NFT로 구매하도록 하고, 해당 NFT를 들고있는 학생들 한정으로 모의고사에서 상위 ?%를 받게된다면 리워드로 자체 민팅한 NFT를 구성하는 Token을 제공하는 형식입니다. 이를 통해 학생들은 정말 공부하면서 돈을 벌 수 있고, 경쟁을 할 수 있기 때문에 공부에 대한 모티베이션을 줄 수 있으며, 인강 업체의 경우에도 자체 민팅한 토큰에 대한 수수료 %까지 겸해서 수익을 얻을 수 있다는 장점과 경쟁에 참여하고 싶은 우수한 학생들을 다수 유입시킬 수 있다는 점에서 매우 좋은 수익구조라고 생각합니다. ","date":"2023-02-01","objectID":"/stepn/:3:3","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"Conclusion 결국 GameFi의 핵심은 기존에 컨텐츠 또는 경쟁력 있는 컨텐츠 아이템 또는 전문성에 대한 방향성이 맞을 것이 핵심이고, 이를 통해서 “경쟁\"을 통한 수익을 제공한다는 점이 핵심인 것 같습니다. 스테픈이 보기 좋지 않은 이유는 운동에 대한 요소는 뒷전이고, “돈\"에 대한 사용자 유입을 선전하고 있지만, 그 구조가 결코 사용자들이 돈을 벌도록 하기 어렵다는 점이 서로 윈윈인 아이템이 아닌, 어색하게 컨텐츠를 우겨넣는 느낌이 들기 때문입니다. ","date":"2023-02-01","objectID":"/stepn/:4:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["crypto","whitepaper"],"content":"refs Stepn과 Tokenomics 스테픈·올림푸스 다오’로 본 지속 불가능한 구조 ","date":"2023-02-01","objectID":"/stepn/:5:0","tags":["dev","STEPN"],"title":"[Whitepaper] STEPN 그리고 tokenomics","uri":"/stepn/"},{"categories":["dev"],"content":"The official Rust book","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Part1. Rust 프로그래밍 에 이어서 Rust의 고급 문법들을 익혀보겠습니다. 11. Testing ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:0:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"11-1. Test 작성하기 가장 단순하게 말하면, 러스트 내의 테스트란 test 속성(attribute)이 주석으로 달려진 (annotated) 함수입니다. attribute란 러스트 코드 조각에 대한 메타데이터입니다. #[cfg(test)]mod tests{#[test]fn it_works(){assert_eq!(2+2,4);}} #[test]를 fn위에 올리게된다면, 이 함수는 test 함수라는 것을 뜻합니다. assert_eq!, assert_ne! 매크로는 PartialEq와 Debug 트레잇을 구현해야합니다. 즉 #[derive(PartialEq, Debug)] 어노테이션이 필요합니다. test module이 외부 fn에 대해 테스트를 작성하기 위해서 일반적으로 glob을 활용한 use super::*을 내부에 적습니다. pubfn add_numbers(a: i32,b: i32)-\u003e i32 {a+b}#[cfg(test)]mod tests{usesuper::*;#[test]fn it_works(){letexpect=4;assert_eq!(expect,add_numbers(2,2));}}// $ cargo test should_panic을 활용하면 에러 처리하는 부분 또한 테스트할 수 있습니다. pubstruct Guess{value: u32,}implGuess{pubfn new(value: u32)-\u003e Guess{ifvalue\u003c1{panic!(\"Guess value must be greater than or equal to 1, got {}.\",value);}elseifvalue\u003e100{panic!(\"Guess value must be less than or equal to 100, got {}.\",value);}Guess{value}}}#[cfg(test)]mod tests{usesuper::*;#[test]#[should_panic(expected = \"Guess value must be less than or equal to 100\")]fn greater_than_100(){Guess::new(200);}} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:1:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"11-2. Test 실행하기 cargo test는 기본적으로 스레드를 이용해 병렬적으로 수행됩니다. 만일 병렬 테스트를 실행하고 싶지 않을 경우, 스레드 갯수를 그저 1개로 줄이면 됩니다. $ cargo test -- --test-threads=1 cargo test에는 총 2가지 종류의 argument가 존재합니다. \u003e cargo test --help Execute all unit and integration tests and build examples of a local package Usage: cargo test [OPTIONS] [TESTNAME] [-- [args]...] (컴파일 옵션) cargo test 커맨드라인에 테스트 옵션/파일이름을 위해 전달되는 argument OPTIONS TESTNAME (컴파일후 생성된 바이너리 실행 옵션) cargo test 바이너리를 실행시 전달할 옵션입니다. cargo test는 위의 2가지 argument를 구분하기 위해 --를 사용합니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:2:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"--nocapture --nocapture를 사용하면 stdout까지 print되는 것을 막을 수 있습니다. $ cargo test -- --nocapture ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:2:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"filtering cargo는 test 뒤에 나오는 네이밍을 regex로 필터링합니다. 만약 아래와 같은 코드가 있고, $ cargo test add를 실행하게 된다면 pubfn add_two(a: i32)-\u003e i32 {a+2}#[cfg(test)]mod tests{usesuper::*;#[test]fn add_two_and_two(){assert_eq!(4,add_two(2));}#[test]fn add_three_and_two(){assert_eq!(5,add_two(3));}#[test]fn one_hundred(){assert_eq!(102,add_two(100));}} $ cargo test add Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs Running target/debug/deps/adder-06a75b4a1f2515e9 running 2 tests test tests::add_two_and_two ... ok test tests::add_three_and_two ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out 다음과 같은 결과가 일어납니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:2:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"ignore 만약 특정 테스트들을 무시하고 싶으면 #[ignore]를 사용하면됩니다. #[test]fn it_works(){assert_eq!(2+2,4);}#[test]#[ignore]fn expensive_test(){// code that takes an hour to run } 역으로 ignore된 테스트들만 실행시키고 싶다면, –ignored를 추가하면 됩니다. $ cargo test -- --ignored ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:2:3","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"11-3. 테스트 조직화 Unit test Integration test ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:3:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"unit test 관례는 각 파일마다 테스트 함수를 담고 있는 tests라는 이름의 모듈을 만들고, 이 모듈에 cfg(test)라고 어노테이션 하는 것입니다. cfg(test) 이 어노테이션은 러스트에게 우리가 cargo build를 실행시킬 때가 아니라 cargo test를 실행시킬 때에만 컴파일하고 실행시키라고 말해줍니다. 통합 테스트는 다른 디렉토리에 위치하기 때문에, 이 어노테이션이 필요없습니다. 또한 rust의 private은 test에서는 접근가능 합니다. pubfn add_two(a: i32)-\u003e i32 {internal_adder(a,2)}fn internal_adder(a: i32,b: i32)-\u003e i32 {a+b}#[cfg(test)]mod tests{usesuper::*;#[test]fn internal(){assert_eq!(4,internal_adder(2,2));}} 마지막으로 rust의 모듈 특성을 이용하면, test 파일을 소스 코드와 분리해서 관리할 수도 있습니다. Should unit tests really be put in the same file as the source? src/ ... ops.rs ops/ test.rs ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:3:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Integration test 러스트의 통합테스트는 tests/ 디렉토리로 완전히 src/와 분리되서 관리됩니다. src/ lib.rs ops.rs ops/ test.rs tests/ 12. I/O 커맨드 라인 프로그램 CLI repo 13. Funtional Programming Closure Iterator ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:3:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"13.1 Closure Closures are functions that can capture the enclosing environment. |val| val + x simple define closure fn add_one_v1(x: u32)-\u003e u32 {x+1}letadd_one_v2=|x: u32|-\u003e u32 {x+1};letadd_one_v3=|x|{x+1};letadd_one_v4=|x|x+1;{letexpensive_closure=|num|{println!(\"calculating slowly...\");thread::sleep(Duration::from_secs(2));num};} 클로저는 만약 좁은 범위에서 사용되기 때문에, 문맥상 타입이 명확하다면 오히려 불필요하게 타입을 쓰지 않아도 좋은 접근인 것 같다. 한번 호출 이후 타입은 고정됩니다. letexample_closure=|x|x;lets=example_closure(String::from(\"hello\"));letn=example_closure(5); error[E0308]: mismatched types --\u003e src/main.rs | | let n = example_closure(5); | ^ expected struct `std::string::String`, found integral variable | = note: expected type `std::string::String` found type `{integer}` full example #[derive(Debug, PartialEq, Copy, Clone)]enum ShirtColor{Red,Blue,}struct Inventory{shirts: Vec\u003cShirtColor\u003e,}implInventory{fn giveaway(\u0026self,preference: Option\u003cShirtColor\u003e)-\u003e ShirtColor{// |no parameter| =\u003e self.most_stocked call closure preference.unwrap_or_else(||self.most_stocked())}fn most_stocked(\u0026self)-\u003e ShirtColor{let(mutn_red,mutn_blue)=(0,0);forcin\u0026self.shirts{matchc{ShirtColor::Red=\u003en_red+=1,ShirtColor::Blue=\u003en_blue+=1,}}ifn_red\u003en_blue{ShirtColor::Red}else{ShirtColor::Blue}}}fn main(){letstore=Inventory{shirts: vec![ShirtColor::Blue,ShirtColor::Red,ShirtColor::Blue],};letuser_pref1=Some(ShirtColor::Red);letgiveaway1=store.giveaway(user_pref1);println!(\"The user with preference {:?} gets {:?}\",user_pref1,giveaway1);letuser_pref2=Some(ShirtColor::Red);letgiveaway2=store.giveaway(user_pref2);println!(\"The user with preference {:?} gets {:?}\",user_pref2,giveaway2);} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Memoization (lazy evaluation) with Fn trait 각 클로저 인스턴스는 자신의 유일한 익명 타입을 갖습니다: 즉, 두 클로저가 동일한 타입 서명을 갖더라도 그들의 타입은 여전히 다른 것으로 간주 됩니다. 구조체 필드에 클로저를 구현한 경우. (Fn trait) impl pubstruct Cacher\u003cT\u003ewhereT: Fn(u32)-\u003e u32,{calculation: T,value: Option\u003cu32\u003e,}impl\u003cT\u003eCacher\u003cT\u003ewhereT: Fn(u32)-\u003e u32,{pubfn new(calculation: T)-\u003e Cacher\u003cT\u003e{Cacher{calculation,value: None,}}pubfn value(\u0026mutself,arg: u32)-\u003e u32 {matchself.value{Some(v)=\u003ev,None=\u003e{letv=(self.calculation)(arg);self.value=Some(v);v}}}} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Iterator 모든 iterator는 lazy하게 evaluation합니다. (python의 range와 같다.) letv1=vec![1,2,3];letv1_iter=v1.iter();forvalinv1_iter{println!(\"Got: {}\",val);} iterator는 내부적으로 next()를 사용하여 item들을 참조합니다. 또한 next는 \u0026mut self로 참조하는데, 이를 통해 next가 호출 될 때마다, item들이 소비됩니다. 모든 반복자는 표준 라이브러리에 정의된 Iterator 라는 이름의 트레잇을 구현 합니 다. 트레잇의 정의는 아래와 같습니다. traitIterator{type Item;fn next(\u0026mutself)-\u003e Option\u003cSelf::Item\u003e;// methods with default implementations elided }...#[test]fn iterator_demonstration(){letv1=vec![1,2,3];letmutv1_iter=v1.iter();assert_eq!(v1_iter.next(),Some(\u00261));assert_eq!(v1_iter.next(),Some(\u00262));assert_eq!(v1_iter.next(),Some(\u00263));assert_eq!(v1_iter.next(),None);} next 호출로 얻어온 값들은 벡터 안에 있는 값들에 대한 불변 참조라는 점 역시 유의 하세요. iter() 불변 참조에 대한 반복자를 만듭니다. 만약 v1 의 소유권을 갖고 소유된 값들을 반환하도록 하고 싶다면, iter 대신 into_iter 를 호출해야 합니다. 비슷하게, 가변 참조에 대한 반복자를 원한다면, iter 대신 iter_mut 을 호출할 수 있습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"반복자를 소비하는 메서드들 sum 또한 item을 소비합니다. #[test]fn iterator_sum(){letv1=vec![1,2,3];letv1_iter=v1.iter();lettotal: i32 =v1_iter.sum();assert_eq!(total,6);} sum 은 호출한 반복자의 소유권을 갖기 때문에, sum 을 호출한 후 v1_iter 은 사용할 수 없습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:3","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"다른 반복자를 생성하는 메서드들 map() letv1: Vec\u003ci32\u003e=vec![1,2,3];v1.iter().map(|x|x+1);// 새로운 iterator를 생성 iterator는 lazy하기 때문에, consume 되기전까지는 evaluate되지 않습니다. 그렇기 때문에 위에 코드는 아래와 같은 경고를 만들게 되는데요. warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy and do nothing unless consumed --\u003e src/main.rs:4:5 | 4 | v1.iter().map(|x| x + 1); | ^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: #[warn(unused_must_use)] on by default 이를 해결하기 위해서는 iterator를 소비해주면 됩니다. collect() letv1: Vec\u003ci32\u003e=vec![1,2,3];letv2: Vec\u003c_\u003e=v1.iter().map(|x|x+1).collect();assert_eq!(v2,vec![2,3,4]); filter #[derive(PartialEq, Debug)]struct Shoe{size: u32,style: String,}fn shoes_in_my_size(shoes: Vec\u003cShoe\u003e,shoe_size: u32)-\u003e Vec\u003cShoe\u003e{shoes.into_iter().filter(|s|s.size==shoe_size).collect()}#[test]fn filters_by_size(){letshoes=vec![Shoe{size: 10,style: String::from(\"sneaker\")},Shoe{size: 13,style: String::from(\"sandal\")},Shoe{size: 10,style: String::from(\"boot\")},];letin_my_size=shoes_in_my_size(shoes,10);assert_eq!(in_my_size,vec![Shoe{size: 10,style: String::from(\"sneaker\")},Shoe{size: 10,style: String::from(\"boot\")},]);} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:4","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"성능 비교하기: 루프 vs. 반복자 performance compare 오히려 iterator가 loop보다 빠르게 측정된다. 빠르다는 것이 중요한 것은 아니고 비록 iterator가 고수준의 abstract임에도, 컴파일이 진행되면 low level 코드와 같은 수준까지 내려갑니다. 이를 zero cost abstraction라고 러스트에서는 부릅니다. 즉 iterator와 closure 코드는 고수준이지만, 컴파일러의 zero cost abstraction 덕분에 런타임 성능 걱정없이 사용할 수 있습니다. 15. 스마트 포인터 러스트에서 스마트 포인터는 보통 구조체를 이용해서 구현된 기능이 추가된 포인터입니다. String, Vec\u003cT\u003e 또한 스마트 포인터의 일종입니다. 이유는 이들이 얼마간의 메모리를 소유하고, 개발자들이 다루도록 허용하기 때문입니다. 또한 메타데이터와, 추가 능력(확장) 기능을 가지고 있습니다. Smart pointer In computer science, a smart pointer is an abstract data type that simulates a pointer while providing added features, such as automatic memory management or bounds checking. Such features are intended to reduce bugs caused by the misuse of pointers, while retaining efficiency. Smart pointers typically keep track of the memory they point to, and may also be used to manage other resources, such as network connections and file handles. Smart pointers were first popularized in the programming language C++ during the first half of the 1990s as rebuttal to criticisms of C++’s lack of automatic garbage collection. 스마트 포인터가 일반적인 구조체와 구분되는 특성은 바로 Deref, Drop 트레잇을 구현한다는 것입니다. Deref: 스마트 포인터 구조체의 인스턴스가 참조자처럼 동작하도록 하여 참조자나 스마트 포인터 둘 중 하나와 함께 작동하는 코드를 작성하게 해줍니다. Drop: 스마트 포인터의 인스턴스가 스코프 밖으로 벗어났을 때, 실행되는 코드 표준 라이브러리에는 가장 대표적으로 아래의 스마트 포인터들이 있습니다. Box\u003cT\u003e: 값을 힙에 할당 Rc\u003cT\u003e: Reference Counting 타입, 복수개의 소유권 가능하도록 함. 빌림 규칙을 컴파일 타임 대신 런타임에 강제하는 타입인, RefCell\u003cT\u003e를 통해 접근 가능한 Ref\u003cT\u003e와 RefMut\u003cT\u003e ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:4:5","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.1 Box\u003cT\u003e 데이터를 스택이 아닌 힙에 저장하도록 합니다. 스택 대신 힙에 저장한다는 점 외에는, 성능적인 오버헤드는 없습니다. (stack vs heap 자료구조에 상에서 성능 오버헤드를 뜻하는 듯) 아래 3가지 경우에 자주 사용합니다. 컴파일 타임에 크기를 알 수 없는 타입을 갖고 있고, 정확한 사이즈를 알 필요가 있는 맥락 안에서 해당 타입의 값을 이용하고 싶을 때 커다란 데이터를 가지고 있고 소유권을 옮기고 싶지만 그렇게 했을 때 데이터가 복사되지 않을 것이라고 보장하기를 원할 때 어떤 값을 소유하고 이 값의 구체화된 타입을 알고 있기보다는 특정 트레잇을 구현한 타입이라는 점만 신경 쓰고 싶을 때 (trait object 17장) 이번 장에서는 1번 상황을 설명합니다. 2번의 경우는 그저 stack에 여러개 올리기 부담스러울 정도로 큰 데이터 또는 copy가 일어날지 불명확할 떄 heap에 저장시킨다는 뜻입니다. {letbx=Box::new(5);} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:5:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Recursive type 컴파일 타임에서, 러스트는 어떤 타입이 얼마나 많은 공간을 차지하는지를 알 필요가 있습니다. 컴파일 타임에는 크기를 알 수 없는 한 가지 타입이 바로 재귀적 타입 (recursive type)입니다. 하지만 이때 재귀적 타입 정의 안에 Box를 사용하면 가능합니다. without Box, 컴파일 에러 enum List{Cons(i32,List),Nil,}useList::{Cons,Nil};fn main(){letlist=Cons(1,Cons(2,Cons(3,Nil)));} with Box, 성공. enum List{Cons(i32,Box\u003cList\u003e),Nil,}useList::{Cons,Nil};fn main(){letlist=Cons(1,Box::new(Cons(2,Box::new(Cons(3,Box::new(Nil))))));} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:5:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.2 Deref trait Deref 트레잇을 구현한다는 것은, dereference operator(역참조 연산자) 즉 *의 동작을 커스터마이징 하는 것을 허용합니다. 우선 다음은 일반적인 역참조 연산자 입니다. fn main(){letmutx=5;lety=\u0026x;assert_eq!(5,x);assert_eq!(5,*y);// 역참조, deref } ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:6:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Box\u003cT\u003e를 참조자처럼 사용하기 Box는 Deref trait를 구현하고 있기 때문에, 다음과 같이 동작할 수 있습니다. fn main(){letx=5;lety=Box::new(x);assert_eq!(5,x);assert_eq!(5,*y);// 역참조 } ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:6:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"커스텀 Box 타입 deref를 지원하는 커스텀 box 타입 usestd::ops::Deref;struct MyBox\u003cT\u003e(T);impl\u003cT\u003eMyBox\u003cT\u003e{fn new(x: T)-\u003e MyBox\u003cT\u003e{MyBox(x)}}impl\u003cT\u003eDerefforMyBox\u003cT\u003e{type Target=T;fn deref(\u0026self)-\u003e \u0026T{dbg!(\"deref is called\");\u0026self.0// 도대체 self.0이 뭘가르키는 거지.... }}fn main(){letx=5;lety=MyBox::new(x);dbg!(*y);// \"deref is called\" // *y = 5 } 러스트는 *y를 뒤에서 다음과 같이 호출합니다. *(y.deref()); ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:6:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"deref coercion (역참조 강제, 암묵적 역참조) 역참조 강제란(암묵적 역참조) 우리가 특정 타입의 값에 대한 참조자를 함수 혹은 메소드의 인자로 넘기는 중 정의된 파라미터 타입에는 맞지 않을 때 자동적으로 발생합니다. Deref 트레잇을 구현한 타입은 컴파일러가 암묵적 역참조를 자동으로 처리해줍니다. 암묵적 역참조 fn hello(name: \u0026str){println!(\"Hello, {}!\",name);}fn main(){letm=MyBox::new(String::from(\"Rust\"));hello(\u0026m);} 만약 암묵적 역참조가 없다면 fn main(){letm=MyBox::new(String::from(\"Rust\"));hello(\u0026(*m)[..]);} Deref 트레잇이 관련된 타입에 대해 정의될 때, 러스트는 해당 타입을 분석하여 파라미터의 타입에 맞는 참조자를 얻기 위해 필요한 수만큼의 Deref::deref를 사용할 것입니다. Deref::deref가 삽입될 필요가 있는 횟수는 컴파일 타임에 분석되므로, 역참조 강제의 이점을 얻는 데에 관해서 어떠한 런타임 페널티도 없습니다! ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:6:3","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Mutable reference의 암묵적 역참조(deref coercion) 불변 참조자에 대한 *를 오버 라이딩하기 위해 Deref 트레잇을 이용하는 방법과 비슷하게, 러스트는 가변 참조자에 대한 *를 오버 라이딩하기 위한 DerefMut 트레잇을 제공합니다. 러스트 컴파일러는 다음 3가지 경우에 해당 하는 타입을 만나면 역참조 강제를 수행합니다. T: Deref\u003cTarget=U\u003e일때 \u0026T에서 \u0026U로 T: DerefMut\u003cTarget=U\u003e일때 \u0026mut T에서 \u0026mut U로 T: Deref\u003cTarget=U\u003e일때 \u0026mut T에서 \u0026U로 1번은 앞서 보았던 역참조 강제이며, 2번은 mut reference에서도 역참조 강제가 일어난다는 것을 뜻합니다. 마지막 세 번째 경우는 좀 더 교묘합니다: 러스트는 가변 참조자를 불변 참조자로 강제할 수도 있습니다. 하지만 그 역은 불가능합니다: 불변 참조자는 가변 참조자로 결코 강제되지 않을 것입니다. 빌림 규칙 때문에, 만일 여러분이 가변 참조자를 가지고 있다면, 그 가변 참조자는 해당 데이터에 대한 유일한 참조자임에 틀림없습니다 (만일 그렇지 않다면, 그 프로그램은 컴파일되지 않을 것입니다). 가변 참조자를 불변 참조자로 변경하는 것은 결코 빌림 규칙을 깨트리지 않을 것입니다. 불변 참조자를 가변 참조자로 변경하는 것은 해당 데이터에 대한 단 하나의 불변 참조자가 있어야 한다는 요구를 하게 되고, 이는 빌림 규칙이 보장해줄 수 없습니다. 따라서, 러스트는 불변 참조자를 가변 참조자로 변경하는 것이 가능하다는 가정을 할 수 없습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:6:4","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.3 Drop trait struct CustomSmartPointer{heap_data: String,}implDropforCustomSmartPointer{fn drop(\u0026mutself){println!(\"Drop CustomSmartPointer `{}`\",self.heap_data);}}fn main(){leta=CustomSmartPointer{heap_data: String::from(\"leoo\"),};letb=CustomSmartPointer{heap_data: String::from(\"wants to learn more loves.\"),};println!(\"CustomSmartPointers are created.\");}// CustomSmartPointers are created. // Drop CustomSmartPointer `wants to learn more loves.` // Drop CustomSmartPointer `leoo` Drop 트레잇은 prelude에 포함되어 있으므로, 이를 가져오지 않아도 됩니다. drop 함수의 본체는 여러분이 만든 타입의 인스턴스가 스코프 밖으로 벗어났을 때 실행시키고자 하는 어떠한 로직이라도 위치시킬 수 있는 곳입니다. drop은 stack에 스택에 따라 처리되기 때문에, 최근에 선언된 스마트포인터일 수록 더 먼저 처리됩니다. 일반적이지는 않지만 아주 가끔, 여러분은 값을 일찍 정리하기를 원할 지도 모릅니다. 한 가지 예는 락을 관리하는 스마트 포인터를 이용할 때입니다. 단 러스트는 default로 .drop() 메서드(소멸자, destructor)가 호출되는 것을 허용하지 않습니다. 만약 명시적으로 drop을 일찍 시켜주고 싶다면 std::mem::drop 함수를 이용할 수 있습니다. std::mem::drop 함수는 Drop 트레잇 내에 있는 drop 메소드와 다릅니다. 우리가 일찍 버리도록 강제하길 원하는 값을 인자로 넘김으로써 이를 호출할 수 있습니다. 이 함수는 프렐루드에 포함되어 있습니다. fn main(){letc=CustomSmartPointer{data: String::from(\"some data\")};println!(\"CustomSmartPointer created.\");// method가 아닌, 함수로 처리 drop(c);println!(\"CustomSmartPointer dropped before the end of main.\");}// CustomSmartPointer created. // Dropping CustomSmartPointer with data `some data`! // CustomSmartPointer dropped before the end of main. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:7:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.4 Rc\u003cT\u003e와 레퍼런스 카운팅 스마트 포인터 대부분의 경우에서, 소유권은 명확합니다: 여러분은 어떤 변수가 주어진 값을 소유하는지 정확히 압니다. 그러나, 하나의 값이 여러 개의 소유자를 가질 수도 있는 경우가 있습니다. 예를 들면, 그래프 데이터 구조에서, 여러 에지가 동일한 노드를 가리킬 수도 있고, 그 노드는 개념적으로 해당 노드를 가리키는 모든 에지들에 의해 소유됩니다. 노드는 어떠한 에지도 이를 가리키지 않을 때까지는 메모리 정리가 되어서는 안됩니다. 복수 소유권을 가능하게 하기 위해서, 러스트는 Rc\u003cT\u003e라 불리우는 타입을 가지고 있습니다. 이 이름은 참조 카운팅 (reference counting) 의 약자입니다. 이는 어떤 값이 계속 사용되는지 혹은 그렇지 않은지를 알기 위해 해당 값에 대한 참조자의 갯수를 계속 추적하는 것입니다. before: RC\u003cT\u003e없이 소유권을 나눠가질 때: 컴파일 에러 enum List{Cons(i32,Box\u003cList\u003e),Nil,}useList::{Cons,Nil};fn main(){leta=Cons(5,Box::new(Cons(10,Box::new(Nil))));letb=Cons(3,Box::new(a));letc=Cons(4,Box::new(a));} error[E0382]:useofmovedvalue:`a`--\u003esrc/main.rs:13:30|12|letb=Cons(3,Box::new(a));|-valuemovedhere13|letc=Cons(4,Box::new(a));|^valueusedhereaftermove|=note:moveoccursbecause`a`hastype`List`,whichdoesnotimplementthe`Copy`trait Cons variant는 이것이 가지고 있는 데이터를 소유하므로, 우리가 b리스트를 만들때, a는 b 안으로 이동되고 b는 a를 소유합니다. 그 뒤, c를 생성할 때 a를 다시 이용하는 시도를 할 경우, 이는 a가 이동되었으므로 허용되지 않습니다. 우리는 Cons가 대신 참조자를 갖도록 정의를 변경할 수도 있지만, 그러면 라이프타임 파라미터를 명시해야 할 것입니다. 라이프타임 파라미터를 명시함으로써, 리스트 내의 모든 요소들이 최소한 전체 리스트만큼 오래 살아있도록 명시될 것입니다. 빌림 검사기는 예를 들면 let a = Cons(10, \u0026Nil);을 컴파일되도록 하지 않게 할텐데, 이는 일시적인 Nil 값은 a가 그에 대한 참조자를 가질 수도 있는 시점 이전에 버려질 것이기 때문입니다. after: RC\u003cT\u003e를 사용. enum List{Cons(i32,Rc\u003cList\u003e),Nil,}useList::{Cons,Nil};usestd::rc::Rc;fn main(){leta=Rc::new(Cons(5,Rc::new(Cons(10,Rc::new(Nil)))));letb=Cons(3,Rc::clone(\u0026a));letc=Cons(4,Rc::clone(\u0026a));} Rc는 프렐루드에 포함되어 있지 않으므로 우리는 이를 가져오기 위해 use std::rc::Rc가 필요합니다. Rc::clone(\u0026a) 보다는 a.clone()을 호출할 수도 있지만, 위의 경우 러스트의 관례는 Rc::clone를 이용하는 것입니다. Rc::clone의 구현체는 대부분의 타입들의 clone 구현체들이 하는 것처럼 모든 데이터의 깊은 복사 (deep copy) 를 만들지 않습니다. Rc::clone의 호출은 오직 참조 카운트만 증가 시키는데, 이는 큰 시간이 들지 않습니다. 이를 통해서 코드 내에서 성능 문제가 있어 문제가 될 부분들을 찾고 있다면, 깊은 복사 클론만 고려할 필요가 있고 Rc::clone 호출은 무시할 수 있습니다. 레퍼런스 카운트 출력하기 fn main(){leta=Rc::new(Cons(5,Rc::new(Cons(10,Rc::new(Nil)))));println!(\"count after creating a = {}\",Rc::strong_count(\u0026a));letb=Cons(3,Rc::clone(\u0026a));println!(\"count after creating b = {}\",Rc::strong_count(\u0026a));{letc=Cons(4,Rc::clone(\u0026a));println!(\"count after creating c = {}\",Rc::strong_count(\u0026a));}println!(\"count after c goes out of scope = {}\",Rc::strong_count(\u0026a));} count after creating a = 1 count after creating b = 2 count after creating c = 3 count after c goes out of scope = 2 ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:8:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.5 RefCell\u003cT\u003e와 내부 가변성 패턴 interior mutability(내부 가변성)이란 어떤 데이터와 관련된 immutable reference가 있더라도, 여러분이 데이터를 변형할 수 있게 해주는 러스트의 디자인 패턴입니다. 보통 borrow rule에 의해서 이는 허용되지 않지만, unsafe코드를 사용하여 이를 우회할 수 있습니다. 만약 우리가 런타임에 borrow rule을 따릇 것이라는 것을 보장할 수 있다면, 컴파일러가 이를 보장하지 못하더라도 내부 가변성 패턴을 이용하는 타입을 사용할 수 있습니다. unsafe 코드는 안전한 API로 감싸져 있고, 외부에서는 여전히 불변하게 동작합니다. RefCell\u003cT\u003e는 대표적으로 내부 가변성(interior mutability)를 따르는 타입입니다. Box\u003cT\u003e, Rc\u003cT\u003e, 혹은 RefCell\u003cT\u003e을 선택하는 이유의 요점은 다음과 같습니다: Rc\u003cT\u003e는 동일한 데이터에 대해 복수개의 소유자를 가능하게 합니다; Box\u003cT\u003e와 RefCell\u003cT\u003e은 단일 소유자만 갖습니다. Box\u003cT\u003e는 컴파일 타임에 검사된 불변 혹은 가변 빌림을 허용합니다; Rc\u003cT\u003e는 오직 컴파일 타임에 검사된 불변 빌림만 허용합니다; RefCell\u003cT\u003e는 런타임에 검사된 불변 혹은 가변 빌림을 허용합니다. RefCell\u003cT\u003e이 런타임에 검사된 가변 빌림을 허용하기 때문에, RefCell\u003cT\u003e이 불변일 때라도 RefCell\u003cT\u003e 내부의 값을 변경할 수 있습니다. RefCell\u003cT\u003e 예시 pubtraitMessenger{fn send(\u0026self,msg: \u0026str);}pubstruct LimitTracker\u003c'a,T: 'a +Messenger\u003e{messenger: \u0026'a T,value: usize,max: usize,}impl\u003c'a,T\u003eLimitTracker\u003c'a,T\u003ewhereT: Messenger{pubfn new(messenger: \u0026T,max: usize)-\u003e LimitTracker\u003cT\u003e{LimitTracker{messenger,value: 0,max,}}pubfn set_value(\u0026mutself,value: usize){self.value=value;letpercentage_of_max=self.valueasf64/self.maxasf64;ifpercentage_of_max\u003e=0.75\u0026\u0026percentage_of_max\u003c0.9{self.messenger.send(\"Warning: You've used up over 75% of your quota!\");}elseifpercentage_of_max\u003e=0.9\u0026\u0026percentage_of_max\u003c1.0{self.messenger.send(\"Urgent warning: You've used up over 90% of your quota!\");}elseifpercentage_of_max\u003e=1.0{self.messenger.send(\"Error: You are over your quota!\");}}}#[cfg(test)]mod tests{usesuper::*;usestd::cell::RefCell;struct MockMessenger{sent_messages: RefCell\u003cVec\u003cString\u003e\u003e,// 여기에서 사용되었다. }implMockMessenger{fn new()-\u003e MockMessenger{MockMessenger{sent_messages: RefCell::new(vec![])}}}implMessengerforMockMessenger{fn send(\u0026self,message: \u0026str){self.sent_messages.borrow_mut().push(String::from(message));}}#[test]fn it_sends_an_over_75_percent_warning_message(){// --snip-- assert_eq!(mock_messenger.sent_messages.borrow().len(),1);}} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:9:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Rc와 RefCell를 조합하여 가변 데이터의 복수 소유자 만들기 RefCell를 사용하는 일반적인 방법은 Rc와 함께 조합하는 것입니다. Rc이 어떤 데이터에 대해 복수의 소유자를 허용하지만, 그 데이터에 대한 불변 접근만 제공하는 것을 상기하세요. 만일 우리가 RefCell을 들고 있는 Rc를 갖는다면, 우리가 변경 가능하면서 복수의 소유자를 갖는 값을 가질 수 있습니다. 우리가 어떤 리스트의 소유권을 공유하는 여러 개의 리스트를 가질 수 있도록 하기 위해 Rc를 사용했던 cons 리스트 예제를 상기해보면, Rc\u003cT\u003e가 오직 불변의 값만을 가질 수 있기 때문에, 우리가 이들을 일단 만들면 리스트 안의 값들을 변경하는 것은 불가능했습니다. 이 리스트 안의 값을 변경하는 능력을 얻기 위해서 RefCell\u003cT\u003e을 추가해 봅시다. #[derive(Debug)]enum List{Cons(Rc\u003cRefCell\u003ci32\u003e\u003e,Rc\u003cList\u003e),Nil,}useList::{Cons,Nil};usestd::rc::Rc;usestd::cell::RefCell;fn main(){letvalue=Rc::new(RefCell::new(5));leta=Rc::new(Cons(Rc::clone(\u0026value),Rc::new(Nil)));letb=Cons(Rc::new(RefCell::new(6)),Rc::clone(\u0026a));letc=Cons(Rc::new(RefCell::new(10)),Rc::clone(\u0026a));*value.borrow_mut()+=10;println!(\"a after = {:?}\",a);println!(\"b after = {:?}\",b);println!(\"c after = {:?}\",c);} Cons 정의 내에 RefCell를 사용함으로써 우리가 모든 리스트 내에 저장된 값을 변경할 수 있음을 보여줍니다. a after = Cons(RefCell { value: 15 }, Nil) b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil)) c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil)) 이 기술은 매우 깔끔합니다! RefCell을 이용함으로써, 우리는 표면상으로는 불변인 List를 갖고 있습니다. 하지만 우리는 내부 가변성 접근을 제공하여 우리가 원할때 데이터를 변경시킬 수 있는 RefCell 내의 메소드를 사용할 수 있습니다. 빌림 규칙의 런타임 검사는 데이터 레이스로부터 우리를 지켜주고, 우리 데이터 구조의 이러한 유연성을 위해서 약간의 속도를 트레이드 오프 하는 것이 때때로 가치있습니다. 표준 라이브러리는 내부 가변성을 제공하는 다른 타입을 가지고 있는데, 이를 테면 Cell는 내부 값의 참조자를 주는 대신 값이 복사되어 Cell 밖으로 나오는 점만 제외하면 비슷합니다. 또한 Mutex가 있는데, 이는 스레드들을 건너가며 사용해도 안전한 내부 가변성을 제공합니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:9:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"15.5 reference cycle (순환참조) 러스트의 memory safety(memory leak 안정보장)은 뜻하지 않게 해제 되지 않는 메모리 생성을 힘들게 하지만, Rc\u003cT\u003e, RefCell\u003cT\u003e 처럼 메모리 릭을 허용하는 것이 있다는 것을 알 수 있습니다. 즉 아이템들 끼리 서로를 순환 참조하는 참조자를 만드는 것이 가능합니다. 이로 인해 메모리릭이 발생되는데, 서로 참조하는 cycle에서 reference count는 결코 0이 되지 않을 것이고, 그렇게 되면 해당 값들은 버려지지 않게 됩니다. 순환 참조가 발생하는 코드 usestd::cell::RefCell;usestd::rc::Rc;useList::{Cons,Nil};#[derive(Debug)]enum List{Cons(i32,RefCell\u003cRc\u003cList\u003e\u003e),Nil,}implList{fn tail(\u0026self)-\u003e Option\u003c\u0026RefCell\u003cRc\u003cList\u003e\u003e\u003e{match*self{Cons(_,refitem)=\u003eSome(item),Nil=\u003eNone,}}}fn custom_print(name: \u0026str,l: \u0026Rc\u003cList\u003e){println!(\"### About {name} ###\");println!(\"rc count = {}\",Rc::strong_count(\u0026l));println!(\"next block = {:?}\",l.tail());}fn main(){leta=Rc::new(Cons(5,RefCell::new(Rc::new(Nil))));custom_print(\"a\",\u0026a);letb=Rc::new(Cons(10,RefCell::new(Rc::clone(\u0026a))));custom_print(\"a\",\u0026a);custom_print(\"b\",\u0026b);// reference cycle point (memory leak); // a -\u003e b; ifletSome(link)=a.tail(){*link.borrow_mut()=Rc::clone(\u0026b);}// thread 'main' has overflowed its stack // fatal runtime error: stack overflow custom_print(\"a\",\u0026a);custom_print(\"b\",\u0026b);} [5, Nil]를 가진 리스트 a를 만든 뒤, [10, a]를 가진 리스트 b를 생성하였습니다. 이후 borrow_mut()를 사용해 a의 tail인 Nil이 b로 변경되도록 하였습니다. a: [5, b] b: [10, a] 순환참조에 의한 메모리릭 문제는 러스트 컴파일러에 기대어서는 안되며 테스트, 코드리뷰 등으로 파악해야 하는 논리적인 에러입니다. 순환참조를 피하는 다른 해결책으로는 각 인스턴스들의 그래프에 따라서 소유권이 필요한 노드와 그렇지 않은 노드를 파악해서 끊어주면 됩니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:10:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"순환 참조 방지하기 Rc\u003cT\u003e를 Weak\u003cT\u003e로 변경하기 Rc::downgrade(): 참조자(reference)를 weak reference(Weak\u003cT\u003e로 변경시킵니다. Weak\u003cT\u003e 타입의 스마트 포인터는 clone()이 호출될 시, Rc인스턴스의 strong_count를 +=1 시키는 것이 아니라, weak_count라는 필드를 1 증가시킵니다. weak_count와 strong_count의 차이점 즉, Weak과 Rc의 차이점은 Rc\u003cT\u003e가 제거되기(free) 위해서는 strong_count == 0이어야 하지만 Weak\u003cT\u003e는 제거되기 위해서 weak_count가 0일 필요가 없습니다. 강한 참조는 여러분이 Rc\u003cT\u003e 인스턴스의 소유권을 공유할 수 있는 방법입니다. 약한 참조는 소유권 관계를 표현하지 않습니다. (Weak\u003cT\u003e) 그렇기 때문에 Weak\u003cT\u003e가 참조하고 있는 값은 이미 버려져 있을지도 모릅니다. Weak\u003cT\u003e가 가리키고 있는 값을 가지고 어떤 일을 하기 위해서는, 반드시 그 전에 참조하고 있는 값의 존재여부를 확인해야 합니다. 이를 위해서 Weak\u003cT\u003e의 .upgrade() 메소드를 호출합니다. 이 메소드는 Option\u003cRc\u003cT\u003e\u003e를 반환할 것이고, Some이 return된다면 값이 있다는 것이며, None의 경우네는 값이 free된 경우입니다. 아래는 Weak를 활용해 트리 데이터: 자식 노드를 가진 Node를 만들어 보겠습니다. usestd::cell::RefCell;usestd::rc::Rc;#[derive(Debug)]struct Node{value: i32,children: RefCell\u003cVec\u003cRc\u003cNode\u003e\u003e\u003e,}fn main(){letleaf=Rc::new(Node{value: 3,children: RefCell::new(vec![]),});letbranch=Rc::new(Node{value: 5,children: RefCell::new(vec![Rc::clone(\u0026leaf)]),});} dbg!(branch); 결과값 [src/main.rs:21] branch = Node { value: 5, children: RefCell { value: [ Node { value: 3, children: RefCell { value: [], }, }, ], }, } 이를 통해 branch는 leaf에 접근가능하게 되었으며, leaf는 2개의 strong reference count를 가지게 되었습니다. 다음으로 leaf가 branch에 접근가능하도록 코드를 수정 해보겠습니다. usestd::cell::RefCell;usestd::rc::{Rc,Weak};#[derive(Debug)]struct Node{value: i32,parent: RefCell\u003cWeak\u003cNode\u003e\u003e,children: RefCell\u003cVec\u003cRc\u003cNode\u003e\u003e\u003e,}fn generate_empty_node()-\u003e RefCell\u003cWeak\u003cNode\u003e\u003e{RefCell::new(Weak::new())}fn main(){letleaf=Rc::new(Node{value: 3,parent: generate_empty_node(),children: RefCell::new(vec![]),});// leaf parent = None println!(\"leaf parent = {:?}\",leaf.parent.borrow().upgrade());letbranch=Rc::new(Node{value: 5,parent: generate_empty_node(),children: RefCell::new(vec![Rc::clone(\u0026leaf)]),});// link to parent *leaf.parent.borrow_mut()=Rc::downgrade(\u0026branch);// leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) }, \u003c- branch 자신 // children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) }, \u003c- leaf // children: RefCell { value: [] } }] } }) \u003c- leaf의 children println!(\"leaf parent = {:?}\",leaf.parent.borrow().upgrade());} leaf 노드가 branch를 parent로 가리키도록 하였습니다. 다음으로 아래 custom print함수를 사용해, weak count와 strong count 갯수를 확인해보겠습니다. fn print_node(node: \u0026Rc\u003cNode\u003e){println!(\"value = {} ,strong = {}, weak = {}\",node.value,Rc::strong_count(node),Rc::weak_count(node),);} fn main(){letleaf=Rc::new(Node{value: 3,parent: generate_empty_node(),children: RefCell::new(vec![]),});print_node(\u0026leaf);// value = 3 ,strong = 1, weak = 0 {letbranch=Rc::new(Node{value: 5,parent: generate_empty_node(),children: RefCell::new(vec![Rc::clone(\u0026leaf)]),});// link to parent *leaf.parent.borrow_mut()=Rc::downgrade(\u0026branch);print_node(\u0026branch);// value = 5 ,strong = 1, weak = 1 print_node(\u0026leaf);// value = 3 ,strong = 2, weak = 0 }// leaf parent = None println!(\"leaf parent = {:?}\",leaf.parent.borrow().upgrade());print_node(\u0026leaf);// value = 3 ,strong = 1, weak = 0 } leaf 노드는 내부 scope에 정의된 branch를 parent로 하였고, 이에대한 참조를 weak reference로 해두었기 때문에 branch는 scope를 벗어날 때 free됩니다. (strong count가 0). 이때 branch는 weak count = 1인 leaf의 weak reference를 가지고 있지만 이는 free에는 어떤 영향도 주지 않습니다. 이를 통해 어떠한 메모리 릭도 발생되지 않습니다. leaf parent = None을 보시면, 스코프 끝 이후에 leaf의 부모에 접근을 시도하였기 때문에 None이 반환됩니다. 참조 카운트들과 버리는 값들을 관리하는 모든 로직은 Rc와 Weak, 그리고 이들의 Drop 트레잇에 대한 구현부에 만들어져 있습니다. 자식으로부터 부모로의 관계가 Node의 정의 내에서 Weak 참조자로 되어야 함을 특정함으로서, 여러분은 순환 참조와 메모리 릭을 만들지 않고도 자식 노드를 가리키는 부모 노드 혹은 그 반대의 것을 가지게 될 수 있습니다. 16. 동시성 들어가기 앞서 이번장에서는 동시성과 병렬성을 구분하지 않고 모두 동시성이라고 칭합니다. 또한 런타임의 범위를 프로그래밍 언어의 모든 바이너리 내에 포함되는 코들르 의미합니다. 대표적으로 스레드는 코드 snippet에 대해 실행 순서를 보장하지 않기 때문에, 발생하는 문제점들은 다음과 같습니다. (3) race condition deadlock 특정한 상황에서만 발생되어 재현하기와 안정적으로 수정하기가 힘든 버그들 1:1 스레드라는 것은 프로그래밍 언어에서 운영체제 API가 제공하는 스레드와 1:1로 상응하는 스레드를 의미합니다. 반면 green thread의 경우에는 운영체제 스레드와 M:N관계를 가집니다. 그린 스레드 M:N 구조는 자체 스레드들을 관리하기 위해 더 큰 언어 런타임이 필요하게 됩니다. 이런 트레이드 오프 때문에 러스트의 std 라이브러리는 오직 1:1 스레드 구현만 제공합니다. 이런 트레이드 오프(오버헤드)를 감수하더라도 context switching에 더 저렴한 cost를 원한다면 ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:10:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"thread::spawn() 새로운 스레드 생성하기 {thread::spawn(||{foriin1..10{println!(\"hi number {} from the spawned thread!\",i);thread::sleep(Duration::from_millis(1));}});} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:11:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":".join().unwrap() join 핸들을 사용하여 모든 스레드 끝날때까지 기다리기 개의 경우 메인 스레드가 종료되는 이유로 생성된 스레드가 조기에 멈출 뿐만 아니라, 생성된 스레드가 모든 코드를 실행할 것임을 보장해 줄수도 없습니다. 그 이유는 스레드들이 실행되는 순서에 대한 보장이 없기 때문입니다. 이를 해결하기 위해서는 .join()을 사용하면 됩니다. thread::spawn()은 JoinHandle을 리턴하며, 이를 변수에 담아 .join() 메서드를 호출시키면 스레드가 끝날때까지 기다릴 수 있습니다. usestd::thread;usestd::time::Duration;fn main(){lethandle=thread::spawn(||{foriin1..10{println!(\"hi number {} from the spawned thread!\",i);thread::sleep(Duration::from_millis(1));}});foriin1..5{println!(\"hi number {} from the main thread!\",i);thread::sleep(Duration::from_millis(1));}// join spwaned thread. handle.join().unwrap();} hi number 1 from the main thread! hi number 2 from the main thread! hi number 1 from the spawned thread! hi number 3 from the main thread! hi number 2 from the spawned thread! hi number 4 from the main thread! hi number 3 from the spawned thread! hi number 4 from the spawned thread! hi number 5 from the spawned thread! hi number 6 from the spawned thread! hi number 7 from the spawned thread! hi number 8 from the spawned thread! hi number 9 from the spawned thread! ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:12:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"move 클로저 스레드 간 데이터 소유권 이동 move 클로저는 thread::spawn와 함께 자주 사용되는데 그 이유는 이것이 여러분으로 하여금 어떤 스레드의 데이터를 다른 스레드 내에서 사용하도록 해주기 때문입니다. 클로저의 파라미터 목록 앞에 move 키워드를 이용하여 클로저가 그 환경에서 사용하는 값의 소유권을 강제로 갖게 할 수 있습니다. 이 기술은 값의 소유권을 한 스레드에서 다른 스레드로 이전하기 위해 새로운 스레드를 생성할 때 특히 유용합니다. move가 필요한 코드를 먼저 보여드리겠습니다. usestd::thread;fn main(){letv=vec![1,2,3];lethandle=thread::spawn(||{println!(\"Here's a vector: {:?}\",v);// 만약 v에 대해서 레퍼런스를 주었다면, v가 언제까지 살아있을지 확신을 할 수 없습니다. });drop(v);// v를 main thread에서 제거 handle.join().unwrap();} 이러한 이유로, 러스트 컴파일러는 다음과 같은 에러 메시지를 제공합니다. help:toforcetheclosuretotakeownershipof`v`(andanyotherreferencedvariables),usethe`move`keyword|6|lethandle=thread::spawn(move||{|^^^^^^^ 즉 클로저 안에서 v에 대한 소유권을 main으로부터 받아오라고 말해줍니다. usestd::thread;fn main(){letv=vec![1,2,3];lethandle=thread::spawn(move||{println!(\"Here's a vector: {:?}\",v);});// drop(v); // error[E0382]: use of moved value: `v` handle.join().unwrap();} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:13:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Message Passing 스레드에 대한 Go의 슬로건 중 하나는 다음과 같습니다. “Do not communicate by sharing memory; instead, share memory by communicating.” 이 처럼 안전한 동시성을 보장하는 인기있는 방법은 message passing 입니다. 러스트 또한 go처럼 channel을 활용합니다. 프로그래밍에서 채널은 둘로 나뉘어져 있습니다. transmitter (송신자) abbr. tx receiver (수신자) abbr. rx transmitter 측은 여러분이 강에 고무 오리를 띄우는 상류 위치이고, receiver 측은 하류에 고무 오리가 도달하는 곳입니다. 여러분 코드 중 한 곳에서 여러분이 보내고자 하는 데이터와 함께 송신자의 메소드를 호출하면, 다른 곳에서는 도달한 메세지에 대한 수신 종료를 검사합니다. 송신자 혹은 송신자가 드롭되면 채널이 닫혔다 (closed) 라고 말합니다. usestd::sync::mpsc;fn main(){} 채널을 사용하기 위해서는 std 라이브러리인 mpsc를 활용합니다. mpsc는 multiple producer, single consumer의 약자입니다. 다시 말해 표준 라이브러리 mpsc가 채널을 구현한 방법은 한 채널이 값을 생성하는 복수개의 송신 단말을 가질 수 있지만 값을 소비하는 단 하나의 수신 단말을 가질 수 있음을 의미합니다. mpsc::channel()는 튜플을 반환합니다. usestd::sync::mpsc;usestd::thread;fn main(){let(tx,rx)=mpsc::channel();// 튜플 반환 thread::spawn(move||{letv=String::from(\"Hi\");tx.send(v).unwrap();// Result\u003cT, E\u003e });letreceived=rx.recv().unwrap();println!(\"Got: {}\",received);} rx는 2가지 유용한 메소드를 활용해 메시지를 받을 수 있습니다. .recv() .try_recv() recv()는 block한 상태로 메시지가 보내질 때까지 기다립니다. 그리고 그 전달된 값은 Result\u003cT,E\u003e형태로 전달됩니다. try_recv()는 블록하지 않는 대신, 해당 시점에 Result\u003cT,E\u003e형태로 값을 전달해줍니다. 만약 메시지가 전달되었다면 Ok, 없다면 Err입니다. 만약 메시지를 기다리면서 다른 작업을 해야한다면 유용하게 사용할 수 있습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:14:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"채널간 메시지 전달과 소유권 처리 다음으로 tx에서 rx로 값을 내려보낸 뒤에, 그 값을 사용한다면 소유권 체크가 어떻게 되는지 확인해보겠습니다. usestd::sync::mpsc;usestd::thread;fn main(){let(tx,rx)=mpsc::channel();thread::spawn(move||{letv=String::from(\"Hi\");tx.send(v).unwrap();println!(\"Here!!!! is Problem {val}\");});letreceived=rx.recv().unwrap();println!(\"Got: {}\",received);} error[E0382]:useofmovedvalue:`val`--\u003esrc/main.rs:10:31|9|tx.send(val).unwrap();|--- value moved here 10|println!(\"val is {}\",val);|^^^valueusedhereaftermove|=note:moveoccursbecause`val`hastype`std::string::String`,whichdoesnotimplementthe`Copy`trait 당연히 소유권체크에서 컴파일러가 똑똑하게 잡아줍니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:15:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"multiple producer 마지막으로 mpsc의 multiple producer를 사용하는 코들르 작성하겠습니다. usestd::sync::mpsc;usestd::thread;usestd::time::Duration;fn main(){let(tx,rx)=mpsc::channel();lettx1=tx.clone();thread::spawn(move||{letvals=vec![String::from(\"tx1: hi\"),String::from(\"tx1: from\"),String::from(\"tx1: the\"),String::from(\"tx1: thread\"),];forvinvals{tx1.send(v).unwrap();thread::sleep(Duration::from_secs(1));}});thread::spawn(move||{letvals=vec![String::from(\"tx: more\"),String::from(\"tx: messages\"),String::from(\"tx: for\"),String::from(\"tx: you\"),];forvinvals{tx.send(v).unwrap();thread::sleep(Duration::from_secs(1));}});// receiver forrinrx{println!(\"Got: {}\",r);}} Got: tx: more Got: tx1: hi Got: tx: messages Got: tx1: from Got: tx: for Got: tx1: the Got: tx: you Got: tx1: thread 결과값 순서는 다르게 나올 수 있습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:16:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"shared memory 어떻게 보면 프로그래밍 언어에서 채널들은 단일 소유권과 비슷한데, 이는 채널로 값을 transmit하면, 그 값은 더 이상 이전에 소유권을 가진 영역에서 사용할 수 없기 때문입니다. 반면에 shared memory는 복수 소유권과 유사합니다. 여러개의 스레드들이 동시에 동일한 메모리 위치를 접근할 수 있기 때문입니다. 여러 스레드들이 동시에 접근할 수 있기 때문에 접근에 대해서 제어할 수 있는 장치가 필요합니다. 대표적으로 std::sync::Mutex std::sync::Arc std::sync::atomic 기반으로 작성됨 뮤텍스와 Atomically Reference Counted가 존재합니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Mutex mutual exclusion, 상호 배제 상호 배제, 뮤텍스란 내부적으로 주어진 시간에 오직 하나의 스레드만 데이터 접근을 허용합니다. 이를 위해 lock을 사용하며, 스레드들은 데이터에 접근하기 위해 lock을 요청합니다. 뮤텍스 작동을 단순화 시키면 2가지를 기억하면 됩니다. 데이터를 사용하기 전에 반드시 락을 얻는 시도를 해야한다. 뮤텍스가 보호하는 데이터의 사용이 끝났다면, 다른 스레드들이 락을 얻을 수 있도록 unlock을 해야한다. 러스트의 경우에는 타입과 ownership개념 덕분에 복잡한 mutex 시스템을 단순화 시킬 수 있습니다. 즉 러스트에서는 잘못 락을 얻거나, unlock 하는 경우를 컴파일러에서 잡아줄 수 있습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Mutex api 다음은 mutex.lock()가 성공 될 때, 리턴되는 MutexGuard\u003cT\u003e에 대한 주석 내용 중 일부 입니다. The data protected by the mutex can be accessed through this guard via its [Deref] and [DerefMut] implementations. Deref를 통해서 MutexGuard는 데이터를 접근해야하며, RAII 즉 Drop 트레잇을 가지고 있기 때문에, scope 밖으로 벗어날 경우 자동으로 drop 처리됩니다. 이를 통해 개발자가 실수록 언락하는 것을 잊어버릴 경우를 처리해줍니다. usestd::sync::Mutex;fn main(){letm=Mutex::new(5);// i32 데이터를 보호하는 mutex {letmutnum=m.lock().unwrap();println!(\"{}\",num);// 5 *num=6;println!(\"{}\",num);// 6 }} ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"여러 스레드들 사이에서 Mutex 공유하기 이를 확인해보기 위해, 10개의 스레드를 실행시키면서, mutex로 보호받는 counter:i32 값을 +1 진행 시켜보겠습니다. usestd::sync::Mutex;usestd::thread;fn main(){letcounter=Mutex::new(0);letmuthandlers=vec![];for_in0..10{lethandler=thread::spawn(move||{// 문제 발생 포인트 letmutn=counter.lock().unwrap();*n+=1;});handlers.push(handler);}forhandlerinhandlers{handler.join().unwrap();}println!(\"Result: {}\",*counter.lock().unwrap());} error[E0382]:useofmovedvalue:`counter`--\u003esrc/main.rs:9:37|5|letcounter=Mutex::new(0);|------- move occurs because `counter` has type `Mutex\u003ci32\u003e`, which does not implement the `Copy` trait ...9|lethandler=thread::spawn(move||{|^^^^^^^valuemovedintoclosurehere,inpreviousiterationofloop10|letmutn=counter.lock().unwrap();|------- use occurs due to use in closure 10번째 줄에서, move된 counter.lock()을 클로저 안에서 호출했기 때문이라고 컴파일러는 말하고 있습니다. 좀 더 내부적으로는 현재 counter의 소유권이 공유되도록 설정 되어있지 않기 때문에, 여러 스레드들에서 공유를 할 수가 없습니다. 이는 다음과 같이 하나의 main thread가 counter의 소유권을 클로저(스레드)에 넘겨주고 마지막에 join 이후에 println!()을 하더라도 동일하게 발생할 문제입니다. usestd::sync::Mutex;usestd::thread;fn main(){letcounter=Mutex::new(0);letmuthandlers=vec![];lethandler=thread::spawn(move||{letmutn=counter.lock().unwrap();*n+=1;});handlers.push(handler);forhandlerinhandlers{handler.join().unwrap();}println!(\"Result: {}\",*counter.lock().unwrap());// error[E0382]: borrow of moved value: `counter` } 이를 해결하기 위해서는 이전에 확인했던 레퍼런스 카운터 기반 스마트포인터 Rc\u003cT\u003e를 활용하면 됩니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:3","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Rc: Multiple Ownership with Multiple Threads usestd::rc::Rc;usestd::sync::Mutex;usestd::thread;fn main(){letcounter=Rc::new(Mutex::new(0));// 이 부분 변경됨 letmuthandles=vec![];for_in0..10{letcounter=Rc::clone(\u0026counter);// 이 부분 변경됨. lethandle=thread::spawn(move||{letmutnum=counter.lock().unwrap();*num+=1;});handles.push(handle);}forhandleinhandles{handle.join().unwrap();}println!(\"Result: {}\",*counter.lock().unwrap());} error[E0277]:`Rc\u003cMutex\u003ci32\u003e\u003e`cannotbesentbetweenthreadssafely--\u003esrc/main.rs:11:36|11|lethandle=thread::spawn(move||{|------------- ^------ ||||______________________|_____________withinthis`[closure@src/main.rs:11:36:11:43]`|||||requiredbyaboundintroducedbythiscall12||letmutnum=counter.lock().unwrap();13||14||*num+=1;15||});||_________^`Rc\u003cMutex\u003ci32\u003e\u003e`cannotbesentbetweenthreadssafely|=help:within`[closure@src/main.rs:11:36:11:43]`,thetrait`Send`isnotimplementedfor`Rc\u003cMutex\u003ci32\u003e\u003e`note:requiredbecauseit's used within this closure --\u003e src/main.rs:11:36 | 11 | let handle = thread::spawn(move || { | ^^^^^^^ note: required by a bound in `spawn` Rc\u003cMutex\u003ci32\u003e\u003e cannot be sent between threads safely. 이전에 살펴보았듯 Rc는 스레드 safe하지 않습니다. 즉 Rc의 레퍼런스 카운트는 ::clone() 호출 할 때 만약 여러 thread들에 분산되어있으면, 레퍼런스 카운트에 대해서 thread race condition이 발생할 수 있습니다. 이 때문에 잘못된 레퍼런스 카운트를 야기할 수 있고, 이는 zombie를 살아있게 만들어 memory leak이 발생하게 만듭니다. 이를 해결하기 위해서 러스트는 Atomic을 지원합니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:4","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Atomic Reference Counting with Arc\u003cT\u003e 기본적으로 thread safe기능은 성능저하를 trade off로 가져옵니다. 그렇기 때문에 러스트에서는 thread safe가 디폴트가 아니며, 동시성이 필요한 부분에서 atmoic을 활용해 primitive type 변수들이 thread safe하도록 보장하도록 만들어주어야 합니다. Arc\u003cT\u003e는 Rc\u003cT\u003e와 같은 API를 가지고 있기 때문에 앞서 예시에서 Rc::를 Arc::로 변경만 해주면 됩니다. usestd::sync::{Arc,Mutex};usestd::thread;fn main(){letcounter=Arc::new(Mutex::new(0));// 이 부분 변경됨 letmuthandles=vec![];for_in0..10{letcounter=Arc::clone(\u0026counter);// 이 부분 변경됨. lethandle=thread::spawn(move||{letmutnum=counter.lock().unwrap();*num+=1;});handles.push(handle);}forhandleinhandles{handle.join().unwrap();}println!(\"Result: {}\",*counter.lock().unwrap());} Result: 10 ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:5","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"RefCell\u003cT\u003e/Rc\u003cT\u003e vs Mutex\u003cT\u003e/Arc\u003cT\u003e 두 그룹간의 유사성 사실 위의 예시 코드들을 보면 counter가 mut하지 않음에도, 변경이되는 RefCell와 같은 내부 가변성을 제공하는 것을 알 수 있습니다. Mutex\u003cT\u003e는 RefCell\u003cT\u003e와 마찬가지로 논리적 에러를 막아주지 못합니다. 즉 RefCell가 순환참조자 같은 memory leak을 야기할 수 있듯이, Mutex는 Deadlock위험이 있습니다. 예를 들면 2개의 리소스에 대한 Mutex의 락을 두 개의 스레드가 각각 하나씩 나누어 가지고, 서로의 lock을 획득해야 다음 코드가 진행될 수 있다면 데드락이 발생할 수 있습니다. 정리하면 다음과 같은 2가지 유사성이 있습니다. RefCell와 Mutext가 비슷하게 내부 가변성을 제공한다는 것입니다. Mutex\u003cT\u003e는 Deadlock RefCell\u003cT\u003e는 memory leak(순환 참조 등) RefCell\u003cT\u003e/Rc\u003cT\u003e and Mutex\u003cT\u003e/Arc\u003cT\u003e ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:17:6","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Sync와 Send trait을 활용한 확장 가능한 동시성 러스트는 매우 적은 숫자의 동시성 기능을 std라이브러리에서 제공하는 대신, 확장성을 위하여 sync와 send trait을 열어줍니다. 즉 동시성을 확장하기 위해서는 std::marker 트레잇인 Sync, Send를 구현하면 됩니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:18:0","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Send trait 스레드 사이에서 소유권 이전을 허용하기 Send가 구현된 타입들은 소유권이 스레드들 사이에서 이전될 수 있음을 나타내며, 대부분의 rust타입들은 Send가 구현되어있습니다. 단 Rc와 raw pointer는 불가능합니다. Rc의 경우에는 clone 된 이후, 다른 스레드로 복제본이 소유권 전송이 된다면 두 스레드 모두 동시에 레퍼런스카운트를 write하려고 시도할 수 있기 때문입니다. 그렇기 때문에 Rc는 단일 스레드에서만 사용되도록 구현되어있습니다. raw pointer는 19장에서 알아보겠습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:18:1","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["dev"],"content":"Sync trait 여러 스레드로부터의 접근을 허용하기 Sync 마커 트레잇은 Sync가 구현된 타입이 여러 스레드로부터 안전하게 참조 가능함을 나타냅니다. 바꿔 말하면, 만일 \u0026T (T의 참조자) 가 Send이면, 즉 참조자가 다른 스레드로 안전하게 보내질 수 있다면, T는 Sync합니다. Send와 유사하게, 기초 타입들은 Sync하고, 또한 Sync한 타입들로 전체가 구성된 타입 또한 Sync합니다. 스마트 포인터 Rc는 Send가 아닌 이유와 동일한 이유로 또한 Sync하지도 않습니다. RefCell 타입과 연관된 Cell 타입의 가족들도 Sync하지 않습니다. RefCell가 런타임에 수행하는 빌림 검사 구현은 스레드-안전하지 않습니다. 스마트 포인터 Mutex는 Sync하고 “여러 스레드 사이로 Mutex 공유하기” 절에서 본 것처럼 여러 스레드에서 접근을 공유하는데 사용될 수 있습니다. ","date":"2023-01-30","objectID":"/the_rust_programming_lang_part2/:18:2","tags":["dev","rust","language"],"title":"[Part2] The rust programming language","uri":"/the_rust_programming_lang_part2/"},{"categories":["icp","dev"],"content":"How to set up Internet Computer development environment.","date":"2023-01-27","objectID":"/setup_icp_env/","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"How to set up Internet Computer development environment. ","date":"2023-01-27","objectID":"/setup_icp_env/:0:0","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"TL;DR Install the Canister SDK Build and deploy a dapp locally Collect free cycles to power your dapp Create a “cycles wallet” from which you can transfer cycles to any other dapps you want to power Deploy a dapp on-chain ","date":"2023-01-27","objectID":"/setup_icp_env/:1:0","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"1. Set up infrastructure ","date":"2023-01-27","objectID":"/setup_icp_env/:2:0","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"1-1. Get Cycles Faucet Get Cycles Faucet Request 20T cycles from ICP Discord ","date":"2023-01-27","objectID":"/setup_icp_env/:2:1","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"1-2. Setup SDK Setup SDK dfx: Difinity execution command-line interface $ sh -ci \"$(curl -fsSL https://internetcomputer.org/install.sh)\" $ dfs --version dfx 0.12.1 ","date":"2023-01-27","objectID":"/setup_icp_env/:2:2","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"1-3. Claim cycles \u003e dfx identity list Creating the \"default\" identity. WARNING: The \"default\" identity is not stored securely. Do not use it to control a lot of cycles/ICP. To create a more secure identity, create and use an identity that is protected by a password using the following commands: dfx identity create \u003cmy-secure-identity-name\u003e # creates a password protected identity dfx identity use \u003cmy-secure-identity-name\u003e # uses this identity by default Error: Failed to load identity manager. Caused by: Failed to load identity manager. Cannot create identity directory at '...': Permission denied (os error 13) Generate Identity and set it default \u003e sudo rm -rf leoo \u003e dfx identity list anonymous default * # dfx identity new \u003cmy-secure-identity-name\u003e \u003e sudo dfx identity new leoo.j \u003e dfx identity list anonymous default * leoo.j # dfx identity use \u003cmy-secure-identity-name\u003e # uses this identity by default \u003e sudo dfx identity use leoo.j Using identity: \"leoo.j\". Claim Cycles \u003e sudo dfx wallet --network ic redeem-faucet-coupon \u003cCOUPON_NUMBER\u003e Please enter the passphrase for your identity: [hidden] Decryption complete. \u003e sudo dfx wallet --network=ic balance Please enter the passphrase for your identity: [hidden] Decryption complete. 20.099 TC (trillion cycles). ","date":"2023-01-27","objectID":"/setup_icp_env/:2:3","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"2. Hello world locally I faced some permission error while doing Hello_World canister. So I posted below issue on ICP forum. Issue that I faced \u003e dfx new hello \u003e cd hello Terminal A // base root is hello \u003e dfx start Running dfx start for version 0.12.1 Using the default definition for the 'local' shared network because /Users/minwook/.config/dfx/networks.json does not exist. Dashboard: http://localhost:56958/_/dashboard Terminal B // base root is hello \u003e yarn install // or npm install \u003e dfx deploy ... Deployed canisters. URLs: Frontend canister via browser hello_frontend: http://127.0.0.1:4943/?canisterId=rkp4c-7iaaa-aaaaa-aaaca-cai Backend canister via Candid interface: hello_backend: http://127.0.0.1:4943/?canisterId=rno2w-sqaaa-aaaaa-aaacq-cai\u0026id=r7inp-6aaaa-aaaaa-aaabq-cai if you faced frontend build hangs How to fix dfx deploy infinite hang Open package.json file. edit scripts like below. as-is \"scripts\": { ... \"generate\": \"dfx generate hello_backend\" }, to-be \"scripts\": { ... \"generate\": \"dfx --identity anonymous generate hello_backend\" }, Finally Open your browser and navigate to the url output by the dfx deploy. In my case, it is http://127.0.0.1:4943/?canisterId=rkp4c-7iaaa-aaaaa-aaaca-cai. ","date":"2023-01-27","objectID":"/setup_icp_env/:3:0","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["icp","dev"],"content":"3. (OPT) Check my public wallet dashboard You can check your wallet dashboard by below command. \u003e dfx identity --network ic get-wallet Please enter the passphrase for your identity: [hidden] Decryption complete. zze7b-pqaaa-aaaam-abciq-cai With given wallet ID, you can browse your public dashboard site. Type https://.ic0.app/ on your web browser. My public ICP Dashboard - fin - ","date":"2023-01-27","objectID":"/setup_icp_env/:4:0","tags":["dev","web3.0","blockchain","internet computer"],"title":"Internet Computer development environment","uri":"/setup_icp_env/"},{"categories":["dev"],"content":"The official Rust book","date":"2023-01-11","objectID":"/the_rust_programming_lang/","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Rust에서 공식적으로 지원하는 “The rust programming language” 을 통해서 Rust 핵심 문법적 특징과 예시코드 그리고 이면에 숨은 디자인 원칙들을 정리 해보겠습니다. 3. Common Programming Concepts ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:0:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"3-1. Variables and Mutability Rust에서 기본 변수는 불변성입니다. 이를 통해 컴파일 타임에 실수로 immutable 변수를 변경하는 버그를 잡아내도록 강제합니다. mut 키워드를 사용하면 Mutability를 제공할 수 있습니다. (가변변수) immutable vs mutable 만약 매우 큰 구조체를 다루는 경우 mutable 인스턴스를 사용하는 것이 새로 인스턴스를 할당하고 반환하는 것보다 빠를 수 있습니다. 데이터 크기가 작을수록 새 인스턴스를 생성하고 FP(함수적) 프로그래밍 스타일로 작성하는 것이 더 합리적이고, 그렇기에 약간의 성능 하락을 통해 가독성을 확보할 수 있다면 더 가치있는 선택입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:1:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Constants const vs Variables 상수에 대해서는 mut을 사용하는 것이 허용되지 않습니다: 상수는 항상 불변합니다. 상수는 let키워드 대신 const키워드를 사용해야 하고, 값의 type을 선언해야 합니다. 상수는 can be declared in any scope(including the global scope) 상수는 may be set only to a constant expression(상수 표현식), not the result of a value that could only be computed at runtime., 즉 컴파일 타임에 하드코드 되어야합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:1:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Shadowing “선언한 변수와 같은 이름의 새로운 변수를 선언할 수 있고, 새 변수는 이전 변수를 shadows하는 것” fn main(){letx=5;letx=x+1;{letx=x*2;println!(\"The value of x in the inner scope is: {x}\");// x is 12 }println!(\"The value of x is: {x}\");// x is 6 } shadowing과 mut은 크게 2가지 차이가 있습니다. 문법 차이 // shadowing {letx=5;letx=x+1;}// mut {letmutx=5;x=x+1;} shadowing은 같은 이름을 유지하면서, 다른 타입을 사용할 수 있습니다. 즉 네이밍을 깔끔하게 사용할 수 있습니다. // shadowing: 깔끔한 네이밍 유지 가능하다. {letspaces=\" \";letspaces=spaces.len();}// mut: 컴파일 에러 {letmutspaces=\" \";spaces=spaces.len()// error[E0308]: mismatched types }// immutable: 더럽다. {letspaces_str=\" \";letspaces_len=spaces_str.len();} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:1:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"3-2. Data Types Rust의 타입은 크게 2가지: scalar와 compound 두가지로 나뉩니다. Rust는 statically typed language(타입이 고정된 언어)입니다. 즉 Rust는 컴파일타임에 모든 변수의 타입이 정해집니다. 그러므로 명시적으로 타입을 지정 또는 컴파일러가 타입을 추측할 수 있도록 선택의 폭을 줄여주어야 합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:2:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"scalar types A scalar type represents a single value. Rust는 4가지의 primary 스칼라 타입을 가지고 있습니다. Integer Types Table 3-1: Integer Types in Rust Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize arch는 32-bits, 64-bits 같은 컴퓨터 아키텍처를 뜻합니다. Integer Literals Table 3-2: Integer Literals in Rust Number literals Example Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b‘a' 확실하게 정해진 경우가 아니면 Rust의 기본 값인 i32가 일반적으로는 좋은 선택입니다. Integer Overflow Integer overflow란 type의 값 scope를 벗어나는 경우를 뜻합니다. {letn: u8 =256;} 이 경우 rust에서는 2가지 모드 --debug, --release에 따라서 다르게 동작합니다. debug 모드로 컴파일 integer overflow를 런타임에 체크하여, “Unrecoverable Errors with panic!”을 일으킵니다. release 모드로 컴파일 panic 대신 two’s complement wrapping을 실시합니다. u8의 경우 256이면 최소값인 0으로 값이 변환됩니다. {// $ cargo build --release letmuta: u8 =0;letmutb: u8 =255;println!(\"{a}, {b}\");// 0, 255 a=a-1;b=b+1;println!(\"{a}, {b}\");// 255, 0 } Floating-Point Types fn main(){letx=2.0;// f64 lety: f32 =3.0;// f32 } The Boolean Type fn main(){lett=true;letf: bool =false;// with explicit type annotation } The Character Type fn main(){letc='z';letz: char ='ℤ';// with explicit type annotation letheart_eyed_cat='😻';} char literal은 single quotes를 사용해야 합니다. 또한 Rust의 char타입은 four bytesUnicode Scalar를 표현하는 값입니다. (ASCII 보다 많은 표현 가능) 즉 한국어/중국어/일본어 표의 문자, 이모티콘, 넓이가 0인 공백문자를 char타입 변수로 받을 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:2:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Compound types Compound types can group multiple values into one type. Rust는 Sequence types에서 총 3가지의 primative 타입(tuples and arrays, slice)을 가지고 있습니다. Tuple: (), (\u0026str, i32)… i.g. () Array: [Type; Expression] i.g. [i32; 3] : i32가 3개있는 배열 Slice: [T] \u0026[T]: shared slice reference \u0026mut [T]: mutable slice reference Box\u003c[T]\u003e: boxed slice The Tuple Type 튜플에 포함되는 각 값의 타입이 동일할 필요없이 서로 달라도 됩니다. // 다른 타입들을 사용할 경우 {lettup: (i32,f64,u8)=(500,6.4,1);}// 단일 타입을 사용할 경우 {lettup=(500,6.4,1);let(x,y,z)=tup;// 패턴 매칭 destructuring } 마침표(.)를 통해서 튜플의 index 접근이 가능합니다. {letx: (i32,f64,u8)=(500,6.4,1);letfive_hundred=x.0;letsix_point_four=x.1;} The Array Type 튜플과는 다르게, 배열의 모든 요소는 모두 같은 타입이어야 합니다. Rust에서는 배열은 고정된 길이를 갖습니다. (선언되면 크기가 커지거나 작아지지 않는다.) {leta=[1,2,3,4,5];} 배열이 유용할 때는 당신의 데이터를 heap보다 stack에 할당하는 것을 원하거나, 항상 고정된 숫자의 요소(element)를 갖는다고 확신하고 싶을 때입니다. (vector 타입은 가변적) {letmonths=[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];letfirst=months[0];letsecond=months[1];} index를 사용해 요소에 접근하려고 하면 Rust는 지정한 색인이 배열 길이보다 작은지 확인합니다. index가 array 길이보다 크면 *패닉(panic)*을 발생시킵니다. 또한 index 에러는 컴파일 시에는 아무런 에러도 발생시키지 않습니다만, 프로그램의 결과는 실행 중에 에러가 발생했고 성공적으로 종료되지 못했다고 나옵니다. $ cargo run Compiling arrays v0.1.0 (file:///projects/arrays) Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs Running `target/debug/arrays` thread '\u003cmain\u003e' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:6 note: Run with `RUST_BACKTRACE=1` for a backtrace. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:2:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"3-3. Functions Rust code uses snake case as the conventional style for function and variable names Rust는 당신의 함수의 위치를 신경쓰지 않습니다, 어디든 정의만 되어 있으면 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:3:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Statements and Expressions Statements(구문) are instructions that perform some action and do not return a value. Expressions(표현식) evaluate to a resultant value. // statement {lety=6;letx=(lety=6);// compile error, return value가 없기 때문 }// { } 또한 표현식입니다. fn main(){letx=5;lety={letx=3;x+1// expression, evaluated return value };// let y = 4; } Expression은 경우 종결을 나타내는 세미콜론(;)을 사용하지 않습니다. 만약 세미콜론을 표현식 마지막에 추가하면, 이는 구문으로 변경되고 반환 값이 아니게 됩니다. 이후부터 함수의 반환 값과 표현식을 살펴보실 때 이 점을 유의하세요. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:3:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Functions with Return Values return 키워드와 값을 써서 함수로부터 일찍 반환할 수 있지만, 대부분의 함수들은 암묵적으로 마지막 표현식을 반환합니다. fn five()-\u003e i32 {5} 위의 코드의 경우 return 5가 동작하게 됩니다. 이와 반대로 fn five()-\u003e i32 {5;} 와 같이 세미콜론을 붙이게 된다면 ()(비어있는 튜플)을 반환하게 되어, mismatched typed 에러가 발생합니다. 반면 fn five()-\u003e (){5;} 와 같이 return 타입을 tuple로 변경하게 될 경우 컴파일 에러가 사라지는 것을 확인할 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:3:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"3-4. Comments fn main(){// I’m feeling lucky today. letlucky_number=7;} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:4:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"3-5. Control Flow if의 조건문은 반드시 명시적으로 bool 타입이어야 합니다. fn main(){letnumber=3;// mismatched types ifnumber{println!(\"number was three\");}} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:5:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Using if in a let Statement {letnumber=ifcondition{5}else{6};} 변수가 가질 수 있는 타입이 오직 하나여야 합니다. 그러므로 아래와 같은 코드는 에러입니다. {letnumber=ifcondition{5}else{\"six\"};} Rust는 컴파일 타임에 number 변수의 타입이 뭔지 확실히 정의해야 합니다. 그래야 number가 사용되는 모든 곳에서 유효한지 검증할 수 있으니까요. Rust는 number의 타입을 런타임에 정의되도록 할 수 없습니다. 컴파일러가 모든 변수의 다양한 타입을 추적해서 알아내야 한다면 컴파일러는 보다 복잡해지고 보증할 수 있는 것은 적어지게 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:5:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"반복문 (3) loop, while, for loop {loop{do_something();}} 어라? 이 방식은 while true { }와 큰 차이점이 없어 보입니다. 그래서 리서치해보니 loop은 expression으로 값을 return할 수 있습니다. 반면에 while과 for는 statement로 값을 return할 수 없습니다. {letmutcnt=0;letresult=loop{cnt+=1;ifcnt==10{breakcnt*2;}};assert_eq!(result,20);} FYI 위 코드에서 loop의 마지막 부분에 };이 사용되었다는 것을 알 수 있습니다. while {letmuti=0;whilei\u003c5{do_something();i=i+1}} 그러나 이런 방식은 에러가 발생하기 쉽습니다. 개발자가 정확한 index를 사용하지 못하면 프로그램은 패닉을 발생합니다. 또한 느립니다. 이유는 컴파일러가 실행 간에 반복문을 통해 반복될 때마다 요소에 대한 조건 검사를 수행하는 런타임 코드를 추가하기 때문입니다. 이에 대한 대안으로 for을 사용합니다. for {letarr=[1,2,3,4,5];foreinarr.iter(){do_somethin(e);}} 이를 통해 index에 대한 실수를 줄일 수 있습니다. 만약 배열의 길이 만큼이 아닌 특정한 횟수만큼 반복하고 싶다면 Range를 사용합니다. {fornin(1..4).rev(){do_something();}} 4. Ownership 소유권(Ownership)은 러스트의 가장 유니크한 특성이며, 러스트가 가비지 콜렉터 없이도 메모리 안정성 보장을 하게 해줍니다. 4-1. 소유권은 무엇인가? 4-2. References and Borrowing 4-3. The Slice ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:5:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"4.1. 소유권은 무엇인가? 모든 프로그램은 실행하는 동안 컴퓨터의 메모리(Heap)를 사용하는 방법을 관리해야 합니다. 크게 3가지 방식이 있는데요. java, python 같은 언어는 실행될 때 사용하지 않는 메모리들을 정리하는 GC를 사용하고 c / c++ 같은 언어에서는 프로그래머가 직접 explicit(명시적)으로 사용한 메모리를 할당하고 해제해야 합니다. Golang의 경우에 초기 개발자가 java의 GC 개발자라는 점을 활용해 GC를 가지고 있습니다. 마지막으로 Rust의 경우에는 3. 컴파일 타임에 정한 규칙들을 활용해 소유권을 시스템으로 메모리가 관리됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Ownership 규칙 (3) 러스트의 각각의 값(each value)은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다. 한번에 딱 하나의 오너만 존재할 수 있다. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped). Heap vs Stack Stack LIFO로 동작하는 자료구조. stack의 element들은 동일한 size를 가져야 한다. 예를 들면 instance는 heap에, 이를 가리키는 로컬 변수 pointer는 정해져있는 element이므로 stack에 저장 Scope 벗어나면 pop됩니다. Heap pointer를 타고타고 찾는 구조. (Linked list) 이기 때문에 stack은 top만 보는 특성에 비해서, 접근하는 데 느립니다. Heap의 경우에는 프로세서가 메모리 내부를 레퍼런스들을 타고타면서 jump해야하지만, stack의 경우에는 데이터가 붙어있으니 덜 jump해도 됩니다. 그러므로 더 빠릅니다. 이 때문에 stack은 modify 비용이 크지만, heap의 경우에는 modify 되는 다양한 size 데이터들을 저장할 수 있습니다. 컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해서는, 힙에 데이터를 저장할 수 있습니다. allocating(allocating on the heap): 데이터를 힙에 넣을때, 먼저 저장할 공간이 있는지 물어봅니다. 그러면 운영체제가 충분히 커다란 힙 안의 빈 어떤 지점을 찾아서 이 곳을 사용중이라고 표시하고, 해당 지점의 포인터를 우리에게 돌려주죠. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Strings 타입 Rust에서 string literal은 compile시 binary로 저장됩니다. 즉 하드코딩 되어있습니다. 그러니 stack, heap 둘 중 어디에도 저장되지 않습니다. Binary로 하드코딩 되어있기 때문에, 당연히 immutable합니다. Java's String Literal 비교를 위해서, JAVA7 이후 JVM의 경우 string literal은 constant pool에 저장됩니다. Constant Pool은 Heap의 일부이기 때문에 GC됩니다. (7이전에는 PermGen 영역) Immutable한 String Literal을 런타임에 mutable하게 만들기 위해서는 from(): type convert, 내부적으로는 os에 메모리 요청 .push_str(): append {letmuts=String::from(\"hello\");s.push_str(\", minwook :)\");// \"hello, minwook :)\" } ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Memory and Allocation String 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 우리는 힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 메모리 공간을 할당받아 내용물을 저장할 필요가 있습니다. 이는 즉 다음을 의미합니다: 런타임에 운영체제로부터 메모리가 요청되어야 한다. String의 사용이 끝났을 때 운영체제에게 메모리를 반납(free)할 방법이 필요하다. 즉 allocate와 free가 쌍으로 구현되어야 합니다. 첫번째는 String::from을 호출하면 가능하며, 2번의 경우 대부분 언어는 GC를 통해 관리합니다. Rust는 2번을 위해서 “메모리는 변수가 소속되어 있는 scope 밖으로 벗어나는 순간 자동으로 free(반납)됩니다.” 운영체제에게 메모리를 반납(free)시키기 위해 Rust는 drop() 함수가 존재하며, 중괄호가 } 닫힐 때 자동으로 drop()를 호출합니다. {lets=String::from(\"hello\");// s는 여기서부터 유효합니다 // s를 가지고 뭔가 합니다 }// 이 스코프는 끝났고, s는 더 이상 // 유효하지 않습니다 C++에서는 이렇게 아이템의 수명주기의 끝나는 시점에 자원을 해제하는 패턴을 Resource Acquisition Is Initialization, RAII) 라고 부릅니다. 이제 이 free를 힙에 할당시킨 데이터를 사용하는 여러 개의 변수를 사용하고자 할 경우, 즉 좀더 복잡한 상황들을 살펴보겠습니다. 변수와 데이터가 상호작용하는 방법: Move 변수와 데이터가 상호작용하는 방법: Clone 스택에만 있는 데이터: Copy 1. 변수와 데이터가 상호작용하는 방법: Move lets1=String::from(\"hello\");lets2=s1; String은 아래 그림의 왼쪽과 같이 세 개의 부분으로 이루어져 있습니다. 문자열의 내용물을 담고 있는 메모리의 포인터, 길이, 그리고 용량입니다. 이 데이터의 그룹은 스택에 저장됩니다. 내용물을 담은 오른쪽의 것은 힙 메모리에 있습니다. s2에 s1을 assign 하게될경우 대부분 프로그래밍 언어에서는 총 2가지 현상이 일어날 수 있습니다. 얕은 복사(Shallow Copy) 깊은 복사(Deep Copy) 얕은 복사(Shallow Copy): heap 메모리 상의 데이터는 복사되지 않는 것, 즉 stack의 레퍼런스(포인터)만 복사 되는 것. 참조해서 데이터를 수정하게 될 경우, 원하지 않는 현상이 일어날 수 있습니다. 앞서 우리는 변수가 스코프 밖으로 벗어날 때, 러스트는 자동적으로 drop함수를 호출하여 해당 변수가 사용하는 힙 메모리를 제거한다고 했습니다. 그러므로 이렇게 shallow copy가 일어나게 된다면, s2와 s1은 동시에 메모리를 해제(free)하려 합니다. 이는 두번-해제(double free)오류 라고 알려져있습니다. (메모리 안전성 관련 버그 중 하나) 메모리를 두번이상 해제하는 것은 memory corruption(손상)의 원인이 되며, 보안 취약성을 일으킬 수 있습니다. 깊은 복사(Shallow Copy): heap 메모리 상의 데이터까지 복사되는 것 깊은 복사의 경우에는, 힙 안의 데이터가 클 경우 s2 = s1 연산은 런타임 상에서 매우 느려질 가능성이 있습니다. 그래서 Rust는 Move라는 개념을 도입합니다. {lets1=String::from(\"hello\");lets2=s1;println!(\"{s1}, {s2}\");// compile error } 실제 위의 코드는 아래와 같은 컴파일 에러를 발생시킵니다. error[E0382]: use of moved value: `s1` --\u003e src/main.rs:4:27 | 3 | let s2 = s1; | -- value moved here 4 | println!(\"{}, world!\", s1); | ^^ value used here after move | = note: move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait Move: shallow copy에서 첫번째 변수의 무효화 된 개념. 러스트는 s2에 s1을 대입하게 될 경우, 첫번째 변수인 s1을 무효화 시킵니다. 그래서 아래와 같은 현상이 내부적으로 발생합니다. 그래서 위의 코드에서 move된 s1에 대한 참조를 없애게 된다면 정상적으로 동작하게 됩니다. {lets1=String::from(\"hello\");lets2=s1;println!(\"{s2}\");// \"hello\" } 이런 Move 개념을 통해서 Rust는 아래의 문제들을 해결하면서 shallow: double free 에러. shallow: 원치 않게 오리지널 heap 데이터 변경. deep: heap의 데이터 복사에 의한 퍼포먼스 저하. 동시에 allocate한 메모리에 대해서 운영체제에게 메모리를 반납(free) 을 할 수 있게 되었습니다. 2. 변수와 데이터가 상호작용하는 방법: Clone Rust의 Deep copy 방법 만일 String의 스택 데이터 만이 아니라, 힙 데이터를 깊이 복사하기를 정말 원한다면, clone이라 불리우는 공용 메소드를 사용할 수 있습니다. lets1=String::from(\"hello\");lets2=s1.clone();println!(\"s1 = {}, s2 = {}\",s1,s2);// s1 = hello, s2 = hello 러스트는 .clone()이라는 명시적인 제약을 두어, 성능상의 문제가 발생할 때 손쉽게 찾아볼 수 있게 문법적으로 강제하였습니다. 3. 스택에만 있는 데이터: Copy String에서는 불가능했던, 코드가 앞서 보았던 int예시에서는 문제없이 동작하는 것을 알 수 있습니다. {letx=5;lety=x;println!(\"x = {}, y = {}\",x,y);// x = 5, y = 5 } 위의 코드의 int타입의 경우에는 clone을 호출하지 않았지만, x도 유효하며 y로 Move(이동)하지 않았습니다. 그 이유는 정수형과 같이 컴파일 타임에 결정되어 있는 크기의 타입은 스택에 모두 저장되기 때문에, 실제 값의 복사본이 빠르게 만들어질 수 있습니다. 이는 변수 y가 생성된 후에 x가 더 이상 유효하지 않도록 해야할 이유가 없다는 뜻입니다. 바꿔 말하면, 여기서는 깊은 복사와 얕은 복사 간의 차이가 없다는 것으로, clone을 호출하는 것이 보통의 얕은 복사와 아무런 차이점이 없어 우리는 이를 무시할 수 있다는 것입니다. 러스트는 정수형과 같이 스택에 저장할 수 있는 타입에 대해 Copy trait(카피 트레잇)이라고 불리우는 특별한 어노테이션(annotation)을 가지고 있습니다. 만일 어떤 타입이 Copy 트레잇을 갖고 있다면, 대입 과정 후에도 예전 변수를 계속 사용할 수 있습니다. 그리고 당연하게도 만약 Copy trait을 어노테이트한 타입이, Drop trait도 어노테이트 했다면 에러를 내도록합니다. 아래는 Rust가 지원하는 타입중에서, Copy가 가능한 타입 리스트입니다. int 타입들 (i.g u32) bool 타입들 float 타입들 char 타입들 Copy가 가능한 타입만으로 구성된 튜플 (즉 숫자형 또는 bool 또는 char인 경우) i.g. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다. i.g. (i32, f64)는 혼합되어 있지만 Copy가 됩니다. 왜냐하면 숫자형, bool, char안에 포함되는 타입들이기 때문에. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"소유권과 함수(Ownership and Functions) 함수에 변수를 넘기는 것(args, param) 또한 대입(=)과 마찬가지로 이동(Move)하거나 복사(Move)가능합니다. fn main(){lets=String::from(\"hello\");// s가 스코프 안으로 들어왔습니다. takes_ownership(s);// s의 값이 함수 안으로 이동했습니다. // 그리고 여기 부터는 더이상 유효하지 않습니다. letx=5;// x가 스코프 안으로 들어왔습니다. makes_copy(x);// x가 함수 안으로 이동했습니다만, // i32는 Copy가 되므로, x를 이후에 계속 // 사용해도 됩니다. }// 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로, // 별다른 일이 발생하지 않습니다. fn takes_ownership(some_string: String){// some_string이 스코프 안으로 들어왔습니다. println!(\"{}\",some_string);}// 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는 // 해제되었습니다. fn makes_copy(some_integer: i32){// some_integer이 스코프 안으로 들어왔습니다. println!(\"{}\",some_integer);}// 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다. hello 5 만일 우리가 s를 takes_ownership 함수를 호출한 이후에 사용하려 한다면, 러스트는 컴파일 타임 오류를 낼 것입니다. 저는 개인적으로 맞는지 아닌지는 모르겠지만, scalar 타입들에 대해서는 String이 아니면, 모두 Copy 기억하려고 합니다. 또한 문득 개인적으로 Copy vs Clone에 대해서는 명확하게 구분이 불가능한 것 같아 Copy vs Clone Youtube: copy vs clone 을 정리할 예정입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Return Values and Scope return 또한 소유권을 이동시킵니다. fn main(){lets1=gives_ownership();// gives_ownership은 반환값을 s1에게 // 이동시킵니다. lets2=String::from(\"hello\");// s2가 스코프 안에 들어왔습니다. lets3=takes_and_gives_back(s2);// s2는 takes_and_gives_back 안으로 // 이동되었고, 이 함수가 반환값을 s3으로도 // 이동시켰습니다. }// 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로 // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로 // 벗어나서 drop이 호출됩니다. fn gives_ownership()-\u003e String {// gives_ownership 함수가 반환 값을 // 호출한 쪽으로 이동시킵니다. letsome_string=String::from(\"hello\");// some_string이 스코프 안에 들어왔습니다. some_string// some_string이 반환되고, 호출한 쪽의 // 함수로 이동됩니다. }// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다. fn takes_and_gives_back(a_string: String)-\u003e String {// a_string이 스코프 // 안으로 들어왔습니다. a_string// a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다. } 어떤 값을 다른 변수에 대입하면 값이 이동됩니다. 힙에 데이터를 갖고 있는 변수가 스코프 밖으로 벗어나면, 해당 값은 데이터가 다른 변수에 의해 소유되도록 이동하지 않는한 drop에 의해 제거될 것입니다. 만일 함수에게 값을 사용할 수 있도록 하되 소유권은 갖지 않도록 하고 싶다면요? 함수의 본체로부터 얻어진 결과와 더불어 우리가 넘겨주고자 하는 어떤 값을 다시 쓰고 싶어서 함께 반환받아야 할 경우가 대표적입니다. 이런 경우에는 아래와 같이 튜플을 이용하여 여러 값을 돌려받는 식으로 가능하긴 합니다. fn main(){lets1=String::from(\"hello\");let(s2,len)=calculate_length(s1);println!(\"The length of '{}' is {}.\",s2,len);}fn calculate_length(s: String)-\u003e (String,usize){letlength=s.len();// len()함수는 문자열의 길이를 반환합니다. (s,length)} 하지만 이건 보편화 되기에 너무 많이 과한 작업이 됩니다. 다행히, 러스트는 이런 경우를 위해 참조자(references)라는 feature 문법을 도입했습니다. for using a value without transferring ownership, called references. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:6:5","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"4.2. References and Borrowing References (참조자, 불변 참조자, immutable) Borrowing Mutable references (가변 참조자) Dangling References The Rules of References ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"References 바로 위의 코드에서, s1의 소유권을 넘기는 대신 Rust는 함수 signature를 reference 타입으로 변경시켜서 처리할 수 있습니다. fn main(){lets1=String::from(\"hello\");letlen=calculate_length(\u0026s1);println!(\"The length of '{}' is {}.\",s1,len);}fn calculate_length(s: \u0026String)-\u003e usize {s.len()}// 여기서 s는 스코프 밖으로 벗어났습니다. 하지만 가리키고 있는 값에 대한 소유권이 없기 // 때문에, 아무런 에러도 발생하지 않습니다. 참조자 s가 drop됩니다. s2 선언부가 사라지고, calculate_length() 튜플 return이 사라졌습니다. calculate_length에 \u0026s1을 사용합니다. \u0026를 references(참조)라고 부르며, 어떤 값의 소유권을 넘기지 않고 참조하도록 할 수 있습니다. 위 도표와 같이, calculate_length의 param인 참조자 s라는 포인터 타입 local변수가 생성되고, 이 포인터가 s1을 참조하는 형식입니다. Reference를 활용하게 되면, 참조자는 소유권을 갖고 있지는 않기 때문에, 이 참조자가 가리키는 값은 참조자가 스코프 밖으로 벗어났을 때도 메모리가 반납되지 않을 것입니다. \u0026s(참조자)를 파라미터로 가지게 되어, 함수는 소유권을 가지지 않게 될 수 있습니다. 그러므로 당연히 소유권을 되돌려주기 위해 값을 다시 반환할 필요도 없게 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Borrowing 함수의 파라미터로 참조자(\u0026s)를 만드는 것을 Borrowing(빌림)라고 부릅니다. 어떤 무언가를 빌렸다는 것은, 함부로 빌린 물건을 대해서는 안됩니다. 우리가 빌린 무언가를 고치려고 시도한다면 무슨 일이 생길까요? fn main(){lets1=String::from(\"hello\");modify(\u0026s1);}fn modify(s: \u0026String){s.push_str(\", minwook\");} error[E0596]: cannot borrow `*s` as mutable, as it is behind a `\u0026` reference --\u003e src/main.rs:7:3 | 6 | fn modify(s: \u0026String) { | ------- help: consider changing this to be a mutable reference: `\u0026mut String` 7 | s.push_str(\", minwook\"); | ^^^^^^^^^^^^^^^^^^^^^^^ `s` is a `\u0026` reference, so the data it refers to cannot be borrowed as mutable 변수가 기본적으로 불변인 것처럼, 참조자도 마찬가지입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Mutable references (가변 참조자) 변할 수 있는 참조자 (\u0026mut) 빌린 물건을 의도적으로 수정하고 싶다면, \u0026mut를 붙여주면 됩니다. 또한 원래 물건(변수) 또한 mut 처리해주어야 합니다. fn main(){letmuts1=String::from(\"hello\");modify(\u0026muts1);}fn modify(s: \u0026mutString){s.push_str(\", minwook\");} 하지만 가변 참조자는 딱 한가지 큰 제한이 있습니다. 특정한 스코프 내에 특정한 데이터 조각에 대한 가변 참조자를 딱 하나만 만들 수 있다는 겁니다. 아래 코드는 실패할 겁니다. {letmuts=String::from(\"hello\");letr1=\u0026muts;letr2=\u0026muts;}// error[E0499]: cannot borrow `s` as mutable more than once at a time. 이런 불편한 제한사항 덕분에, 여러분이 가질 수 있는 이점은 바로 러스트가 컴파일 타임에 데이터 레이스(data race)를 방지할 수 있도록 해준다는 것입니다. 아래는 Data race가 발생될 수 있는 race condition 조건입니다. 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다. 그 중 적어도 하나의 포인터가 데이터를 쓴다. 데이터에 접근하는데 동기화(sync)를 하는 어떠한 수단 없다. Rust는 하나의 원본값(변수)에 대해 같은 scope 안에서 2개 이상의 \u0026mut를 만들 수 없도록, 문법적 강제를 합니다. 이로써 1번의 조건을 사전에 차단하였습니다. Rust의 scope를 사용하면, “동시\"에 만드는 것을 우회하여, 여러개의 가변 참조자를 만들 수 있습니다. letmuts=String::from(\"hello\"): {letr1=\u0026muts;}// 여기서 r1은 스코프 밖으로 벗어났으므로, 우리는 아무 문제 없이 새로운 참조자를 만들 수 있습니다. letr2=\u0026muts; mutable reference(가변 참조자)와 immutable reference(불변 참조자, 디폴트)를 혼용에 대한 규칙도 존재합니다. letmuts=String::from(\"hello\");letr1=\u0026s;letr2=\u0026s;// ok immutable reference는 중복해도 modify 할 수없으니(Read Only) 문제 없습니다. 반면에 혼용하게 될 경우에는 에러가 생깁니다. letmuts=String::from(\"hello\");letr1=\u0026s;letr2=\u0026muts;// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable. 위와 같이 불변 참조자를 가지고 있을 동안 가변 참조자를 만들 수 없습니다. 불변 참조자의 사용자는 사용중인 동안에 값이 값자기 바뀌리라 예상하지 않기 때문입니다. 이는 순서를 반대로 해도 같습니다. (\u0026mut 선언 후 \u0026 재선언) letmuts=String::from(\"hello\");letr2=\u0026muts;letr1=\u0026s;// error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Dangling References 포인터가 있는 언어에서는 자칫 잘못하면 댕글링 포인터(dangling pointer, 허상 포인터)를 만들기 쉬운데, 댕글링 포인터란 어떤 메모리를 가리키는 포인터를 보존하는 동안, 포인터가 가리키고 있는 메모리를 해제함으로써 다른 개체에게 사용하도록 줘버렸을 지도, 또는 제거되었을지도 모를 메모리를 참조하고 있는 포인터를 말합니다. 이와는 반대로, 러스트에서는 컴파일러가 모든 참조자들이 댕글링 참조자가 되지 않도록 보장해 줍니다. 만일 우리가 어떤 데이터의 참조자를 만들었다면, 컴파일러는 그 참조자가 스코프 밖으로 벗어나기 전에는 데이터가 스코프 밖으로 벗어나지 않을 것임을 확인해 줍니다. 댕글링 참조자를 만들어보며 보도록 하겠습니다. fn main(){letdangle_ref=dangle();}fn dangle()-\u003e \u0026String {lets=String::from(\"hello\");\u0026s}// s는 }를 벗어나는 시점에 free되므로, \u0026s는 dangling reference입니다. error[E0106]: missing lifetime specifier ... help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from. (해석: 이 함수의 반환 타입은 빌린 값을 포함하고 있는데, 빌려온 실제 값은 없습니다.) 여기서의 해법은 String을 직접 반환하는 것입니다. 소유권이 밖으로 이동되었고, 아무것도 할당 해제되지 않습니다. fn no_dangle()-\u003e String {lets=String::from(\"hello\");s} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"The Rules of References 지금 까지 Reference(참조자)에 대해 논의한 것들을 정리해봅니다. 어떠한 경우이든, Rust는 아래 두가지 중에서, 오직 하나만 가질 수 있습니다. one mutable reference(하나의 가변 참조자, \u0026mut) any number of immutable references(임의 개수의 불변 참조자들, \u0026) 참조자는 항상 유효해야만 한다. 다음으로, 우리는 다른 종류의 참조자인 슬라이스(slice)를 알아보겠습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:7:5","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"4.3. Slices 슬라이스는 여러분이 컬렉션(collection) 전체가 아닌 컬렉션의 연속된 일련의 요소들을 참조할 수 있게 합니다. 소유권을 갖지 않는 또다른 데이터 타입은 슬라이스입니다. slice의 필요성 string slice란? 그 밖의 슬라이스들 ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:8:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"slice가 없다면? 여기 작은 프로그래밍 문제가 있습니다. 스트링을 입력 받아 그 스트링에서 찾은 첫번째 단어를 반환하는 함수를 작성해보세요. 만일 함수가 공백문자를 찾지 못한다면, 이는 전체 스트링이 한 단어라는 의미이고, 이때는 전체 스트링이 반환되어야 합니다. fn first_word(s: \u0026String)-\u003e ? 이 함수 first_word는 \u0026String을 파라미터로 갖습니다. 우리는 소유권을 원하지 않으므로, 이렇게 해도 좋습니다. 하지만 뭘 반환해야할까요? 우리는 스트링의 일부에 대해 표현할 방법이 없습니다. 하지만 단어의 끝부분의 인덱스를 반환할 수는 있겠습니다. // String 파라미터의 바이트 인덱스 값을 반환하는 first_word 함수 fn first_word(s: \u0026String)-\u003e usize {// 공백인지 확인할 필요가 있기 때문에, String은 as_bytes 메소드를 이용하여 바이트 배열로 변환. letbytes=s.as_bytes();for(i,\u0026item)inbytes.iter().enumerate(){// 공백 문자를 찾았다면, 이 위치를 반환합니다. ifitem==b' '{returni;}}s.len()} 이제 우리에게 스트링의 첫번째 단어의 끝부분의 인덱스를 찾아낼 방법이 생겼습니다. usize를 그대로 반환하고 있지만, 이는 \u0026String의 내용물 내에서만 의미가 있습니다. 바꿔 말하면, 이것이 String로부터 분리되어 있는 숫자이기 때문에, 아래 코드 처럼 이것이 나중에도 여전히 유효한지를 보장할 길이 없습니다. fn main(){letmuts=String::from(\"hello world\");letword=first_word(\u0026s);// word는 5를 갖게 될 것입니다. s.clear();// 이 코드는 String을 비워서 \"\"로 만들게 됩니다. // word는 여기서 여전히 5를 갖고 있지만, 5라는 값을 의미있게 쓸 수 있는 스트링은 이제 없습니다. // word는 이제 완전 유효하지 않습니다! } 이처럼 word의 인덱스가 s 데이터와 싱크가 안맞을 것은, 지겹고 쉽게 발생할 수 있는 오류입니다. 이러한 인덱스들을 관리하는 것은 우리가 second_word 함수를 작성했을 때 더더욱 다루기 어려워집니다. 이 함수의 시그니처는 아래와 같은 모양이 되어야 할 것입니다. fn second_word(s: \u0026String)-\u003e (usize,usize){} 이로써, 모든 개발자들은 매번 동기화를 유지할 필요가 있는, 원본 데이터와 분리된 세 개의 변수들을 가지게 되었습니다. 이를 해결하기 위해서 도입한 문법이 바로 String slice입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:8:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"스트링 슬라이스 string slice는 String의 일부분에 대한 reference(참조자)입니다. lets=String::from(\"hello world\");lethello=\u0026s[0..5];// 0, 1, 2, 3, 4 // let hello = \u0026s[..5];와 동일 letworld=\u0026s[6..11];// 6, 7, 8, 9, 10 // let len = s.len(); // let slice = \u0026s[3..len]; 와 동일 // let slice = \u0026s[3..]; 와 동일 전체 스트링의 슬라이스를 만들기 위해 양쪽 값을 모두 생략할 수 있습니다. 따라서 아래 두 줄의 표현은 동일합니다. lets=String::from(\"hello\");letn=s.len();letslice=\u0026s[0..n];letslice=\u0026s[..]; 이 모든 정보를 잘 기억하시고, first_word가 슬라이스를 반환하도록 다시 작성해봅시다. “스트링 슬라이스”를 나타내는 type은 \u0026str로 씁니다. fn first_word(s: \u0026String)-\u003e \u0026str {letbytes=s.as_bytes();for(i,\u0026item)inbytes.iter().enumerate(){ifitem==b' '{return\u0026s[0..i];}}\u0026s[..]} 만약 아까 와 같이, clear()한 경우 발생하는 문제는 그럼 어떻게 해결될 까요? fn main(){letmuts=String::from(\"hello world\");letword=first_word(\u0026s);s.clear();// Error! println!(\"the first word is: {}\",word);} 17:6 error: cannot borrow `s` as mutable because it is also borrowed as immutable [E0502] s.clear(); // Error! ^ 15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `s` until the borrow ends let word = first_word(\u0026s); ^ 18:2 note: previous borrow ends here fn main() { } Borrowing(빌림) 규칙에서 만일 무언가에 대한 불변 참조자를 만들었을 경우, 가변 참조자를 만들 수 없다는 점을 상기해보세요. clear()가 String을 잘라낼 필요가 있기 때문에, 이 함수는 가변 참조자를 갖기 위한 시도를 할 것이고, 이는 실패하게 됩니다. 스트링 리터럴은 슬라이스입니다 스트링 리터럴이 바이너리 안에 저장된다고 하는 얘기를 상기해봅시다. 이제 슬라이스에 대해 알았으니, 우리는 스트링 리터럴을 적합하게 이해할 수 있습니다. lets=\"Hello, world!\";// s는 \u0026str 타입 여기서 s의 타입은 \u0026str입니다. 이것은 바이너리의 특정 지점을 가리키고 있는 슬라이스입니다. 이는 왜 스트링 리터럴이 불변인가도 설명해줍니다; \u0026str은 불변 참조자이기 때문입니다. 파라미터로서의 스트링 슬라이스 리터럴과 String의 슬라이스를 얻을 수 있다는 것을 알게 되었다면, first_word는 fn first_word(s: \u0026str)-\u003e \u0026str { 로 시그니처를 변경시킬 수 있습니다. fn main(){letmy_string=String::from(\"hello world\");// first_word가 `String`의 슬라이스로 동작합니다. letword=first_word(\u0026my_string[..]);letmy_string_literal=\"hello world\";// first_word가 스트링 리터럴의 슬라이스로 동작합니다. letword=first_word(\u0026my_string_literal[..]);// 스트링 리터럴은 또한 스트링 슬라이스이기 때문에, // 아래 코드도 슬라이스 문법 없이 동작합니다! letword=first_word(my_string_literal);} 이런 Rust의 확장성은 python 처럼 slice를 편하게 만들어주네요. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:8:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"그 밖의 슬라이스들 slice는 스트링 이외에도 array, vector에 모두 동작합니다. 5. Structs Using Structs to Structure Related Data. OOP의 핵심, 데이터 속성과 메소드, 그리고 associated functions를 묶어주는 struct를 러스트 또한 제공합니다. 5.1. Defining and Instantiating Structs 5.2. An Example Program Using Structs 5.3. Method Syntax ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:8:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"5.1. Defining and Instantiating Structs 튜플과 유사하게, 구조체의 구성요소들은 각자 다른 타입을 지닐 수 있습니다. 구조체를 정의할 때는 struct 키워드를 먼저 입력하고 명명할 구조체명을 입력하면 됩니다. struct User{name: String,email: String,sign_in_count: u64,is_active: bool,} 구조체를 통해 인스턴스를 생성할때, 필드들의 순서가 정의한 필드의 순서와 같을 필요는 없습니다. User 구조체 정의에서, \u0026str 문자 슬라이스 타입 대신 String타입을 사용했습니다. 이는 의도적인 선택으로, 구조체 전체가 유효한 동안 구조체가 그 데이터를 소유하게 하고자 함입니다. #[derive(Debug)]struct User{name: String,email: String,sign_in_count: u64,is_active: bool,}fn main(){letmutuser=User{email: String::from(\"leoo_is_cool@leoo.com\"),name: String::from(\"leoo.j\"),is_active: true,sign_in_count: 1,};user.is_active=false;println!(\"{:#?}\",user);} 변수명이 필드명과 같을 때 간단하게 필드 초기화하기 fn build_user(email: String,name: String)-\u003e User{User{email,// email: email과 동일 name,// name: name과 동일 is_actieve: true,sign_in_count: 1,}} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:9:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"struct update syntax 구조체 갱신법을 이용하여 기존 구조체 인스턴스로 새 구조체 인스턴스 생성하기 .. 연산자를 활용하면 쉽게 인스턴스를 생성할 수 있습니다. before letuser2=User{email: String::from(\"another@example.com\"),name: String::from(\"anotherusername567\"),is_active: user1.is_active,sign_in_count: user1.sign_in_count,}; after letuser2=User{email: String::from(\"another@example.com\"),name: String::from(\"anotherusername567\"),..user1}; ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:9:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"tuple structs 이름이 없고 필드마다 타입은 다르게 정의 가능한 튜플 구조체. 러스트의 tuple struct는 파이썬의 Namedtuple과 비슷해 보입니다. Point = namedtuple('Point', ['x', 'y']) p = Point(11, y=22) externcrateassert_type_eq;struct Color(i32,i32,i32);struct Point(i32,i32,i32);fn main(){letblack=Color(0,0,0);letorigin=Point(0,0,0);} black과 origin은 다른 튜플 구조체이기 때문에, 다른타입 입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:9:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"unit-like structs 필드가 없는 유사 유닛 구조체 러스트에서 필드가 없는 튜플인 ()을 unit 또는 unit type라고 부릅니다. 러스트에서 어떤 필드도 없는 구조체 역시 정의 가능합니다. 이를 유닛처럼 동작하는 구조체, unit-like structs라고 부릅니다. 유사 유닛 구조체는 특정한 타입의 트레잇(trait)을 구현해야하지만 타입 자체에 데이터를 저장하지 않는 경우에 유용합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:9:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"구조체 안의 데이터 소유권 (Ownership) 구조체가 소유권이 없는 데이터의 참조를 저장할수는 있지만, 라이프타임(lifetimes)의 사용을 전제로 합니다. 라이프타임은 구조체가 존재하는동안 참조하는 데이터를 계속 존재할 수 있도록 합니다. 라이프타임을 사용하지 않고 참조를 저장하고자 하면 에러가 발생합니다. struct User{username: \u0026str,// 참조(reference) 데이터 email: \u0026str,// // 참조(reference) 데이터 sign_in_count: u64,active: bool,}fn main(){letuser1=User{email: \"someone@example.com\",username: \"someusername123\",active: true,sign_in_count: 1,};}// error[E0106]: missing lifetime specifier ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:9:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"5.2. An Example Program Using Structs 리팩토링을 하면서 배워보는 struct before fn main(){letlength1=50;letwidth1=30;println!(\"The area of the rectangle is {} square pixels.\",area(length1,width1));}fn area(length: u32,width: u32)-\u003e u32 {length*width} 1차 리팩토링: 튜플: argument를 하나로 줄일 수 있다. fn main(){letrect1=(50,30);println!(\"The area of the rectangle is {} square pixels.\",area(rect1));}fn area(dimensions: (u32,u32))-\u003e u32 {dimensions.0*dimensions.1// 명확하지 못함. } 2차 리팩토링: 구조체: 필드들을 명시적으로 사용가능 struct Rectangle{length: u32,width: u32,}fn main(){letr1=Rectangle{length: 50,width: 30,};println!(\"The area of the rectangle is {} square pixels.\",area(\u0026r1));}fn area(rectangle: \u0026Rectangle)-\u003e u32 {rectangel.length*rectangle.width// explicit하게 필드들 사용가능 } 추가로 확인할 점은, fn area(rectangle: \u0026Rectangle) -\u003e u32에서 rectangle이 ownership move가 아닌 reference를 통한 borrow로 이뤄졌다는 것입니다. 이를 통해 main()에서 r1에 대한 소유권을 유지할 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:10:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"derived trait 파생 트레잇(derived trait)으로 유용한 기능 추가하기 구조체를 pretty print하기 위해서는 아래 2가지를 사용하면 됩니다. #[derive(Debug)] println!(\"{:#?}\", r1); #[derive(Debug)]struct Rectangle{length: u32,width: u32,}fn main(){letrect1=Rectangle{length: 50,width: 30};// 1. print struct println!(\"rect1 is {:?}\",rect1);// rect1 is Rectangle { length: 50, width: 30 } // 2. pretty print struct println!(\"rect1 is {:#?}\",rect1);// rect1 is Rectangle { // length: 50, // width: 30 // } }} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:10:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"5.3. Method Python과 마찬가지로, 메서드의 첫번쨰 파라미터는 언제나 self가 전달되며, 필요에 따라 다음과 같이 활용됩니다. self: 소유권 가져오기 \u0026self: 소유권 없이 readonly \u0026mut self: 소유권 없이 read/write self의 타입은 작성될 필요가 없습니다. impl 뒤에 나오는 struct가 알려주기 때문입니다. `self` method의 parameter를 self로 받는, 이러한 테크닉은 보통 해당 메소드가 self을 다른 무언가로 변형시키고 이 변형 이후에 호출하는 측에서 원본 인스턴스를 사용하는 것을 막고 싶을 때 종종 쓰입니다. #[derive(Debug)]struct Rectangle{length: u32,width: u32,}implRectangle{fn area(\u0026self)-\u003e u32 {self.length*self.width}} Rust의 역참조 C++ 같은 언어에서는, 메소드 호출을 위해서 서로 다른 두 개의 연산자가 사용됩니다. 만일 어떤 객체의 메소드를 직접 호출하는 중이라면 .를 이용하고 어떤 객체의 포인터에서의 메소드를 호출하는 중이고 이 포인터를 역참조할 필요가 있다면 -\u003e를 씁니다. 달리 표현하면, 만일 object가 포인터라면, object-\u003esomething()은 (*object).something()과 비슷합니다. 러스트는 -\u003e 연산자와 동치인 연산자를 가지고 있지 않습니다; 대신, 러스트는 자동 참조 및 역참조 (automatic referencing and dereferencing) 이라는 기능을 가지고 있습니다. 메소드 호출은 이 동작을 포함하는 몇 군데 중 하나입니다. 동작 방식을 설명해보겠습니다: object.something()이라고 메소드를 호출했을 때, 러스트는 자동적으로 \u0026나 \u0026mut, 혹은 *을 붙여서 object가 해당 메소드의 시그니처와 맞도록 합니다. 달리 말하면, 다음은 동일한 표현입니다. p1.distance(\u0026p2);(\u0026p1).distance(\u0026p2); 첫번째 표현이 훨씬 깔끔해 보입니다. 이러한 자동 참조 동작은 메소드가 명확한 수신자-즉 self의 타입을 가지고 있기 때문에 동작합니다. 수신자와 메소드의 이름이 주어질 때, 러스트는 해당 메소드가 읽는지 (\u0026self) 혹은 변형시키는지 (\u0026mut self), 아니면 소비하는지 (self)를 결정론적으로 알아낼 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:11:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"더 많은 파라미터를 가진 메소드 implRectangle{fn area(\u0026self)-\u003e u32 {self.length*self.width}fn can_hold(\u0026self,other: \u0026Rectangle)-\u003e bool {self.length\u003eother.length\u0026\u0026self.width\u003eother.width}}fn main(){letrect1=Rectangle{length: 50,width: 30};letrect2=Rectangle{length: 40,width: 10};println!(\"Can rect1 hold rect2? {}\",rect1.can_hold(\u0026rect2));// Can rect1 hold rect2? true } ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:11:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"연관 함수 (associated functions) 다른 말로 static method impl 블록의 또다른 유용한 기능은 self 파라미터를 갖지 않는 함수도 impl 내에 정의하는 것이 허용된다는 점입니다. 이를 연관 함수 (associated functions) 라고 부르는데, 그 이유는 이 함수가 해당 구조체와 연관되어 있기 때문입니다. 이들은 메소드가 아니라 여전히 함수인데, 이는 함께 동작할 구조체의 인스턴스를 가지고 있지 않기 때문입니다. i.g. String::from() 연관 함수는 생성자로서 자주 사용됩니다. implRectangle{fn square(size: u32)-\u003e Rectangle{Rectangle{length: size,width: size}}}fn main(){letsq=Rectangle::square(3);} 연관 함수는 이용 가능한 인스턴스 없이 우리의 구조체에 특정 기능을 이름공간 내에 넣을 수 있도록 해줍니다. 6 Enums and Pattern Matching enum, match, Option, if let 6.1 Enum 정의하기 6.2 match 흐름제어 연산자 6.3 if let을 사용한 간결한 흐름 제어 ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:11:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"6.1 Enum 정의하기 Enum values Option 열거형이 Null 값 보다 좋은 점들. variants of the enum enum IpAddrKind{V4,V6,} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:12:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Enum Values struct Ipv4Addr{address: (u8,u8,u8,u8),...}struct Ipv6Addr{address: String,...}enum IpAddr{V4(Ipv4Addr),V6(Ipv6Addr),} Enum은 각 variants가 다른 유형의 타입들으로 저장할수도 있습니다. enum Message{Quit,Move{x: i32,y: i32 },Write(String),ChangeColor(i32,i32,i32),} Quit 은 연관된 데이터가 전혀 없습니다. (unit-like struct) Move 은 익명 구조체를 포함합니다. Write 은 하나의 String 을 포함합니다. (tuple structs) ChangeColor 는 세 개의 i32 을 포함합니다. (tuple structs) enum Message{Quit,Move{x: i32,y: i32 },Write(String),ChangeColor(i32,i32,i32),}implMessage{fn call(\u0026self){println!(\"called\");}}struct QuitMessage;// 유닛 구조체 struct MoveMessage{x: i32,y: i32,}struct WriteMessage(String);// 튜플 구조체 struct ChangeColorMessage(i32,i32,i32);// 튜플 구조체 fn main(){letm=Message::Write(String::from(\"hello\"));m.call();} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:12:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Option 열거형이 Null 값 보다 좋은 점들. 러스트는 다른 언어들에서 흔하게 볼 수 있는 null 특성이 없습니다. Null, 10억달러의 실수 by Tony Hoare 나는 그것을 나의 10억 달러의 실수라고 생각한다. 그 당시 객체지향 언어에서 처음 참조를 위한 포괄적인 타입 시스템을 디자인하고 있었다. 내 목표는 컴파일러에 의해 자동으로 수행되는 체크를 통해 모든 참조의 사용은 절대적으로 안전하다는 것을 확인하는 것이었다. 그러나 null 참조를 넣고 싶은 유혹을 참을 수 없었다. 간단한 이유는 구현이 쉽다는 것이었다. 이것은 수없이 많은 오류와 취약점들, 시스템 종료를 유발했고, 지난 40년간 10억 달러의 고통과 손실을 초래했을 수도 있다. // Rust std라이브러리에 정의되어 있는 Null 대체제 enum Option\u003cT\u003e{Some(T),None,}fn main{letsome_number=Some(5);letsome_string=Some(\"a string\");letabsent_number: Option\u003ci32\u003e=None;} 그럼 rust의 Option::None이 null 보다 나은 이유는 뭘까요? 간단하게 말하면, Option\u003cT\u003e 와 T (T 는 어떤 타입이던 될 수 있음)는 다른 타입이며, 컴파일러는 Option\u003cT\u003e 값을 명확하게 유효한 값처럼 사용하지 못하도록 합니다. letx: i8 =5;lety: Option\u003ci8\u003e=Some(5);letsum=x+y;// i8 + Option\u003ci8\u003e은 컴파일 에러. 이런 컴파일 에러 덕분에 null값이 더해지는 것을 방지할 수 있습니다. 다르게 얘기하자면, T 에 대한 연산을 수행하기 전에 Option\u003cT\u003e 를 T 로 변환해야 합니다. 일반적으로, 이런 방식은 null 과 관련된 가장 흔한 이슈 중 하나를 발견하는데 도움을 줍니다(실제로 null 일 때, if (x != null): 처럼 if 처리하는 경우입니다.) null 일 수 있는 값을 사용하기 위해서, 명시적으로 값의 타입을 Option 로 만들어 줘야 합니다. 그다음엔 값을 사용할 때 명시적으로 null 인 경우를 처리해야 합니다. 이를 통해 타입이 Option\u003cT\u003e 가 아닌 모든 곳은 값이 null 아니라고 안전하게 가정할 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:12:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"6.2 match 흐름제어 연산자 match의 힘은 패턴의 표현성으로부터 오며 컴파일러는 모든 가능한 경우가 다루어지는지를 검사합니다. enum Coin{Penny,Nickel,Dime,Quarter,}fn to_cents(coin: Coin)-\u003e u32 {matchcoin{Coin::Penny=\u003e1,Coin::Nickel=\u003e5,Coin::Dime=\u003e10,Coin::Quarter=\u003e25,}} match에서 갈래들은 arm이라고 합니다. match 표현식이 실행될 때, 결과 값을 각 갈래의 패턴에 대해서 순차적으로 비교합니다. match의 arm에서 코드부분이 짧다면, 중괄호는 보통 사용하지 않습니다. fn to_cents(coin: Coin)-\u003e u32 {matchcoin{Coin::Penny=\u003e{println!(\"Lucky penny!\");1},Coin::Nickel=\u003e5,Coin::Dime=\u003e10,Coin::Quarter=\u003e25,}} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:13:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"바인딩 arm의 또 다른 유용한 기능은 패턴과 매치된 값을 바인딩할 수 있다는 것입니다. #[derive(Debug)]// So we can inspect the state in a minute enum UsState{Alabama,Alaska,// ... etc }enum Coin{Penny,Nickel,Dime,Quarter(UsState),}fn to_cents(coin: Coin)-\u003e u32 {matchcoin{Coin::Penny=\u003e{println!(\"Lucky penny!\");1},Coin::Nickel=\u003e5,Coin::Dime=\u003e10,Coin::Quarter(state)=\u003e{println!(\"State quarter from {:?}!\",state);25},}}fn main(){to_cents(Coin::Quarter(UsState::Alaska));// State quarter from Alaska } ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:13:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Option\u003cT\u003e를 이용하는 매칭 fn plus_one(x: Option\u003ci32\u003e)-\u003e Option\u003ci32\u003e{matchx{None=\u003eNone,Some(i)=\u003eSome(i+1),}}letfive=Some(5);letsix=plus_one(five);letnone=plus_one(None); ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:13:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"_ placeholder letsome_u8_value=0u8;matchsome_u8_value{1=\u003eprintln!(\"one\"),3=\u003eprintln!(\"three\"),5=\u003eprintln!(\"five\"),7=\u003eprintln!(\"seven\"),_=\u003e(),} _ 패턴은 어떠한 값과도 매칭 될 것입니다. _는 명시하지 않은 모든 가능한 경우에 대해 매칭 될 것입니다. ()는 단지 단위 값이므로, _ 케이스에서는 어떤 일도 일어나지 않을 것입니다. match 표현식은 단 한 가지 경우에 대해서만 고려하는 경우 장황할 수 있습니다. 이러한 상황을 위하여, 러스트는 if let을 제공합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:13:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"6.3 if let을 사용한 간결한 흐름 제어 if와 let을 조합하여 하나의 패턴만 매칭 시키고 나머지 경우는 무시하는 값을 다루는 경우 사용. if let은 match문법의 syntax sugar입니다. before letsome_u8_value=Some(0u8);matchsome_u8_value{Some(3)=\u003eprintln!(\"three\"),_=\u003e(),} after: if let ifletSome(3)=some_u8_value{println!(\"three\");} else사용 letmutcnt=0;ifletCoin::Quarter(state)=coin{println(\"State quarter from {:?}!\",state);}else{cnt+=1;} 7. Module mod와 파일 시스템 pub로 visibility 제어하기 use로 이름 가져오기 ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:14:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"7-1. mod와 파일 시스템 src/lib.rs mod client;// 모듈을 선언만 한 경우 // 정의(impl)는 다른 파일에서 찾으라고 컴파일러에게 말합니다. mod network; 러스트는 기본적으로 src/lib.rs만 찾아볼줄 압니다. 최초 진입점. src/client.rs fn connect(){} src/network.rs fn connect(){}mod server{fn connect(){}} 만약 network의 하위 모듈인 server를 분리하고 싶다면 $ mkdir src/network $ mv src/network.rs src/network/mod.rs $ mv src/server.rs src/network // 모듈 레이아웃 communicator ├── client └── network └── server // 파일 레이아웃 ├── src │ ├── client.rs │ ├── lib.rs │ └── network │ ├── mod.rs │ └── server.rs 이렇게 복잡한 과정이 필요한 이유는 다음과 같은 상황일 경우가 생길 수 있기 때문입니다. src/lib.rs // 모듈 계층구조 communicator ├── client └── network └── client 3개의 모듈 client network network::client 이제 구현 부분을 src/client.rs src/network.rs 만 하게 될 경우 client와 서브모듈인 network::client를 구분하기 힘듭니다. 따라서, network 모듈의 network::client 서브모듈을 위한 파일을 추출하기 위해서는 src/network.rs 파일 대신 network 모듈을 위한 디렉토리를 만들 필요가 있습니다. network 모듈 내의 코드는 그후 src/network/mod.rs 파일로 가고, 서브모듈 network::client은 src/network/client.rs 파일을 갖게할 수 있습니다. 이제 최상위 층의 src/client.rs는 모호하지 않게 client 모듈이 소유한 코드가 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:15:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"모듈 파일 시스템의 규칙 만일 foo라는 이름의 모듈이 서브모듈을 가지고 있지 않다면, foo.rs라는 이름의 파일 내에 foo에 대한 선언을 집어넣어야 합니다. 만일 foo가 서브모듈을 가지고 있다면, foo/mod.rs라는 이름의 파일에 foo에 대한 선언을 집어넣어야 합니다. ├──foo│├──bar.rs(containsthedeclarationsin`foo::bar`)│└──mod.rs(containsthedeclarationsin`foo`,including`modbar`) ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:15:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"7-2. pub로 visibility 제어하기 러스트의 모든 코드의 기본 상태는 비공개(private)입니다. 이는 module에도 적용됩니다. pubmod client;//public mod 선언 mod network;// private mod 선언 당연한 말이지만 라이브러리를 만들때, api로 사용되는 코드들은 pub로 열어주어야 타 사용자들이 re-use(재샤용)할 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:16:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"private의 visibility 규칙 만일 어떤 아이템이 공개(pub)라면, 이는 부모 모듈의 어디에서건 접근 가능합니다. 만일 어떤 아이템이 비공개라면, 같은 파일 내에 있는 부모 모듈 이 부모의 자식 모듈에서만 접근 가능합니다. // src/lib.rs mod outermost{pubfn middle_function(){}fn middle_secret_function(){}mod inside{pubfn inner_function(){}fn secret_function(){}}}fn try_me(){outermost::middle_function();// (o) outermost::middle_secret_function();// (x), 컴파일 에러 outermost::inside::inner_function();// (x), outermost에 의해서만 접근할 수 있습니다. outermost::inside::secret_function();// (x) } 비록 outermost 모듈이 private이지만, try_me와 같은 루트 모듈안에 존재하기 때문에, try_me가 outermost를 접근할 수 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:16:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"7-3. use로 외부 네임스페이스 가져오기 pubmod a{pubmod series{pubmod of{pubfn nested_modules(){}}}}fn main(){a::series::of::nested_modules();} 완전하게 경로를 지정한 모듈을 참조하는 건, 이름이 너무 길어질 수 있습니다. 이를 간결하게 해주기 위해 러스트는 use라는 키워드를 도입하였습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:17:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"use를 이용해 간결하게 가져오기 pubmod a{pubmod series{pubmod of{pubfn nested_modules(){}}}}usea::series::of;fn main(){of::nested_modules();} 열거형 또한 모듈과 비슷한 일종의 namespace를 형성하고 있기 때문에, 열거형의 variant 또한 use를 이용하여 가져올 수 있습니다. enum TrafficLight{Red,Yellow,Green,}useTrafficLight::{Red,Yellow};fn main(){letred=Red;letgreen=TrafficLight::Green;} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:17:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"*를 이용해 glob(전체) 가져오기 네임스페이스 안에 모든 아이템을 가져오기 위해서는 * 문법을 이용할 수도 있습니다. 명시적으로 사용되는 것이 아닌 만큼 naming conflict가 생길 수 있으니, 조심해야 합니다. usestd::fmt;useTrafficLight::*;enum TrafficLight{Red,Yellow,Green,}implfmt::DebugforTrafficLight{fn fmt(\u0026self,f: \u0026mutfmt::Formatter)-\u003e fmt::Result{write!(f,\"{:?}\",self)}}implfmt::DisplayforTrafficLight{fn fmt(\u0026self,f: \u0026mutfmt::Formatter)-\u003e fmt::Result{write!(f,\"{:?}\",self)}}fn main(){letred=Red;letyellow=Yellow;println!(\"{:?}, {:?}\",red,yellow);// warning: variant `Green` is never constructed } 또한 위의 경우를 보면, glob import를 시행하였지만, Green never constructed 경고가 발생할 수 있다. 즉 모든 아이템을 import하였지만 let green = Green;을 하지 않았기 때문에 발생한 친절한 경고인 것이다. 8. Collection vector string hashmap std collection in detail ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:17:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"8.1 Vector 벡터는 같은 타입의 값만을 저장할 수 있습니다. 벡터는 동적입니다, // 선언만 제공 letv: Vec\u003ci32\u003e=Vec::new();// 값과 함께 선언 letv=vec![1,2,3]; 벡터는 제네릭(generic)을 이용하여 구현되었습니다. 즉 선언시점에 벡터는 Type을 알려주어야 합니다. struct와 마찬가지로 벡터도 스코프 밖으로 벗어났을 때 해제됩니다. {letv=vec![1,2,3,4];}// 벡터 v free된다. 벡터가 드롭될 때 벡터의 내용물 또한 전부 드롭되는데, 이는 벡터가 가지고 있는 정수들이 모두 제거된다는 의미입니다. 만약 struct를 담는 벡터의 경우에는? 이를 테스트해보기 위해 상위 scope에 struct를 선언해두고 inner scope에서 vector를 선언한 뒤 inner scope에서 vector가 해제될 때, 상위 scope에 선언된 strct는 어떻게 될지? #[derive(Debug)]struct User{is_active: bool,}fn main(){letis_gc_user=User{is_active: false};println!(\"{:?}\",is_gc_user);// User { is_active: false } {letmutv=vec![User{is_active: true},User{is_active: true}];v.push(is_gc_user);// moved is_gc_user foruinv.iter(){print!(\"{:?}\",u.is_active);// true true false }println!(\"{:?}\",v.len());// 3 }println!(\"{:?}\",is_gc_user);// error[E0382]: borrow of moved value: `is_gc_user` } 마지막 println!(\"{:?}\", is_gc_user);에서 컴파일 에러가 나타납니다. 즉 상위 scope에 있는 구조체는 inner scope로 move되어, }가 실행될 때 해제됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:18:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"벡터의 요소들 읽기 벡터 속 element를 읽을 수 있는 방법은 총 2가지 입니다. \u0026와 [숫자] .get() letv=vec![1,2,3,4,5];letthird: \u0026i32 =\u0026v[2];letthird: Option\u003c\u0026i32\u003e=v.get(2); ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:18:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"유효하지 않은 참조자 letmutv=vec![1,2,3,4,5];letfirst=\u0026v[0];v.push(6);// error[E0502]: cannot borrow `v` as mutable because it is also borrowed as // immutable 이 에러에 대한 내막은 벡터가 동작하는 방법 때문입니다: 새로운 요소를 벡터의 끝에 추가하는 것은 새로 메모리를 할당하여 예전 요소를 새 공간에 복사하는 일을 필요로 할 수 있는데, 이는 벡터가 모든 요소들을 붙여서 저장할 공간이 충분치 않는 환경에서 일어날 수 있습니다. 이러한 경우, 첫번째 요소에 대한 참조자는 할당이 해제된 메모리를 가리키게 될 것입니다. 빌림 규칙은 프로그램이 이러한 상황에 빠지지 않도록 해줍니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:18:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"벡터 내의 값들 변경 letmutv=vec![100,32,57];foriin\u0026mutv{*i+=50;} mut ref(가변 참조자, \u0026mut)가 참고하고 있는 값을 바꾸기 위해서, i에 += 연산자를 이용하기 전에 역참조 연산자 (*)를 사용하여 값을 얻어야 합니다. Rust's Order of expression 위 코드의 경우에는 left-to-right입니다. The operands of these expressions are evaluated prior to applying the effects of the expression. Expressions taking multiple operands are evaluated left to right as written in the source code. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:18:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"열거형을 사용하여 여러 타입을 저장하기 enum SpreadsheetCell{Int(i32),Float(f64),Text(String),}letrow=vec![SpreadsheetCell::Int(3),SpreadsheetCell::Text(String::from(\"blue\")),SpreadsheetCell::Float(10.12),]; 러스트가 컴파일 타임에 벡터 내에 저장될 타입이 어떤 것인지 알아야할 필요가 있는 이유는 각 요소를 저장하기 위해 얼만큼의 힙 메모리가 필요한지 알기 위함입니다. 부차적인 이점은 이 백터에 허용되는 타입에 대해 명시적일 수 있다는 점입니다. 만약 런타임에 벡터에 저장하게 될 타입의 모든 경우를 알지 못하는 경우, 열거형은 사용할 수 없기 때문에 이를 위하여 trait object라는 것이 있습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:18:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"8.2 String Rust의 스트링은 총 3가지를 지칭합니다. String (Struct std::string::String struct 타입) \u0026str (스트링 슬라이스, 스트링 리터럴) primitive type str letmuts=String::new();lets=\"hello world\".to_string();lets=String::from(\"hello world\");lethello=String::from(\"안녕하세요\");// utf-8 based ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:19:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"+연산자 fn main(){lets1=String::from(\"Hello, \");lets2=String::from(\"world!\");// 우리는 1. String + \u0026str만 더할 수 있고 // 다음 조건들은 더하지 못합니다. (컴파일 에러) // (x) String + String // (x) \u0026str + \u0026str -\u003e lets3=s1+\u0026s2;// s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요 println!(\"{s1}\");// error[E0382]: borrow of moved value: `s1` } let s3 = s1 + \u0026s2;은 String + \u0026String 타입인데, 반하여 실제 +의 구현체를 보면 fn add(self,s: \u0026str)-\u003e String {} 라는 것 (2번째 인자가 \u0026str 타입)을 알 수 있습니다. \u0026String이 \u0026str로 타입 처리가 되는 이유는 러스트의 deref coercion(역참조 강제) 기능 덕분입니다. 만약 어떤 파라미터도 소유권을 넘기지 않는 방식으로 concat을 하고 싶다면 format!()을 사용하면 됩니다. lets1=String::from(\"tic\");lets2=String::from(\"tac\");lets3=String::from(\"toe\");lets=format!(\"{}-{}-{}\",s1,s2,s3); ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:19:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"String Indexing rust는 스트링 인덱싱을 허용하지 않습니다. lets1=String::from(\"hello\");leth=s1[0];// error: the trait bound `std::string::String: std::ops::Index\u003c_\u003e` is not satisfied [--explain E0277] 이를 이해하기 위해서는 rust가 스트링을 내부적으로 메모리에 저장하는 방식을 알아야합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:19:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"String의 내부적 표현 Rust가 String indexing을 에러처리하는 이유 String은 Vec\u003cu8\u003e을 감싼 것입니다(wrapper). String의 UTF-8로 인코딩된 글자 수와, 실제 각 char이 차지하는 바이트(1~4byte/ 문자 당)의 차이가 있습니다. fn main(){lets1=\"ynte\";// 1byte per char lets2=\"уйте\";// 2byte per char lets3=\"ㄱㄴㄷㄹ\";// 3byte per char lets4=\"ㅏㅑㅗㅛ\";// 3byte per char lets5=\"🌱🌱🌱🌱\";// 4byte per char // 4, 8, 12, 12, 16 println!(\"{}, {}, {}, {}, {}\",s1.len(),s2.len(),s3.len(),s4.len(),s5.len());} 이런 모호함을 방지하기 위해, String의 index 접근을 컴파일 에러로 처리합니다. 추가로 러스트가 String indexing을 에러 처리하는 또 하나의 이유는 인덱스 연산은 O(1) 즉 Constant Complexity를 제공하기 위해서입니다. 하지만 스트링 내에 얼마나 많은 유효 문자(valid characters, 예를 들면 힌두어에서 ‘े’는 발음 구별 부호로 그 자체로는 이해할 수 없는 char입니다)가 있는지 시작 지점부터 인덱스로 지정된 곳까지 훑어야 하기 때문입니다. 그래도 panic을 감수하고 서라도, 정말 스트링 슬라이스를 써야 한다면 string slice를 명시적으로 사용하면 됩니다. letliteral=\"йте\";letc=\u0026literal[0..2];//й indexing 잘못한다면 프로그램을 죽일 수 있습니다. thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'й' (bytes 0..2) of `йте`', src/main.rs:4:15 또한 만일 String에 대해, 개별 char에 접근하길 원한다면 indexing대신 loop를 사용할 수 있습니다. fn main(){forcin\"ㅏㅑ가나다뷁\".chars(){println!(\"{}\",c);}}// ㅏ // ㅑ // 가 // 나 // 다 // 뷁 Rust에서는 이렇게 복잡하게 스트링을 관리함으로써 handle errors involving non-ASCII characters later in your development life cycle.해줍니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:19:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"8.3 HashMap usestd::collections::HashMap;letmutscores=HashMap::new();scores.insert(\"Blue\",10);scores.insert(\"Yellow\",50); zip과 collect()을 통한 init usestd::collections::HashMap;fn main(){letteams=vec![\"Blue\",\"Yellow\"];letinitial_scores=vec![10,50];letscores=teams.iter().zip(initial_scores.iter());// (\"Blue\", 10) // (\"Yellow\", 50) // for e in scores { // println!(\"{:?}\", e); // } letscores_table: HashMap\u003c_,_\u003e=scores.collect();println!(\"{:#?}\",scores_table);// { // \"Blue\": 10, // \"Yellow\": 50, // } } .zip을 하게 되면 (키, 값) 튜플이 만들어지게 되고, 이를 collect()하게 되면 hashMap을 반환합니다. 이때 hash table에 대해서 타입을 명시해주어야 합니다. HashMap\u003c_, _\u003e을 사용하게 되면, 러스트는 벡터에 담긴 데이터의 타입에 기초하여 해쉬에 담길 타입을 추론할 수 있습니다. .collect(): 튜플 -\u003e hashMap .zip(): iter, iter -\u003e tuple ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:20:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"해쉬맵의 소유권처리 i32와 같이 Copy 트레잇을 구현한 타입: 그 값들은 해쉬맵 안으로 복사 String같이 소유된 값: 소유권 move \u0026str타입은 copy usestd::collections::HashMap;fn main(){letk=\"Favorite color\";// \u0026str type letv=\"Blue\";letmutmap=HashMap::new();map.insert(k,v);println!(\"{k}, {v}\");//문제 없음 } borrow되어 k,v는 사용할 수 없게 됩니다. {letk=String::from(\"Favorite color\");letv=String::from(\"Blue\");..map.insert(k,v);println!(\"{k}, {v}\");// error[E0382]: borrow of moved value: `k` } ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:20:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"HashMap Update key에 할당된 값이 없을 경우에만 업데이트 원할 경우 usestd::collections::HashMap;letmutscores=HashMap::new();scores.insert(String::from(\"Blue\"),10);scores.entry(String::from(\"Yellow\")).or_insert(50);scores.entry(String::from(\"Blue\")).or_insert(50);println!(\"{:?}\",scores); 9. Error Handling \u003cRust like error handling in python\u003e Rust에서 에러는 2가지 종류가 존재합니다. recoverable error unrecoverable error 2번은 버그를 알기 위해 필요하며, 1번의 경우에는 합리적으로 필요한 에러 즉 개발자가 코드로 대응할 에러를 뜻합니다. 러스트에서는 go처럼 exception 메커니즘을 사용하지 않습니다. recoverable error는 Result\u003cT,E\u003e를 사용 unrecoverable error는 panic! 매크로를 사용합니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:20:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"9-1. Panic! panic!은 기본적으로 unwinding을 사용합니다. 즉 패닉을 마주하면, 프로그램은 해당 함수로 부터 스택을 거꾸로 훑어가면서 데이터를 제거하는데 이 과정에서 비교적 많은 연산을 사용합니다. 만약 훑어가기와 데이터 제거 없이 프로그램을 그냥 종료하고 싶다면 panic 정책을 abort로 하면 됩니다. 이 경우, panic을 마주하면 프로그램을 바로 종료합니다. # Cargo.toml [profile.release] panic = `'a`bort' ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:21:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"9-2. Result\u003cT,E\u003e Result\u003cT,E\u003e를 match를 활용해서 처리하는 방법 usestd::fs::File;usestd::io::ErrorKind;fn main(){letf=File::open(\"hello.txt\");letf=matchf{Ok(file)=\u003efile,// match guard를 사용 Err(referror)iferror.kind()==ErrorKind::NotFound=\u003ematchFile::create(\"hello.txt\"){Ok(fc)=\u003efc,Err(e)=\u003e{panic!(\"Tried to create file but there was a problem: {:?}\",e)}},Err(error)=\u003e{panic!(\"There was a problem opening the file: {:?}\",error)}};} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:22:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"unwarp와 expect match의 syntax sugar들인 unwarp와 expect를 사용하여 Result를 핸들링할 수도 있습니다. unwrap(): Result의 값이 Err variant라면 자동으로 panic!처리 expect(): unwrap()과 동일하지만, panic 에러 메시지 추가할 수 있습니다. // unwrap() usestd::fs::File;fn main(){letf=File::open(\"hello.txt\").unwrap();} // expect() usestd::fs:File;fn main(){letf=File::open(\"hello.txt\").expect(\"Failed to open hello.txt\");} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:22:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"에러 전파하기 match를 이용한 에러전파 usestd::fs::File;usestd::io;usestd::io::Read;fn read_file(name: \u0026str)-\u003e Result\u003cString,io::Error\u003e{letf=File::open(name);letmutf=matchf{Ok(file)=\u003efile,Err(e)=\u003ereturnErr(e),};letmuts=String::new();matchf.read_to_string(\u0026muts){Ok(_)=\u003eOk(s),Err(e)=\u003eErr(e),}}fn main(){letr=read_file(\"hello.txt\");matchr{Ok(_)=\u003etodo!(),Err(e)=\u003eprintln!(\"{}\",e.to_string()),}} 러스트에서는 위의 패턴을 지원하기 위한 syntax sugar(숏컷)로 ?가 있습니다. usestd::io;usestd::io::Read;usestd::fs::File;fn read_file(name: \u0026str)-\u003e Result\u003cString,io::Error\u003e{letmutf=File::open(name)?;letmuts=String::new();f.read_to_string(\u0026muts)?;Ok(s)} match 표현식과 물음표 연산자가 수행하는 한 가지 차이점은 물음표 연산자를 사용할 때 에러 값들이 표준 라이브러리 내에 있는 From 트레잇에 정의된 from 함수를 hit(call)한다는 것입니다. 또한 ?는 에러가 발생하면 그 즉시 해당 함수 scope를 벗어나 err를 return합니다. 아래 테스트를 보면 fn read_file(name: \u0026str)-\u003e Result\u003cString,io::Error\u003e{println!(\"Start read_file\");letmutf=File::open(name)?;println!(\"If error this will not be called\");letmuts=String::new();f.read_to_string(\u0026muts)?;Ok(s)}fn main(){letr=read_file(\"hello.txt\");matchr{Ok(_)=\u003etodo!(),Err(e)=\u003eprintln!(\"{}\",e.to_string()),}} 다음과 같이 에러가 발생하면 “If error this will not be called” 부분을 실행하지 않습니다. 이는 match 코드에서도 Err(e) =\u003e return Err(e) 가 구현된 부분으로 동일합니다. Start read_file No such file or directory (os error 2) ? changing 체이닝을 통해서 에러를 더욱 pretty하게 처리할 수 있습니다. usestd::io;usestd::io::Read;usestd::fs::File;fn read_username_from_file()-\u003e Result\u003cString,io::Error\u003e{letmuts=String::new();File::open(\"hello.txt\")?.read_to_string(\u0026muts)?;Ok(s)} ?는 Result를 반환하는 함수에서만 사용될 수 있습니다. 즉 위의 특성때문에 ()를 반환하는 main() {} 함수에서는 ?를 사용할 수 없습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:22:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"9-3. 예외처리 가이드라인 panic(unwrap, expect)을 일으켜도 좋다고 생각되는 상황들은 다음과 같습니다. 테스트, 프로토타입 코드 컴파일러보다 여러분이 더 많은 정보를 가지고 있을 때 usestd::net::IpAddr;// 이 경우에는 127.0.0.1이 에러 나지 않을 것을 개발자는 안다. lethome=\"127.0.0.1\".parse::\u003cIpAddr\u003e().unwrap(); ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:23:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"유효성을 검사하는 커스텀 타입 생성하는 방법 pubstruct Guess{value: u32,}implGuess{pubfn new(value: u32)-\u003e Guess{ifvalue\u003c1||value\u003e100{panic!(\"Guess value must be between 1 and 100, but got {}.\",value);}Guess{value}}// struct의 value필드는 private이기 때문에, Getter pubfn value(\u0026self)-\u003e u32 {self.value}} 10. 제너릭, 트레잇, 라이프타임 10.1 제너릭 10.2 트레잇: 공유 동작을 정의하기 10.3 라이프타임을 이용한 참조자 유효화 제너릭은 다양한 타입들에 대해서 공통점들을 추상화 시켜서 코드를 줄이는 방법이고, 트레잇은 동작을 제네릭 한 방식으로 정의하는 방법을 말합니다. 트레잇을 통해서 특정 제너릭 타입에 대하여 특정 동작을 하는 타입으로 강제할 수 있습니다. 라이프타임은 제너릭의 일종으로 컴파일러에게 참조자들이 서로에게 어떤 연관이 있는지에 대한 정보를 줄 수 있도록 합니다. 라이프타임을 통해 “수많은 상황에서 값을 빌릴 수 있도록 허용해 주고도 여전히 참조자들이 유효할지를 컴파일러가 검증하도록 해줄 수 있습니다.” ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:23:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"10.1 제너릭 T로 제너릭을 표현하는 것은 관례상 사용하는 것입니다. 즉 문법적 강제가 없습니다. generic before fn largest_i32(list: \u0026[i32])-\u003e i32 {letmutlargest=list[0];for\u0026iteminlist.iter(){ifitem\u003elargest{largest=item;}}largest}fn largest_char(list: \u0026[char])-\u003e char {letmutlargest=list[0];for\u0026iteminlist.iter(){ifitem\u003elargest{largest=item;}}largest}fn main(){letnumbers=vec![34,50,25,100,65];letresult=largest_i32(\u0026numbers);println!(\"The largest number is {}\",result);letchars=vec!['y','m',`'a`','q'];letresult=largest_char(\u0026chars);println!(\"The largest char is {}\",result);} after first try. // error[E0369]: binary operation `\u003e` cannot be applied to type `T` fn largest\u003cT\u003e(list: \u0026[T])-\u003e T{letmutlargest=list[0];for\u0026iteminlist.iter(){ifitem\u003elargest{largest=item;}}largest}fn main(){letnumbers=vec![34,50,25,100,65];letresult=largest(\u0026numbers);println!(\"The largest number is {}\",result);letchars=vec!['y','m',`'a`','q'];letresult=largest(\u0026chars);println!(\"The largest char is {}\",result);} 위 코드를 컴파일하면 std::cmp::PartialOrd라는 트레잇을 언급합니다. 이를 해결할 수 있는 방법은 10.2에서 다루겠습니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:24:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"구조체에서 제너릭 struct Point\u003cT\u003e{x: T,y: T,} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:24:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Enum에서 제너릭 enum Result\u003cT,E\u003e{Ok(T),Err(E),} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:24:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"메소드에서 제너릭 #[derive(Debug)]struct Point\u003cT,U\u003e{x: T,y: U,}impl\u003cT,U\u003ePoint\u003cT,U\u003e{fn mix_diff\u003cV,W\u003e(self,other: Point\u003cV,W\u003e)-\u003e Point\u003cT,W\u003e{Point{x: self.x,y: other.y,}}fn mix(self,other: Point\u003cT,U\u003e)-\u003e Point\u003cT,U\u003e{Point{x: self.x,y: other.y,}}}fn main(){letp1=Point{x: 1,y: 99.9};letp2=Point{x: \"Hello\",y: 'c' };letdiff_type=Point{x: 5,y: 10.4}.mix_diff(p2);println!(\"{:#?}\",diff_type);letsame_type=Point{x: 5,y: 10.4}.mix(p1);println!(\"{:#?}\",same_type);println!(\"{:#?}\",Point{x: 5,y: 10.4}.mix_diff(Point{x: 1,y: 99.9}));} Point { x: 5, y: 'c', } Point { x: 5, y: 99.9, } Point { x: 5, y: 99.9, } ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:24:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"제너릭 타입 성능(런타임 비용) 러스트는 제네릭 파라미터 대신 구체적인 타입을 명시했을 때와 비교해 전혀 느려지지 않습니다. Finally, while Rust’s preferred strategy of monomorphising generics (ala C++) produces fast code, it demands that significantly more code be generated than other translation strategies. Rust programmers can use trait objects to trade away this code bloat by using dynamic dispatch instead. (in Rust faq part) 러스트는 컴파일 타임에 제네릭을 사용하는 코드에 대해 단형성화(monomorphization) 를 수행함으로써 이러한 성능을 이루어 냈습니다. 단형성화란 제네릭 코드를 실제로 채워질 구체적인 타입으로 된 특정 코드로 바꾸는 과정을 말합니다. 러스트 컴파일러는 제네릭 코드가 호출되는 모든 곳을 살펴보고 제네릭 코드가 호출될 때 사용된 구체적인 타입에 대한 코드를 생성합니다. 즉 만약, 아래와 같은 코드가 존재한다면 before compile fn main(){letinteger=Some(5);letfloat=Some(5.0);} after compile enum Opiton_i32{Some(i32),None,}enum Opiton_f64{Some(f64),None,}fn main(){letinteger=Opiton_i32::Some(5);letfloat=Opiton_f64::Some(5.0);} 위와 같은 코드를 컴파일 타임에 만들어냅니다. 그러므로 타 언어에 비해 바이너리 파일은 커지겠지만, 런타임 퍼포먼스는 아무런 손해없이 제너릭을 사용할 수 있습니다. 이런 컴파일 기능을 단형성화(monomorphization)라고 부릅니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:24:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"10.2 트레잇: 공유 동작을 정의하기 트레잇은 다른 언어들에서 ‘인터페이스(interface)‘라고 부르는 기능과 유사하지만, 몇 가지 다른 점이 있습니다. 트레잇은 타입들이 공통적으로 갖는 동작에 대하여 추상화하도록 해줍니다. 트레잇(trait)은 러스트 컴파일러에게 특정한 타입이 다른 타입들과 함께 공유할 수도 있는 기능에 대해 말해줍니다. trait 정의 (lib.rs with aggregator crate) pubtraitSummary{fn summary(\u0026self)-\u003e String;} trait impl (lib.rs with aggregator crate) pubstruct News{pubheadline: String,publocation: String,pubauthor: String,pubcontent: String,}pubstruct Tweet{pubusername: String,pubcontent: String,pubreply: bool,pubretweet: bool,}// impl 강제 with trait implSummaryforNewsArticle{fn summary(\u0026self)-\u003e String {format!(\"{}, by {} ({})\",self.headline,self.author,self.location)}}implSummaryforTweet{fn summary(\u0026self)-\u003e String {format!(\"{}: {}\",self.username,self.content)}} other file // You do not need to write extern crate anymore for external dependencies in Rust 2018. // 여기에서는 아래와 같은 코드가 필요없어진다. // extern crate aggregator; // use aggregator::Summarizable; useaggregator::{Summary,Tweet};fn main(){lettweet=Tweet{username: String::from(\"horse_ebooks\"),content: String::from(\"of course, as you probably already know, people\",),reply: false,retweet: false,};println!(\"1 new tweet: {}\",tweet.summarize());} Orphan rule(고아 규칙) 트레잇 구현과 함께 기억할 한 가지 제한사항이 있습니다: 트레잇 혹은 타입이 우리의 크레이트 내의 것일 경우에만 해당 타입에서의 트레잇을 정의할 수 있습니다. 바꿔 말하면, 외부의 타입에 대한 외부 트레잇을 구현하는 것은 허용되지 않습니다. 간단하게 말하면, 부모 타입이 존재하지 않기 때문에 고아 규칙이라고 부릅니다. 이 규칙이 없다면, 두 크레이트는 동일한 타입에 대해 동일한 트레잇을 구현할 수 있게 되고, 이 두 구현체가 충돌을 일으킬 것입니다: 러스트는 어떤 구현을 이용할 것인지 알지 못할 것입니다. 러스트가 고아 규칙을 강제하기 때문에, 다른 사람의 코드는 여러분의 코드를 망가뜨리지 못하고 반대의 경우도 마찬가지입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:25:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Trait Bound 이제 method가 아닌 trait을 받아들이는 fn을 만들어봅니다. pubfn notify\u003cT: Summary\u003e(itemT){println!(\"Breaking news! {}\",item.summary());} +를 이용하면 하나의 제네릭 타입에 대해 여러 개의 트레잇 바운드를 특정할 수 있습니다. fn some_function\u003cT: Display+Clone,U: Clone +Debug\u003e(t: \u0026T,u: \u0026U)-\u003e i32 { ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:25:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Where 위의 some_function을 where이라는 syntax를 사용하면 더욱 가시성을 확보해서 코딩할 수 있습니다. we can use a where clause, like this: after where fn some_function\u003cT,U\u003e(t: \u0026T,u: \u0026U)-\u003e i32 whereT: Display+Clone,U: Clone +Debug{} where 뒤쪽으로 trait bound를 이동시켜서, 함수를 더 잘 읽을 수 있도록 해주었습니다. 이제 아래와 같은 largest 함수를 trait bound를 사용해 고쳐보겠습니다. before fn largest\u003cT\u003e(list: \u0026[T])-\u003e T{letmutlargest=list[0];for\u0026iteminlist.iter(){ifitem\u003elargest{largest=item;}}largest} 1st try fn largest\u003cT: PartialOrd\u003e(list: \u0026[T])-\u003e T{}// error[E0508]: cannot move out of type `[T]`, a non-copy array after(완성본) fn largest\u003cT: PartialOrd +Copy\u003e(list: \u0026[T])-\u003e T{letmutlargest=list[0];for\u0026iteminlist{ifitem\u003elargest{largest=item}}largest}// where 사용한 경우 fn largest\u003cT\u003e(list: \u0026[T])-\u003e TwhereT: PartialOrd +Copy,{letmutlargest=list[0];for\u0026iteminlist{ifitem\u003elargest{largest=item}}largest}// main() fn main(){letnumbers=vec![34,50,25,100,65];letresult=largest(\u0026numbers);println!(\"The largest number is {}\",result);letchars=vec!['y','m','a','q'];letresult=largest(\u0026chars);println!(\"The largest char is {}\",result);} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:25:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Using Trait Bounds to Conditionally Implement Methods 조건에 따라 Trait Bound를 다르게하여 method를 정의할 수도 있습니다. usestd::fmt::Display;struct Pair\u003cT\u003e{x: T,y: T,}impl\u003cT\u003ePair\u003cT\u003e{fn new(x: T,y: T)-\u003e Self{Self{x,y}}}impl\u003cT: Display+PartialOrd\u003ePair\u003cT\u003e{fn cmp_display(\u0026self){ifself.x\u003e=self.y{println!(\"The largest member is x = {}\",self.x);}else{println!(\"The largest member is y = {}\",self.y);}}} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:25:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"10.3 라이프타임을 이용한 참조자 유효화 러스트에서 모든 reference는 lifetime을 가지며, 이는 reference가 유효할 수 있는 scope를 뜻합니다. Lifetime의 주 목적은 dangling reference(댕글링 참조자)를 방지하는 것입니다. 아래는 댕글링 참조자를 임의로 만들어본 코드입니다. {letr;{letx=5;r=\u0026x;}// 로컬 변수 x는 이 scope에서 free되며 r은 x를 가리키고 있습니다. (dangling reference) println!(\"{r}\");// error: `x` does not live long enough } 에러가 발생하는 것을 알 수 있는데요, 그럼 러스트 컴파일러는 위와 같은 상황을 어떻게 알아차릴까요? ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:0","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Borrow Checker borrow checker(검사기)는 컴파일러의 한 부분으로, 모든 borrow가 유효한지를 검사하며, 이때 scope를 기준으로 유효성을 판단합니다. {letr;// -------+-- `'a` // | {// | letx=5;// -+-----+-- 'b r=\u0026x;// | | }// -+ | // | println!(\"r: {}\",r);// | // | // -------+ } r의 lifetime인 'a는 'b에 비하여 더 큰 lifetime을 가지고 있는데, 더 작은 lifetime인 'b를 r에 assign하려 하기 때문에 컴파일에러를 일으킵니다. 다시 말해, reference와 reference가 가리키는 대상 총 2가지가 있는데 reference \u003e reference가 가리키는 대상인 경우 에러를 일으킵니다. 이를 흔히 댕글링 포인터라고 부릅니다. (reference, 포인터는 살아있는데 가리키고 있는 본질이 free된 경우) ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:1","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"함수에서 제너릭의 라이프타임 fn longest(x: \u0026str,y: \u0026str)-\u003e \u0026str {ifx.len()\u003ey.len(){x}else{y}}fn main(){letstring1=String::from(\"abcd\");letstring2=\"xyz\";letresult=longest(string1.as_str(),string2);println!(\"The longest string is {}\",result);} error[E0106]: missing lifetime specifier | 1 | fn longest(x: \u0026str, y: \u0026str) -\u003e \u0026str { | ^ expected lifetime parameter | = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y` 이 도움말은 반환 타입에 대하여 제네릭 라이프타임 파라미터가 필요하다는 것을 말해주고 있는데, 왜냐하면 반환되는 참조자가 x를 참조하는지 혹은 y를 참조하는지를 러스트가 말할 수 없기 때문입니다. 사실, 우리 또한 모르는데, 이 함수의 본체 내의 if 블록은 x의 참조자를 반환하고 else 블록은 y의 참조자를 반환하기 때문입니다. 우리가 이 함수를 정의하고 있는 시점에서, 우리는 이 함수에 넘겨지게 될 구체적인 값을 모르므로, if 케이스가 실행될지 혹은 else 케이스가 실행될지는 알 수 없습니다. 또한 함수에 넘겨지게 될 참조자의 구체적인 라이프타임을 알지 못하므로, 우리가 반환하는 참조자가 항상 유효한지를 결정하기 위해서 Listing 10-17과 10-18에서 했던 것과 같이 스코프를 살펴볼 수도 없습니다. 빌림 검사기 또한 이를 결정할 수 없는데, 그 이유는 x와 y의 라이프타임이 반환 값의 라이프타임과 어떻게 연관되어 있는지 알지 못하기 때문입니다. 우리는 참조자들 간의 관계를 정의하는 제네릭 라이프타임 파라미터를 추가하여 빌림 검사기가 분석을 수행할 수 있도록 할 것입니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:2","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"explicit lifetime 사실 라이프타임은 implicit하게 동작하고 있기 때문에, 평소에는 코드에 작성할 필요없지만, 위의 코드와 같이 컴파일 타임에 lifetime이 어떻게 될지 알 수 없는 경우에는 explicit하게 lifetimedmf 명시 해야합니다. 라이프타임 명시는 연관된 참조자가 얼마나 오랫동안 살게 되는지를 바꾸지는 않습니다. 함수의 시그니처가 제네릭 타입 파라미터를 특정할 때 이 함수가 어떠한 타입이든 허용할 수 있는 것과 같이, 함수의 시그니처가 제네릭 라이프타임 파라미터를 특정할 때라면 이 함수는 어떠한 라이프타임을 가진 참조자라도 허용할 수 있습니다. 라이프타임 명시가 하는 것은 여러 개의 참조자에 대한 라이프타임들을 서로 연관 짓도록 하는 것입니다. 라이프타임 명시는 약간 독특한 문법을 갖고 있습니다: 라이프타임 파라미터의 이름은 어퍼스트로피 ‘로 시작해야 합니다. 라이프타임 파라미터의 이름은 보통 모두 소문자이며, 제네릭 타입과 비슷하게 그들의 이름은 보통 매우 짧습니다. 'a는 대부분의 사람들이 기본적으로 사용하는 이름입니다. 라이프타임 파라미터 명시는 참조자의 \u0026 뒤에 오며, 공백 문자가 라이프타임 명시와 참조자의 타입을 구분해줍니다. \u0026i32// a reference \u0026`'a`i32// a reference with an explicit lifetime \u0026`'a`muti32// a mutable reference with an explicit lifetime 만일 라이프타임 'a를 가지고 있는 i32에 대한 참조자인 first를 파라미터로, 그리고 또한 라이프타임 'a를 가지고 있는 i32에 대한 또 다른 참조자인 second를 또 다른 파라미터로 가진 함수가 있다면, 이 두 개의 같은 이름을 가진 라이프타임 명시는 참조자 first와 second가 돌다 동일한 제네릭 라이프타임만큼 살아야 한다는 것을 가리킵니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:3","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"function signature lifetime fn longest\u003c'a\u003e(x: \u0026'a str,y: \u0026'a str)-\u003e \u0026'a str {ifx.len()\u003ey.len(){x}else{y}} 'a를 통해 컴파일러는 x와 y값 중에서 가장 짧은 lifetime을 기준으로 검사를 실시하게 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:4","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"implicit lifetime 현재 러스트 컴파일러는 \u0026str(스트링 슬라이스)같은 경우에는 라이프타임을 자동으로 추론해주는 결정론적 패턴 분석이 있습니다.(룰) 이를 lifetime elision rules(라이프타임 생략 규칙)이라 부르며, 규칙은 다음과 같습니다. 들어가기 앞서 용어를 정리하면 input lifetime: 함수/메소드 파라미터에 대한 라이프타임 output lifetime: 반환값에 대한 라이프타임 명시적인 라이프타임이 없을때, 참조자가 어떤 라이프타임을 가지는가? lifetime elision rules 명시적이지 않은 라이프타임의 경우 판단 규칙은 다음 순서로 컴파일러에서 진행됩니다. 참조자인 각각의 파라미터는 고유한 라이프타임 파라미터를 갖습니다. 바꿔 말하면, 하나의 파라미터를 갖는 함수는 하나의 라이프타임 파라미터를 갖고: fn foo\u003c‘a\u003e(x: \u0026‘a i32), 두 개의 파라미터를 갖는 함수는 두 개의 라이프타임 파라미터를 따로 갖고: fn foo\u003c‘a, ‘b\u003e(x: \u0026‘a i32, y: \u0026‘b i32), 이와 같은 식입니다. 만일 정확히 딱 하나의 라이프타임 파라미터만 있다면, 그 라이프타임이 모든 출력 라이프타임 파라미터들에 대입됩니다: fn foo\u003c‘a\u003e(x: \u0026‘a i32) -\u003e \u0026‘a i32. 만일 여러 개의 입력 라이프타임 파라미터가 있는데, 메소드라서 그중 하나가 \u0026self 혹은 \u0026mut self라고 한다면, self의 라이프타임이 모든 출력 라이프타임 파라미터에 대입됩니다. 이는 메소드의 작성을 더욱 멋지게 만들어줍니다. 즉 정리하면 파라미터 갯수에 따라 라이프타임을 만든다. (파라미터 : 라이프타임 = 1:1) 파라미터가 1개인경우, return의 lifetime 또한 같은 lifetime을 가지도록 한다. \u0026self, \u0026mut self인 경우(즉 메서드 인경우)이면서 return type이 reference인 경우, return lifetime이 self와 같도록 만든다. 다음은 예시입니다. 파라미터가 1개인 경우 // 원본 fn first_word(s: \u0026str)-\u003e \u0026str {}// 1번 규칙 fn first_word\u003c'a\u003e(s: \u0026'a str)-\u003e \u0026str {}// 2번 규칙 (최종) fn first_word\u003c'a\u003e(s: \u0026'a str)-\u003e \u0026'a str {} 파라미터가 2개인 경우 // 원본 fn longest(x: \u0026str,y: \u0026str)-\u003e \u0026str {}// 1번 규칙 (최종) fn longest\u003c'a,'b\u003e(x: \u0026'a str,y: \u0026'b str)-\u003e \u0026str {}error[E0106]: missinglifetimespecifier|1|fn longest(x: \u0026str,y: \u0026str)-\u003e \u0026str {|^expectedlifetimeparameter 위와 같이, 파라미터가 2개이상인 경우이면서 메서드가 아닌 경우이기 때문에 return 타입에 대한 lifetime을 명시해주어야 합니다. 왜냐하면 elision rule에 벗어난 경우이기 때문입니다. 메서드인 경우 struct ImportantExcerpt\u003c'a\u003e{part: \u0026'a str,}// \u003c'a\u003e이 2번 쓰인걸 주목 // 또한 method의 return이 참조자가 아닌 primitive type 값인걸 주목 (elision rule은 reference에 대해서만 기능합니다.) impl\u003c'a\u003eImportantExcerpt\u003c'a\u003e{fn level(\u0026self)-\u003e i32 {3}} 구조체 필드를 위한 라이프타임 이름은 언제나 impl 키워드 뒤에 선언되어야 하며, 그러고 나서 구조체의 이름 뒤에 사용되어야 하는데, 이 라이프타임들은 구조체 타입의 일부이기 때문입니다. rule3이 적용된 메서드 예시 struct ImportantExcerpt\u003c'a\u003e{part: \u0026'a str,}impl\u003c'a\u003eImportantExcerpt\u003c'a\u003e{fn announce_and_return_part(\u0026self,announcement: \u0026str)-\u003e \u0026str {println!(\"Attention please: {}\",announcement);self.part}} 위의 코드 경우 announce_and_return_part의 return value인 self.part는 ImportantExcerpt의 self와 같은 라이프타임을 가지게 됩니다. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:5","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Static lifetime 프로그램의 전체 라이프타임을 가리키는 특별 라이프타임 lets: \u0026'static str =\"I have a static lifetime.\"; “static with static lietime('static”) staticNAME: \u0026'static str =\"Steve\"; static vs const Read RFC 246 to get more details. constants declare constant values. These represent a value, not a memory address. This is the most common thing one would reach for and would replace static as we know it today in almost all cases. statics declare global variables. These represent a memory address. They would be rarely used: the primary use cases are global locks, global atomic counters, and interfacing with legacy C libraries. const immutable, 사용하는 곳에 컴파일 시점에 binary 변경된 값으로 변환됨. Have no fixed address in memory They’re inlined to each place which uses them, this means they are put directly into the binary on the places which use them. Usually faster runtime but bigger executable file because it doesn’t have to look up an address like static. static mutable(unsafe box를 필요) Have a fixed address in memory (global scope) Their value is loaded from this fixed address each place which uses them. Usually slower runtime because we need to perform the extra instruction of loading the data from the fixed address. However this could result in a smaller executable file (only when it is used frequently) because it doesn’t have to have multiple copies of the value baked into the executable. ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:6","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Let’s recap with example See a code with generic type parameter, trait bound, lifetime. usestd::fmt::Display;fn longest_with_an_announcement\u003c'a,T\u003e(x: \u0026'a str,y: \u0026'a str,ann: T,)-\u003e \u0026'a str whereT: Display,{println!(\"Announcement! {}\",ann);ifx.len()\u003ey.len(){x}else{y}} ","date":"2023-01-11","objectID":"/the_rust_programming_lang/:26:7","tags":["dev","rust","language"],"title":"[Part1] The rust programming language","uri":"/the_rust_programming_lang/"},{"categories":["dev"],"content":"Rust Q\u0026A를 통해서 알아보는 원리","date":"2023-01-07","objectID":"/rust_principle/","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"Rust Q\u0026A 를 통해서 알아보는 Rust 프로그래밍 원리를 살펴보고, 유용했던 문구들을 스크랩 해둡니다. 또한 앞으로 Rust 공부는 다음과 같은 순서로 진행할 예정입니다. Rust Q\u0026A Book: The Rust Programming language Effective Rust(35) Rust by Example ","date":"2023-01-07","objectID":"/rust_principle/:0:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"1. Rust 프로젝트 Rust의 목표는 무엇일까요? To design and implement a safe, concurrent, practical systems language. Rust는 이 수준의 추상화와 효율을 추구하는 다른 언어들이 만족스럽지 못 하기에 존재합니다. 특히: 안전성이 너무 덜 주목되어 있습니다. 동시성 지원이 부족합니다. 실용적으로 쓰기가 힘듭니다. 자원에 대한 제어가 제한적입니다. Rust는 효율적인 코드와 편안한 수준의 추상화를 제공하며, 동시에 위 4가지를 모두 개선하는 대안으로 만들어졌습니다. Rust의 목표가 아닌 것은 무엇이 있나요? 우리는 특별히 최신의 기술을 도입하지 않습니다. 오래되고 자리 잡힌 기술이 더 좋습니다. 우리는 표현력, 최소주의 또는 우아함을 다른 목표에 우선하지 않습니다. 이들은 바람직하긴 하지만 부수적인 목표입니다. 우리는 C++나 기타 다른 언어의 모든 기능 집합을 커버하려 하지 않습니다. Rust는 자주 쓰이는 기능들을 제공할 것입니다. 우리는 100% 정적이거나, 100% 안전하거나, 100% 반영적(reflective)이거나, 기타 어떤 의미에서도 너무 교조적이려 하지 않습니다. 트레이드 오프는 존재합니다. 우리는 Rust가 “가능한 모든 플랫폼”에서 동작할 걸 요구하지 않습니다. 언젠가 Rust는 널리 쓰이는 하드웨어와 소프트웨어 플랫폼에서 불필요한 타협 없이 동작할 것입니다. ","date":"2023-01-07","objectID":"/rust_principle/:1:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"2. 성능 Rust는 얼마나 빠른가요? C++와 동일하게 Rust는 비용 없는 추상화를 주요 원칙으로 삼습니다. Rust에는 전역으로 성능을 떨어뜨리는 추상화가 존재하지 않으며, 런타임 시스템에서 부하가 발생하지도 않습니다. Rust가 LLVM에 기반해 있고 LLVM이 보기에 Clang과 비슷하게 보이려 한다는 걸 생각해 보면, LLVM에서 성능 개선이 일어난다면 Rust도 도움을 받게 됩니다. 장기적으로는 Rust 타입 시스템의 더 풍부한 정보로 C/C++ 코드에서는 어렵거나 불가능한 최적화도 가능해질 것입니다. Rust는 쓰레기 수거(garbage collection, GC)를 하나요? 아니요. Rust의 중요 혁신 중 하나는 쓰레기 수거 없이 메모리 안전성을 보장한다는 것입니다(즉, 세그폴트가 나지 않습니다). Rust는 GC를 피한 덕에 여러 장점을 제공할 수 있었습니다. 자원들을 예측 가능하게 해제할 수 있고, 메모리 관리 오버헤드가 낮으며, 사실상 런타임 시스템이 없습니다. 이 모든 특징들 때문에 Rust는 아무 맥락에나 깔끔하게 포함(embed)하기 쉬우며, 이미 GC를 가지고 있는 언어에 Rust 코드를 통합하기에도 훨씬 쉽습니다. 제 프로그램이 왜 느린 거죠? Rust 컴파일러는 요청이 없다면 최적화 없이 컴파일을 하는데, 이는 최적화를 하면 컴파일이 느려지고 개발 과정에서는 보통 바람직하지 않기 때문입니다. cargo로 컴파일을 한다면 –release 플래그를 쓰세요. rustc를 직접 써서 컴파일을 한다면 -O 플래그를 쓰세요. 어느 쪽이나 최적화를 켜는 역할을 합니다. Rust 컴파일이 느린 것 같습니다. 왜 그런 건가요? 코드를 기계어로 번역하고 최적화를 하기 때문입니다. Rust는 효율적인 기계어로 컴파일되는 고수준 추상화를 제공하고, 이 번역 과정은 특히 최적화를 할 경우 시간이 걸리게 마련입니다. Rust 컴파일이 느리다고 느끼는 주된 원인은 C++와 Rust가 컴파일 모델이 다르다는 점, 즉 C++의 컴파일 단위는 한 파일이지만 Rust는 여러 파일로 이루어진 크레이트라는 것 때문입니다. 따라서 개발 도중에 C++ 파일 하나를 고치면 Rust에 비해 컴파일 시간이 훨씬 줄어들 수 있습니다. 현재 Rust 컴파일러를 리팩토링해서 증분 컴파일(Incremental Compile)을 가능하게 하려는 대형 작업이 진행 중이며, 완료되면 Rust에서도 C++ 모델과 같이 컴파일 시간이 개선될 것입니다. (4) 컴파일 모델과는 별개로, Rust의 언어 설계에는 컴파일 시간에 영향을 미치는 요소가 여럿 있습니다. Rust는 비교적 복잡한 타입 시스템을 가지고 있고, 실행 시간에 Rust를 안전하게 만들기 위한 제약 사항을 강제하는 데 무시할 수 없는 컴파일 시간을 사용해야 합니다. Rust 컴파일러에는 오래된 기술 부채가 있으며, 특히 생성되는 LLVM IR의 품질이 좋지 못하기 때문에 LLVM이 시간을 들여 이를 “고쳐야” 합니다. 미래에는 MIR 기반 최적화 및 번역 단계가 Rust 컴파일러가 LLVM에 가하는 부하를 줄여 줄지도 모릅니다. Rust가 코드 생성에 LLVM을 쓰는 것은 양날의 검이라는 점입니다. LLVM 덕분에 Rust는 세계구급 런타임 성능을 보여 주지만, LLVM은 컴파일 시간에 촛점을 맞추지 않은 거대한 프레임워크이며 특히 품질이 낮은 입력에 취약합니다. 마지막으로 Rust가 일반화(제너릭) 타입을 C++와 비슷하게 단형화(monomorphise)하는 전략은 빠른 코드를 생성하지만, 다른 번역 전략에 비해 상당히 많은 코드를 생성해야 한다는 문제가 있습니다. 이 코드 팽창은 트레이트 객체를 써서 동적 디스패치와 장단을 교환할 수 있습니다. Rust의 HashMap은 왜 느린가요? Rust의 HashMap은 기본적으로 SipHash 해시 알고리즘을 사용합니다. 이 알고리즘은 해시 테이블 충돌 공격을 막으면서 여러 종류의 입력에 대해 적절한 성능을 내도록 설계되었습니다. SipHash가 많은 경우 경쟁력 있는 성능을 보여 주긴 하지만, SipHash는 정수 같이 키가 짧을 경우 다른 해시 알고리즘에 비해 현저히 느립니다. 이 때문에 종종 HashMap의 성능이 낮은 걸 볼 수 있습니다. 이런 경우에는 보통 FNV 해시를 추천하지만, 이 알고리즘이 충돌 공격에서 SipHash와 다른 특성을 보인다는 점은 염두에 두어야 합니다. Rust는 꼬리 재귀(tail-call) 최적화를 하나요? 일반적으로는 아닙니다. 제한적으로 꼬리 재귀 최적화를 하긴 하지만 보장되지는 않습니다. 이 기능은 언제나 요청되어 왔기 때문에 Rust에는 이를 위해 예약어(become)가 예약되어 있습니다 Rust에는 런타임이 있나요? Java 같은 언어들에서 말하는 그런 통상의 런타임은 없습니다만, Rust 표준 라이브러리의 일부분은 힙(heap), 스택 추적(backtrace), 되감기(unwinding) 및 보호(guard)를 제공하는 “런타임”이라고 볼 수 있습니다. 사용자의 main 함수가 실행되기 전에는 소량의 초기화 코드가 실행됩니다. 또한 Rust 표준 라이브러리는 C 표준 라이브러리를 링크하는데 여기에서도 비슷한 런타임 초기화가 일어납니다. Rust 코드는 표준 라이브러리 없이 컴파일될 수 있으며 이 경우 런타임은 대략 C와 비슷해집니다. ","date":"2023-01-07","objectID":"/rust_principle/:2:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"3. 문법 (Syntax) 왜 중괄호인가요? 또한 중괄호는 프로그래머 입장에서는 더 유연한 문법을 제공하고 컴파일러 입장에서는 더 간단한 파서를 가능하게 합니다. if 조건에서 소괄호를 생략할 수 있는데, 그럼 한 줄짜리 블럭에는 왜 중괄호를 넣어야 하나요? C에서는 if 조건문에서 괄호가 필수이고 중괄호가 선택이지만, Rust에서는 반대로 합니다. 이렇게 해서 조건문 몸체와 조건을 명확하게 구분할 수 있고, 중괄호가 선택이라서 벌어지는 위험도 막을 수 있는데, 이는 Apple의 goto fail 버그와 같이 리팩토링 과정에서 흔히 생기고 잡기 어려운 오류들을 유발할 수 있습니다. Why is there no literal syntax for dictionaries? Rust의 전반적인 설계는 언어의 크기를 제한하되 강력한 라이브러리를 만들 수 있게 하는 쪽을 선호합니다. Rust는 배열과 문자열 리터럴을 초기화하는 문법을 가지고 있지만 언어에 내장된 컬렉션 타입은 이걸로 전부입니다. 매우 널리 쓰이는 Vec 컬렉션 타입 같이, 라이브러리에서 정의하는 다른 타입들은 vec! 같은 매크로를 사용하여 초기화를 합니다. 나중에는 Rust가 매크로를 써서 컬렉션을 초기화하는 설계가 다른 타입에도 일반적으로 사용할 수 있도록 확장될 수 있고, 그렇게 되면 HashMap이나 Vec 같은 것 뿐만이 아니라 BTreeMap 같은 다른 타입들도 간단하게 초기화할 수 있게 될 것입니다. When should I use an implicit return?(암묵적인 반환) Rust는 매우 수식 지향적인 언어이며 “암묵적인 반환”은 이 설계의 한 부분입니다. if, match나 일반 블록들은 Rust에서는 다 수식입니다. 예를 들어 다음 코드는 i64가 홀수인지 확인하고 결과를 단순히 값으로 내서 결과를 반환합니다: fn is_odd(x: i64)-\u003e bool {ifx%2!=0{true}else{false}}fn is_odd(x: i64)-\u003e bool {x%2!=0} 두 예제에서 함수의 마지막 줄은 그 함수의 반환값입니다. 중요한 것은 함수가 세미콜론으로 끝난다면 그 반환값은 ()이고, 이는 반환값이 없다는 뜻이라는 점입니다. 암묵적으로 반환하려면 세미콜론이 없어야 합니다. 명시적인 반환은 함수 몸체의 맨 끄트머리보다 이전에 반환을 해야 해서 암묵적인 반환이 불가능할 때만 쓰입니다. 물론 위 함수들도 return 예약어와 세미콜론을 쓸 수는 있지만, 이는 Rust 코드 규약에 어긋날 뿐 아니라, 불필요하게 번잡해 보입니다. 왜 함수의 타입 서명(signature)들은 추론되지 않는 거죠? Rust에서 선언은 타입을 명시적으로 쓰는 편이며 실제 코드는 타입을 추론하는 편입니다. 이 설계에는 몇 가지 이유가 있습니다: 선언의 서명을 명시적으로 쓰면 모듈 및 크레이트 수준에서 인터페이스 안정성을 강제하는 데 도움이 됩니다. 서명은 프로그래머가 코드를 더 잘 이해할 수 있게 하므로, IDE가 함수의 인자 타입들을 추측하려고 전체 크레이트에 추론 알고리즘을 돌릴 필요가 사라집니다. 언제나 명시적이고 바로 옆에 있기 때문이죠. 기계적으로는 추론 과정에서 한 번에 한 함수만 보면 되므로 추론 알고리즘이 간단해집니다. 왜 `match`에는 모든 조건들이 들어 있어야 하나요? 리팩토링을 돕고 코드를 명료하게 하기 위함입니다. 먼저, match가 모든 가능성을 커버하고 있다면 enum에 새 변종(variant)을 넣을 때 실행 시간 (execution time)에 오류가 나는 게 아니라 컴파일(compile time)이 실패하게 됩니다. Rust에서 이런 종류의 컴파일러 도움은 두려움 없이 리팩토링을 가능하게 합니다. 두 번째로, 이러한 체크는 기본 선택지를 명시적으로 만듭니다. 일반적으로 모든 가능성을 커버하지 않는 match를 안전하게 만드는 방법은 아무 선택지도 선택되지 않았을 때 스레드를 패닉하게 만드는 것 뿐입니다. Rust의 옛 버전에서는 match가 모든 가능성을 커버하지 않아도 되게 했는데 수많은 버그의 온상이 되었습니다. 기술되지 않은 선택지는 _ 와일드 카드로 간단하게 무시할 수 있습니다: matchval.do_something(){Cat(a)=\u003e{/* ... */}_=\u003e{/* ... */}} ","date":"2023-01-07","objectID":"/rust_principle/:3:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"4. 디자인 패턴 Rust는 객체 지향적(object-oriented)인가요? It is multi-paradigm. 객체 지향 언어에서 할 수 있는 많은 것들은 Rust에서도 할 수 있지만, 전부 가능한 건 아니고, 여러분에게 익숙한 추상화를 사용하지 않을 수도 있습니다. How do I map object-oriented concepts to Rust? 다중 상속과 같은 객체 지향 개념을 Rust로 옮기는 방법은 여럿 있습니다만, Rust는 객체 지향이 아니기에 객체 지향 언어들과는 상당히 다르게 보일 수 있습니다. How do I handle configuration of a struct with optional parameters? 가장 쉬운 방법은 구조체 인스턴스를 생성하는 어떤 함수에든 (보통 new()에) Option 타입을 쓰는 겁니다. 또 다른 방법은 builder패턴을 써서, 타입을 생성하기 전에 멤버 변수를 인스턴스화하는 특정 함수들을 호출해야 하도록 하는 것입니다. Rust에서 전역 변수를 쓰려면 어떻게 하죠? Rust에서 전역 변수는 컴파일 시간에 계산된 전역 상수라면 const 선언을 쓸 수 있고, 변경 가능한 전역 변수는 static을 쓸 수 있습니다. 다만 static mut 변수를 변경하려면 unsafe가 필요한데, 이는 안전한 Rust에서는 발생하지 않는다고 보장하는 데이터 레이스(data race)가 일어날 수 있기 때문입니다. const와 static 값의 중요한 차이는 static에서는 참조를 얻을 수 있지만 const는 지정된 메모리 위치를 가지지 않기 때문에 불가능하다는 점입니다. How can I set `compile-time constants` that are defined procedurally? You can define primitives using const declarations as well as define const functions and inherent methods. (원시 값을 const 선언으로 정의할 수 있고, const 함수나 선천적인 메소드도 정의할 수 있습니다.) To define procedural constants that can’t be defined via these mechanisms, use the lazy-static crate, which emulates compile-time evaluation by automatically evaluating the constant at first use. (이 방법으로 선언할 수 없는 procedural 상수를 선언하려면 lazy-static crate를 사용하세요. 이 크레이트는 컴파일 시간 evaluation를 상수가 처음 사용될 때, 자동으로 평가하여 procedural constants를 흉내냅니다.) `main` 이전에 실행되는 초기화 코드를 만들 수 있나요? Rust에는 “main 이전의 life”라는 개념이 없습니다. lazy-static 크레이트가 가장 가까운 것일텐데, 이 크레이트는 “main보다 이전”이라는 시간을 정적 변수를 처음 사용할 때 지연하여 초기화하는 걸로 흉내냅니다. Rust에서 상수 수식이 아닌 값을 전역에 넣을 수 있나요? 아니요. Globals cannot have a non-constant-expression constructor and cannot have a destructor at all. Static constructors are undesirable because portably ensuring a static initialization order is difficult. Life before main is often considered a misfeature, so Rust does not allow it. ","date":"2023-01-07","objectID":"/rust_principle/:4:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"5. Other Languages How can I implement something like C's `struct X { static int X; };` in Rust? Rust는 static 필드가 없습니다. 대신 주어진 모듈에서만 접근할 수 있는 static 변수를 선언할 수 있습니다. 왜 Rust는 C 같이 안정화된 ABI가 없는 건가요? 그리고 왜 `extern`을 어노테이트 해야하는 거죠? _Rust가 2015년 5월에야 1.0이 되었다는 걸 볼 때 안정된 ABI 같은 큰 투자를 하기에는 아직 너무 이릅니다. 하지만 미래에도 일어나지 않을 거라는 얘기는 아닙니다. extern를 쓰면 Rust가 잘 정의된 C ABI 같이 특정한 ABI를 써서 다른 언어와 상호작용하도록 할 수 있습니다. Rust 코드가 C 코드를 호출할 수 있나요? 네. C 코드를 Rust에서 부르는 것은 C++에서 C 코드를 부르는 것만큼 효율적이도록 설계되었습니다. C 코드가 Rust 코드를 호출할 수 있나요? _네. Rust 코드가 extern 선언으로 노출되어 C의 ABI와 호환되도록 만들어야 합니다. 이러한 함수는 C 코드에 함수 포인터로 전달되거나, #[no_mangle] 속성으로 symbol mangling을 껐을 경우, C 코드에서 바로 호출될 수 있습니다._ C++의 템플릿 특수화 같은 걸 Rust에서는 어떻게 할 수 있을까요? Rust는 현재 템플릿 특수화(template specialization)와 완전히 같은 기능을 가지고 있지 않지만, 현재 작업이 진행 중 이며 아마 곧 추가될 것입니다. 다만 Associated types 으로 비슷한 결과를 얻을 수도 있습니다. Rust에는 C++ 같은 생성자가 있나요? 아니요. 대신 함수가 생성자와 같은 역할을 수행합니다. Rust에서 생성자에 대응되는 함수의 일반적인 이름은 new()로, 이는 언어 규칙이 아니라 단순한 규약일 따름입니다. new() 함수는 다른 함수랑 다를 바가 없고, 이런 식으로 씁니다. struct Foo{a: i32,b: f64,c: bool,}implFoo{fn new()-\u003e Foo{Foo{a: 0,b: 0.0,c: false,}}} Go와 Rust가 비슷한 점은 무엇이고 다른 점은 무엇인가요? Rust는 Go보다 저수준입니다. 예를 들어 Rust는 쓰레기 수거기(garbage collector)를 필요하지 않지만 Go는 필요로 합니다. 일반적으로 Rust는 C나 C++와 비견할 만한 제어 수준을 제공합니다. Rust의 촛점은 고수준의 편안함을 제공하면서도 안전함과 효율성을 보장하는 것이며, Go의 촛점은 빠르게 컴파일되고 수많은 도구와 함께 멋지게 동작할 수 있는 작고 간단한 언어가 되고자 하는 것입니다. Rust has strong support for generics, which Go does not. Rust는 함수형 프로그래밍에서 많은 영향을 받았으며, 여기에는 하스켈의 타입 클래스에서 유래한 타입 시스템이 포함됩니다. Go has a simpler type system, using interfaces for basic generic programming. ","date":"2023-01-07","objectID":"/rust_principle/:5:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"6. 모듈 및 크레이트 `모듈`과 `크레이트` 사이에 어떤 관계가 있나요? 크레이트는 컴파일 단위로, Rust 컴파일러가 다룰 수 있는 가장 작은 규모의 코드입니다. 모듈은 크레이트 안에 있는 코드 구조의 (중첩될 수도 있는) 단위입니다. 크레이트에는 암묵적이고 이름이 없는 최상위 모듈이 포함됩니다. 재귀 정의는 여러 모듈에 걸쳐 있을 수 있지만 여러 크레이트에는 걸칠 수 없습니다. 왜 모듈 파일을 정의하기 위해 크레이트 최상위에 mod를 넣어야 하나요? 그냥 use로 지정하면 안 되나요? Rust에서 모듈은 제자리에 선언하거나 다른 파일에서 선언할 수 있습니다. 각각의 예제는 다음과 같습니다. // main.rs에서 mod hello{pubfn f(){println!(\"hello!\");}}fn main(){hello::f();} // main.rs에서 mod hello;fn main(){hello::f();}// hello.rs에서 pubfn f(){println!(\"hello!\");} 첫 예제에서 모듈은 모듈이 사용되는 곳과 같은 파일에 정의되어 있습니다. 둘째 예제에서 메인 파일의 모듈 선언은 컴파일러에게 hello.rs나 hello/mod.rs를 찾아 보고 그 파일을 읽으라고 말해 줍니다. mod와 use의 차이를 주목하세요. mod는 모듈이 존재한다고 선언하지만, use는 다른 곳에 선언된 모듈을 참조하여 그 내용물을 현재 모듈의 범위 안에 가져 옵니다. ","date":"2023-01-07","objectID":"/rust_principle/:6:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"7. 다중 플랫폼 Rust를 안드로이드 및 iOS 프로그래밍에 쓸 수 있나요? 네 할 수 있습니다! 이미 Rust를 안드로이드와 iOS에서 사용하는 예제가 있습니다. android: https://github.com/rust-mobile/ndk ios 개인적인 Rust 프로그램을 웹 브라우저에서 실행할 수 있나요? 아마도요. Rust는 asm.js와 WebAssembly 모두를 실험적으로 지원합니다. WebAssembly의 동향에 대한 유용한 글, Naver D2 ","date":"2023-01-07","objectID":"/rust_principle/:7:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"8. 저수준 Rust가 메모리 상에 값이 어떻게 배치될 지가 고정되어 있나요? 기본적으로는 아닙니다. 일반적으로 enum과 struct의 배치는 정의되지 않습니다. 따라서 컴파일러가 패딩을 구분값(discriminant)을 넣는데 재사용하거나, 중첩된 enum들의 변종(variant)들을 압축하거나, 패딩을 없애기 위해 필드를 재배치하는 등의 잠재적인 최적화를 할 수 있게 됩니다. 데이터를 들고 있지 않은 (“C와 비슷한”) enum은 정의된 표현을 가지도록 할 수 있습니다. 이러한 enum은 데이터를 들고 있지 않은 이름들만의 단순 목록이므로 쉽게 구분할 수 있습니다: enum CLike{A,B=32,C=34,D} 이러한 enum에 #[repr(C)] 속성을 적용하면 대응되는 C 코드가 가질 표현과 같은 표현이 되도록 할 수 있습니다. 따라서 FFI(foreign function interface) 코드에서 C enum이 쓰일 대부분의 상황에서 Rust enum을 쓸 수 있습니다. 마찬가지로 struct에도 이 속성을 적용하면 C struct가 가질 배치와 같은 배치가 되도록 할 수 있습니다. ","date":"2023-01-07","objectID":"/rust_principle/:8:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"9. 디버깅 / Tool Rust 프로그램은 어떻게 디버깅하나요? Rust 프로그램은 C나 C++와 같이 gdb나 lldb로 디버깅할 수 있습니다. 사실은 모든 Rust 설치과정에는 (플랫폼 지원에 따라) rust-gdb나 rust-lldb 둘 중 하나가 함께 들어 있습니다. 이들은 gdb와 lldb에 Rust 값을 보기 좋게 출력해 주도록 감싼 것입니다. rustc가 표준 라이브러리 코드에서 패닉(panic)이 일어났다고 하는데, 제 코드의 실수를 어떻게 찾을 수 있을까요? 이 오류는 보통 사용자 코드에서 None이나 Err을 unwrap()해서 일어납니다. RUST_BACKTRACE=1 환경 변수를 설정해서 스택 추적(backtrace)을 켜는 게 더 많은 정보를 얻는데 도움이 됩니다. 디버그 모드로 컴파일하거나(cargo build의 기본값), 함께 들어 있는 rust-gdb나 rust-lldb 같은 디버거를 쓰는 것도 도움이 됩니다. rust의 gofmt 같은 포맷팅 툴: rustfmt ","date":"2023-01-07","objectID":"/rust_principle/:9:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"10. 오류 Rust에는 왜 예외(exception)가 없나요? 예외는 제어 흐름을 이해하기 복잡하게 만들고, 타입 시스템을 넘어서는 유효성/무효성을 표현하며, (Rust의 주요 촛점인) 멀티스레딩된 코드와 잘 상호작용하지 않습니다. Rust는 오류 처리에 타입 기반의 접근을 선호하며, 이는 Rust의 제어 흐름, 동시성 및 여타 다른 것들에 더 잘 맞아 들어 갑니다. 여기 저기 보이는 `unwrap()`를 어떻게 할 수 없나요? unwrap()은 Option이나 Result 안에 있는 값을 뽑아 내고 아무 값도 없으면 패닉을 일으키는 함수입니다. unwrap()이 잘못된 사용자 입력 따위의 “예상할 수 있는 오류들을 다루는 기본 방법” 이 되어서는 안 됩니다. 현업 코드에서 이는 값이 비어 있지 않으며 만에 하나 비어 있다면 프로그램이 깨지는 단언(assertion)처럼 취급되어야 합니다. 또한 unwrap()은 아직 오류를 처리하고 싶지 않은 빠른 프로토타입이나, 오류 처리가 주요 논점을 흐릴 수 있는 곳에서도 유용합니다. 모든 곳에 `Result를` 쓰는 것 말고 더 쉽게 오류를 처리할 방법이 없나요? 다른 사람의 코드에 있는 Result를 처리하지 않는 방법을 원한다면 항상 unwrap()를 쓸 수 있지만, 아마도 원하는 게 아닐 겁니다. Result는 어떤 계산이 성공적으로 끝나거나 끝나지 않을 수 있다는 표시입니다. 이러한 실패를 처리하도록 요구하는 건 Rust가 튼튼한 코드를 권장하는 방법 중 하나입니다. Rust는 실패를 더 편리하게 처리할 수 있도록 try! 매크로 같은 도구를 제공합니다. 정말로 오류를 처리하고 싶지 않다면 unwrap()를 쓰세요. 하지만 이렇게 하면 실패시 코드가 패닉을 일으키고, 보통 이는 프로세스를 종료시킨다는 점을 유의하시길 바랍니다. ","date":"2023-01-07","objectID":"/rust_principle/:10:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"10. 숫자 부동 소숫점 계산을 할 때 f32와 f64 중 어느 쪽을 선호해야 하나요? 잘 모르겠으면 정밀도를 우선시해서 f64를 선택하세요. 실수들을 비교하거나 HashMap 및 BTreeMap의 키로 쓸 수 없는 이유는 뭔가요? (us 문서 기준 개인 해석입니다.) Floats(실수)타입은 total ordering과 totla equality가 없습니다. 그렇기 때문에 Eq trait를 구현할 수 없습니다. total ordering과 total equality가 Float형에 존재하지 않는 이유는 floating-point값인 NaN이 다른 floating point 값들 그리고 그 자신과도 비교불가하기 때문입니다. (그래서) float타입이 Eq(total equality 구현체)와 Ord(total order 구현체)를 구현하지 못하기 때문에, 이 두 trait를 사용하는 타입들에서 사용될 수 없습니다. 해당 타입에는 BTreeMap, HashMap 또한 포함됩니다. 두 Map 타입에서는 key값에 total ordering 또는 total equality가 필요합니다. (3rd 인) 이 ordered-float 크레이트에서는 f32, f64 타입들을 랩핑하여 Ord와 Eq 구현체들을 제공합니다. 그러므로 특정한 상황에서 유용하게 사용할 수 있습니다. How can I convert between numeric types? 두 가지 방법이 있는데, 하나는 as 예약어로 원시 타입 사이에서 간단한 변환을 하는 것이고, 다른 하나는 Into와 From 트레이트를 써서 타입 변환을 하는 것입니다(직접 트레이트를 구현해서 변환을 추가할 수도 있습니다). Into와 From 트레이트는 변환에서 손실이 일어나지 않을 때만 구현되어 있습니다. 이를테면 f64::from(0f32)는 컴파일이 되지만 f32::from(0f64)는 아닙니다. 한편 as는 원시 타입들 사이에서는 모두 변환이 가능하며 필요하다면 값을 잘라냅니다(truncating). ","date":"2023-01-07","objectID":"/rust_principle/:11:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"11. 문자열 `\u0026str`과 `String`에는 어떤 차이가 있나요? String은 힙에 할당된 UTF-8 바이트를 소유하는 버퍼입니다. 변경 가능한 String은 수정할 수 있고 필요에 따라 그 용량(capacity)을 늘릴 수 있습니다. \u0026str은 다른 데 (보통 힙에) 할당되어 있는 String으로부터 참조된 슬라이스나, 문자열 리터럴의 경우 정적 메모리를 가리키는, 용량이 고정된 “view\"입니다. \u0026str은 Rust 언어가 구현하는 원시 타입이지만 String은 표준 라이브러리에 구현되어 있습니다. String의 각 문자를 O(1), 즉 상수 시간에 접근하려면 어떻게 해야 하나요? 불가능합니다. Rust string들은 UTF-8로 인코딩되어 있습니다. UTF-8에서 A single visual character(보여지는 하나의 문자)는 반드시 single byte가 아닐 수도 있습니다(ASCII-encoded string일 경우). 각 바이트는 “code unit” (in UTF-16, code units are 2 bytes; in UTF-32 they are 4 bytes)라고 불립니다. “Code points”는 하나 또는 2이상의 code unit들로 구성되어 있으며, 문자를 가장 가까이 근사한다고 할 수 있는 “자소(grapheme) 클러스터”는 여러 개의 코드 포인트로 구성되어 있습니다. 따라서 UTF-8 문자열에서 바이트를 인덱싱할 수 있다 하더라도 상수 시간에 i번째 코드포인트나 자소 클러스터를 얻어낼 수는 없습니다. 하지만 원하는 코드포인트나 grapheme 클러스터가 어느 바이트에서 시작하는지 안다면 그건 상수 시간에 접근할 수 있습니다. str::find()나 정규식 검색 결과는 바이트 인덱스를 반환하므로 이 방법으로 접근하는 게 가능합니다. Why are strings `UTF-8` by default? str 타입이 UTF-8인 것은 현실에서, 특히 엔디안이 정해져 있지 않은 네트워크 전송에서 이 인코딩이 널리 쓰이기 때문이고, I/O를 할 때 어느 방향에서도 코드포인트를 다시 변환할 필요가 없는 것이 최선이라고 생각하기 때문입니다. 물론 이는 문자열 안의 특정 유니코드 코드포인트의 위치를 찾는데 O(n) 연산이 필요하다는 뜻이긴 합니다. 이미 시작하는 바이트 인덱스를 알고 있을 경우에는 예상대로 O(1) 시간이 걸리겠지만요. 어떻게 보면 바람직하지 않을 수도 있지만, 어떻게 보면 이 문제 자체가 트레이드오프로 가득 차 있기에 다음 중요한 점들을 지적할 필요가 있겠습니다: str에서 ASCII 영역의 코드포인트를 훑는 건 바이트 단위로 안전하게 할 수 있습니다. 예를 들어 .as_bytes()를 쓸 경우 u8타입(8-bit unsigned int type)을 얻는 건 O(1) 연산이며 이 값은 ASCII 범위의 char로 변환하거나 비교할 수 있습니다. 그러니 이를테면 '\\n'로 줄 바꿈을 찾는다면 바이트 단위로 검색해도 됩니다. UTF-8은 원래부터 이렇게 설계되었거든요. 대부분의 “문자 기반” 텍스트 연산들은 “ASCII 범위의 코드포인트 한정” 같이 매우 제약된 언어 가정이 있어야만 동작합니다. ASCII 범위를 벗어나면 언어학적인 단위들(glyphs[글리프], 낱말, 문단)의 경계를 찾기 위해 (상수 시간이 아닌) 복잡한 알고리즘을 써야 하기 마련입니다. 저희는 언어학적으로 올바르며 “honest\"하다고 유니코드에서 인증한 알고리즘을 권장합니다. char 타입은 UTF-32입니다. 한 번에 한 코드포인트를 들여다 보는 알고리즘이 정말로 필요하다고 생각한다면 type wstr = [char]을 정의하여 str로부터 한번에 읽어들인 뒤 wstr에서 연산을 하면 됩니다. 다르게 말하면, 언어가 “기본적으로 UTF-32로 디코딩하지 않는다”고 해서 UTF-32로 디코딩하거나 다시 인코딩하는 것 자체가 불가능한 건 아니라는 말입니다. 왜 UTF-8이 UTF-16이나 UTF-32보다 보통 더 선호되는지 자세한 설명을 원한다면 UTF-8 Everywhere manifesto 를 읽어 보시길 바랍니다. 어떤 문자열 타입을 써야 하죠? Rust는 네 쌍의 문자열 타입이 있고 각각 다른 역할을 합니다. 각 쌍마다 “소유된” 문자열 타입과 “슬라이스” 문자열 타입이 따로 있고, 다음과 같이 구성되어 있습니다 Rust의 서로 다른 문자열 타입은 각자 다른 목적을 가집니다. String과 str은 UTF-8로 인코딩된 일반 목적의 문자열입니다. - OsString과 OsStr은 현재 플랫폼에 맞춰 인코딩되어 있고 운영체제와 상호작용할 때 쓰입니다. CString과 CStr은 C 문자열의 Rust 버전으로 FFI 코드에 사용됩니다. PathBuf와 Path는 OsString과 OsStr에 편의를 위해 경로 조작을 위한 메소드들을 추가한 것입니다. \u0026str와 String을 동시에 받는 함수를 어떻게 짤 수 있나요? 함수가 소유된 문자열을 필요로 하지만 아무 문자열 타입이나 받고 싶다면, Into\u003cString\u003e 제약을 쓰세요. 함수가 문자열 슬라이스를 필요로 하지만 아무 문자열 타입이나 받고 싶다면, AsRef\u003cstr\u003e 제약을 쓰세요. 함수가 문자열 타입에 대해 신경쓰지 않고 두 가능성을 일관되게 처리하고 싶다면, 입력 타입으로 Cow\u003cstr\u003e을 쓰세요. Into\u003cString\u003e 이 예제에서 함수는 소유된 문자열과 문자열 슬라이스를 둘 다 받으며, 어느 쪽인지에 따라 함수 몸체 안에서 아무 일도 하지 않거나 입력을 소유된 문자열로 변환합니다. 참고로 변환은 명시적으로 해야 하며 안 그러면 변환되지 않을 것입니다. fn accepts_both\u003cS: Into\u003cString\u003e\u003e(s: S){lets=s.into();// s를 `String`으로 변환합니다. // ... 함수의 나머지 내용 } AsRef\u003cstr\u003e 이 예제에서 함수는 소유된 문자열과 문자열 슬라이스를 둘 다 받으며, 어느 쪽인지에 따라 아무 일도 하지 않거나 입력을 문자열 슬라이스로 변환합니다. 이는 입력을 참조로 받아서 다음과 같이 자동으로 일어나게 할 수 있습니다: fn accepts_both\u003cS: AsRef\u003cstr\u003e\u003e(s: \u0026S){// ... 함수의 몸체 } Cow\u003cstr\u003e 이 예제에서 함수는 Cow을 받는데, 이는 일반화된 타입이 아니라 컨테이너로서 필요에 따라 소유된 문자열이나 문자열 슬라이스를 담을 수 있습니다. fn accepts_cow(s: Cow\u003cstr\u003e){// ... 함수의 몸체 } ","date":"2023-01-07","objectID":"/rust_principle/:12:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"12. 컬렉션 How can I iterate over a collection without moving/consuming it? 가장 쉬운 방법은 컬렉션의 IntoIterator 구현체를 사용하는 겁니다. IntoIterator는 \u0026Vec과 \u0026mut Vec에 구현되어 있으며, 아래는 \u0026Vec를 활용해 이를 설명합니다. letv=vec![1,2,3,4,5];foritemin\u0026v{print!(\"{} \",item);}println!(\"\\nLength: {}\",v.len()); Rust의 for 반복문은 반복하고자 하는 대상에 대해 (IntoIterator 트레이트에 정의된) into_iter()를 호출합니다. IntoIterator 트레이트를 구현하는 모든 value들은 for 반복문에서 사용될 수 있습니다. into_iter()는 컬렉션을 옮기거나 소모하는 것이 아니라, 그 내용물을 빌리도록 합니다. 다른 표준 컬렉션에 대해서도 똑같은 관계가 성립합니다. 만약 옮기거나 소모하는 반복자가 필요하다면 for 반복문에서 반복할 때 \u0026나 \u0026mut 없이 쓰세요. 빌리는 반복자를 직접 접근하고 싶다면 보통 iter() 메소드를 써서 얻을 수 있습니다. Why do I need to type the array size in the array declaration? 꼭 그럴 필요 없습니다. 배열을 직접 선언한다면 원소의 갯수로부터 크기가 추론됩니다. 하지만 고정된 크기의 배열을 받는 함수를 선언한다면 컴파일러가 배열이 얼마나 클 지를 알아야 합니다. 하나 짚고 넘어가야 하는 게 있는데, Rust는 현재 서로 다른 크기의 배열에 대해 generics를 지원하지 않습니다. 만약 갯수가 바뀔 수 있는 값들의 연속된 컨테이너를 받고자 한다면 (소유권이 필요하냐 마냐에 따라) Vec이나 slice를 사용하세요. ","date":"2023-01-07","objectID":"/rust_principle/:13:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"13. 소유권 추가로 다시 봐야할 듯 싶어 link 를 적어둡니다. What is the difference between `passing by value`, `consuming`, `moving`, and `transferring ownership`? 다 같은 뜻입니다. 네 가지 경우에서 모두, 값이 새 소유자에게 옮겨가고, 원 소유자가 소유를 잃어버려 더 이상 쓸 수 없게 됩니다. 단 만약 타입이 Copy 트레이트를 구현한다면 원 소유자의 값은 무효화되지 않아 계속 쓸 수 있습니다. 왜 어떤 타입은 함수에 넘긴 뒤에도 재사용할 수 있지만 다른 타입은 그렇지 않나요? 타입이 Copy 트레이트를 구현하면 함수에 전달될 때 복사됩니다. Rust의 모든 numeric type들은 Copy를 구현하지만, struct type들은 기본적으로 Copy를 구현하지 않기 때문에 대신 이동이 일어납니다. This means that the struct can no longer be used elsewhere, unless it is moved back out of the function via the return. (즉 구조체는 함수에서 다시 반환되거나 하지 않는 한 더 이상 다른 데서 사용할 수 없게 됩니다.) ","date":"2023-01-07","objectID":"/rust_principle/:14:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"14. Lifetimes(수명) Why lifetimes? lifetime은 메모리 안전성에 대한 Rust의 해답입니다. Rust는 수명을 사용해 쓰레기 수거(garbage collection)의 성능 비용 없이 메모리 안전성을 보장합니다. Why is the lifetime syntax the way it is? 'a 문법은 ML(meta language) 계열의 프로그래밍 언어에서 따 왔는데, 여기서 'a 문법은 generic type parameter를 나타내는 데 사용됩니다. Rust의 경우 수명 문법은 모호하지 않고, 눈에 띄어야 했으며 타입 선언에서 트레이트와 참조와 함께 쓰기 좋아야 했습니다. 다른 문법도 의논되었으나 이보다 확실히 더 좋은 문법이 제시되진 않았습니다. Why do some references have lifetimes, like `\u0026'a T`, and some do not, like `\u0026T`? 사실 모든 참조 타입에는 수명이 있지만, 대부분의 경우 직접 쓸 필요가 없습니다. 규칙은 다음과 같습니다: function body에서는 수명을 명시적으로 쓸 필요가 전혀 없습니다.(항상 올바른 값이 추론될 것입니다). function signature (예를 들어 인자 타입이나 반환 타입) 에서는 수명을 명시적으로 써야 할 수도 있습니다. 여기에서는 수명 탈락(elision)라는 간단한 기본값이 적용되는데 이는 다음 세 규칙으로 구성되어 있습니다 function argument들에서 탈락된(elided) 각각 수명들은 서로 다른 인자가 됩니다. 입력된 수명이 하나 뿐이면, 그게 탈락되었든 아니든 그 함수의 return value들의 all elided lifetimes(탈락된 수명들)에 할당됩니다. 입력 수명이 여럿 있지만 그 중 하나가 \u0026self거나 \u0026mut self라면, self의 lifetime이 all elided output lifetimes(모든 탈락된 출력 수명들)에 할당됩니다. 마지막으로 struct와 enum 정의에서는 모든 수명이 명시적으로 선언되어야 합니다. 만약 이 규칙이 컴파일 에러(compilation errors)를 일으킨다면, Rust 컴파일러는 일어난 에러를 가리키는 메시지를 제공하며 그 에러가 일어난 inference process(추론 단계)에 따라 필요한 solution을 제시할 것입니다. How can Rust guarantee no `null pointers` and no `dangling pointers`(유령 포인터)? \u0026Foo와 \u0026mut Foo 타입의 값을 만드는 유일한 방법은 `이미 존재하는 Foo 타입의 값을 reference가 point하는 값으로 specify하는 것 뿐입니다. reference는 region of code(즉, the lifetime of the reference) 안에서 원래 값을 “빌리며”, reference가 값을 “빌리는” 동안에는 original value를 옮기거나 소멸시킬 수 없습니다. How do I express the absence of a value without null? You can do that with the Option type, which can either be Some(T) or None. Some(T) indicates that a value of type T is contained within, while None indicates the absence of a value. ","date":"2023-01-07","objectID":"/rust_principle/:15:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["dev"],"content":"15. 제너릭 Generic에 대해서는 복잡한 내용들이 많아 링크로 대체합니다. Generic: en GenericL kr ","date":"2023-01-07","objectID":"/rust_principle/:16:0","tags":["rust","principles"],"title":"Rust 디자인 원칙 🦀","uri":"/rust_principle/"},{"categories":["book","wisdom"],"content":"공자가 추구했던 양심이란?","date":"2022-12-18","objectID":"/the_analects/","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"논어가 말하는 양심은 무엇인가? ","date":"2022-12-18","objectID":"/the_analects/:0:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"tl;dr 공자는 ‘인간의 길’에 대한 답을 사랑, 정의, 예절, 지혜의 ‘양심’에서 찾고, 이를 체득하고 실천하는 삶을 살고자 노력하였습니다. (6p) 윤홍식 선생님의 글을 읽으면 항상 많이 배우는 것 같다. 간단하지만 깊어서 생각해보고 적용할 점이 많은 것 같다. 마음에 와 닿았던 문구 위주로 정리해봅니다. ","date":"2022-12-18","objectID":"/the_analects/:1:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"一以貫之, 일이관지 공자께서 말씀하시길 “자공아 너는 내가 많이 배워서 아는 사람이라고 생각하느냐?” “그렇습니다. 아닙니까?”, “아니다. 나는 오직 ‘하나’로 꿰뚫었을 뿐이다.“라고 하셨다. by 논어, [위력공] 우리가 어떤 일을 처리하거나 다른 사람들과 인간관계를 맺을 때 늘 양심에 비추어 보아, 그 옳고 그름을 자명하게 판단한 뒤에 행동하는 것이야말로 양심을 계발하는 첩경입니다. 그렇게 우리의 양심이 계발되면 수많은 지식이 자연히 하나로 꿰어지고, 언제 어디서나 나와 남 모두의 이익을 위해 행동할 수 있게 됩니다. (10p) 자공이 “한 마디 말로서 종신토록 행해야 할 것은 무엇입니까?“라고 묻자, 공자께서 말씀하시길 “그것은 ‘서’(인자할 서)이니 내가 당하기 싫은 일을 남에게 가하지 않는 것이다.“라고 하셨다. by 논어, [위력공] 인자한 자는 자기가 서고 싶으면 남도 세워 주고, 자기가 이르고 싶으면 남도 이르게 해 준다. 자기를 살펴 남의 입장을 이해 하는 것, 이를 ‘사랑의 올바른 방법’이라 말할 수 있다. by 논어 [옹야] 그러니 남을 나 처럼 여기는 사람은, 내가 우뚝 서고 싶은 만큼 남도 우뚝 서고 싶어 한다는 것을 잘 이해하여, 남도 우뚝 설 수 있도록 도와줄 것입니다. 이처럼 남의 욕망에 깊이 공감하게 되면, 남의 마음이 자신의 마음처럼 공감이 되어 무시할 수가 없기 때문에, 결국 남의 성공을 돕게 됩니다. (13p) 먼저 ‘내가 남에게 바라는 것’을 이해하고, 이를 바탕으로 ‘남이 나에게 바라는 것을 정확히 헤아려 남에게 베푸는 것, 이것이야말로 사랑을 실천하는 최선의 방법입니다. 남을 진정으로 사랑하고 싶다면 남이 진정으로 원하는 것을 베풀 수 있어야 합니다. (중략) 사랑을 제대로 실천하기 위해서는 “남에게 바라지 않는 것을 남에게 가하지 말며, 남에게 바라는 것을 남에게 베풀라!“라는 양심의 명령을 충실히 따르기만 하면 되는 것입니다.(14p) “정성스러운 자는 힘쓰지 않아도 적중하고, 생각하지 않아도 답을 알아내며, 언제 어디서나 차분하고 침착하게 ‘중도’를 걸으니 바로 ‘성인’이시다.” by 중용 ","date":"2022-12-18","objectID":"/the_analects/:2:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"Knowing 인간에게는 옳고 그름을 자명하게 분별하는 ‘보편적인 판단능력’이 있습니다. 그래서 배우지 않아도 옳은 것과 그릇된 것을 분명히 구별해 낼 수 있습니다. 맹자는 이것을 ‘양심’중에서 양지(타고난 판단능력)이라 불렀습니다. 이 양지의 발현이 바로 ‘시비지심’입니다. \"(중략) 그래서 다른 모든 것에 있어 까다로운 사람도 양지에 있어서는 자신의 것 이상을 바라지 않는 게 일반적이다. … 올바르게 판단하고 옳고 그름을 판별하는 능력이 바로 양지이며 이성이다” by 데카르트 [방법서설] 모든 일에 대해 다만 ‘옳고 그름’을 살펴볼 뿐이다. 가령 오늘 한 가지 일을 하면서 스스로 마음이 편안하고 의심이 없다면 그것은 ‘옳은 것’이다. 그러나 한 가지 일이라도 스스로 믿을 수 없다면 그것은 ‘그릇된 것’이다. by 남송 주희 [주자어류] 자신의 인지과정을 점검하는 내면의 인지능력을 ‘메타인지’라고 부릅니다. 메타인지는 ‘인지과정을 인지하는 능력’ (중략) 이러한 메타인지가 편견에 의해 왜곡되어 건강하지 못하면, 자신의 편견에 부합하는 것을 자명하다고 착각하게 됩니다.(23p) 공자께서 말씀하시길 “유(자로)야, 너에게 안다는 것에 대해 가르쳐 주마. 아는 것을 안다 하고, 모르는 것을 모른다 하는 것이 바로 ‘아는 것’이다.“라고 하셨다. by 논어 [위정] 알지 못한다는 것을 아는 것이 ‘뛰어난 것’이요, 알지 못한다는 것을 알지 못하는 것이 ‘병’이다. 대저 오직 ‘병’을 병으로 여겨야 병이 없다. 성인은 병이 없으니, 병을 병으로 여기기 때문이다. 이 때문에 병이 없다. by 노자 그 사람은 모르면서도 뭔가 안다고 생각하나, 나는 내가 모르는 것을 모른다고 생각하였습니다. 바로 그 점에서 나는 그 사람보다 ‘지혜’가 있다고 생각했습니다. by 소크라테스의 변론 1)남에게 들었다고 옳다고 여기지 말고, 2) 예전부터 전해내려 왔다고 옳다고 여기지 말고, 3) 소문을 듣고 옳다고 여기지 말고, 4) 자신이 따르는 경전과 일치한다고 옳다고 여기지 말고, 5) 추측으로 옳다고 여기지 말고 6) 체험이 없는 추론을 근거로 옳다고 여기지 말고 7) 논리적이라는 이유로 옳다고 여기지 말고 8) 자신의 사유의 결과와 일치한다고 옳다고 여기지 말고 9) 권위 있는 이가 말했다고 해서 옳다고 여기지 말고 10) 존경하는 수행자가 말했다고 해서 옳다고 여기지 말아야 한다. by Buddha [칼라마(Kalama-sutta)경] All you need to say is simply ‘Yes’ or ‘No’; anything beyond this comes from the evil one. by Jesus, [matt 5:37] ","date":"2022-12-18","objectID":"/the_analects/:3:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"효 유자가 말하길 “그 사람됨이 효성스럽고 공경스러우면서 윗사람을 침범하기를 좋아하는 자는 드물며, 2) 윗사람을 침범하기를 좋아하지 않고서 난리를 일으키기를 좋아하는 자는 있지 않다. 군자는 근본(효,제)에 힘써야 하니, 근본이 확립되면 ‘도’가 자연히 발현된다. 효성스럽고 공경스러운 것은 ‘사랑’을 실천하는 근본일 것이다.” 라고 하였다. 내가 가족이나 남을 위해 뭔가 작은 것이라도 할 수 있는 일이 없는지를 한번 돌아보면서, 그날 하루를 자신의 양심에 충실하게 사는 훈련을 해 보세요. 하루에 하나라도 좋으니, 자신의 ‘생각, 말, 행동’을 재료 삼아 양심을 담은 작품을 만들어 보세요. ‘양심 작품’을 창조하는 삶은 곧장 가능합니다. 우리에게는 양심이 있으니까요. 이러한 창작이 이어지다 보면 뭔가 좋은 생각이 더욱 떠오르고, 인생의 활로가 보이고, 세상을 바꿀 힘도 생길 것입니다. (47p) ","date":"2022-12-18","objectID":"/the_analects/:4:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"교언영색 (교묘한 말고 꾸민 얼굴) 공자께서 말씀하시길 “말을 교묘하게 하고 얼굴색을 예쁘게 꾸미는 사람치고 인자한 사람이 드물다.“라고 하셨다. 정말로 양심적이라면 욕심꾼과 내가 둘 다 잘살 수 있는 방법을 찾아 버리기 때문에, 욕심꾼이 나를 어떻게 하지 못합니다. 여러분도 그런 자명하고 강력한 양심을 추구하시기 바랍니다. 상대방을 가해자로 만들고 자신을 피해자로 만드는 일이 양심적일 수는 없으니까요. (53p) ","date":"2022-12-18","objectID":"/the_analects/:5:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"조화와 절제 유자가 말하기를 “예절을 쓸 때에는 ‘조화’를 귀하게 여긴다. (중략) 그러나 절대로 행해지지 않을 것이 있으니, 오직 조화만 알고 조화만을 추구하여 예절로서 ‘절제’하지 않는다면, 또한 행해지지 않을 것이다. 라고 하였다. 예절에는 조화가 참으로 귀한 것입니다. 예절은 여러 사람이 모여서 서로를 배려하고 조화롭게 살기 위해 필요한 것이니까요. 예절은 5행 중에서는 ‘불’의 덕목이고, 계절로는 여름의 덕목입니다. 여름에는 만물이 자기 안에 있던 것을 훤히 타오르는 불처럼 밖으로 표현합니다. 겨울에 씨앗으로 존재하던 것이 여름이 되면 아름드리나무가 되고 꽃이 되어 자신의 속을 완전히 드러내죠. 그런데 만약 조화가 없이 각자대로 자기표현만 중시한다면 전체는 엉망이 될 것 입니다. 서로를 배려해 가면서 자기 소리를 내야만 전체적인 하모니가 이루어지니까요. 그런데 유자는 오직 ‘조화’만 중시하면서 서로 ‘절제’를 하지 않으면, 또한 문제가 생길 것이라고 경고하고 있습니다. 예절에는 조화가 중요하지만, 그 안에 반드시 절도나 절제가 있어야 함을 말하는 것입니다. 예절이 본래 조화를 추구하지만, 절제를 잃어버리면 크게 방탕해지는 결과를 낳을 수가 있으니까요. 예절에는 절제가 중요하지만 그 안에는 반드시 이런 ‘조화’와 ‘사랑’이 있어야 합니다. 사랑이 없는 예절은 남과 조화를 이룰 수 없고, 결국 살벌한 형식만 남게 될 것이기 때문입니다. (107p) ","date":"2022-12-18","objectID":"/the_analects/:6:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"정의와 예절과 사랑 유자가 말하기를 1)약속이 ‘정의’에 가까워야 그 말한 바를 실천할 수 있으며, 2)공손하더라도 ‘예절’에 가까워야 치욕을 멀리할 수 있다. 3) 이로 말미암아 친애하는 이들을 잃어버리지 않는다면, 또한 숭상할 만하다.“라고 하였다. 예절에 합당하지 않으면 치욕스러운 일을 당할 수 있다고 경고하고 있습니다. 이것은 너무 지나치게 공손한 것은 옳지 않다는 의미입니다. 예절에 맞는다면 사실 당당해야 합니다. 내가 당당하게 남을 배려해 주는 것이 예절인데, 공손함이 지나치면 비굴해질 수 있죠. 자신이 비굴해지는 것은 양심에도 맞지 않는다고 느낄 겁니다. 그런 행동은 하고 나서 본인 뿐만이 아니라 받은 사람도 찜찜해집니다. 양심에 찜찜한 것은 그런 행위가 결국 ‘욕심’ 때문에 이루어진 것이기 때문입니다. 남에게 공손한 사람으로 보이고 싶다는 욕심이 오히려 일을 망치는 것이죠. (114p) ","date":"2022-12-18","objectID":"/the_analects/:7:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"학문을 좋아하는 자세 공자께서 말씀하시길 “1) 군자가 음식을 먹음에 배부름을 구하지 않으며, 2)거처함에 편안함을 구하지 않고, 3) 일을 실천함에 민첩하며, 4) 말을 삼가고, 5) 도가 있는 이에게 나아가 바로잡는다면, 가히 학문을 좋아한다고 이를 만하다.“라고 하셨다. 군자는 말이 실천보다 앞서지 않게 항상 조심합니다. 자신의 행실이나 역량보다 말이 앞서면 결국 ‘거짓’과 ‘사기’가 됩니다. 사기꾼이란 게 별게 아니라, 말을 세게하고 실천이 약한 사람을 말합니다. 말이 역량 이상으로 과한 것은, 남에게 인정받고 싶다는 욕심이 크기 때문입니다. 그래서 사람들은 흔히 말이 실천보다 과한 것입니다. (121p) ","date":"2022-12-18","objectID":"/the_analects/:8:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"남을 알아주지 못함을 걱정하라 공자께서 말씀하시길 “남이 나를 알아주지 못함을 걱정하지 말고, 남을 알아주지 못함을 걱정해야 한다.“라고 하셨다. 예절: 처한 상황을 있는 그래도 진심으로 수용하고, 생각과 언행이 겸손하며 상황과 조화를 이루었는가? (134p) ","date":"2022-12-18","objectID":"/the_analects/:9:0","tags":["book"],"title":"The analects, by Confucius","uri":"/the_analects/"},{"categories":["book","wisdom"],"content":"워렌 버핏이 바라보는 돈과 투자 그리고 기업에 대하여.","date":"2022-12-15","objectID":"/warren_buffett/","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"워렌 버핏이 바라보는 돈과 투자 그리고 기업에 대하여. ","date":"2022-12-15","objectID":"/warren_buffett/:0:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 워렌 버핏은 어떻게 부자가 되었을까? 남들이 비싼 물건들을 구입하기 바쁠 때, 꼭 필요한 물건이 무엇일지 비싸게 고민하고 남들이 싸게 물건들을 팔기 바쁠 때, 자신은 꼭 필요한 물건만 주시하다 싸게 구한 뒤, 몇 년이 지나 남들이 꼭 필요한 물건을 비싸게 탐내기 시작하면, 욕심 부리지 않는 선에서 만족스러운 금액을 받고 다시 주는 것. ","date":"2022-12-15","objectID":"/warren_buffett/:1:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 실제로 주식 투자로 부자가 되기 위해서는 평생 동안에 올바른 결정 몇 개만 내리면 된다. 위대한 투자 아이디어는 일년에 한 번도 도출되기 어려울 만큼 드물다. (112p) 그는 무언가를 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. (65p) 연상된 점: 올바른 결정, 원하는 것 깨달은 점: 부자가 되기 위한 몇번 안되는 결정을 내리기 전에, 올바른 것이 무엇인지 자신이 무엇을 원하고 있는지 명확하게 알고있어야 한다. 인생을 잘 살기 위해서는 올바른 것이 무엇인지, 내가 무엇을 구하고 있는지 명확하게 알아야 한다. 나는 내 무의식을 다스리지 못하고 있기 때문에 계속 ‘따뜻한 아이스아메리카노’를 주문하고 있었고, 몇몇 부자들은 독이든 아이스 아메리카노를 주문한 것 같다. ","date":"2022-12-15","objectID":"/warren_buffett/:2:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"3. 저자의 주장에 대한 나의 생각 “사업의 세계에서는 백미러가 전면 유리보다 더 선명하게 보이는 법이다.” 버핏은 기술 분야의 앞날을 예측할 수 없다며, 이는 자신의 절친한 친구이자 컴퓨터 업계를 속속들이 알고 있는 빌 게이츠 역시 마찬가지일 것이라고 말한다. 앞날을 예측하는 것이 어렵다는 사실은, 버핏이 오랜 세월을 두고 그 실효성이 입증된 제품에만 관심을 두는 원인이기도 하다. 실효성이 입증된 제품의 경우, 적어도 15년 정도는 앞을 내다볼 수 있다. +: 15년 미래를 예측한다는 것과 워렌 버핏이 기술 분야에 관심을 덜 가져주어서 감사하다. 워렌 버핏이 들어왔다면 기술관련 주식들을 더 비싸게 구매해야 되기 때문이다. -: 직접 소설가가 되어보기 전까진, 소설이 아닌 것을 써볼 수 없다. 버핏은 엔지니어가 아니었기 때문에 기술 분야의 앞날을 모르는 것은 당연한 일이다. 어찌보면 모르기 때문에 투자하지 않는 것은 당연한 일이지만, 이 판단은 소설이기 때문에 나와는 맞지 않다. 아빠가 되어보면 아빠를 이해할 수 있고, 기술자가 되어보면 기술을 이해할 수 있다. 이해할 수 있다면, 당연히 예측도 가능해야 한다. ","date":"2022-12-15","objectID":"/warren_buffett/:3:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"4. 질문 및 토의 사항 Q. 다들 주문할 좋은 기업들은 찾으셨나요? ","date":"2022-12-15","objectID":"/warren_buffett/:4:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"5. 작은 실천 계획 돈을 버는 것도 중요하지만, 그 만큼 번 돈을 함부로 쓰지 않는 것도 중요하다. (12p) 미국 여행 지출 기록 매달 말 토요일, 지출계획표 작성 루틴 추가. 경기침체 대비, 앞으로 1년간 현재 지출에서 40% 절감 목표. 주식을 산다는 것은 기업의 일부를 산다는 의미다. (38p) 투자할 기업들 비전 정리 및 CEO 기부 현황 분석표 작성. “회계는 업종을 불문하고 모든 사업의 언어다.” (51p) 재무재표 관련 도서구매 “나는 10년 혹은 15년 후의 그림이 그려지는 사업을 찾는다.” (68p) 투자 시나리오에 10년-15년 미래 시나리오 작성 기업의 연차 보고서도 읽으라. 그러나 문자 그대로 따라해서는 곤란하다. (72p) 투자 시나리오 양식에 기업별 연차 보고서 링크 추가 ","date":"2022-12-15","objectID":"/warren_buffett/:5:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"6. 자유 감상문 템플턴 동안 책추남님이 추천해주신 책들은 읽을 때 한번, 내 생각으로 반박해보면서 한번, 저자를 통해 무언갈 받아들일 때 또 한 번 읽게 된다. 그래서 그런지 쉽게 읽지 못하고, 대부분 한 달 정도를 고민하고 나에게 적용하려고 노력했다. 이 책과 ‘돈 공부는 처음이라’ 역시 한 달 정도를 고민했다. 지금 이 글을 쓰는 시점인 아침, 내일 있을 만남에서 공유할 숙제들을 하지 못했다는 생각에 무거운 마음으로 기상했다. 그렇게 마음에 여유가 없는 상태에서 아침에 글을 쓰는데 잘 써지지 않았다. 사실 글을 쓸 수 있는 시간은 많이 있었지만, ‘좀 더 완벽하게!’, ‘좀 더 내 가슴이 뛰는걸!’, ‘좀 더 내가 실천할 수 있는걸!‘들을 외치다 보니 어느새 시간이 다 지나있었다. 이러다 보니 시간에 쫒겨 여유로울 때보다, 더 인위적인 글이 작성되는 것을 느꼈다. “불완전하더라도, 일주일 전에 글을 완성하고 보완했으면 어땠을까?” 이렇게 마음의 여유가 없게 된것은 내가 시간을 잘 관리하지 못해서이고, 다른말로 내가 ‘시간’에 대해 부유하지 않다는 것이다. 그렇게 생각하니 문득 내가 원하는 부자들의 공통점을 하나 떠올리게 되었는데 그것은 “마음의 여유\"였다. “나는 내가 넘지 못할 2미터의 막대를 뛰어넘으려 하지 않는다. 충분히 넘을 수 있는 30센티미터의 막대를 넘으면 그만이다. by 워렌 버핏” 나는 마음의 여유를 가지고 싶다. 따뜻한 아침을 보내고 싶고, 평온한 저녁을 보내고 싶다. 내가 원하는 부자란 이렇게 마음의 여유가 있는 사람이고, 10년 뒤에도 지금처럼 마음의 여유를 가지기 위해서는 그저 10년 뒤인 나와 내 가정이 필요할 금액을 지금부터 구해두면 된다. 돈이 없으면 마음의 여유가 없고, 돈이 있지만 마음의 여유가 없으면 부자가 될 수 없다. 이 공식을 적용하면, 워렌 버핏은 중요한 게 무엇인지 알고 계신 분이었다. 그렇기 때문에 10-15년 동안 신경 쓰지 않아도 될 기업들에 투자하였던 것이다. 구하라, 그러면 얻을 것이다. 그러나 구하지 않는다면 절대 얻을 수 없다. (16p) 워렌은 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. (65p) 이 공식은 앞으로 나의 투자에서도 똑같이 적용할 것이다. 나는 내가 가장 좋은 퍼포먼스를 낼 수 있는 상태가 ‘마음의 여유’가 있는 상태라는 것을 알고. 마음의 여유가 있는 상태에서 행동했다면, 지금 내가 할 수 있는 최고의 행동을 한 것이다. “불완전하게 시험공부를 하고, 마음이 여유로운 상태로 보다 완벽을 구하자. 중요한 것은 마음의 여유이다.” 이 글을 다 쓴 시점, 문득 ‘버핏의 공식을 적용한 나’보다 더 부자가 되는 방법이 떠올랐는데, 그것은 머리로는 버핏의 20년이 아닌 30년 뒤의 미래를 준비하는 마음을 가지는 것이고, 가슴으로는 30년 뒤에 마음의 여유가 없을 사람들을 위해, 내가 할 수 있는게 뭐가 있을지를 고민하고 지금 준비하는 것이라고 생각했다. “오래전에 누군가가 나무를 심었기 때문에 오늘 당신이 나무 그늘에서 편히 쉴수 있는 것이다. by 워렌 버핏” ","date":"2022-12-15","objectID":"/warren_buffett/:6:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"Buffett’s Quotes ","date":"2022-12-15","objectID":"/warren_buffett/:7:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"1. Getting and Staying Rich (부자되기 그리고 부자로 살아남기) 12 돈을 버는 것도 중요하지만, 그만큼 번 돈을 함부로 쓰지 않는 것도 중요하다. 16 매도 호가는 높게, 매수 호가는 낮게 부르라. (중략) 구하라, 그러면 얻을 것이다. 그러나 구하지 않는 절대 얻을 수 없다. 20 미국에서 개인이 모은 가장 큰 재산은 50개 기업으로 구성된 포트폴리오로 형성된 것이 아니다. 오직 하나의 탁월한 사업을 알아본 사람에 의해 가장 큰 부가 완성되었다. 22 일단 서명하면 계약을 파기하는 것은 불가능하다. 24 곤란한 상황에서 빠져나오는 것보다 그런 상황에 빠지지 않도록 조심하는 것이 훨씬 쉽다. 26 투자 결정은 결혼을 결정하는 것처럼 신중하게 28 업종을 불문하고 사업 전망이라는 것은 언제나 지나치게 장미빛을 띠게 마련이다. 29 “돈을 잃어도 좋습니다. 아주 큰돈을 잃더라도 상관없습니다. 하지만 절대로 명성을 잃어서는 안 됩니다. 아무리 작은 명성이라도 말입니다. (중략) 결국 우리는 합당한 평가를 받게 될 것입니다.” 31 주식시장은 자신이 무엇을 하는지 아는 이에게는 부를 선사한다. 그러나 무엇을 하는지 모르는 이에게는 가차없이 가난을 안긴다. 그래서 무지한 사람이 탐욕스럽기까지 하면 심각한 금전적 타격을 입게 되는 것이다. 자신이 무엇을 하는지 모르는데 따르는 대가는 이처럼 엄청나다. 32 타석에 들어설 때마다 홈런을 치겠다고 욕심을 부리지도 않는다. 다만 자신만의 고유한 타격 자세를 잡은 뒤 자신이 좋아하는 공이 오기를 묵묵히 기다릴 뿐이다. 더 이상 개선할 필요가 없는 훌륭한 제품을 생산하는 회사, 20년 후에도 건재할 것이 확실한 사업, 전부 매수해도 좋을 가격에 주식이 매매되는 회사 등을 노리는 것이 버핏이 말하는 자신만의 고유한 타격 자세다. 34 습관이라는 사슬은 끊어지기 전까지는 너무 가벼워 그 무게를 전혀 느끼지 못한다. (중략) 사업이 공경에 처한 다음에야 비용을 절감하는 기업을 떠올려 보자. 37 뭔가 대단한 일을 해야만 위대한 결과를 얻을 수 있는 것은 아니다. 하루 아침에 벼락부자가 되는 것만이 부자가 되는 유일한 길은 아니다. 버핏은 연평균 수익률 200퍼센트가 아니라 20퍼센트를 목표로 한다. 연리 20퍼센트로 10만 달러를 투자하면 20년 후에는 총 380만 달러가 된다. 30년이면 2370만 달러다. 주식 투자는 마라톤과 같다. 38 주식을 산다는 것은 기업의 일부를 산다는 의미다. 39 투자의 세계에서 큰돈을 벌기 위해서는 우선 자기 스스로 생각하는 법을 배워야 한다. 그리고 자기 스스로 생각하기 위해서는 홀로 서는 것을 두려워하지 말아야 한다. 41 5조 달러 규모의 미국 주식 시장에서 돈을 벌지 못하면서 수천 마일 떨어진 해외에서 실력을 보여 준다는 것은 희망 사항에 불과하다. (원효대사 해골물이 생각남) 45 버핏은 자식들에게 큰 재산을 물려주면 그들이 자신만의 인생을 살 수 없다고 생각한다. 부모의 재산을 물려받은 사람들이 상류층을 형성하는 것이 사회적으로도 결코 좋지 않다고 생각한다. 일한 만큼 벌고 번 만큼 대우받으며 사는, 능력 위주의 사회가 국가 발전에 더 기여한다는 생각이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:1","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"2. Business (투자 기업 고르기) 48 모든 것에는 끝이 있다. 굴러가는 공만 살펴서는 안 된다. 공이 어디로 굴러가고 있는지도 미리 살펴야 한다. 50 회사 운영 능력이 탁월한 경영자도 기초 체력이 부실한 기업은 어쩔 수 없다. 위대한 기업은 현금이 풍부한 반면 부채는 거의 없다. 또한 어려운 상황을 돌파하거나 불황을 견디는 능력도 뛰어나다. 그러나 평범한 기업은 언제나 현금 확보에 전전긍긍하며, 부채는 넘쳐난다. 51 회계는 업종을 불문하고 모든 사업의 언어다. 52 변화는 쉽게 일어나지 않는다. 세상에는 부실한 기초 체력 때문에 저가에 거래되는 기업이 수두룩하다. 버핏은 이런 기업 보다 제대로 된 가격에 거래되는 우량 기업을 선호한다. 우량 기업임에도 저가에 매매되는 경우라면 더욱 선호한다. 그러나 이런 경우는 극히 드물다. 54 가격이 폭락한 종목을 살 때는 그 회사의 장기적인 기업 가치에 문제가 없는지 반드시 확인해야 한다. 장기적 기업 가치가 건재하다면 기업의 장기적인 실적도 우수할 것이고, 이것은 결국 주가에 반영될 것이다. 56 주식 투자는 자신이 다닐 회사를 선택하는 것과 비슷하다. 이는 어려운 문제라기보다 올바른 선택의 문제다. 확실한 기차에 올라타야 시간 낭비와 고통을 그만큼 줄일 수 있다. 오랫동안 노력하여 튼튼한 기초 체력을 갖춘 기업은 어떠할까? 이런 회사는 대개 현금이 여유로운 편이다. 따라서 월급도 많고, 실적에 따른 연봉 인상과 보너스도 잦다. 게다가 경영진은 항상 풍부한 현금을 유용하게 사용할 방법을 모색하기 때문에 회사가 발전할 여지도 많다. 58 부실 운영과 부실 경영은 부실 회계로 이어진다. (중략) 지금도 어떤 기업에서는 회계 부정을 저지르고 있다는 사실을 명심하라. 59 성장하기 위해 많은 자본이 필요한 사업과 많은 자본이 필요 없는 사업의 차이는 크다. 이런 업종은 경쟁에서 살아남기 위해 끊임 없이 자본을 투입해야 한다. 5년마다 제품을 재구성하는데 수십억 달러를 들여야 한다면 사업 규모 확대나 신사업 인수, 주식 환매 등에 지출할 돈은 그 만큼 적어지게 된다. 한편 사업을 성장시키는 데 가외 자본을 투입할 필요가 없는 경우에는 이 돈을 사업 규모 확대 등에 지출할 수 있다. 이렇게 되면 회사의 주당 순이익이 증가하고, 결국 주가도 상승하게 된다. 성장하는 데 막대한 자본이 필요한 업종을 선택하면 큰돈을 벌기 어렵다. 반면 성장에 큰 자본이 필요 없는 종목을 선택해서 손해를 보는 일은 거의 없다. 61 기초 체력이 부실한 기업은 한 가지 문제를 해결하고 나면 곧바로 또 다른 문제에 봉착한다. 부엌에 바퀴벌레가 한 마리만 있는 경우는 드물기 떄문이다. 62 싸구려 시장으로 진출해도 매출을 증가시킬 수는 있지만, 일단 싸구려로 전락하면 다시 고가 시장으로 올라가기 힘들다. 64 “인간의 모든 비극은 혼자 조용히 방에 있지 못하는데서 비롯된다.” by 파스칼. 64 CEO들은 대개 조용히 방에 있지 못하다. 그들은 동분서주하며 이 회사 저 회사와 계약을 맺고, 이를 통해 회사 몸집을 불리는 일만이 자신들이 받는 엄청난 연봉에 걸맞은 행동이라고 생각한다. 월스트리트가 이를 부추기는 면도 분명 있다. 거기에 기존의 문제를 해결하기 보다, 새로운 문제를 떠맡기가 종종 더 쉽다는 사실도 작용한다. 버핏은 지속적인 경쟁 우위를 지닌 기업만을 사들인다. 이런 기업은 높은 자기 자본 이익률과 지속적으로 높은 수익률이 증명하듯 경제적 기초 체력이 튼튼하다. “무차별 상품형(commodity-type) 이런 유형의 사업은 소비자가 구매를 결정하는 중요한 요인이 가격밖에 없는 제품과 서비스를 제공하기 때문에 자본 이익률도 낮고, 수익률도 일정하지 않다. 전 세계에 있는 회사 대부분이 이러한 무차별 상품형 기업에 속한다. 65 그러나 한 가지 확실한 것이 있다. 버핏은 지속적인 경쟁 우위를 보이는 기업을 발견하면 지체하지 않고 사들인다는 사실이다. 그는 무언가를 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. 66 투자 리스크는 사업의 질이 높을수록, 그리고 사업의 질에 비해 주가가 낮을수록 리스크는 낮아진다.(투자 리스크=주가/사업의 질) 주식시장에서 반드싯 피해야 하는 것은 질 낮은 기업을 높은 가격에 사는 일이다. 질이 높은 기업과 질에 비해 저가인 종목은 취하고, 질이 낮은 기업과 질에 비해 고가인 종목은 피해야 한다. 67 주식 투자는 종목 하나하나가 완전히 새로운 게임이라는 사실을 명심하라. 충분한 안전 마진(margin of safety)이 확보될 정도로 승률이 자신에게 유리하게 전개될 때를 기다려 크게 투자하는 것이 돈을 버는 비결이다. 재미있는 사실은, 주식 시장은 종종 아주 성공이 확실한 종목들을 선보인다는 사실이다. 버핏이 추구하는 것은 오직 이처럼 확실한 성공을 보장하는 종목들뿐이다. 68 나는 10년 혹은 15년 후의 그림이 그려지는 사업을 찾는다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:2","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"3. Mentors (거인의 어깨 위에 올라타기) 70 오래전에 누군가가 나무를 심었기 때문에 오늘 당신이 나무 그늘에서 편히 쉴수 있는 것이다. 거인의 어깨 위에 올라타면 당신이 일하는 분야에서 더 큰 성공을 거둘 수 있다. 중요한 것은 자신에게 맞는 거인을 선택하는 일이다. 71 유용하다 싶은 내부 정보를 들었다면 다른 사람은 이미 그것을 이용하고 있다는 사실을 명심하라. 더구나 내부 정보를 이용한 거래는 불법이다. 72 벤저민 그레이엄과 필 피셔의 책을 읽으라. 기업의 연차 보고서도 읽으라. 그러나 문자 그대로 따라해서는 곤란하다. 74 나는 사업가이기 때문에 더 좋은 투자가가 될 수 있고, 또 투자가이기 떄문에 더 좋은 사업가가 될 수 있다. 뛰어난 사업가는 좋은 사업과 그렇지 못한 사업을 구별할 줄 안다. 뛰어난 투자가는 사업체가 싸게 거래되고 있는 때와 비싸게 거래되고 있는 떄를 구별할 줄 안다. (commodity-type \u003c-\u003e consumer-monopoly, 소비자 독점형) 75 버핏은 경쟁 우위가 있는 소비자 독점형 기업만 사들였다. 제값만 주고 살 수만 있다면 장기간 보유했을 떄 반드시 큰돈을 벌어 줄 것이라고 버핏은 확신했다. 78 모두가 노리는 종목에 투자하려면 아주 비싼 대가를 치러야 한다. 이런 종목은 향후 주가가 오를 일은 별로 없는 반면 떨어질 일은 아주 많다. 가격이 떨어질 일만 남은 종목을 고가로 매수하는 것보다는 가격이 오를 일만 남은 종목을 저가로 매수하는 것에 더 관심이 있다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:3","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"4. Education (스스로 익히는 투자 전략) 83 자신의 경험을 통해 배우는 것도 좋지만, 가능하면 다른 사람의 경험을 통해 배우는 것이 현명하다. (중략) 무엇을 해야 하는지 알아야 하는 것과 마찬가지로 무엇을 하면 안 될지도 알아야 한다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:4","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"5. Management Philosophy (버핏의 경영 철학) 87 누군가를 고용하려 할 때는 정직, 지능, 열정 이 세가지를 살펴야 한다. 그중에서도 가장 중요한 것이 정직이다. 정직하지 않다면 지능과 열정도 그 빛을 잃는다. 89 물고기에게 땅에서 걷는 일이 어떤 것인지 설명할 수 있을까? 수백 번 이야기하는 것보다 단 하루라도 직접 걸어 보게 하는 것이 낫다. 사업을 운영하는 것도 이와 마찬가지다. 90 수영장의 물이 다 빠지고 나서야 누군가 알몸으로 헤엄치고 있었다는 사실을 알게 된다. 실제로 돈이 보이지 않으면 환상에 가까웠던 열렬한 호들갑은 한순간에 사라지고 만다. 남는 것은 텅 빈 통장과 파산 선고뿐이다. 문제는 물이 빠지기 전까지는 누가 알몸으로 헤엄치고 있는지 모른다는 것이다. 91 아이디어가 부실하면 말이 화려해진다. 주주들의 비난을 피하려고 하는 것은 결국 자신의 결정에 책임을 지지 않겠다는 의미다. 책임지지 않는 CEO를 기업의 리더라고 할 수 있을까? 주주인 내가 바로 그 회사의 소유주가 아닌가? 92 “오늘부터 비용을 점감하겠다\"고 말하는 관리자는 그다지 훌륭하다고 볼 수 없다. 93 사랑은 100만 달러를 줘도 살 수 없다. 사랑을 받는 유일한 방법은 스스로 사랑받을 만한 사람이 되는 것이다. 사랑받는 사람은 먼저 남에게 자신이 가진 것을 준다. 그리고 결과적으로 준 것보다 더 많이 받는다. 그는 먼저 남에게 주지 않으면 아무것도 얻지 못한다는 사실을 안다. 이렇게 사랑을 받는 사람 중 자신이 성공하지 못했다고 느끼는 사람은 없다. 또한 사랑을 받지 못하면서도 성공했다고 느끼는 사람도 없다. 94 사랑과 존경은 더 큰 사랑과 존경을 낳는다. 95 나를 움직이는 것은 결과보다는 과정에서 맛보는 일에 대한 재미와 열정이다. 버핏은 투자자로서 자신의 일에 열정이 있다. 그는 심지어 돈을 내고서라도 투자라는 일을 할 사람이다. 그러나 실제로는 돈을 지불하기는커녕 좋아하는 일을 하면서도 엄청난 부자가 되었으니 이보다 더 좋은 일이 있을 리 없다. 96 매 홀마다 홀인원을 한다면 골프를 오래 즐기기 어렵다. 도전이 없는 일은 지루하며, 자부심도 느끼기 어렵다. 당연히 동기 부여가 되지 않은 사람들만 꾀게 마련이다. 도전과 함께하는 일이라야 재미도 있고, 자부심도 높아진다. 도전과 함께하는 일이라야 창의력을 발휘할 수도 있고, 최고의 인재를 끌어 모을 수도 있다. 그러나 도전에는 항상 위험이 따른다. 실수하라 어느새 성공이 가까이에 와 있음을 알게 될 것이다. 97 언젠가 하고 싶은 일을 할 수 있는 때가 오면 자신이 정말 사랑하는 일을 하라. 아침에 저절로 눈이 떠질 것이다. 98 신나게 할 수 있는 일을 하라. 돈은 따라올 것이다. 일을 위해 열심히 일하면 나중에는 그 일이 당신을 위햏 일해 줄 것이다. 단지 멋진 경력을 하나 보태겠다는 생각에 좋아하지도 않는 일을 선택하는 것은 어리석은 짓이다. 99 “완벽한 이상형을 찾아 헤맨 친구가 있었다. 마침내 그 여자를 찾았을 때는 안타깝게도 그녀 역시 자신만의 이상형을 찾고 있었다.” ","date":"2022-12-15","objectID":"/warren_buffett/:7:5","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"6. Analysts, Advisers, Brokers (투자자가 반드시 피해야 할 사람들) 102 이발사에게 머리카락을 잘라야 하냐고 묻는 것만큼 어리석은 행동은 없다. 문제를 고쳐 주는 대가로 돈을 받는 사람들은 문제가 없으면 돈을 벌 일도 없기 때문에 없는 문제라도 만들어 내는 경향이 있다. 103 예측하는 사람에게 있어 앞날을 묻는 사람이란 그저 자신에게 돈을 주는 사람, 그 이상도 이하도 아니다. 전문적인 예측가라 하더라도 미래가 훤히 내다보이는 수정 구슬을 가지고 있는 것은 아니다. 이들에게도 그저 매달 갚아야 하는 주택 융자금과 학비를 대야 하는 대학생 자녀들이 있을 뿐이다. 104 이처럼 월스트리트는 투자자들로 하여금 이 종목에서 저 종목으로 최대한 자주 갈아타게 만들고, 이로부터 수익을 얻는다. 증권분석가라고 불리는 예측가들의 주 업무는 투자자들이 투자 종목을 이리저리 바꾸도록 종용하는 일이다. 문제는 이런 행동이 반복되는 가운데 돈을 버는 것은 투자자가 아니라 월스트리트의 예측가들이라는 사실이다. 105 다수의 의견이 나의 판단을 대신하도록 내버려 두어서는 안 된다. 107 “가장 단순한 설명이 가장 훌륭한 설명 by 윌리엄 오컴”, 인간에게는 쉬운 것을 어렵게 만드는 묘한 성향이 있는 것 같다. 무엇이든 이해하기 어렵게 만들어야 사람들이 전문가를 찾게 되고, 자신은 전문가로서 문제를 해결해 준 대가로 높은 수수료를 받을 수 있다는 것이다. 주식 중개인의 논리는 아주 간단하다. 자신이 받는 보수는 주식 투자자를 부자로 만들어 주는 데 대한 대가라는 것이다. 그리고 복잡하고 어려운 투자 게임을 투자자 혼자 하기는 어렵기 때문에 주식 중개인인 자신에게 자문을 구해야 한다고 한다. 그러나 주식 중개인들이 그렇게 똑똑하다면 자신이 부자가 되기 위해 굳이 다른 사람, 즉 투자자의 돈이 필요할까라는 의문을 던져 보아야 한다. 109 증권회사는 30년 동안 주식을 보유하라고 권할 수 없다. 그것은 힘든 자기희생을 기꺼이 감내하는 수도승이나 할 수 있는 일이다. 109 시장 상황의 변화를 구실로 불과 한 달 전에 매수한 종목을 다시 매도하라고 권하는 주식 중개인이 있다면, 그는 망상에 빠진것이 아니라 단지 거짓말을 하고 있는 것이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:6","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"7. Why Not to Diversify (투자 결정을 내릴 때) 112 어떤 종목에 투자하려면 그 종목의 사업 경쟁력을 모두 검토해야 한다. 이를 생각하면 50개의 서로 다른 종목에 투자하는 것이 소수 종목에 집중 투자하는 것에 비해 집중도나 시간적인 면에서 효율적이지 못하다는 것을 알 수 있다. 112 실제로 주식 투자로 부자가 되기 위해서는 평생 동안에 올바른 결정 몇 개만 내리면 된다. 위대한 투자 아이디어는 일년에 한 번도 도출되기 어려울 만큼 드물다. 113 분산 투자는 자신의 무지를 감추는 수단에 불과하다. 버핏은 자신이 무엇을 하고 있는지 알고 있기 때문에 굳이 달걀을 나눠 담지 않는다. 그보다는 제대로 고른 달걀 몇 개에 자신의 투자를 집중한 다음 엄중히 관리하는 것을 선호한다. 114 월스트리트는 거래가 있어야 돈을 번다. 그러나 투자자는 움직이지 않고 가만히 있을 때 돈을 번다. 119 옳은 선택 몇 개만으로도 충분히 성공할 수 있다. 버핏의 재산 가운데 90퍼센트는 이렇게 선별한 10개 종목으로부터 형성되었다. 하지 않는 것이 하는 것 만큼 중요할 떄도 있다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:7","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"8. Discipline, Prudence, and Patience (투자자의 태도) 122 “사소한 일에서 원칙을 지키지 못하면 큰일을 할 때도 원칙을 지키기 어렵다.” 123 글로 써보는 것만큼 스스로 생각하게 만들고 또 자신의 사고를 바로잡는 방법도 없다. 어떤 것을 글로 표현할 수 없다면 그것에 관해 제대로 생각해 보았다고 할 수 없다. 당신의 돈을 어디에 투자해야 하는지 머릿속으로만으로 생각하는 것도 좋지만, 직접 글로 써 보는 것이 더 좋은 이유는 바로 여기에 있다. 124 다른 사람들이 덜 신중하게 행동할수록 더 신중하게 행동하라. 이는 특히 주가가 하늘 높은 줄 모르고 치솟는 강세장일 때 더욱 빛을 발하는 말이다. 125 “투수가 공을 던지기 전에 방망이를 휘두르지 말라” 기다릴 줄 아는 버핏은 미래의 사업 실적을 가늠하기 어려운 회사는 절대 매입하지 않는다. 지금 수익을 올리고 있더라도 과거에 실적이 전혀 없는 회사를 멀리하는 것도 같은 이유 때문이다. 과거에 단 한푼의 수익도 올린 적이 없는 회사를 사들이는 것은 그 회사가 앞으로 돈을 벌 것이라는 막연한 바람을 사는 것과 다름없다. 결국 있지도 않을 미래의 수익 흐름(income stream)을 위해 투자하는 것이다. 존재하지 않을 미래의 수익 흐름은 그 가치를 측정할 수 없다. 만약 당신의 투자 전략이 회사의 막연한 미래 수익에 근거하고 있다면 당신은 미래의 불확실성에 필연적으로 뒤따르는 난관을 자초하고 있는 것이다. 127 “개인의 가장 중요한 자산은 바로 자기 자신이다. 그러므로 스스로를 관리하고 향상시키기 위해 부단히 노력해야 한다.” 128 “나 역시 고급 양복을 구입한다. 그러나 미래 가치를 생각했을 때 그다지 수지맞는 구매라고는 할 수 없다.” 129 “배우자를 고르는 것처럼 매수할 기업을 고르라. 즉 적극적인 관심과 특정 상대를 배제하지 않는 열린 마음으르 가져야 한다. 그러나 절대 서둘러서는 안 된다.” 129 적절한 때란 언제인가? 바로 일반적인 약세장이나 업종 불황, 기업의 기초 체력에 영향을 주지 않는 일회성 사건, 광적인 투매 현상 등이 이에 해당한다. 초유량 기업의 주식이 엄청나게 싼 가격에 거래되는 떄가 바로 투자할 타이밍이다. 버핏은 그저 인내심을 갖고 이런 상황이 나타나기를 느긋이 기다릴 뿐이다. 물론 이런 상황이 매일, 매달 일어나는 것은 아니다. 심지어 수년 동안 전혀 일어나지 않을 떄도 있다. 그러나 이런 투자 상황은 적어도 버핏을 세계 2위의 부자로 만들어 주기에 충분할 정도로는 주기적으로 발생했다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:8","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"9. Beware the Folly of Greed (일류 투자자의 기질) 132 다른 투자자들이 머뭇머뭇할 때 위대한 기업을 매입하라. 그러나 다른 투자자들이 모두 욕심을 내고 있다면 아무리 위대한 기업이라도 신중하라. 이런 기질을 갖춘 투자자라면 언제 어느 곳을 겨냥하여 방아쇠를 당겨야 할지 스스로 알 것이다. 즉, 다른 모든 투자자들이 겁을 먹고 주식을 헐값에 처분할 떄 방아쇠를 당기고, 다른 투자자들이 너나없이 달려들어 주가가 턱없이 치솟을 떄 총알을 아껴야 한다는 것을 안다. 132 버핏은 지금까지 과도한 주가 상승을 이유로 주식 매수를 완전히 멈춘 적이 두 번 있었다. 첫 번째는 1960년대 후반의 강세장, 두 번째는 1990년대 후반의 강세장이었다. 이를 통해 상당량의 현금을 확보, 시장 붕괴의 철퇴를 맞아 헐값이 된 종목들을 손쉽게 사들일 수 있었다. 134 버핏은 이따금 투자자들이 특정 종목에 과도하게 몰려들어 주가를 높인다는 사실을 잘 알고 있다. 또 어떤 떄는 특정 종목을 과도하게 기피하여 주가를 터무니없이 낮춘다는 사실도 알고 있다. 이런 일이 발생하면 버핏은 투자자들의 두려움과 어리석음에서 비롯된 저평가 종목을 놓치지 않고 이용한다. 탐욕을 조심하라. 그리고 투자자들의 두려움과 어리석음이 투자 기회를 만들도록 내버려 두라. 이것이 바로 현명한 투자자의 방식이다. 138 욕심을 주인으로 섬기는 대신 하인으로 부릴 수 있다면, 욕심은 투자를 할 때 멋지니 동기 부여가 된다. 욕심이 지나치면 행복할 수 없지만, 욕심이 전혀 없어도 부자가 될 수 없기 때문이다. 138 투자의 본질은 이렇게 타인의 주머니를 바라보며 시기와 질투심에 사로잡히는 것이 아니다. 투자는 돈을 벌기 위한 자기만의 열정이 더 중요한 게임이다. 세상에서 가장 행복한 부자는 자신이 하고 싶은 일을 통해 돈을 버는 동시에 다른 이들의 부에는 큰 관심이 없는 사람이다. 부자가 된다는 것이 타인에 대한 시기심으로 괴로워하는 것이라면 무슨 재미가 있을까? 140 다른 사람들이 욕심을 부릴 떄 신중하라. 다른 사람들이 두려워할 때 욕심 부리라. 대부분의 투자자들이 두려워하는 상황은 매수하려는 투자자가 없는 약세장이다. 이들은 약세장에서 기업의 내재 가치에 근거한 장기 경쟁력을 전혀 고려하지 않은 채 보유 주식을 매도한다. 이때가 바로 버핏이 욕심을 부리는 때다. 쏟아지는 우량 종목 중 자신이 오래전부터 사고 싶었던 종목을 모조리 사들이는 것이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:9","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"10. When to Sell, When to Leave(팔아야 할 때, 떠나야 할 때) 142 자신이 구멍에 빠진 것을 알았을 때는 더 이상 땅을 파지 않는 것이 가장 중요하다. 143 일단 우량 종목을 제대로 골랐다면 더 이상 다른 종목에 기웃대지 말라. 우량 종목에 충분한 금액을 투자한 다음에는, 약간의 이익을 위해 서둘러 팔고 다른 종목을 찾기보다, 처음의 결정을 믿고 기다리는 편이 낫다. 이것이 위대한 기업을 알아보는 안목과 적절한 매수 시점의 포착이 중요한 이유다. 만약 훌륭한 장기 경쟁력을 갖추지 못한 기업에 투자했다면 버나드 바루크의 조언을 따르라 사람들이 어마어마한 돈을 번 비결에 대해 묻자 바루크는 장난기 섞인 미소를 떠올리며 이렇게 말했다. “나는 언제나 남들보다 너무 빨리 팔았다.” 144 “다른 투자자들이 주식을 내다 팔 때 나는 사들인다.” 버핏은 다른 투자자들이 주식을 살 때가 아닌 팔 때가 바로 매수의 적기라고 생각한다. 버핏이 매수했던 우량종목들은 모두 좋지 않은 뉴스가 들려올 때 사들인 것이다. 145 “대부분의 투자자들은 다른 투자자들이 관심을 보일 때 따라서 관심을 보인다. 그러나 정작 관심을 가져야 할 때는 아무도 관심을 두지 않을 때다. 한창 인기 있을 때 사들이면 큰돈을 벌기 어렵다.” 현명한 투자자는 인기 있는 종목과 그에 따른 집단 광기를 경계한다. 사람들이 인기 있는 종목에만 달려들어 주가를 터무니없이 치솟게 한다는 사실을 알기 떄문이다. 어떤 기업의 주식을 사고 싶다면 인기가 떨어졌을 때를 노리라. 그때가 가장 유리한 가격에 매수할 수 있고, 또 향후 주가 상승의 폭도 가장 크다. 146 “변화에 좌우되거나 변화에 목숨을 걸어야 하는 기업에는 관심이 없다. 결혼 생활과 마찬가지로 투자 역시 변화보다는 지속성이 더 중요하다.” 147 “리스크는 자신이 하는 일을 제대로 이해하지 못하는 데서 발생한다.” 비인기 종목에 투자할 때 그 기업의 장기적인 경쟁력을 확인할 수 없다면 투자 위험이 높아질 수밖에 없다. 투자 리스크를 줄이는 유일한 길은 자신이 투자하는 기업에 관해 더 잘 아는 것이다. “나는 기업을 매수하는 이유에 대해 종이 한 장을 가득 채우기 전까지는 절대로 매수하지 않는다.” 어떤 기업에 투자하고자 하는 자신만의 이유를 말할 수 없다면 그 기업의 주식은 사면 안 된다. 매수 이유에 대한 자기만의 답변이 가능하다면, 그것을 수차례 시도한다면 당신은 큰돈을 벌 수 있을 것이다. 148 질문은 투자자로 하여금 생각하게 만들고, 질문에 대한 자기만의 답은 생각을 행동으로 옮기게 만든다. 여기서 중요한 것은 올바른 투자 종목을 찾는 것이라기보다 올바른 질문에 대한 올바른 답을 갖고 있느냐 하는 것이다. 149 신규 상장 시 투자 은행은 발행 주식과 채권 가격을 이미 최고 한도로 설정해 놓았기 떄문에 일반 투자자로서는 할인된 가격에 매수할 여지가 전혀 없다. 대신 버핏은 주식이나 채권이 일정 기간 거래된 다음 주식 시장의 근시안적 비관론 떄문에 이들 유가증권의 가격이 본래 가치 이하로 떨어질 때를 기다린다. 투자 은행은 투자자에게 할인 가격을 허용하지 않지만, 주식시장은 투자자에게 할인 가격을 제시할 수 있다. 150 경영자가 갖춰야 할 가장 중요한 덕목은 정직이다. 사람들을 잘못 이끄는 CEO는 자신 역시 잘못된 방향으로 이끌고 말 것이다. 자신의 실수를 솔직하게 인정하는 CEO는 실수를 통해 더 많은 것을 배울 수 있다. 자신의 잘못임에도 다른 사람과 사건을 탓하는 CEO는 향후 다른 중요한 사안에 있어서도 자신에게 거짓말을 할 가능성이 크다. “항상 목표 달성을 외치는 경영자는 언젠가 숫자를 조작하고 싶은 유혹에 빠지기 쉽다.” 151 할 가치가 전혀 없는 일은 잘할 가치 역시 전혀 없다. 본질적인 가치가 낮은 기업은 결국 앞으로 돈을 벌 가망성도 희박하다. 그렇다면 왜 자신에게 전혀 이롭지 않은 기업에 아까운 시간과 열정을 낭비하는가? 153 “기업 실적이 좋고 나쁜 것은 얼마나 노를 잘 젓느냐의 문제라기보다 얼마나 좋은 배를 선택했느냐의 문제다. 물이 샌다는 사실을 알았다면 배를 갈아타는 것이 훨씬 생산적이다.” ","date":"2022-12-15","objectID":"/warren_buffett/:7:10","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"11. Mistakes to Beware Of (치명적 실수) 156 “나는 과거를 돌아보지 않는다. 과거에 매달린다고 달라지는 것은 아무것도 없다. 우리는 과거가 아닌 미래를 향해 나아갈 수 있을 뿐이다.” 156 백 가지 결정 가운데 열 가지 잘못된 결정을 내린 경우, 당신은 열 가지 실수에 집착하는 바람에 새롭게 내려야 할 결정에 충분한 주의를 기울이지 못한다. 157 앞으로도 주식 투자라는 게임을 할 때 당신은 해야 할 일을 빠트리는 실수를 무수히 하게 될 것이다. 그러나 이런 유형의 실수는 그렇게 치명적이지 않다. 치명적인 실수란 하지 말아야 할 행동을 하는 것을 의미하는 말이다. 158 “나는 내 실수에 대해 설명하고 싶다. 이 말은 내가 실수를 완벽하게 이해했다는 의미다.” 158 자신이 하고 있는 일의 의미를 제대로 이해하지 못한다면 왜 그 일을 하려고 하는가? 직관을 따르는 것은 올바른 투자법이 아니다. (머리, 가슴, 배) 159 “실수를 하지 않고는 어떠한 결정도 내릴 수 없다.” 어떤 사람은 결정을 잘 내리고, 또 어떤 사람은 그렇지 못하다. 전자는 사람들을 이끄는 사람이 되고, 후자는 리더가 이끄는 대로 따라가는 사람이 된다. 159 의사 결정을 할 때 중요한 것은 현재의 실수에 발목 잡히지 않고 다음번 의사 결정으로 무리 없이 넘어갈 수 있느냐 하는 점이다. 결정을 내리지 못하고 미적대는 것은 아무런 결정을 내리지 않기로 결정한 것과 다름없다. 이런 일이 반복되다 보면 미결 사항이 산처럼 쌓이고, 아무 일도 진행되지 않는다. 당연히 회사는 더 이상 수익을 내지 못한다. “다른 엔지니어와 다른 점이 무엇이냐는 질문에 자신의 실수를, 실험에서 빠지지 않는 당연한 일부로 인정하고 받아들인 점이라고 대답했다. Cray Supercomputer를 설계한 세계적인 컴퓨터 설계자 Seymour Cray ","date":"2022-12-15","objectID":"/warren_buffett/:7:11","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"12. Your Circle of Competence (투자 대상 범위) 162 “합리적 이성을 바탕으로 투자 결정을 내려야 한다. 잘 모른다면 투자하지 말라.” 164 “어떤 투자 아이디어를 이해했다면 그것을 다른 사람들이 이해하도록 설명할 수 있어야 한다.” 다른 사람에게 설명할 수 없다면 제대로 이해하지 못한 것이다. 버핏은 투자 대상에 관해 잘 알지 못하면 투자하지 않았다. 설명할 수 없다면 함부로 덤비지 말라. 167 “나의 투자 방법은 아주 간단하다. 기본적인 경쟁력을 갖춘 기업, 그리고 정직하고 유능한 경영자가 운영하는 우량 기업을 골라 적정 가격에 매수하는 것이다. 이외에 내가 달리 할 일은 없다.” 167 기업의 기초 체력이 튼실한지 아닌지 알려면 해당 사업 분야에 관해 잘 알고 있어야 한다. 정직하고 유능한 경영자가 운영하는 기업인지 알고 싶을 때에도 역시 그 사업 분야에 대한 지식이 있어야 한다. 적정 가격인지 아닌지를 판단할 때 역시 해당 사업 분야에 관해 알아야 한다. 기업이나 사업에 관한 이러한 기본 지식과 정보야 말로 버핏을 성공으로 이끈 비결이라 할 수 있다. 168 “나의 능력 범위를 벗어난 곳에 그럴 듯환 먹잇감이 있다고 해서 무리하게 접근하지는 않는다. 그저 나의 능력의 범위 안에 먹잇감이 나타나기를 기다릴 뿐이다. 버핏은 자신의 능력 범위 밖에 있는 기업이라고 판단되면 아예 눈길조차 주지 않는다. 버핏은 아무도 주목하지 않는 기업을 선택해 인수하는 방식을 취한다고 했다. 이런 선택이 가능하려면 해당 기업의 내재적인 경제 가치를 잘 알아야 했다. 그래야만 그 기업의 미래를 예측할 수 있기 때문이다. 그 기업이나 사업 분야에 관해 잘 알지 못하면 이러한 예측과 선택이 불가능하다. 171 앞날을 예측하는 것이 어렵다는 사실은, 버핏이 오랜 세월을 두고 그 실효성이 입증된 제품에만 관심을 두는 원인이기도 하다. 실효성이 입증된 제품의 경우, 적어도 15년 정도는 앞을 내다볼 수 있다. (면도기, 껌 기타 등등) 버핏은 앞길을 분명하게 예측할 수 있는 제품만 선호한다. 이러한 제품이라면 단기적 관점이 주를 이루는 주식 시장이 그 가치를 얼마로 측정하든 관계없이 사업의 장기적 경제 가치를 가늠할 수 있다. 175 “투자자를 녹초로 만드는 것은 경제 상황이 아니라 투자자 자신이다.” 다른 사람들이 ‘파티장’을 떠나면 안절부절못하다가 헐값에 주식을 처분하고 그 사람들을 다시 따라가다. 이성적인 판단은 간데없고, 감정에만 치우친 결정을 내리는 것이다. 일확천금을 꿈꾸며 근시안적으로 접근하기 때문에 기업의 장기적인 경제 가치 따위는 아예 안중에도 없다. (💡 10년뒤의 위험, 10년뒤의 가능성을 투자한다. ) ","date":"2022-12-15","objectID":"/warren_buffett/:7:12","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"13. The Price You Pay (가격 결정) 178 “가치가 아닌 가격에서 투자 판단의 실마리를 구하는 것도 나름대로의 일리가 있다. 가격은 당신이 지불하는 액수이고, 가치는 거래를 통해 얻는 무엇이다.” 지불 규모가 너무 크면 당연히 가치는 줄어든다. 반면 지불 규모가 작을수록 가치는 늘어난다. 요컨대 투자의 비결은 항상 낮은 가격을 지불하고 높은 가치를 얻는 것이다. 179 “한 번 오르면 반드시 떨어지는 때가 있다고 하지만, 예외도 있는 법이다.” (버크셔 해서웨이) 대단하긴 하다. 22년 기준으로 모든 기업이 떨어질 때, 신재생 에너지 흐름을 타서 또 올랐다. 한편으로는 버핏의 벌어들인 자산에 대한 신뢰감과 버핏의 원활한 현금 덕분 일수도 있다고 보지만 수영장 물이 다 빠져나가봐야 알 것 같다. 180 “주식 시장은 주식의 가격을 결정할 뿐이다. 주식 시장은 당신에게 봉사하기 위해 있는 것이지, 당신을 가르치기 위해 있는 것이 아니다.” 180 버핏에게 주식 시장은 단기적 경제 전망에 따른 주가 형성을 참고하는 장일 뿐이다. 단기적 접근법을 따르게 되면 짧은 주기로 주가 변동이 이루어지고, 장기적인 경제 가치와는 무관하게 주가가 형성된다. 이러한 단기적 변동으로 인해 장기적 경제 가치 이하로 혹은 이상으로 주가가 형성되기도 한다. 대체로 주식 시장은 종목의 가치를 과대평가하는 경향이 있다. 180 버핏은 주가가 기업의 장기적 가치 이하로 형성될 때 주식을 매수하고, 가치가 과대 평가됐던 수준으로 주가가 오르기를 기다린다. 우량 기업의 주식을 낮은 가격에 매수한 경우에는 사내 유보 이익이 장기적인 기업의 내재 가치를 증가시킬 것이다. 그리고 이는 결국 주가 상승으로 이어질 것이다. 투자자는 그때까지 주식을 보유해야 한다. 우량 기업이라면, 언젠가는 주식 시장에서 제대로 평가받지 못했던 장기적 가치가 드러나게 마련이다. 그러므로 근시안적인 주식 시장의 의견에 상관하지 말라. 기업의 장기적 경제 가치를 기준으로 매수 대상과 시점을 결정하라. 무엇을 언제 살지는 주식 시장이 아닌 바로 투자자 자신이 결정해야 함을 잊지 말라. 182 “처음에는 기업의 기초 경제 지표에 따라 주가가 결정된다. 그러나 일정 시점이 되면 투기가 가격을 결정한다.” 현명한 투자자는 기업의 기초 경제 지표가 자신에게 유리하게 나타날 때를 기준으로 매수를 결정한다. 그래야 주가가 하락하더라도 안전 마진을 확보할 수 있다. 시간 역시 기초 경제 지표의 친구다. 즉 시간이 경과하면 결국에는 장기적인 경제 가치에 따라 가격 조정이 일어난다. 그러다 투기가 개입되면 기초 경제 지표는 안중에 없어지고, 가격이 급등하면서 매수를 촉진하는 단계로 접어든다. 멍청한 사람은 현명한 사람이 하던 일을 뒤늦게 따라한다. 즉 현명한 투자자는 투기가 개입되는 시점이 언제인지 알고, 적절한 시기에 빠져 나올 줄도 안다. 그러나 미련한 투자자는 장기적 기초 경제가치가 반영된 가격에 투기적 수요가 더해져 주가가 한껏 치솟았을 때 매수에 들어간다. 186 “모든 거품에는 그것을 터뜨릴 핀이 항상 도사리고 있다. 결국 핀은 거품을 터뜨리고, 초보 투자자들은 새로운 교훈을 얻게 된다. 그러나 그 교훈은 아주 오래된 것이다.” 너도나도 주식에 달려들면 투기 열풍이 조성된다. 특정 종목의 주가가 오른다 싶으면 재빨리 이 주식을 매수하여 쉽게 돈을 벌려고 한다. 이런 투기 열풍은 약 30년에 한번씩 찾아온다. 보통은 새로운 기술이 개발됐을 때 이런 현상이 나타나기 쉽다. 지난 100여년을 돌아보면 라디오, 항공사, 자동차, 컴퓨터, 생명 공학, 인터넷 등이 등장했을 떄가 그랬다. 투기적 강세장의 주가에는 기업의 기초 경제 가치가 아니라 도박장의 광기가 반영된다. 버핏은 초창기 부터 투기적 강세장은 애써 외면했다. 그가 보기에 투기적 강세장에서 형성된 높은 주가는, 결코 발생할 것 같지 않은 미래 수익이 반영된 결과다. 미래 수익이 실현되지 않고, 주가가 오르리라는 기대도 사라지면 중력의 법칙에 따라 주가는 무서운 속도로 급전직하한다. 187 “나는 주식 시장을 통해 돈을 벌어 보겠다고 생각한 적이 없다. 내일 당장 시장이 문을 닫아 향후 5년 동안 개장하지 않는다는 가정 하에 투자한다.” 버핏은 주식 자체가 아니라 기업을 인수한다는 생각으로 투자를 한다. 187 버핏은 기본적으로 주식 시장을, 일확천금을 획득하여 ‘올해의 뮤추얼 펀드 상’ 이라는 타이틀을 거머쥐겠다는 욕망에 사로잡혀 기업의 장기적 경제 가치는 무시한 채 근시안적으로 접근하는 조직으로 본다. 그래서 주식 시장을 자신의 주 활동 무대로 삼지 않는다. 적절한 기업의 주식을 적정 가격에 매수하기만 하면 그것으로 족하다. 이제 이 우량 기업의 가치가 오르기만 기다리면 된다. 주가에 기업의 내재 가치가 반영됨에 따라 투자자의 주머니는 두둑해진다. 여기서 중요한 점은 주식 시장이 향후 5년 동안 폐쇄되더라도 기업의 내재 가치는 지속적으로 상승한다는 점이다. 주식 시장은 단기간의 기업 가치를 바탕으로 형성된 가격표를 제공하는 장소에 불과하다. 매수한 주식을 5년 동안 보유한다면 그 이전, 즉 1년에서 5년 사이에 주식 시장에서 주가가 어떻게 형성되는지를 신경 쓸 이유가 없다. 주식 시장의 주가가 의미 있는 떄는 보유 주식을 매도하는 시점뿐이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:13","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"14. Long-Term Economic Value is the Secret( 버핏이 욕심 부릴 때 ) 190 “주식 시장은 스트라이크 선언이 없는 야구 경기장과 같아서 날아오는 공마다 방망이를 휘두를 필요는 없다. 자신이 가장 좋아하는 공만 노리라.” 이렇게 하다 보니 단기적인 주가 변동에만 관심이 몰려 기업의 장기적 경제 가치와 무관하게 주가가 형성되어 버린다. 191 그러므로 주식투자로 큰돈을 벌고 싶다면 전문 펀드 매니저를 멀리하라. 그리고 그들이 장기적인 가격을 예측할 때 저지르는 실수를 이용하라. 그렇게 하기 위해서는 이들 펀드 매니저들의 근시안적인 시각을 십분 활용할 수 있어야 한다. 192 “역사를 통해 배울 수 있는 사실은 아이러니하게도 사람들은 역사를 통해 아무것도 배우지 않는다는 사실이다.” 단기적 주가 변동을 통해 큰돈을 벌겠다는 생각으로 높은 가격에 주식을 매수하는 일을 끊임없이 반복하는 것, 투자자들은 주식 시장에서 똑같은 실수를 계속 반복한다. 투자자라면 누구나 행하는 이 공통된 실수가, 사실은 주식 시장을 움직이는 동력으로 작용하고 있다. 192 장기적 경제 가치에 비해 과도하게 높이 형성된 주가는 (주로 강세장에서 많이 발생하는 현상이다) 다양한 기대 심리가 사라지고 투자 상황의 변화가 일어나면 폭락할 가능성이 농후하다는 사실이다. 강세장에서 과도하게 높이 형성된 가격에 매수한 투자자들은 갑작스런 주가 폭락을 견디지 못하고 빈털터리가 되고 만다. 192 그래서 버핏은 주가가 지나치게 높게 형성됐다 싶으면 시장에서 멀찌감치 떨어져 있다가, 주가가 하락하기 시작하면 그제야 매수에 관심을 보이고, 가격이 충분히 떨어졌다 싶을 때 그리고 그 기업이 올바른 기업일 때 비로소 행동에 나선다. 194 “시세 변동을 적이 아닌 친구로 생각하라. 변동의 물결에 휩쓸리기 보다 그 어리석음에서 이익을 창출하라.” 194 주식 시장은 기업의 장기적 경제 가치는 무시하고 단기적 전망에만 의거해 거래하는 무지한 야수와 같다. 단기적 전망이 좋지 않다는 것은 곧 주가가 급락할 수 있음을 의미한다. 그 과정에서 기업의 장기적인 잠재력은 철저히 무시된다. 바보들이 달려들어 주가를 올리고 있을 때는 관망세를 취하다가 바보들이 모두 물러나고 주가가 하락하기 시작할 때를 노리라. (1973, 1987년) 198 “기업의 장기적 가치를 보고 주식을 구매하는 투자자에게 시장의 불확실성은 오히려 좋은 친구다.” 결국 실제 가치에 맞게 주가를 끌어올려 줄 것은 장기적 경제 가치이기 때문이다. 199 “월스트리트의 전문가들에게 기업과 주식은 단지 거래를 위한 재료일 뿐이다.” 자산 관리 전문가들은 사업적 관점에서 기업과 주식을 바라보지 않는다. 단지 자신이 베팅하는 화면상의 숫자로 볼 뿐이다. 199 이런 카지노와 같은 성격은 주식 시장이 처음 생겼을 때부터 있었던 특성이다. 사람들은 기본적으로 내기를 즐긴다. 별다른 이유가 있어서가 아니다. 단지 내기가 재미있기 때문이다. 전문가들은 주식이라는 미끼로 투자자들에게서 엄청난 돈을 받은 다음, 이를 걸고 내기를 한다. 주가가 심하게 요동치는 것은 바로 전문가들의 도박성향 때문이다. 201 “아무리 재능이 뛰어나고 많이 노력한다 해도 결과를 얻기까지는 어느 정도 시간이 걸린다. 아홉 명의 여자를 임신시켰다고 해서 한달 만에 아이를 얻을 수는 없는 노릇이다.” 201 기업의 가치가 형성되는 데는 시간이 걸린다. 아이가 자라 어른이 되는 데 일정한 시간이 필요하듯 한 기업의 가치가 신장되는 데에도 시간이 필요하다. 하지만 처음부터 경제 가치가 높은 우량 기업을 매수한다면 투자자가 얻을 수 있는 가치는 놀랄 정도로 높아질 것이다. 206 “오늘의 투자자는 어제의 성장 실적에서 수익을 내는 것이 아니다.” 206 지금 투자자가 거두는 수익의 근원은 과거의 성장 실적이 아니라 미래의 성장 실적이다. 오늘 내가 어느 기업을 사들여 이익을 보았다면, 그것은 오로지 그 회사의 성장 가능성에서 나온 것임을 알아야 한다. 과거는 결코 주식 시장의 수익 원천이 될 수 없다. 206 이제 남은 문제는 해당 기업이 성장 가능성이 있는가, 있다면 나는 그에 대해 얼마를 지불할 의사가 있는가 하는 점이다. 지속적 경쟁 우위를 지닌 제품을 생산하며 성장 가능성도 있는 기업이지만 매수 가격이 너무 높다면 향후 당신의 투자 수익은 줄어들 수 밖에 없다. 이는 당신의 연간 수익률 또한 줄어들게 만드는 결과로 이어진다. 당신이라면 연간 100만 달러의 수익밖에 내지 못하는 기업을 1억 달러를 주고 사들일 것인가? 아마 그렇지는 않을 것이다. 하지만 연간 2000만 달러의 수익을 내는 기업이라면 기꺼이 1억 달러를 투자할 것이다. 문제는 양극단의 중간에 위치한 경우다. 그러나 만약 당신이 버핏처럼 되고자 한다면 판단이 쉽지 않은 어정쩡한 중간 조건도 거부하라. 오로지 더 쉬운 조건, 즉 싼 경우에만 거래하라. 208 “주식 시장이 효율적이었다면 나는 아마 거리에서 구걸하는 신세를 면치 못했을 것이다.” (효율적 시장 가설, 모든 정보가 대중들에게 똑같이 유통되어, 그날의 주식 가치가 정확하게 주가에 반영된다는 가설이다.) 208 단기적 시각에서 보면 주식 시장은 매우 효율적이다. 이런 단기적 효율성은 장기적 관점으로 볼 때 주식의 가격을 잘못 매기는 비효율을 만들어 낸다. 결국 장기적 관점에서 볼 때 주식 시장은 비효율적이라는 의미다. (1973년) 여기서 놓치지 말아야 할 사실은 주식 시장의 단기적 효율성이 종종 장기적인 비효율을 낳는다는 점이다. 당신은 이런 주식 시장의 장기적 비효율을 이용하여 큰돈을 벌 수 있다. 210 “주식 시장은 다른 사람들이 어떤 어리석은 행동을 하는지 알려 주는 참고 자료일 뿐이다.” 버핏은 주식 시장의 향방에는 조금도 관심이 없다. 그는 다만 대형 뮤추얼 펀드를 운용하는 근시안적 시각의 주식 투기꾼들이 장기적 관점에서 볼 때 어리석은 행동을 하고 있는지 아닌지 확인하는 데만 관심이 있다. 211 모멘텀 투자 전략 (Momentum investing) 주가가 급등하면 주식을 사고, 주가가 급락하면 주식을 판다. 회사 수익이 조금만 떨어져도 주식을 팔고, 수익이 조금만 올라도 주식을 산다. 전쟁이 일어날 기미만 보이면 주식을 팔고, 종전의 서광이 약간이라도 비치면 주식을 산다. 212 “투자란 주식 조각을 사는 것이 아니라 기업의 일부를 사서 그 기업이 성장하는 과정을 지켜보는 행위다. 반면, 투기란 단기적 주가 향방에 목을 매고 주사위를 던치는 행위다. 투자는 투자자를 부자로 만들어 주지만, 투기는 주사위를 굴리는 펀드 매니저를 부자로 만들어준다. (죄송하지만, 나는 선한 가치관을 가지지 못한 지적 끌림을 느끼는 기업은 단기적으로 투자할 것이다. 디즈니, 텐센트 등의 기업이 그렇다. IP) 213 “우리는 주식 시장과 금리, 기업 활동 등이 향후 어떻게 전개될지 조금도 알 수 없다. 과거에도 그랬고 지금도 그러하며 미래에도 마찬가지다. 213 다른 투자자들이 모두 주식 시장의 시세 동향과 내년의 금리 변동에만 관심을 가졌기 때문이다. 시세 동향과 금리 변동 추이에만 관심을 두는 투자자는 결국 미국 연방 준비은행에서 발표하는 약간의 금리 인상 뉴스에도 장기적인 경제 가치가 탁월한 우량 기업의 주식을 내다 파는 어리석은 행동을 하고 만다. 이처럼 민감한 투자자들이 어리석은 이유 때문에 (나같이 예민한 사람들) 우량 기업의 주식을 대량으로 내다 팔 때를 기다린다. 때가 오면 버핏은 그 주식들을 가만히 주워 담는다. 213 역발상 투자 전략(selective contrarian investment strategy): 부자가 되고 싶다면 주식 시장이 어떻게 될 것이라든가, 연방 준비 은행이 금리를 얼마나 올릴 것인가 등에 관한 갖가지 예측이나 장담에 귀를 닫으라. 대신 지속적 경쟁 우위를 지닌 기업의 장기적 경제 가치를 판단하는 데만 집중하라. 그런 다음 얼마에 주식이 거래되고 있는지 살피라. 장기적 기업 가치에 비해 주가가 낮게 형성됐다고 판단되면 주식을 사라. 주가가 가치보다 높게 형성되었다면 기다리라. 215 “부자가 된다고 해서 그 사람의 본질까지 바뀌는 것은 아니다. 돈을 벌기 전에 바보였다면 돈","date":"2022-12-15","objectID":"/warren_buffett/:7:14","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"Cross my mind 문득 든 생각. 워렌 버핏은 보수적이다. 내가 욕심에 눈이 멀었을 때, 정신을 차릴 수 있게 해주는 할아버지다. 그럼에도 나와 워렌은 다르다. 젊었을 때는 젊은 사람의 방식이 있고, 늙었을 때는 늙은 사람들의 방식이 있다. 이 세상은 젊은이와 늙은이가 함께 살며, 그때와 지금이 다르고 지금이 미래와 다르다. 다만 원칙은 같다. 왜냐하면 늙은 사람들로 부터 젊은 사람들이 태어나고, 이전 세대로 부터 다음 세대가 태어나기 때문이다. 말은 행동보다 가볍다. 행동했던 노인들의 지혜가 젊은이의 지혜보다 대부분 더 옳다. 예수님, 석가모니가 조금 특이했던 것이다. 그럼에도 나는 코카콜라를 좋아하지 않는다. 나는 워렌이 아니다. 나를 지켜야 한다. 늙은 사람들의 신념은 흔들리지 않지만, 고정관념 또한 그 만큼 흔들리지 않는다. 젊은 사람들의 신념은 흔들리기 쉽지만 고정관념 또한 쉽게 흔들릴 수 있다. 균형을 맞춰야 옳다. 고정관념으로 세상을 바라보면 젊어질 수 없고 즉 미래를 미워하고, 반대로 내 신념만 고집한다면 늙어진다 즉 과거를 미워한다. 과거를 미워하면, 어른들이 경험한 시간 만큼을 다시 내가 시간을 주고 실수해야 하며, 미래를 미워하게 되면, 실수를 하지 못해 노인들보다 더 지혜롭게 살 수 없다. 둘 모두 균형을 맞춰야 옳다. 나는 어린이들을 사랑하며 노인들을 공경하고 싶다. 어린이와 노인들은 모두 똑같은 스승이다. 어린이에게는 행동을 배우고, 노인들에게는 실수를 배운다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:15","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["HowTo"],"content":"Set up a Cold wallet especially nano s plus","date":"2022-12-05","objectID":"/ledger/","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"How to setup my cold wallet (nano s plus). 거래소를 잘 신뢰하지 못하던 차에, 2022년 FTX 사태가 터져서 겸사겸사 Cold wallet을 구매하였습니다. 미국에 지내는 동안 tax포함 약 $85.00에 Nano S plus를 구입하여 세팅하는 과정을 정리합니다. 또한 앞으로 거래 시 DeX(Decentralized exchange, P2P방식의 분산형 암호화폐 거래소)의 특성을 가진 거래소에서 거래를 할 생각이며, 편의를 위할 때는 Ledger 인프라를 사용할 것 같다. ","date":"2022-12-05","objectID":"/ledger/:0:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"TL;DR PIN CODE Recovery letters (24 words) Install Ledger Live (opt) Update firmware. Install coin apps to nano device. Add your accounts Water proof 현재 까지 나온 Ledger사의 Cold wallet들은 방수를 지원하지 않는다. 물론 악세사리로, 방수케이스를 판매하지만 cold wallet 자체는 방수가 되지 않기 때문에 변기에 빠뜨리거나 커피를 쏟는다면 기기가 고장날 수 있다. 다만 Seed phrase(24개의 words, recovery letters)만 기억하고 있다면, 이를 통해 새로운 nano 하드웨어를 구매하여 지갑을 다시 복구할 수 있다. seed phrase ","date":"2022-12-05","objectID":"/ledger/:1:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"1. Cold Wallet Background What you should basically know about. My crypto assets are stored on the blockchain (p2p, network). I need a private key to access and manage them. My private key is stored within my Nano Your Nano works as a “cold storage” wallet. This means that it never exposes my private key online even when using the app. Validate transactions: Ledger live allows you to buy, sell, manage, exchange and earn crypto while remaining protected. You will validate every crypto transaction with your Nano. ","date":"2022-12-05","objectID":"/ledger/:2:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"2. How to set Nano S plus in Desktop? With Ledger live desktop app. ","date":"2022-12-05","objectID":"/ledger/:3:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"1. PIN CODE Nano S plus에서 4-8자리의 숫자 PIN코드를 설정합니다. PIN code를 세번 틀리게 될 경우, nano device는 reset됩니다. PIN code Your PIN code is the first layer of security. It physically secures access to your private key and your Nano. Your PIN code must be 4 to 8 digits long. Don’t share it. You can change your PIN code if needed. Three wrong PIN code entries in a row will reset the device. Never store your PIN code on a computer or phone. ","date":"2022-12-05","objectID":"/ledger/:3:1","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"2. Recovery letters (24 words) 준비물: 안전하게 24 영어단어들을 적어둘 공간. Nano S plus에서 보여주는 24개의 단어 리스트 (recovery letters)를 확인하며, 이를 안전한 곳에 적어둡니다. Recovery phrase Your recovery phrase is a secret list of 24 words that backs up your private keys. Your Nano generate a unique recovery phrase. Ledger does not keep a copy of it. If you lose this recovery phrase, You will not be able to access your crypto in case You lose access to your Nano. How does recovery phrase work? Recovery phrase works like a unique master key. Your ledger device uses it to calculate private keys for every crypto asset you own. To restore access to your crypto, any wallet can calculate the same private keys from your recovery phrase. What Happens if I lose Access To My Nano? To restore access to your crypto, any wallet can calculate the same private keys from your recovery phrase. 1. Get a new hardware wallet. 2. Select “Restore recovery phrase on a new device” in the Ledger app. 3. Enter your recovery phrase on your new device to restore access to your crypto. 가장 중요하게 기억할 것 When I connect my Nano to the ledger app, my private key is STILL OFFLINE! ","date":"2022-12-05","objectID":"/ledger/:3:2","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"3. Install Ledger Live Ledger Live desktop앱을 다운로드합니다. Download ledger live link ","date":"2022-12-05","objectID":"/ledger/:3:3","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"4. (opt) Update firmware. Nano S plus의 firmware를 업데이트 합니다. firmware? 하드웨어 장치에 들어가는 소프트웨어의 일종. Ledger의 경우 버그 픽스 그리고 UI변경 때문에 하드웨어 펌웨어를 진행할 것으로 보인다. ","date":"2022-12-05","objectID":"/ledger/:3:4","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"5. Install coin apps to nano device. 사용하고 싶은 종류의 코인들의 sw 어플리케이션을 다운로드합니다. ","date":"2022-12-05","objectID":"/ledger/:3:5","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"6. Add your accounts This section will be continued with my 2023 investment scenario. ","date":"2022-12-05","objectID":"/ledger/:3:6","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"3. How to setup Nano S plus in Phone? my phone: Galaxy (Android) Install Ledger Live app from google playstore link . Physically connect Nano Device and Phone with C type usb cable. Type Pin code. Done ","date":"2022-12-05","objectID":"/ledger/:4:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["plan"],"content":"2023년부터 진행할 투자 시나리오와 투자 원칙들을 정리 합니다. ","date":"2022-12-04","objectID":"/2023_investments/:0:0","tags":["plan"],"title":"(WIP) 2023 투자계획","uri":"/2023_investments/"},{"categories":["wisdom"],"content":"After reading the Book of Proverbs, I write down some phrases that touched my heart.","date":"2022-11-30","objectID":"/proverbs/","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"After reading the Book of Proverbs, write down some phrases that touched my heart. ","date":"2022-11-30","objectID":"/proverbs/:0:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Book of Proverbs The Book of Proverbs (Hebrew: מִשְלֵי, Mīšlē, “Proverbs of Solomon”) is a book in the third section (called Ketuvim) of the Hebrew Bible. Tanakh, Hebrew Bible Book of Proverbs는 타나크(히브리어 성경)안에 들어 있으며, 기원전 1500~400년대 바빌로니아, 팔레스티나, 이집트 등의 지역에서 전해지던 이야기들이 기록된 경전들이 오랜 세월을 거쳐 한권의 책으로 만들어져 전해져 왔다. 또한 타나크는 아래의 4종교의 경전으로도 인정되어 유대교 카톨릭 기독교 이슬람교 학계에서는 중립적으로 히브리 성경이라는 단어를 사용하기도 한다. Proverbs is not merely an anthology but a “collection of collections” relating to a pattern of life which lasted for more than a millennium. Although most of this book identifies Solomon as its author, not all of it is attributed to him. This book itself also emphasizes that this book is a collection of proverbs of many people. 31장으로 구성된 이유 Book of Proverbs는 의도적으로 31장으로 구성되어있다라고 보는 학자들도 있는데, 이유는 매일 1장씩 읽기 편하도록 히스기야 시대에 신하들이 편찬했다는 주장이다. 이 주장을 굳이 믿지 않더라도, 실제로 일자별로 읽어보니 아침을 좀 더 고요하게 마음으로 맞이할 수 있었던 것 같다. ","date":"2022-11-30","objectID":"/proverbs/:1:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Phrases Phrases that touched my heart, with NIV version. ","date":"2022-11-30","objectID":"/proverbs/:2:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 1 Purpose and Theme (7) The fear of the LORD is the beginning of knowledge, but fools despise wisdom and instruction. Warning Against the Invitation of Sinful Men (10) My son, if sinful men entice you, do not give in to them. Wisdom’s Rebuke (31-33) they will eat the fruit of their ways and be filled with the fruit of their schemes. For the waywardness of the simple will kill them, and the complacency of fools will destroy them; but whoever listens to me will live in safety and be at ease, without fear of harm. ","date":"2022-11-30","objectID":"/proverbs/:2:1","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 2 Moral Benefits of Wisdom (1-5) My son, if you accept my words and store up my commands within you turning your ear to wisdom and applying your heart to understanding indeed, if you call out for insight and cry aloud for understanding, and if you look for it as for silver and search for it as for hidden treasure, then you will understand the fear of the Lord and find the knowledge of God. (7-9) He holds success in store for the upright, he is a shield to those whose walk is blameless, for he guards the course of the just and protects the way of his faithful ones. Then you will understand what is right and just and fair–every good path. ","date":"2022-11-30","objectID":"/proverbs/:2:2","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 3 Wisdom Bestows Well-Being (9) Honor the Lord with your wealth, with the firstfruits of all your crops; (12) because the Lord disciplines those he loves, as a father the son he delights in. (21) My son, do not let wisdom and understanding out of your sight, preserve sound judgment and discretion; (25-26) Have no fear of sudden disaster or of the ruin that overtakes the wicked, for the Lord will be at your side and will keep your foot from being snared. ","date":"2022-11-30","objectID":"/proverbs/:2:3","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 4 Get Wisdom at Any Cost (7) The beginning of wisdom is this: Get wisdom. Though it cost all you have, get understanding. (12-13) When you walk, your steps will not be hampered; when you run, you will not stumble. Hold on to instruction, do not let it go; guard it well, for it is your life. (16-17) For they cannot rest until they do evil; they are robbed of sleep till they make someone stumble. They eat the bread of wickedness and drink the wine of violence. (23) Above all else, guard your heart, for everything you do flows from it. (26) Give careful thought to the paths for your feet and be steadfast in all your ways. ","date":"2022-11-30","objectID":"/proverbs/:2:4","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 5 Warning Against Adultery (6) She gives no thought to the way of life; her paths wander aimlessly, but she does not know it. (7) Now then, my sons, listen to me; do not turn aside from what I say. (8) Keep to a path far from her, do not go near the door of her house, (18-19) May your fountain be blessed, and may you rejoice in the wife of your youth. A loving doe, a graceful deer may her breasts satisfy you always, may you ever be intoxicated with her love. ","date":"2022-11-30","objectID":"/proverbs/:2:5","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 6 Warnings Against Folly (8) yet it stores its provisions in summer and gathers its food at harvest. (16-19) There are six things the Lord hates, seven that are detestable to him: haughty eyes, a lying tongue, hands that shed innocent blood, a heart that devises wicked schemes, feet that are quick to rush into evil, a false witness who pours out lies and a person who stirs up conflict in the community. (26) For a prostitute can be had for a loaf of bread, but another man’s wife preys on your very life. (29) So is he who sleeps with another man’s wife; no one who touches her will go unpunished. ","date":"2022-11-30","objectID":"/proverbs/:2:6","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 7 Warning Against the Adulterous Woman (4) Say to wisdom, “You are my sister,” and to insight, “You are my relative.” ","date":"2022-11-30","objectID":"/proverbs/:2:7","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 8 Wisdom’s Call (6-7) Listen, for I have trustworthy things to say; I open my lips to speak what is right. My mouth speaks what is true, for my lips detest wickedness. (12-13) “I, wisdom, dwell together with prudence; I possess knowledge and discretion. To fear the Lord is to hate evil; I hate pride and arrogance, evil behavior and perverse speech. (17-18) I love those who love me, and those who seek me find me. With me are riches and honor, enduring wealth and prosperity. (22-23) “The Lord brought me forth as the first of his works, before his deeds of old; I was formed long ages ago, at the very beginning, when the world came to be. (30-31) Then I was constantly at his side. I was filled with delight day after day, rejoicing always in his presence, rejoicing in his whole world and delighting in mankind. (34-36) Blessed are those who listen to me, watching daily at my doors, waiting at my doorway. For those who find me find life and receive favor from the Lord. But those who fail to find me harm themselves; all who hate me love death.” ","date":"2022-11-30","objectID":"/proverbs/:2:8","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 9 Invitations of Wisdom and Folly (7-8) Whoever corrects a mocker invites insults; whoever rebukes the wicked incurs abuse. Do not rebuke mockers or they will hate you; rebuke the wise and they will love you. (12) If you are wise, your wisdom will reward you; if you are a mocker, you alone will suffer. ","date":"2022-11-30","objectID":"/proverbs/:2:9","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 10 Proverbs of Solomon (3) The Lord does not let the righteous go hungry, but he thwarts the craving of the wicked. (8) The wise in heart accept commands, but a chattering fool comes to ruin. (12-13) Hatred stirs up conflict, but love covers over all wrongs. Wisdom is found on the lips of the discerning, but a rod is for the back of one who has no sense. (16-19) The wages of the righteous is life, but the earnings of the wicked are sin and death. Whoever heeds discipline shows the way to life, but whoever ignores correction leads others astray. Whoever conceals hatred with lying lips and spreads slander is a fool. Sin is not ended by multiplying words, but the prudent hold their tongues. (22) The blessing of the Lord brings wealth, without painful toil for it. (32) The lips of the righteous know what finds favor, but the mouth of the wicked only what is perverse. ","date":"2022-11-30","objectID":"/proverbs/:2:10","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 11 (2) When pride comes, then comes disgrace, but with humility comes wisdom. (10) When the righteous prosper, the city rejoices; when the wicked perish, there are shouts of joy. (13) A gossip betrays a confidence, but a trustworthy person keeps a secret. (16) A kindhearted woman gains honor, but ruthless men gain only wealth. (19) Truly the righteous attain life, but whoever pursues evil finds death. (21) Be sure of this: The wicked will not go unpunished, but those who are righteous will go free. (24-26) One person gives freely, yet gains even more; another withholds unduly, but comes to poverty. A generous person will prosper; whoever refreshes others will be refreshed. People curse the one who hoards grain, but they pray God’s blessing on the one who is willing to sell. (28) Those who trust in their riches will fall, but the righteous will thrive like a green leaf. (30) The fruit of the righteous is a tree of life, and the one who is wise saves lives. ","date":"2022-11-30","objectID":"/proverbs/:2:11","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 12 (9) Better to be a nobody and yet have a servant than pretend to be somebody and have no food. (12-14) he wicked desire the stronghold of evildoers, but the root of the righteous endures. Evildoers are trapped by their sinful talk, and so the innocent escape trouble. From the fruit of their lips people are filled with good things, and the work of their hands brings them reward. (16) Fools show their annoyance at once, but the prudent overlook an insult. (24-25) Diligent hands will rule, but laziness ends in forced labor. Anxiety weighs down the heart, but a kind word cheers it up. (28) In the way of righteousness there is life; along that path is immortality. ","date":"2022-11-30","objectID":"/proverbs/:2:12","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 13 (8) A person’s riches may ransom their life, but the poor cannot respond to threatening rebukes. (16) All who are prudent act with knowledge, but fools expose their folly. (25) The righteous eat to their hearts’ content, but the stomach of the wicked goes hungry. ","date":"2022-11-30","objectID":"/proverbs/:2:13","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 14 (3-4) A fool’s mouth lashes out with pride, but the lips of the wise protect them. Where there are no oxen, the manger is empty, but from the strength of an ox come abundant harvests. (7-10) Stay away from a fool, for you will not find knowledge on their lips. The wisdom of the prudent is to give thought to their ways, but the folly of fools is deception. Fools mock at making amends for sin, but goodwill is found among the upright. Each heart knows its own bitterness, and no one else can share its joy. (13) Even in laughter the heart may ache, and rejoicing may end in grief. (15-16) The simple believe anything, but the prudent give thought to their steps. The wise fear the Lord and shun evil, but a fool is hotheaded and yet feels secure. (21-24) It is a sin to despise one’s neighbor, but blessed is the one who is kind to the needy. Do not those who plot evil go astray? But those who plan what is good find love and faithfulness. All hard work brings a profit, but mere talk leads only to poverty. The wealth of the wise is their crown, but the folly of fools yields folly. (26-27) Whoever fears the Lord has a secure fortress, and for their children it will be a refuge. The fear of the Lord is a fountain of life, turning a person from the snares of death. (29-33) Whoever is patient has great understanding, but one who is quick-tempered displays folly. A heart at peace gives life to the body, but envy rots the bones. Whoever oppresses the poor shows contempt for their Maker, but whoever is kind to the needy honors God. When calamity comes, the wicked are brought down, but even in death the righteous seek refuge in God. Wisdom reposes in the heart of the discerning and even among fools she lets herself be known. ","date":"2022-11-30","objectID":"/proverbs/:2:14","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 15 (3) The eyes of the Lord are everywhere, keeping watch on the wicked and the good. (9) The Lord detests the way of the wicked, but he loves those who pursue righteousness. (11) Death and Destruction lie open before the Lord, how much more do human hearts! (15-16) All the days of the oppressed are wretched, but the cheerful heart has a continual feast. Better a little with the fear of the Lord than great wealth with turmoil. (18) A hot-tempered person stirs up conflict, but the one who is patient calms a quarrel. (20) A wise son brings joy to his father, but a foolish man despises his mother. (22-23) Plans fail for lack of counsel, but with many advisers they succeed. A person finds joy in giving an apt reply and how good is a timely word! (27-29) The greedy bring ruin to their households, but the one who hates bribes will live. The heart of the righteous weighs its answers, but the mouth of the wicked gushes evil. The Lord is far from the wicked, but he hears the prayer of the righteous. (31-33) Whoever heeds life-giving correction will be at home among the wise. Those who disregard discipline despise themselves, but the one who heeds correction gains understanding. Wisdom’s instruction is to fear the Lord, and humility comes before honor. ","date":"2022-11-30","objectID":"/proverbs/:2:15","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 16 (2) All a person’s ways seem pure to them, but motives are weighed by the Lord. (3) Commit to the Lord whatever you do, and he will establish your plans. (4) The Lord works out everything to its proper end even the wicked for a day of disaster. (5) The Lord detests all the proud of heart. Be sure of this: They will not go unpunished. (6) Through love and faithfulness sin is atoned for; through the fear of the Lord evil is avoided. (7) When the Lord takes pleasure in anyone’s way, he causes their enemies to make peace with them. (9-14) In their hearts humans plan their course, but the Lord establishes their steps. The lips of a king speak as an oracle, and his mouth does not betray justice. Honest scales and balances belong to the Lord; all the weights in the bag are of his making. Kings detest wrongdoing, for a throne is established through righteousness. Kings take pleasure in honest lips; they value the one who speaks what is right. A king’s wrath is a messenger of death, but the wise will appease it. (16) How much better to get wisdom than gold, to get insight rather than silver! (19) Better to be lowly in spirit along with the oppressed than to share plunder with the proud. (21-24) The wise in heart are called discerning, and gracious words promote instruction. Prudence is a fountain of life to the prudent, but folly brings punishment to fools. The hearts of the wise make their mouths prudent, and their lips promote instruction. Gracious words are a honeycomb, sweet to the soul and healing to the bones. (28) A perverse person stirs up conflict, and a gossip separates close friends. (32-33) Better a patient person than a warrior, one with self-control than one who takes a city. The lot is cast into the lap, but its every decision is from the Lord. ","date":"2022-11-30","objectID":"/proverbs/:2:16","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 17 (2-3) A prudent servant will rule over a disgraceful son and will share the inheritance as one of the family. The crucible for silver and the furnace for gold, but the Lord tests the heart. (5-7) Whoever mocks the poor shows contempt for their Maker; whoever gloats over disaster will not go unpunished. Children’s children are a crown to the aged, and parents are the pride of their children. Eloquent lips are unsuited to a godless fool how much worse lying lips to a ruler! (9-10) Whoever would foster love covers over an offense, but whoever repeats the matter separates close friends. A rebuke impresses a discerning person more than a hundred lashes a fool. (13) Evil will never leave the house of one who pays back evil for good. (15) Acquitting the guilty and condemning the innocent the Lord detests them both. (17) A friend loves at all times, and a brother is born for a time of adversity. (19) Whoever loves a quarrel loves sin; whoever builds a high gate invites destruction. (23-24) The wicked accept bribes in secret to pervert the course of justice. A discerning person keeps wisdom in view, but a fool’s eyes wander to the ends of the earth. (27-28) The one who has knowledge uses words with restraint, and whoever has understanding is even-tempered. Even fools are thought wise if they keep silent, and discerning if they hold their tongues. ","date":"2022-11-30","objectID":"/proverbs/:2:17","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 18 (2) Fools find no pleasure in understanding but delight in airing their own opinions. (12-13) Before a downfall the heart is haughty, but humility comes before honor. To answer before listening that is folly and shame. (17) In a lawsuit the first to speak seems right, until someone comes forward and cross-examines. ","date":"2022-11-30","objectID":"/proverbs/:2:18","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 19 (4) Wealth attracts many friends, but even the closest friend of the poor person deserts them. (15) Laziness brings on deep sleep, and the shiftless go hungry. (20-21) Listen to advice and accept discipline, and at the end you will be counted among the wise. Many are the plans in a person’s heart, but it is the Lord’s purpose that prevails. ","date":"2022-11-30","objectID":"/proverbs/:2:19","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 20 (21) An inheritance claimed too soon will not be blessed at the end. (23) The Lord detests differing weights, and dishonest scales do not please him. (28) Love and faithfulness keep a king safe; through love his throne is made secure. ","date":"2022-11-30","objectID":"/proverbs/:2:20","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 21 (2-3) A person may think their own ways are right, but the Lord weighs the heart. To do what is right and just is more acceptable to the Lord than sacrifice. (6) A fortune made by a lying tongue is a fleeting vapor and a deadly snare. (8) The way of the guilty is devious, but the conduct of the innocent is upright. (11) When a mocker is punished, the simple gain wisdom; by paying attention to the wise they get knowledge. (13) Whoever shuts their ears to the cry of the poor will also cry out and not be answered. (21) Whoever pursues righteousness and love finds life, prosperity and honor. (27) The sacrifice of the wicked is detestable how much more so when brought with evil intent! ","date":"2022-11-30","objectID":"/proverbs/:2:21","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 22 (3-4) The prudent see danger and take refuge, but the simple keep going and pay the penalty. Humility is the fear of the Lord; its wages are riches and honor and life. (11-12) One who loves a pure heart and who speaks with grace will have the king for a friend. The eyes of the Lord keep watch over knowledge, but he frustrates the words of the unfaithful. Thirty Sayings of the Wise (24-25) Saying3 Do not make friends with a hot-tempered person, do not associate with one easily angered, or you may learn their ways and get yourself ensnared. ","date":"2022-11-30","objectID":"/proverbs/:2:22","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 23 (4-5) Saying8 Do not wear yourself out to get rich; do not trust your own cleverness. Cast but a glance at riches, and they are gone, for they will surely sprout wings and fly off to the sky like an eagle. ","date":"2022-11-30","objectID":"/proverbs/:2:23","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 24 (14) Know also that wisdom is like honey for you: If you find it, there is a future hope for you, and your hope will not be cut off. (16) for though the righteous fall seven times, they rise again, but the wicked stumble when calamity strikes. (17) Do not gloat when your enemy falls; when they stumble, do not let your heart rejoice, ","date":"2022-11-30","objectID":"/proverbs/:2:24","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 25 More Proverbs of Solomon (6-7) Do not exalt yourself in the king’s presence, and do not claim a place among his great men; it is better for him to say to you, “Come up here,” than for him to humiliate you before his nobles. (13) Like a snow-cooled drink at harvest time is a trustworthy messenger to the one who sends him; he refreshes the spirit of his master. (15-17) Through patience a ruler can be persuaded, and a gentle tongue can break a bone. If you find honey, eat just enough too much of it, and you will vomit. Seldom set foot in your neighbor’s house too much of you, and they will hate you. (20-22) Like one who takes away a garment on a cold day, or like vinegar poured on a wound, is one who sings songs to a heavy heart. If your enemy is hungry, give him food to eat; if he is thirsty, give him water to drink. In doing this, you will heap burning coals on his head, and the Lord will reward you. (26-28) Like a muddied spring or a polluted well are the righteous who give way to the wicked. It is not good to eat too much honey, nor is it honorable to search out matters that are too deep. Like a city whose walls are broken through is a person who lacks self-control. ","date":"2022-11-30","objectID":"/proverbs/:2:25","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 26 (2) Like a fluttering sparrow or a darting swallow, an undeserved curse does not come to rest. (5) Answer a fool according to his folly, or he will be wise in his own eyes. (16-20) A sluggard is wiser in his own eyes than seven people who answer discreetly. Like one who grabs a stray dog by the ears is someone who rushes into a quarrel not their own. Like a maniac shooting flaming arrows of death is one who deceives their neighbor and says, “I was only joking!” Without wood a fire goes out; without a gossip a quarrel dies down. (26-27) Their malice may be concealed by deception, but their wickedness will be exposed in the assembly. Whoever digs a pit will fall into it; if someone rolls a stone, it will roll back on them. ","date":"2022-11-30","objectID":"/proverbs/:2:26","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 27 (1-2) Do not boast about tomorrow, for you do not know what a day may bring. Let someone else praise you, and not your own mouth; an outsider, and not your own lips. (6) Wounds from a friend can be trusted, but an enemy multiplies kisses. (9-11) Perfume and incense bring joy to the heart, and the pleasantness of a friend springs from their heartfelt advice. Do not forsake your friend or a friend of your family, and do not go to your relative’s house when disaster strikes you better a neighbor nearby than a relative far away. Be wise, my son, and bring joy to my heart; then I can answer anyone who treats me with contempt. (20) Death and Destruction are never satisfied, and neither are human eyes. ","date":"2022-11-30","objectID":"/proverbs/:2:27","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 28 (1) The wicked flee though no one pursues, but the righteous are as bold as a lion. (4-6) Those who forsake instruction praise the wicked, but those who heed it resist them. Evildoers do not understand what is right, but those who seek the Lord understand it fully. Better the poor whose walk is blameless than the rich whose ways are perverse. (8) Whoever increases wealth by taking interest or profit from the poor amasses it for another, who will be kind to the poor. (20) A faithful person will be richly blessed, but one eager to get rich will not go unpunished. (21) To show partiality is not good yet a person will do wrong for a piece of bread. (23) Whoever rebukes a person will in the end gain favor rather than one who has a flattering tongue. ","date":"2022-11-30","objectID":"/proverbs/:2:28","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 29 (5) Those who flatter their neighbors are spreading nets for their feet. (15) A rod and a reprimand impart wisdom, but a child left undisciplined disgraces its mother. (19-20) Servants cannot be corrected by mere words; though they understand, they will not respond. Do you see someone who speaks in haste? There is more hope for a fool than for them. (23) Pride brings a person low, but the lowly in spirit gain honor. (25) Fear of man will prove to be a snare, but whoever trusts in the Lord is kept safe. ","date":"2022-11-30","objectID":"/proverbs/:2:29","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 30 Agur, son of Jakeh Saying of Agur (8-9) Keep falsehood and lies far from me; give me neither poverty nor riches, but give me only my daily bread. Otherwise, I may have too much and disown you and say, ‘Who is the Lord?’ Or I may become poor and steal, and so dishonor the name of my God. (15-16) “The leech has two daughters. ‘Give! Give!’ they cry. “There are three things that are never satisfied, four that never say, ‘Enough!’: the grave, the barren womb, land, which is never satisfied with water, and fire, which never says, ‘Enough!’ ","date":"2022-11-30","objectID":"/proverbs/:2:30","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 31 Sayings of King Lemuel, utterance his mother taught him. (8) Speak up for those who cannot speak for themselves, for the rights of all who are destitute. (15) She gets up while it is still night; she provides food for her family and portions for her female servants. (30) Charm is deceptive, and beauty is fleeting; but a woman who fears the Lord is to be praised. ","date":"2022-11-30","objectID":"/proverbs/:2:31","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":" You can train your brain to remember better, to learn faster and to achieve mastery in anything you want in your life. (Nishant Kasibhatla) 문득 소중한 사람들과의 감사했던 순간들을 잊어버리기 때문에, 사람이 교만하고 잔인해 질 수 있다고 생각했다. 소중한 시간들을 잊지 않기 위해, 나는 기억을 다스려야한다. 이를 위해 기억력을 높여 줄 3가지 방법 | 한영자막 을 보았고 앞으로의 공부에도 실용적으로 도움이 될 것 같아, 나만의 방법으로 이해하고 정리해보고자 한다. ","date":"2022-11-23","objectID":"/what_is_memory/:0:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"tl;dr Quote For true mastery, you need to focus more on the output rahter than the input. Learn, Do one thing at one time, especially when it comes to learning. Reflect, How can I use this information in my life? Implement, Share it. Nishant Kasibhatla FYI, 영상에 나오는 Nishant Kasibhatla(니샨트 카십하틀라) 는 찾아보니 Grand Master of Memory (= International Association of Memory) 보유자. 기억력 기네스 보유자. 20년간 관련 분야에 대해 코카콜라, Oracle, American express, 필립스 등 수많은 기업 강연함. 등등의 경력을 가지고 있다. ","date":"2022-11-23","objectID":"/what_is_memory/:1:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"1. As Below (3) 3 steps to improve your memory and ability to learn. 1-1. Learn: focus, single task You must ensure that the quality of input is really, really high, Which means avoid multi-tasking. Multi-tasking kills your learning momentum. Quality of input determines the quality of retention. It also affects the quality of recall. Do one thing at one time, especially when it comes to learning 1-2. Reflect: solidifies How to learn solidifies. After you learn something, pause for a while and ask yourself. “Hey, What’s the takeaway from this thing?” “How can I use this information in my life?” “How can I use this information in my work, in my family?” 1-3. Implement: share, express This is where the magic happens, but unfortunately many people miss out on this. What they do, is go on learning new things, and get excited and they feel good and they feel inspired and they go on to learn something new. You just mess up. Illusion of competence If you get into the habit of just learning without implementation, you know what you get. You get the illusion of competence. You feel you’ve learned it. You feel you’re competent. But it’s not competence at all, because you haven’t implemented. Suggestion After learn, Stop and write down what are the few things I can take action on. Schedule it in the calendar and take some action. Share: the best way to learn something is to teach it. When you learn something. Just output it, Just share it with other people. What you’re doing is you’re helping your brain to pay more attention. I(Nishant) have not seen anyone who became a master at something just by doing the input. They all became masters by doing the input and more of the output. If you’re spending X amount of time on input. My suggestion is at least spend 2X amount of time on output. And when you do that, you are well on your way to be a master at achieving anything you want. ","date":"2022-11-23","objectID":"/what_is_memory/:2:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2. As Above 나만의 원칙으로 재해석 해보자. ","date":"2022-11-23","objectID":"/what_is_memory/:3:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2-1. What is Like Me? 나는 “나 답게 살고 싶고, 그렇게 죽고 싶다.”. 현 시점의 나 또한 여전히 성공한 인생이란, 죽기 전까지 나답게 살아서, 후회없이 사는 것이라고 생각한다. 지금까지 나는 “나답게\"에서 나라는 개념을 찾아왔고 이해했고 살아왔다. 10대 “세상이 가지지 못한 복음\"을 믿고 있는, 나는 특별하다. “청소년기에는 죽음을 고민하다 선교사를 꿈꾸며(중2)” 지식: 성경의 예수님을 통해 사랑을, 다니엘을 보며 지혜를, 요한과 바울을 보며 신비를 꿈꾸었으며, 이해: 내 주변의 폭력과 경쟁 속에서 이를 구현하도록 기도했고, 행동: 수능과 재수, 선교(요르단, 티베트, 베이징)를 통해 더 큰 세상을 느꼈다. 20대 “내가 모든 것을 맛보고 나서야 판단하겠다”(만류귀종)는 신념이 있는, 나는 특별하다. “20대에는 내 인생의 전부인 교회를 지우기로 결심하고, 나아가서는 해석을 강요하는, 즉 기존에 시스템으로 존재하는 모든 종류의 믿음을 거부하여 지식: 모든 종류의 배우고 느낄 수 있는 웃긴, 즐거운, 특별한, 대단한, 두근거리는, 신비한, 강한, 쿨한, 부유한, 흥분되는, 지식-조각들을 모아왔고, 이해: 그 동안 교회와 관련된 내 모든 친구와 동생들, 형과 누나들의 모든 연락을 끊고, 술과 담배, Hermetics, Kabbalah, astrology 성공학(네빌고다드, 드마코, 디팩초프라, 조-디스펜자), 조던 피터슨, 사이토 히토리, osho 복싱, 5번의 주전공 수업 그리고 프로그래밍을 이해하기 위해 노력했고, 행동: 알바, 군대, 인턴, 취업 투자, 2번의 이직, 3년의 사회생활 대외활동들(미소국가대표, 멋쟁이사자처럼6-7기, 넥스터즈18-21기) 여행(베트남, 오키나와, 싱가포르, 삿포로, 라오스, 제주도 🏝️)을 통해 더 큰 세상을 느꼈다. 30대 만으로 30세가 되었다. “사랑과 정의를 양심으로 균형 맞추고 싶다”. “30대의 나는 믿음이 아닌, 행동을 통해 알고 싶고, 그 모든 과정이 선했으면 좋겠다. (Albert Einstein) Innovation is not the product of logical thought, even though the final product is tied to a logical structure. 지식: 내가 생각하는 균형이란 선과 악, 양과 음, 사랑과 정의, 자유와 책임, 안과 밖. 나와 너, 천국과 지옥, 인생과 죽음, 말과 행동, 생각과 감정. 하찮은 것과 대단한 것, 양심과 욕심. 내가 생각하는 사랑이란. 선한 것을 좋아하는 마음. 나와 너가 사랑 안에서 둘이 아니라는 것. 나와 세상이 사랑 안에서 둘이 아니라는 것. 들이 쉬는 것, 자유로운 것, 확장하는 것, 아는 것. 내가 생각하는 정의란. 악한 것을 싫어하는 마음. 신념을 행동으로 책임지는 것. 구분하고 있는 나를 아는 것. 뱉어내는 것, 무거운 것. 내가 생각하는 양심이란. 중심을 맞추는 것 (도) 내가 나에게 떳떳한 것. (팔은 안으로 굽으니) 남을 미워한 만큼, 나를 조금 더 미워할 줄 아는 것. (내가 신이 아니니) 남을 사랑한 만큼, 나를 조금 더 사랑할 줄 아는 것. (내가 신을 닮고 싶으니) 받은 만큼, 조금 더 줄 줄 아는 것. (내가 신을 닮고 싶으니) 들이 쉰 만큼, 조금 더 뱉는 것. 이해: 고전/경전 들을 읽고 있고 더 읽을 예정이다. 철학자들의 생각을 읽고 있으며 더 읽을 예정이다. 명상과 단학을 해보고 있고, 더 해볼 예정이다. 돈에 대해 읽고, 정의 내려보고 있으며, 돈의 시나리오를 작성해 다시 투자해볼 예정이다. 영어를 공부하며, 미국 문화를 이해하고 있으며, 기회가 된다면 살아볼 예정이다. 직업에 대해서 고민하고 있으며, 더 정의해 볼 예정이다. 인간관계에 대해서 고민하고 있으며, 가까운 사람들을 통해 행동해보고 있으며, 다시 사회로 나가 시험해 볼 예정이다. 행동: 퇴사 mma 미국 여행 책추남 템플턴 아카데미 홍익학당 신사과정 준비 ","date":"2022-11-23","objectID":"/what_is_memory/:3:1","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2-2. Back to the point 학습과 기억에 대한 원칙을 나만의 것으로 재해석 해보자. Spirit investments Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton 존 템플턴의 멋진말에 공감한다. 모든 행동의 원칙은 내가 사는 이유, 선/악의 기준 즉 나의 양심에 기반해서 도출하고 싶다. 이는 투자에서도, 프로그래밍에서도, 앞으로 공부할 모든 분야에 대해서도 마찬가지라 생각한다. 그리고 사실 분리된 것 같아 보이는 모든 분야에서, 나는 공통의 결을 볼 수 있으리라 생각한다. 나라는 개념 또한 그렇게 생각하기 때문에 앞서 Like Me에 대해서 정리를 해보았다. Einstein and the Poet The truly religious man has no fear of life and no fear of death and certainly no blind faith; his faith must be in his conscience. I am therefore against all organized religion. by Albert Einstein 뉴턴, 라이프니츠 등 과거에는 철학자이자 신학자이자 과학자이자 수학자이고 음악가등 한 인물이 다양한 분야에서 관심을 가지고 공부하고 발견했듯이, 벤포드 법칙과 같은 법칙이 우연으로 보이는 데이터 세상에서 내적 법칙으로 동작하듯이, 나는 내가 할 수 있는 모든 학습을 통해 그 결을 보고 느끼고 싶다. (Albert Einstein) I want to know God’s thoughts; the rest are details. 1. Seek (learn) 신을 찾듯이, 기도 하듯이, 사랑을 읽고 찾는다. 💡: You, love, free-will, study, expand, light, focus, pray, know, search (Matt.22.37) Love the Lord your God with all your heart and with all your soul and with all your mind. (Matt.7.7-12) Ask and it will be given to you; seek and you will find; knock and the door will be opened to you. For everyone who asks receives; the one who seeks finds; and to the one who knocks, the door will be opened. “Which of you, if your son asks for bread, will give him a stone? Or if he asks for a fish, will give him a snake? 2. Establish (reflect) 기존의 나의 존재와 발견한 사랑을 다시 합친다. 💡: Ego, justice, responsibility, connect, spider-web, plan, dark, don’t know, 無極, microcosm, Monad, feel, find (Prov.16.3) Commit to the LORD whatever you do, and he will establish your plans. “어떻게 하면 현실에서 적용할 수 있을까?” “어떻게 하면 강하면서도 선할 수 있을까?” “어떻게 하면 원수도 사랑 할 수 있을까?” 3. Subdue (implement) 나의 법칙으로 다스려본다. 잘 된다면 말과 행동이 일치하는 인생을 살고 있는 것이다. 💡: I, being, As above so below, oneness, 道, 中庸, 良心, macrocosm, 太極, sympathy-empathy, golden rule, Ouroboros (Matt 22.39) And the second is like it: ‘Love your neighbor as yourself.' (Gen 1.28) God blessed them and said to them, “Be fruitful and increase in number; fill the earth and subdue it. Rule over the fish in the sea and the birds in the sky and over every living creature that moves on the ground.” by Rabbi Daniel Lapin 말보다 행동이 더 무겁다. 글을 읽는 것보다 이해하는게 더 어렵고, 이해한 것 보다 그것을 전달하는게 더 어렵고, 말한 것 보다 그렇게 사는게 더 어렵기 때문이다. 말과 행동이 다른 사람이 역한 것은, 자신이 빌려온 지식을 가지고 이해한척, 선생님인척 굴기 때문이다. 이렇게 1 -\u003e 2 -\u003e 3을 하고 나면 다시 반대로 2 -\u003e 1을 하여, 배움을 이어간다. ","date":"2022-11-23","objectID":"/what_is_memory/:3:2","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"3. Conclusion 계자서(戒子書) 끝으로 제갈량(諸葛亮,181-234)이 54세의 나이에 8살 아들인 제갈첨(諸葛瞻)에게 보내는 편지를 통해 배움에 대한 생각을 마무리해보려 합니다. 계자서 비석 탁본 글씨 戒子書, 제갈량 夫君子之行(부군자지행) 무릇 군자의 조행(操行-행동을 조심함)이란 靜以修身(정이수신) 고요한 마음으로 몸을 닦고 儉以養德(검이양덕) 검소함으로써 덕을 기르는 것이다. 非澹泊無以明志(비담박무이명지) 마음에 욕심이 없어 담박하지 않으면 뜻을 밝힐 수 없고, 非寧靜無以致遠(비녕정무이치원) 마음이 안정되어 있지 않으면 원대한 이상을 이룰 수 없다. 夫學須靜也(부학수정야) 무릇 배울 때는 반드시 마음이 안정되어 있어야 하며, 才須學也(재수학야) 재능은 반드시 배움을 필요로 한다. 非學無以廣才(비학무이광재) 배우지 않으면 재능을 발전시킬 수 없고 非靜無以成學(비정무이성학) 마음이 고요하지 않으면 학문을 성취할 수 없다. 慆慢則不能硏精(도만칙불능연정) 마음이 방자하고 오만하면 정밀하고 미묘한 이치를 깊이 연구할 수 없고, 險躁則不能理性(험조칙불능이성) 조급하고 경망하면 자신의 본성을 제대로 다스릴 수 없다. 年與時馳(년여시치) 이치를 제대로 밝히지 못하고 본성을 제대로 다스리지 못하는 사이에 志與歲去(지여세거) 나이는 시간과 함께 달려가고 의지는 세월과 함께 사라지면서 遂成枯落(수성고락) 마침내 가을날 초목처럼 시들어 갈 것이다. 悲嘆(守)窮廬(비탄궁려) 그때 가서 곤궁한 오두막집에서 슬퍼하고, 將復何及也(장부하급야) 탄식해본들 어찌 할 것인가? 대만의 남회근 선생님(중국문화 만담)의 풀의 중 참고할 만한 내용입니다. “무릇 군자는 고요함으로 몸을 닦고 검소함으로 덕을 기른다. 담박하지 않으면 뜻을 밝게 할 수 없고, 고요하지 않으면 멀리 이를 수 없다” [夫君子之行, 靜以修身, 儉以養德. 非淡泊無以明志, 非寧靜無以致遠] 먼저 심경이 고요할 수 있어야 합니다. 중국의 신흥 기업가들, 특히 여러분들은 주의해야 합니다! 담박할 수 있겠습니까? 비단 삶이 담박해야 할 뿐 아니라 생각 또한 담박해야 합니다. “무릇 배움은 모름지기 고요해야 하며[夫學須靜也]” 진정으로 학문을 말하려면 고요한 환경, 고요한 시간을 가져야 합니다. 하루 스물네 시간 중 예닐곱 시간은 혼자서 고요히 돌이켜 생각하고 반성하며 독서해야 합니다. “재능은 모름지기 배워야 얻는다[才須學也]” 지식의 축적, 재능의 신장은 학문을 통해서 나옵니다. “배우지 않으면 재능을 넓힐 수 없고[非學無以廣才]” 광범한 지식을 구하지 않으면 재능이 국한됩니다. “고요하지 않으면 학문을 이룰 수 없다[非靜無以成學]” 고요한 심경이 없다면, 고요한 생각이 없다면 여러분의 학문은 깊어질 수 없습니다. 어떤 판본에서는, “뜻이 없으면 학문을 이룰 수 없다[非志無以成學]”고도 했는데, ‘지(志)’란 입지(立志)로서 뜻을 세우는 것입니다. 강렬한 바람이나 의지가 없다면 학문 역시 깊어질 수 없습니다. “오만하면 세밀히 연구할 수 없고, 험하고 조급하면 본성을 다스릴 수 없다[慢則不能硏精, 險躁則不能理性]” 스스로 자신을 용납하고 게으르며 정진하지 않는 것이 ‘도’이고 ‘만’은 자만으로서 스스로 자기 만족에 빠져 뛰어나다고 생각하는 것입니다. 누구든 쉽게 이런 잘못을 범할 수 있습니다. 예를 들어 봅시다. 여러분은 보통의 젊은 사람들이 독서할 때와 마찬가지로 한 번 보고는 모두 이해했다고 생각하지만 사실은 그림자도 잡지 못했습니다. 이것이 바로 도만입니다. 도만하면 정치하게 연구할 수 없습니다. 내면의 생각과 정서가 요동치면 마음이 안정되지 못해 조급하게 성질을 부리는데, 그렇게 되면 본성을 다스릴 수 없습니다. 자신을 관리할 수 없게 되지요. - 끝 -","date":"2022-11-23","objectID":"/what_is_memory/:4:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["book","money","wisdom"],"content":"What is money? and How to subdue it? ","date":"2022-11-16","objectID":"/spiritual_investments/:0:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"tl;dr Intro Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton ","date":"2022-11-16","objectID":"/spiritual_investments/:1:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"17 Principles Invest for maximum total real return. Invest–don’t trade or speculate. Remain flexible and open-minded about types of investments. Buy low–at the point of maximum pessimism. Search for quality when buying. Buy value, not market trends or economic outlook. Diversify. Do your homework or hire reliable experts to help you. Monitor your investments. Don’t panic. Learn from your mistakes. Use prayer to gain perspective and quiet your mind. Recognize the difficulty of outperforming the market. An investor who has all the answers doesn’t even understand the questions. There is no free lunch. Do not be overly fearful or negative. Those who do good do well. ","date":"2022-11-16","objectID":"/spiritual_investments/:1:1","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"17가지 원칙 최종 수익률로 평가하라. 투기적 매매가 아닌 투자를 하라. 유연한 자세로 투자 대상을 고르라. 쌀 때 사라, 비관적 분위기가 최고조에 달했을 때. 매수하기 전에 먼저 좋은 주식인지 살펴보라. 시장의 유행이나 전망이 아니라 가치를 사라. 위험을 분산하라. 스스로 공부하라, 아니면 전문가의 도움을 받으라. 투자에 주의를 게을리 하지 말라. 패닉에 빠지지 말라. 실수로부터 배우라. 기도를 통해 평정심과 통찰력을 얻으라. 평균 이상의 수익률을 거두기가 얼마나 어려운지 알라. 자만을 버리고 겸손하라. 세상에 공짜는 없다. 너무 두려워하지도 말고 부정적으로 보지도 말라. 선을 행하면 다 잘 된다. ","date":"2022-11-16","objectID":"/spiritual_investments/:1:2","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 돈이란 무엇인가? 그리고 어떻게 다스릴 것인가? A. 하나님을 찾듯 돈을 찾고, 받은 사랑을 대하듯 돈을 대하며, 저지른 실수에 대해서는 책임을 배워 더 사람으로 살자. Book Intro Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton ","date":"2022-11-16","objectID":"/spiritual_investments/:2:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 ","date":"2022-11-16","objectID":"/spiritual_investments/:3:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2-1. 받은 영감: 이 책의 저자는 템플턴이 아닌 Gary Moore이다. 연상된 점: 항룡유회 깨달은 점: 템플턴 경은 Gary Moore같이 속 시원하게 이야기할 친구가 있어서 신이났을 것 같다. 나도 속시원하게 내 이야기를 할 수 있는 친구가 있어서 감사하다. ","date":"2022-11-16","objectID":"/spiritual_investments/:3:1","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2-2. 받은 영감: 형이하적인 17가지 투자 원칙 마다, 저자의 영혼의 원칙이 존재하고 그것을 삶으로 완성시켰다. 연상된 점: As above, so below 깨달은 점: 말은 가볍고 행동은 무겁다. 내 안에 알아차리는 자, 신성, 태극이 존재함과 남/세상과 내가 사랑 안에서 둘이 아니라는 신념은 내가 얼마나 그에 맞게 세상에서 행동을 하는지에 따라서만 내가 이해할 수 있다. ","date":"2022-11-16","objectID":"/spiritual_investments/:3:2","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"3. 저자의 주장에 대한 나의 생각 Gary Moore in spiritual investments “죄악주(Sin stock)라고 부르는 주류회사와 담배회사, 도박회사에는 처음부터 투자하지 않는다는 원칙을 세웠고, 이 원칙은 오늘까지도 지켜지고 있다.” +: Sin stock이라는 개념을 실제로 주식시장에 적용해서 행동함. -: (템플턴을 존경해서, 감히 판단하자면) Sin stock의 종류가 너무 1차원적으로 굳어있다. 과연 술, 담배는 악할까? 돈이 사람에 따라 선하기도 악하기도 하듯, 술/담배 또한 그러한 것 같다. 현재 상황에서 나와 세상에 대체로 악하게 작동된다 판단되는 모든 것이 Sin stock이 되야 된다고 생각하며 그 종류는 계속해서 변경되야 된다고 생각한다. ","date":"2022-11-16","objectID":"/spiritual_investments/:4:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"4. 질문 및 토의 사항 Q. 주식투자와 선행을 분리해서 생각해야 할까? 기업의 주식을 사는 것이 기업의 ‘시가총액’은 높여줄 수 있지만, 실제로 기업의 재산에는 어떤 영향도 주지 않는다고 이해했습니다. 그렇다면 템플턴 경이 말했던 “적어도 자산의 일부는 저개발 국가에 투자해야 한다고 강조한다”(19p) 라는 문맥에서 투자는 주식을 사는 행위가 아닌 걸까요? 그렇다면 투자하기 좋은 기업이란 그저 Sin Stock이 아니면서, 내 자본을 크게 부풀려줄 수 있는 기업일까요? ","date":"2022-11-16","objectID":"/spiritual_investments/:5:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"5. 작은 실천 계획 존 템플턴의 행복론, 존 템플턴의 성공론 읽기. 테크닉적인 주식 공부하며, 나의 좋은 주식 원칙 기록하기. ","date":"2022-11-16","objectID":"/spiritual_investments/:6:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"6. 자유 감상문 이 책을 일주일전 뉴욕 맨하튼 호텔 로비에서 완독하였다. 그 동안 부유한 월스트리트와 화려한 타임스퀘어를 돌아 보았고 그리고 건강하게 센트럴파크도 뛰어 보았다. 그러면서도 찌든 대마 냄새와 추위에 떨면서 술에 취해 자는 많은 노숙자들을 보았다. 그리고 다시 호텔로 돌아와 책을 읽으며 뉴욕의 경험과 함께 돈과 관련된 나의 생각을 정리해 나갔다. Prov 16:3 Commit your works to the Lord, And your thoughts will be established. 현재 나는 “돈을 왜 벌어야 할까?” 라는 질문으로 좋은 페이와 기회를 주는 회사를 그만두었고, 사실 그 질문의 이면에는 너무나도 초라한 마음 상태를 가진 내가 불쌍하기 때문이었다. 회사를 그만둔 뒤, 마음껏 재밌는 것들을 하고, 스케줄의 압박 없이 편하게 지내며, 좋은 고전들을 듣고 읽고 땀을 흘려 운동을 하였다. 시간과 여유가 있으니 자연스레 할머니, 부모님 그리고 친구들을 돌아보며 내가 많은 것들을 놓쳤다는 것을 알았고, 이를 표현하며 더 성숙해졌다. 그러다 미국에 혼자 있는 형이 보고 싶어 달러강세에도(1,410원/$) 돈을 환전해 미국으로 갔고, 그 안에서 생활하면서 다양한 경험을 하고 있다. 그리고 퇴사후 했던 이 모든 과정에서 사실 모두 돈이 필요했다는 것을 알고, 내가 쓴돈 이외에도 형과 부모님의 금전적 희생이 토대가 된다는 것을 알며, 앞으로의 계획을 위해서는 더 많은 돈이 필요하다는 것을 알았다. 그럼 다시 \"나는 왜 돈을 벌어야하고 어떻게 벌어야 할까?\" Sir John Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. 나는 안과 밖에서 모두 신을 찾고 느껴 확장하며 살고싶다. 지금의 백수 생활처럼 지혜를 경험하고 고민할 수 있는 시간과 공간이 필요하다. 즉 자유의 돈이 필요하다. 고민한 만큼 더 많은 위험과 악한것들이 보이니, 사랑하는 모든 것들을 지켜내기 위한 정의의 돈이 필요하다. 지금 사랑하는 사람들과 앞으로 나타날 제2의 제민욱들에게 부끄럽지 않을 증명과 권력으로써의 돈, 즉 책임의 돈이 필요하다. 내가 보기에 아름다워 보이는 향기를 내는 모든 종류의 스승들과 친구들에게 감사를 전하고 싶다, 즉 사랑의 돈이 필요하다. 템플턴 경(그리고 게리 무어)이 전달해준 지식과 그걸 증명해내는 행동 덕분에 많이 배웠습니다. 이 깨달음을 돈에 대한 나의 다짐으로 마무리 하겠습니다. ","date":"2022-11-16","objectID":"/spiritual_investments/:7:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"My Resolution What do I think about money? 나는 돈을 다스릴 것이다. Gen.1.28 God blessed them and said to them, “Be fruitful and increase in number; fill the earth and subdue it.” … 나에게 돈이란 사랑과 정의, 자유와 책임이며. 돈을 다스린다는 것은, 욕심과 양심 사이를 저울질하면서. Prov.21.2 A person may think their own ways are right, but the LORD weighs the heart. 돈을 스승으로 삼아. 사랑과 정의, 자유와 책임을 위해 사용하는 것입니다. Matt.22.37 “Love the Lord your God with all your heart and with all your soul and with all your mind” … And the second is like it: “Love your neighbor as yourself” 먼저는 나에게. 둘째는 가족이며. 셋째는 스승과 친구이며. 이 모든것은 신께 드리는 내 행동의 기도입니다. Prov.15.9 The LORD detests the way of the wicked, but he loves those who pursue righteousness. 그러므로 돈을 통해 내 욕심의 소리와 양심의 소리를 같이 듣겠습니다. Prov.15.31 Whoever heeds life giving correction, will be at home among the wise. 내 행동의 기도가 양심이라면, 내 그릇이 커질 것이고 Prov.19.21 Many are the plans in a person’s heart, but it is the LORD’s purpose that prevails. 내 행동의 기도가 욕심이라면, 내 그릇이 부끄러워 질 것입니다. Prov.15.33 Wisdom’s instruction is to fear the LORD, and humility comes before honor. ","date":"2022-11-16","objectID":"/spiritual_investments/:8:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["life","philosophy"],"content":"한달 전 일도 인생도 제대로 안살고 있는 내가 꼴보기 싫어 직장을 그만두었다. 그리고 사실은 그렇게 못살고 있던 내가 불쌍해서 앞으로는 소중한 것을 놓치지 말라는 마음을 기록해 봅니다. ","date":"2022-10-22","objectID":"/what-i-know/:0:0","tags":["poetry"],"title":"세번째 직장을 그만두고서","uri":"/what-i-know/"},{"categories":["life","philosophy"],"content":"What I know 제목: 나는 내가 나를 모른다는 것을 안다. 나는 숨을 쉰다. 내가 숨을 참는다. 나는 내가 숨을 참지 못할 것을 안다. 숨 보다 숨을 참지 못하는 몸을 더 모른다는 것을 안다. 몸 보다 잊혀진 생각, 감정, 느낌 그리고 기억들을 더 모른다는 것을 안다. 나는 나를 모른다는 것을 안다. 나는 나보다 내 부모를 더 모른다는 것을 안다. 가족보다 친구를 더 모른다는 것을 나는 안다. 친구보다 남을 더 모른다는 것을 나는 안다. 남보다 원수를 더 모른다는 것을 나는 안다. 원수보다 그 원수를 사랑하라는 예수를 더 모른다는 것을 나는 안다. 나는 내가 하나님을 모른다는 것을 안다. 나는 내가 신이 아니라는 것을 안다. 그런데 계속 안다고, 말하는 너가 누군지 모르겠다. 지금 모르겠다고, 말하는 내가 누군지도 모르겠다. 나는 나를 모른다. 나는 내가 나를 모른다는 것을 안다. 그런데 사람들이 나를 알아봐준다. 그래서 더 불편하다. 그래서 더 답답하다. 그래서 더 섭섭하다. 그래서 더 거슬린다. 그래서 더 짜증난다. 그래서 더 부끄럽다. 그래서 더 까먹는다. 그래서 악하다. 그래도 사람들이 나를 알아봐준다. 그래서 더 편하다. 그래서 더 끌린다. 그래서 더 공감한다. 그래서 더 감사하다. 그래서 더 기대한다. 그래서 더 신뢰한다. 그래서 더 사랑한다. 그래서 선하다. 그래서 모르겠다. 그래도 궁금하다. 그러니 재밌다. 그래서 숨을 조금 더 뱉어본다. ","date":"2022-10-22","objectID":"/what-i-know/:1:0","tags":["poetry"],"title":"세번째 직장을 그만두고서","uri":"/what-i-know/"},{"categories":["life"],"content":"나를 포함한 내 주변이 나를 온전히 봐주길 원한다. 나한테 그게 양심이다. ","date":"2022-10-20","objectID":"/behavior/:0:0","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["life"],"content":"원칙 딱 들이쉰 만큼만 뱉어내라. 모든 곳에 신이있다. 시시하다면 지금 내 마음이 급한거다. 내가 높아졌으면 누가 깔아준거다. 망하는거 생각보다 초라하지 않다. 주고 싶으면, 엄마 아빠부터 돌아봐라. 입꼬리 살짝 올리고 있으면, 기분 좋다. 지금 불안하면, 그 장소의 냄새와 맛들을 찾아봐라. 오늘의 원칙이 없으면, 내일의 성장이 없다. 말 만하고 행동하지 않으면, 부끄럽다. 말 없이 행동으로 증명하는게 더 설득력있다. 말보다 감정의 맛이 더 깊다. 모르겠으면 그냥 더 불편한걸 해라. 그래도 법은 지켜라. 안다는건 시각 미각 후각 청각 촉각으로 아는것. 가르치려 들지 마라. 기분 나쁘다. 온전히 봐주고 이해해주길 원한다, 하지만 커밍아웃을 당하면 수치심이 들거다. 기억나지 않는건 내 수치심을 건드렸을 확률이 높다. 까먹기 싫다면, 내일의 나에게 수치심을 줘라. 기록을 한다면, 짧을 수록 좋다. 상대가 못생겼다면, 내 감정이 못생긴거다. 집에가서 그 감정을 품어줘라. 나도 귀한집 자식이다. 유전자 타고 가면 상대방도 내 형제다. 형이랑 싸우고 있으면 엄마 가슴이 찢어진다. ","date":"2022-10-20","objectID":"/behavior/:0:1","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["life"],"content":"폭력 누가 내 왼뺨을 때리려 하면, 왼쪽 가드 -\u003e 투 -\u003e 훅 -\u003e 원투를 정확히 오른쪽 뺨에 때리자. 성인 군자인척 하지 말자. 이건 내가 아빠한테 할아버지처럼 행동하는 것 만큼 어색하다. 꼭 싸워야만 한다면, 말 없이 때리자. 내가 맞아 준다면, 아빠, 엄마, 할머니를 내가 때리고 있다는걸 기억하자. ","date":"2022-10-20","objectID":"/behavior/:0:2","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["book","money","mind"],"content":"나에게 권위에 대한 자발적 순종을 알려준, 적당히 욕심 많은 아버지가 딸들에게 보내는 헌신적인 사랑 ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:0:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 아버지가 딸에게 바라는 것은? A. 자발적 순종 ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:1:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 짐 로저스는 딸을 소유하고 싶어하면서도 할렘 같은 곳으로 가라는 믿음을 준다. 아버지가 딸을 믿어주니 딸이 자유를 가질 수 있다. 그럼 아버지는 딸로 부터 무엇을 가장 원할까? 순종을 알려준 적당히 욕심 많은 아버지. 먼저 내가 받았으니 오버하지 말고 나도 적당히만 순종하자. ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:2:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"3. 저자의 주장에 대한 나의 생각 (207p) “너희도 사람들이 곤경에 처했을 때 모른 체하면 안 된다. 그런 때일수록 힘이 돼주는 일이 중요하다. 외면하지 않고 곁에 있어주는 데 큰돈이 드는 것도 아닌데 당사자는 그 일을 항상 기억하면서 매우 고마워한다.” 부정: 딸들/돈을 사랑하는 마음은 이해되지만 그럼에도 불구하고 힘든 이웃을 도우는 일에 이렇게 까지 값으로 계산하는 의도가 밉다. 딸들이 만약 자신을 그렇게 계산적으로 생각한다고 느낀다면, 본인도 상처입지 않을 수 있을까? 긍정: 짐로저스가 생각하는 “돈\"을 내가 좋아하는 “사랑\"이라는 단어로 대입하여 생각 해본다면. 힘든 이웃을 잊지 말고 도와줄 수 있도록 동기부여를 주는 자상한 아버지이지 않을까, 어쩌면 흔들리는 건 깃발이 아니라 판단하는 내 마음 아닐까? ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:3:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"4. 질문 및 토의 사항 부모는 자식의 어떤 모습에서, 가장 감사함을 느낄까? ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:4:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"5. 작은 실천 계획 내 양심에 선한 기업에 투자하자. 만약 벌었으면 들이 쉰 만큼, 양심에 맞게 뱉자. ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:5:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"6. 자유 감상문 이 책이 불편해서 띄엄띄엄 세번 읽었습니다. 아마 제 안에 권위에 반발하려는 마음과 관련되어 있어 보입니다. 처음읽었을 때: 소유욕에 눈빛이 번들번들한 노인 처음 읽었을 때는 욕심 가득한 할아버지의 모습을 한 짐 로저스를 보며, 잔뜩 화가나 내가 빌려온 지식들로 할 수 있는 최대한의 멋지고 원색적인 비판을 적었습니다. 그래서 지금 “내 아이들에게 주는 선물\"에는 마치 청소년 시절 제가 부모님을 평가했듯 온갖 분노와 욕설이 가득합니다. 스크루지 영감을 떠올리며, 딸들도 돈도 계속 소유하려하는 욕심 많은 노인으로 보며 분노의 감정을 쏟아낸 글들 이하 생략. (첫번째 성찰 일부) 두번째 성찰: 아버지로 보여주는 신의 조각 그렇게 책을 잊은채로 짬짬이 홍익학당의 윤홍식 선생님의 영상을 보며 양심을 들었습니다. 그리고 다시 책을 보니 또 잔뜩 오바해서 빌려온 성인들의 멋진말로 로저스를 평가해놨고, 그 감정에 취해 많이 울었습니다. 그러다 아빠와 엄마에게 고맙다는 마음을 전하고 싶어, 자발적으로 교회를 나가 멋진말들 중 일부를 빌려주신 예수님에게 감사를 전했습니다. 사실 이 글을 쓰는 지금 최대한 담담하게 적고 있지만 두번째 시점에서의 평가글을 보면 또 오버 했습니다. 나는 짐로저스 만큼 행동했는가? 할렘 가봤는가? 못 가보았다. 자식을 사랑하는 마음으로 위험에 대한 자유를 그리고 사랑의 마음으로 221p에 달하는 경험을 명상하고 성찰한 자신의 자명함으로 줄 수 있는가? 당장 나는 주식만해도 내가 사랑으로 투자한 회사를 믿어주지도 못하면서, 즉 행동하지도 못하면서 바리세인마냥 떠들고 있다. 위선자. (두번째 성찰 일부) 자명할 때만 투자하라. 즉 빌려온 지식들로 선한 것 마냥 유세 떨지말자. 나는 분리하지 않고 더 사랑하고 행할 것이다. 욕심 많은 할아버지로 보이던 짐 로저스는 나에게 부모님, 권위, 신, 돈에 대한 순종과 절제를 알려주는 참 스승이다. 탐욕과 욕심으로 번들번들하는 눈을 가진 내가 알아차리지 못했을 뿐. 이 말을 쓰면서도 이 정도면 멋있는 글이 나오겠지? 칭찬 받겠지? 라고 생각하는 내가 참 안쓰럽다. 그럼에도 판단할 수 있는 사랑을 주심에 감사합니다. (두번째 성찰 일부) 세번째: 순종을 알려준 적당히 욕심 많은 아버지 지금 독후감을 쓰기 위해 다시 돌아보니 이제 짐 로저스는 적당히 욕심 많은 아버지로 보입니다. 저는 제가 딱 경험한 만큼만 알 수 있는 것 같습니다. 저는 짐 로저스로 부터 권위에 대한 순종을 배웠으며, 이를 통해 부모님에게 감사한 마음을 느꼈습니다. 그 안에서 발견한 적당한 아름다움에 맞게 돈을 바라보겠습니다. 아버지가 성실함으로 어린 나를 지켜주셨고, 어머니가 젊음을 바쳐 나를 안아주셨습니다. 그 분들이 내가 태어났을 때 따뜻하게 바라봐주셨으니, 그걸 내가 이해한 만큼만 세상을 향해 따뜻하게 웃을 수 있습니다. 부모님 또한 할아버지/할머니의 불완전한 아들/딸로서 미숙한 부모님으로 헌신 하였으니, 저도 주변 사람들의 미숙한 아버지가 되어 딱 적당히 조화로울 수 있도록 따뜻하겠습니다. 내가 들이쉰 만큼만, 뱉어 내겠습니다. by (세번째 기도) ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:6:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["dev"],"content":"홍정모의 따라하며 배우는 C++","date":"2022-10-01","objectID":"/hong_modern_cpp/","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":" Modern c++을 학습하고 기억할만한 요소들을 정리합니다. 1. Terminology ","date":"2022-10-01","objectID":"/hong_modern_cpp/:0:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"0. Terminology 1.0.1. Basic C++ prototype forward declaration header guards (=include guards) 중복될 경우 한번만 include해라 (#pragma once) #pragma once 기 정의된 preprocessor의 일종 macro conditional compilation macro의 #ifdef, #ifndef, #else, #endif fundamental data types (=primitivate data types) auto는 데이터 타입을 자동으로 컴파일 타임에 찾아준다. 1.0.2. Variable and Fundamental types initialization copy initialization int a = 3; direct initialization int a(3); uniform initialization int a{ 3 }; c.f) Most vexing parse: syntax가 일관성이 없어서, uniform initialization이 도입됨. (C++ 11) Fixed-width Integers scientific notation inf: infinite nan: not a number ind: indeterminate literal constants symbolic constants constexpr(c++ 11): 컴파일 타임에 값이 완전히 결정되는 상수 const: 컴파일 타임 / 런타임에 값이 결정되는 모든 상수. (constexpr 포함) 1.0.3. Variable Scope and Extra types Scoped Enumerations (Enum Class) type aliases typedef using struct member selection operator = . memory padding 최적화를 위해서 member들의 순서를 고려해야 한다. (e.g short type 2byte는 2바이트가 뒤에 padding된다.) 1.0.4. Matrix, String, Pointer, Reference nullptr(null pointer) void pointer == generic pointer reference variable :: : scope resolution operator ","date":"2022-10-01","objectID":"/hong_modern_cpp/:1:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"1. Basic C++ namespace using namespace namespace끼리 nested하게 사용가능하다. Macro (preprocessor) Build 타임전, 즉 컴파일 타임에 처리된다. (preprocessor) #ifdef, #ifndef 다음과 같은 경우는 multi platform 즉 여러 os 타입에 따라서 build를 다르게 해주고 싶을 떄, 사용한다. 혹은 gpu 버전에 따라서 버저닝 하고 싶을 때 사용한다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:2:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"2. Basic types Void type void 자체는 메모리가 할당되지 않기 때문에 선언이 불가하다. void my_void; // (x) 하지만 void의 포인터 타입은 메모리 address가 있기 때문에 선언이 가능하다. void *my_void; // (o) int i = 123; float f = 123.456f; my_void = (void*)\u0026i; my_void = (void*)\u0026f; 또한 모든 포인터 address의 사이즈는 같기 때문에 int, float, void 타입 상관없이 동일한 변수에 assign이 가능하다. (void*) void pointer type \u0026i, \u0026f: int와 float 변수의 address 값 Char type casting style // c-style casting cout \u003c\u003c (char)65 \u003c\u003c endl; cout \u003c\u003c (int)'A' \u003c\u003c endl; // c++ style casting cout \u003c\u003c char(65) \u003c\u003c endl; cout \u003c\u003c int('A') \u003c\u003c endl; static cast cout \u003c\u003c static_cast\u003cchar\u003e(65) \u003c\u003c endl; cout \u003c\u003c static_cast\u003cint\u003e('A') \u003c\u003c endl; static_cast의 경우, 명시적으로 type을 변경해주고 싶을 때, compile 타임에 형변환에 대한 타입 오류를 잡아주고 싶을 때 사용합니다. string buffer string operator는 buffer에 임시로 저장되기 떄문에, cin으로 받아들인 값의 경우 cout을 하지 않더라도 buffer에 임시로 보관되어집니다. char c1; cin \u003e\u003e c1; cout \u003c\u003c static_cast\u003cint\u003e(c1) \u003c\u003c endl; cin \u003e\u003e c1; cout \u003c\u003c static_cast\u003cint\u003e(c1) \u003c\u003c endl; $ abc 97 98 \\n vs endl vs std::flush \\n: new line하라. endl: buffer에 있는 모든 것들을 출력한 뒤, new line하라. std::flush: 줄바꿈 없이 buffer에 있는 것들을 모두 쏟아내라. Literal constants 리터럴 상수 unsigned int n = 5u; long n2 = 5L; double d = 6.0e-10; decimal, ocatal, hexa int x = 012; // 8진수 cout \u003c\u003c x \u003c\u003c endl; // 10 int y = 0xF; // 16진수 cout \u003c\u003c y\u003c\u003c endl; // 15 c++14 이후 부터 binary literal이 가능해졌다. 또한 literal 사이에 quota(')를 넣어주게 되면 '를 무시해주기 떄문에, 편하게 구분이 가능하게 되었다. int x = 0b1010; cout \u003c\u003c x \u003c\u003c endl; // 10 int x = 0b1010'1111'1010; // with quota cout \u003c\u003c x \u003c\u003c endl; // 10 Symbolic Constants C++ 11 constexpr // Both is allowed const double gravity { 9.8 }; double const gravity2 { 9.8 }; cout \u003c\u003c gravity \u003c\u003c endl; const는 보통은 앞에 붙인다. pointer ref를 배우게 되면 const의 순서에 따라서 의미상 차이를 가지게 된다. runtime constants (\u003c-\u003e compile time constants) const int compile_time_const(123); // compile time int num; cin \u003e\u003e num; const int runtime_const(num); // runtime c++ 11 부터는 runtime const와 compile-time const를 구분해주기 위해서 constexpr이 도입되었다. constexpr: 컴파일 타임에 initialize되는 상수를 뜻함 constexpr int compile_time_const(123); // compile time int num; cin \u003e\u003e num; const int runtime_const(num); // runtime 또한 constatns들은 일반적으로 하나의 파일에 몰아서 사용한다. MY_CONSTANTS.h #pragma once namespace constants { constexpr double pi(3.141592); constexpr double avogadro(6.22123e23); constexpr double gravity(9.8); } #include \u003ciostream\u003e#include \"MY_CONSTANTS.h\" using namespace std; int main() { cout \u003c\u003c int(constants::pi) \u003c\u003c endl; return 0; } ","date":"2022-10-01","objectID":"/hong_modern_cpp/:3:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"4. Variable variable scope using namespace std; int main() { const int apple = 5; { cout \u003c\u003c apple \u003c\u003c endl; // 5 int apple = 1; cout \u003c\u003c apple \u003c\u003c endl; // 1 } cout \u003c\u003c apple \u003c\u003c endl; // 5 return 0; } const를 사용하더라도 중괄호 안에서 변수는 새롭게 할당되기 때문에 할당이 가능하다. Global variable cout \u003c\u003c ::value \u003c\u003c endl; Static variable Internal Linkage: static int g_x; External Linkage int g_x; extern int g_x; extern const int g_x; Static variable in a Function os로 부터 메모리를 빌려와서, program lifetime 동안 재사용된다. 선언된 scope 블록 안에 제한된다. 즉 scope를 벗어난 공간에서, 해당 variable을 참조할 수 없다.( Global과의 차이) It gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of variable in the previous call gets carried through the next function call. #include \u003ciostream\u003e using namespace std; void doSomething() { static int a = 1; // It is called only once. ++a; cout \u003c\u003c a \u003c\u003c endl; } int main() { doSomething(); // 2 doSomething(); // 3 doSomething(); // 4 doSomething(); // 5 return 0; } 디버깅할 때, 함수가 몇번 호출되는지 확인하고 싶을 때 유용하게 사용가능하다. 전역변수 vs Static variable static은 접근 scope안에서만 할당이 가능한데 반하여, 전역변수는 실수로 다른 scope에서 할당을 하게 되면 원치 않은 결과를 만들어낼 수 있다. Linkage local variable은 해당 소스코드(모듈)에서만 사용되므로, linkage 시켜주지 않는다. Extern global // forward declaration extern void doSomething(); extern int a; int main() { ... } 참고로 extern은 생략 가능하다. 상수 메모리 낭비 header 파일에 const를 선언 및 할당까지 한 뒤, 외부 .cpp 파일들에서 이를 include 시키게 되면, 신기하게 모듈별로 const의 주소가 다르게 나온다. 즉, 메모리 낭비가 생긴다. 이를 방지하기 위해서는 header에는 signature를 넣어주고, extern const의 할당은 .cpp파일에서 하게되면 된다. MyConstants.h #pragma once namespace constants { extern const double pi; extern const double avogadro; extern const double gravity; } MyConstants.cpp #include \u003ciostream\u003e namespace constants { extern const double pi(3.141592); extern const double avogadro(6.22123e23); extern const double gravity(9.8); } helloworld.cpp #include \u003ciostream\u003e#include \"CONSTS.h\" using namespace std; void doSomething(); int main() { cout \u003c\u003c int(constants::pi) \u003c\u003c \" \" \u003c\u003c \u0026constants::pi \u003c\u003c endl; // 3 0x104037d70 doSomething(); // 3 0x104037d70 return 0; } helloworld2.cpp #include \u003ciostream\u003e#include \"CONSTS.h\" using namespace std; void doSomething() { cout \u003c\u003c int(constants::pi) \u003c\u003c \" \" \u003c\u003c \u0026constants::pi \u003c\u003c endl; } Using scope를 최대한 작게 가져가는게 좋다. 가능하면 .cpp에서 사용하는 것이 좋다. 전역 사용만큼은 무조건 피해라. namespace a { int dup_int(10); } namespace b { int dup_int(20); } int main() { using namespace std; { using namespace a; cout \u003c\u003c dup_int \u003c\u003c endl; // 10 } { using namespace b; cout \u003c\u003c dup_int \u003c\u003c endl; // 20 } } Auto Type inference 함수의 return type에 대해서도 auto를 사용할 수 있다. auto add(int x, int y) { return x + y; } trailing return type: 친절하게 설명을 위해서 사용 auto add(int x, int y) -\u003e int; auto add(double x, double y) -\u003e double; auto add(int x, int y) -\u003e int { return x + y; } Scoped Enumerations (Enum Class) C++ 11 Enum을 사용할 때, 주의해야할 점은 아래와 같이 index로 비교하게되면 엉뚱한 결과를 만들 수 있게 된다. #include \u003ciostream\u003e int main() { using namespace std; enum Color { RED, BLUE, }; enum Fruit { BANANA, APPLE, }; Color c = RED; Fruit f = BANANA; if (c == f) { cout \u003c\u003c \"True\" \u003c\u003c endl; } return 0; } 이를 방지하기 위해서 c++11 부터는 enum class가 도입되었다. #include \u003ciostream\u003e int main() { using namespace std; enum class Color { RED, BLUE, }; enum class Fruit { BANANA, APPLE, }; Color c = Color::RED; Fruit f = Fruit::BANANA; /* * 다른 타입끼리 비교하기 때문에 * 여기에서 에러가 발생한다. if (c == f) { cout \u003c\u003c \"True\" \u003c\u003c endl; } */ return 0; } Type aliases Type에 편의상 별명을 붙여주는 것 int main() { typedef double distance_t; double my_distance; distance_t home2work; distance_t home2school; return 0; } pair example // before #include \u003ciostream\u003e#include \u003cvector\u003e int main() { using namespace std; vector\u003cpair\u003cstring, int\u003e\u003e pairlist; return 0; } // after #include \u003ciostream\u003e#include \u003cvector\u003e int main() { using namespace std; typedef vector\u003cpair\u003cstring, int\u003e\u003e pairlist_t; // 위의 typedef 대신에 using을 사용할 수도 있다. using pairlist_t = vector\u003cpair\u003cstring, int\u003e\u003e; pairlist_t pairlist1; pairlist_t pairlist2; return 0; } #include \u003ciostream\u003e#include \u003cvector","date":"2022-10-01","objectID":"/hong_modern_cpp/:4:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Function Parameter function parameter #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, bool (*validator)(const int \u0026)) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with using or typedef #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; // typedef bool (*validator_fnc)(const int \u0026); using validator_fnc = bool (*)(const int \u0026); bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with std::function and default parameter #include \u003ciostream\u003e#include \u003carray\u003e#include \u003cfunctional\u003e using namespace std; using validator_fnc = function\u003cbool(const int \u0026)\u003e; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator = isEven) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } 매우 파이썬스럽게, 가장 깔끔해 보인다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:5:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"3. Matrix double pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int **matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[r][c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int **matrix = new int *[row]; for (int r = 0; r \u003c row; ++r) matrix[r] = new int[col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[r][c] = values[r][c]; printMatrix(matrix, row, col); // delete for (int r = 0; r \u003c row; ++r) delete[] matrix[r]; delete[] matrix; return 0; } single pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int *matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[(col * r) + c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int *matrix = new int[row * col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[(col * r) + c] = values[r][c]; printMatrix(matrix, row, col); // delete delete[] matrix; return 0; } ","date":"2022-10-01","objectID":"/hong_modern_cpp/:6:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Pointer ","date":"2022-10-01","objectID":"/hong_modern_cpp/:7:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Pointer and Const { using namespace std; const int value = 6; const int new_value = 7; const int *ptr_1 = \u0026value; // 6 0x7ffeefb45158 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; // *ptr_1 = new_value; (x) ptr_1 = \u0026new_value; // 7 0x7ffeefb45154 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; } const int를 가리키고 있는 mutable한 포인터를 의미한다. 포인터가 가리키는 값이 const int이기 때문에 dereference해서 값을 바꿀 수 없다. 하지만 포인터 그 자체는 const하지 않기 때문에 새로운 주소값을 넣을 수 있다. { using namespace std; int value = 6; int new_value = 7; int *const ptr_value = \u0026value; // 6 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; *ptr_value = new_value; // ptr_value = \u0026new_value; (x) // 7 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } int를 가리키는 *const 포인터. 포인터는 const이기 때문에 assign이 불가하지만, 포인터가 가리키는 값은 const하지 않기 때문에 변경 가능하다. 즉 포인터를 dereference(*)해서 값 대입 가능하다. c.f) int \u0026ref(레퍼런스)와 int *const ptr는 기능이 같다. { using namespace std; int value = 6; int new_value = 7; const int *ptr_value = \u0026value; // 6 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; value = new_value; // 7 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; // *ptr_value = new_value; (x) ptr_value = \u0026new_value; // 7 0x7ffee6efb154 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } 가리키는 값이 const한 int인 포인터. value 자체는 const가 아니기 때문에 assign 가능하다. value가 const가 아니지만, 포인터는 값을 const하게 처리하기 때문에 dereference가 불가능하다. 포인터 자체는 const하지 않기 때문에 주소 할당이 가능하다. { using namespace std; const int value = 6; const int new_value = 7; const int *const ptr_value = \u0026value; // ptr_value = \u0026new_value; (x) // *ptr_value = new_value; (x) } const int를 가리키는 *const 포인터. pointer value assign과 dereference를 통한 assign 둘 모두 불가하다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:7:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5. Reference ","date":"2022-10-01","objectID":"/hong_modern_cpp/:8:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5.1. Reference and Const reference variable은 변수의 별명이다. (주소, 값 모두 같다.) 파라미터로 넘겨줄 경우, 다른 함수에서 변수를 변경가능하다. #include \u003ciostream\u003e void doSomething(const int value, const int \u0026ref) { using namespace std; cout \u003c\u003c value \u003c\u003c ' ' \u003c\u003c \u0026value \u003c\u003c ' ' \u003c\u003c ref \u003c\u003c ' ' \u003c\u003c \u0026ref \u003c\u003c endl; } int main() { int a = 5; // 5 0x7ffeeaf4e158 doSomething(a, a); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e158 doSomething(a, 5); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e154 return 0; } 파라미터에 변수로 받는 것과, reference로 받는 것은 무슨 차이가 있을까? 파라미터를 변수로 받으면 value copy가 일어난다. (비효율) 반면 reference를 사용한다면 실제 원래 변수와 같은 주소를 가지게 된다. 또한 const int \u0026ref처럼 const reference를 사용한다면 immutable하면서도 reference로 파라미터를 받아 효율을 추구할 수 있다. literal의 주소를 기억할 수 없기 때문에, reference variable 대입에는 lvalue가 들어가야 하지만, const reference타입은 literal을 받을 수 있다. (이 경우 literal을 위한 주소가 할당 된다.) ","date":"2022-10-01","objectID":"/hong_modern_cpp/:8:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"Compare cpp and carbon with each language's base principles.","date":"2022-09-28","objectID":"/cpp/","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"Let’s deep dive into c++ and Carbon ","date":"2022-09-28","objectID":"/cpp/:0:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"tl;dr About main refs C++ Core Guideline C++ reference C++ FAQ ","date":"2022-09-28","objectID":"/cpp/:1:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"1. Principles ","date":"2022-09-28","objectID":"/cpp/:2:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"2. Compile and Linker https://en.cppreference.com/w/cpp/language/translation_phases https://en.cppreference.com/w/cpp/preprocessor ","date":"2022-09-28","objectID":"/cpp/:3:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"3. Why not C++? References Carbon README.md Difficulties improving C++ Carbon vs C++ Generics Memory Safety Carbon’s Principles Errors are values: recoverable Information accumulation: with forward declarations used to introduce names beforethey are first referenced when necessary. Low context sensitivity: 코드를 읽고 이해하는 데 필요한 컨텍스트의 양을 충분히 효과적으로 줄이기 위해쓰기뿐만 아니라 읽기에도 이점이 있는 간결함을 기꺼이 희생하겠다. Prefer providing only one way to do a given thing Safety strategy Memory safety Type safety Data race safety One static open extennsion mechanism Success criteria Difficulties improving C++ Carbon team failed to meaningfully change C++’s direction and priorities towards improvements rather than backwards compatibility, and demonstrates how the process can fail to make directional decisions. C++’s process is oriented around standardization rather than design ","date":"2022-09-28","objectID":"/cpp/:4:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["book","money","mind"],"content":"거래의 신 혼마, 주식시장의 캔들차트와 사께다 전법의 창시자를 읽고 ","date":"2022-09-14","objectID":"/honma-munehisa/:0:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"tl;dr 도서명: 거래의 신 혼마 읽은 기간: 3d (2022.09.13 - 2022.09.15) ","date":"2022-09-14","objectID":"/honma-munehisa/:1:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q: “혼마는 어떤 철학을 가지고 투자하였는가?” A: 원칙을 가지고 인내하고 용감해지며, 지혜로 원칙을 세운다. ","date":"2022-09-14","objectID":"/honma-munehisa/:2:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 혼마는 쌀(상업)을 사랑했고 이를 통해 자연과 자신을 보았다. 나는 만류귀종이라는 말을 참 좋아하는데, 자신의 전문분야를 통해서 세상을 해석하는 모습을 보면서, 나도 개발에 대한 철학을 자연에 빗대어 표현할 수 있는 수준까지 올리고 싶다고 생각했다. ","date":"2022-09-14","objectID":"/honma-munehisa/:3:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"3. 저자의 주장에 대한 나의 생각 “심오한 것은 천정 바닥의 순서를 심득하고, 매일의 시세에 주의하는 것이 원칙이다.” 혼마와 달리 나는 전업 투자자가 아니다. 매일 시세에 주의를 기울일 수 없을 뿐더러 재미없기 때문에 그렇게 하고 싶지도 않다. 그저 내가 관심있는 기술과 비전을 가진 기업에 투자하고 맘 편하게 있으면 안되는 걸까? ","date":"2022-09-14","objectID":"/honma-munehisa/:4:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"4. 질문 및 토의 사항 4-1. 원칙은 불변해야 하는가? 어느 주기로 원칙을 업데이트 해야할까? 나는 투자에 대해서 지식이 혼마, 워렌버핏 같은 인물들에 비해 훨씬 떨어진다. 그러니 내 원칙은 그들의 원칙에 비해 지혜롭지 못할 수 있다. 앞으로도 내 분석은 계속 더 지혜로워 질 것인데, 이미 투자를 하고 있다면 언젠가 과거가 될 내가 만든 원칙과 분석을 “인내\"라는 이름으로 계속 가지고 있어야 할까? 아니면 “용기\"있게 변경해야 할까? 만약 변경해야 한다면 그 주기를 어느 주기로 수정해야 할까? “한번 매입하면 원칙을 가지고 인내하면서 주변에 흔들리지 말고 매수하지 말아야 한다\"라는데, 누구나 그렇듯 그 원칙이라는 것은 죽을 때까지 완성되지 않을 것 같기 때문이다. 4-2. 혼마의 쌀 투자에 대한 디테일들은 오늘날 투자에서 어떻게 적용해야 할까? “쌀 가격이 점점 하락하여 상승 시세로 바뀜없이 각처 모두 최상의 가격물이 수없이 나와 있다는 풍문이며, 분위기도 모두 약하고, 얼마나 하락할지 모르며, 자신이 생각해도 약세장이라 생각할 때 마음을 돌려 매입할 것이다. 이렇게 함은 바닷속에 뛰어드는 심정으로 좀처럼 성공할 수 없을 것 같지만 그때 의심하지 않고 매입해야 하며, 반드시 이운이 된다. 하락한다고 전망될 때 생각한 대로 하락한다면 마음 편할지 모르지만 분위기가 하락한다고 방치할 때 오히려 상승하므로 생각이 따라가지 못하게 된다. 상승도 마찬가지로 즉 바닷속에 뛰어드는 심정이 비결이다. -혼마-” 쌀은 필수재이다. 그러므로 주식과는 성격이 조금 다르다. 일례로 쌀 가격은 상장폐지 할 수 없다. 그러므로 혼마의 투자법은 어쩌면 확실한 BM이 있어서 언론의 주목을 받을 수 있는 기업 또는 이미 주목 받고 있는 대기업에 통하는 투자법인 것 같다. ","date":"2022-09-14","objectID":"/honma-munehisa/:5:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"5. 작은 실천 계획 중요한 결정은 3일간 고민해보고, 매도/매수 타이밍 또한 삼법을 기억해보자! ","date":"2022-09-14","objectID":"/honma-munehisa/:6:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"6. 자유 감상문 500자 이상 혼마는 3을 좋아하는 것 같기 때문에, 내가 느낀 것을 3가지로 정리해보았다. 사랑 혼마는 쌀을 통해 세상을 보았다. 이럴 수 있었던 것은 그가 쌀(상업)을 사랑했기 때문이라 생각한다. 어쩌면 이 덕분에 기다릴 줄아는 인내와 자연의 지혜를 얻은 것이 아닐까? 지금까지 나는 투자를 돈 벌이 수단으로 보았다. 사랑이 빠져있다. 물론 지금껏 내가 관심있는 기술을 다루는 회사들에 투자를 했지만, 여전히 근본은 투자를 사랑없이 돈 벌이 수단으로 보아왔다. 투자 또한 가슴 뛰게 해야겠다, 그렇게 되면 혼마 같이 인내할 수 있지 않을까. 하지만 사실 여전히 데이터나 수치들은 사랑스럽지 않게 느껴진다. 그래도 공부를 해야겠지.. 낭만 혼마의 상업 지혜는 부지런함이 근본으로 들어있다. 책의 느낌만 보면 혼마라는 인물에서 술을 마신다거나, 넷플릭스를 본다던가 하는 여유가 느껴지지 않는다. 그러다 보니 내가 느끼기에는 예수, 오쇼나 사이토 히토리에 비해 사랑이 덜하다는 느낌이 있다. 어쩌면 인내와 부지런함을 강조하는 느낌을 주는 사람들을 내가 싫어해서 일지도 모른다, 사랑과 열정이 먼저이고 인내와 부지런함은 수단일뿐 자연스럽게 따라오는 것인데, 혼마의 투자 원칙들에는 감정이 빠져 있어서 그런가? 그렇다면 투자에는 낭만과 인간적인 감정이 무조건 빠져야 하는걸까? 다시 생각해보니 이렇게 느껴지는 근본적인 이유는 어쩌면 혼마가 왜 쌀(상업)을 사랑하고 그 어마어마한 이윤을 얻었는지에 대한 동기가 책에 빠져 있어서 그런 것 같다. 문득 궁금해진다, 혼마는 그 많은 돈을 왜 벌었는지 왜 그렇게 까지 열심히 상업을 했는지에 대한 근본적인 이유가 말이다. 고집 나는 지금까지 직감에 의존해서 투자를 했으며, 투자에 대한 지식이 거의 없을 정도로 잘 모른다. 나는 직감을 사랑하지만, 투자에 있어서 혼마의 지혜는 나와 비할바가 아닌, 선생님임에도 불구하고 약간 비판적으로 읽고 있는 내 모습을 보면서 에고(고집)를 느꼈다는 점이 반성된다. ","date":"2022-09-14","objectID":"/honma-munehisa/:7:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":[""],"content":"The warm words of the wise rich old-man Saito Hitori ","date":"2022-09-10","objectID":"/hitori-saito/:0:0","tags":["dev"],"title":"Hitori Saito","uri":"/hitori-saito/"},{"categories":[""],"content":"나는 분명 성공한다. 부자의 행동습관 82p 지금 일을 찾고 있는 사람, 어떤 일을 시작하려는 사람이라면 잘 들어보세요. 그 일이 사업이든, 취업이든, 시험이든 상관없습니다. 지금부터 돈 이야기를 할 텐데, 뭔가 다른 얘길 기대했다면 미안합니다. 그래도 돈에 관한 예시가 알기 쉬우니까요. 예컨대 ‘저금통장에 1억이 있으면 좋겠다.‘고 가정해 봅시다. 그러면 우선 해야 할 일은 ‘나는 1억을 반드시 모을 수 있어.‘라고 확신하는 것입니다. 스스로에게 확신이 없으면 목표를 이룰 수 없습니다. 이는 10억의 경우도 마찬가지입니다. 확신을 가졌다면 자문해 보세요. ‘저금 통장에 모인 1억을 정말 상상할 수 있어?‘라고요. 상상할 수 있다면 다음으로는 1억을 모을 수 있는 행동을 취해야 합니다. 행동하지 않고서 돈을 버는 건 불가능하니까요. 가령 1억을 모으기 위해 메밀국수 가게를 열기로 했다면, 우선은 남의 밑에서 일을 배우러 가야겠지요? 1억을 10층짜리 건물이라고 치면, 가장 먼저 해야 할 일은 ‘1층 만들기’라고 생각하는 사람도 있습니다. 그러나 사실은 1층이 아닌 기초부터 만들어 나가야 합니다. 즉, 건물을 세우려면 우선은 땅에 구덩이를 파야 한다는 말이지요. 메밀국수 가게 하나를 열 때라도, 우선은 남의 밑에서 일을 배우는 기초공사에 해당하는 행동이 필요합니다. 만약 모으려 하는 돈이 10억이고, 이를 100층짜리 건물이라고 가정하면 지하 깊숙이 까마득한 곳까지 파야합니다. 다시 말해, 세우고자 하는 건물이 높으면 높을수록 깊은 구덩이를 파야 합니다. 그러니 일단은 행동하지 않으면 안됩니다. 1억을 모으고 싶은데 방법을 모르겠다면, 당장 저금통을 사 와서 하루에 1,000원씩이라도 저금하세요. 월급 중 10만원씩이라도 저금하는 등 생각을 행동으로 바로 옮기다 보면, 점점 좋은 아이디어가 떠오르게 됩니다. 즉 꿈은 목적지를 향해 가는 여정을 즐기며 행동하면 이뤄지기 마련입니다. 어떤 사람이 제게 일본 납세액 1위에 오른 이유는 불로소득 덕분이 아니냐고 묻습니다. 하지만 저는 불로소득을 얻는 방법 같은 건 궁리하지도 않습니다. 게다가 일본 납세액 1위도 불로소득을 통해 달성하지 않았습니다. 저는 열심히 일을 해서 납세액 1위에 올랐기 때문에 일을 해서 돈을 버는 방법밖에 모르며, 또 그 방법밖에 가르쳐 줄 수 없습니다. 불로소득을 얻는 방법은 재산을 그렇게 모은 사람한테 물어봐 주세요. 분명 그 사람에게도 나름대로의 방법이 있을 테니까요. 그러나 저는 사업가이므로 사업으로 돈을 버는 방법밖에 알려줄 수 없습니다. 따라서 제 방법으로 행동하면 분명히 성공합니다. 스파게티 가게든 뭐든 확실히 성공합니다. 성공한다고 믿으니 행동할 수 있습니다. 아무리 쉬운 일도 단번에 성공할 수는 없겠지요? 하지만 연습을 되풀이하면 결국은 성공하게 됩니다. 이처럼 몇 번이고 실패하더라도 ‘나는 분명 성공한다!’ 라는 확신이 있다면, 잘못된 점을 거듭 개선해 가며 성공을 향해 한 걸음씩 나아갈 수 있습니다. 개선하고, 개선하고 또 개선할 수 있는 이유는 나는 틀림없이 성공하리라는 확신이 있기 때문입니다. 운도 마찬가지입니다. 스스로를 운이 좋은 사람이라고 생각하면 행동할 수 있습니다. 그러니 확신을 가지고 미래에 성공한 자신의 모습을 상상해 보세요. 그리고 행동하세요. 행동하는 도중에 산이 있어서 방해된다면, 생각만 하지 말고 삽을 가져와서 조금씩이라도 산을 파내세요. 전력을 다해 파다 보면 여러 가지 아이디어와 지혜가 떠오릅니다. 행동이 뒤따르지 않는 소원은 진짜 소원이 아닙니다. 자기도 모르게 행동을 하고 싶어지고, 실제로 행동하게 되어야 합니다. 이 이야기는 100번 반복해서 읽어주세요. 100번 읽으면 제 뜻을 분명 아실 테니까요. 이상입니다. by Hitori Saito- ","date":"2022-09-10","objectID":"/hitori-saito/:1:0","tags":["dev"],"title":"Hitori Saito","uri":"/hitori-saito/"},{"categories":["life","book","heart"],"content":" Whatever thy hand finds to do, do it with all thy heart by Jesus ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:0:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH00 이 챕터에서는 저자가 유망한 로스쿨 입학하여, 공부하다 갑자기 학교를 그만두고 전세계로 유명 인사들을 만나서 이야기 나눈 여정과 그 도전을 하기까지의 동기부여를 말하고 있다. I had begun thinking: What did I really want from life? What was my goal? I felt I’d lost my way and I was worried about my future. It’s fine to ask yourself what you want from life, but a far more important question is, What does life want from you? … it’s important to allow moments of silence into your life, because silence can let you escape the mental noise that we call “thinking.” I also didn’t want to disappoint my parents, who had been proud of my academic success and career choice. ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:1:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH01 The way is not in the sky. The way is in the heart by Buddha Whatever thy hand finds to do, do it with all thy heart by Jesus Abide at the center of your being, for the more you leave it, the less you learn. Search your heart-the way to do is to be. by Laozi The higher order of logic and understanding originates in your heart. It is experienced in your heart. It is lived in your heart. by Gary zukav We think of the heart in the poetic sense, the seat of love and compassion and it’s this heart that is so terribly important. by Jane goodall ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:2:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH02 파울로 코엘료가 어린시절 내향적이고 고집스러운 아이로 보여서 부모님에 의해 정신병원에 보내졌고, 20대에는 저자와 마찬가지로 law school에 입학했지만 drop out한 스토리가 나온다. From the moment that I realized that I wanted to be a writter, I said, “It may take ten days, ten years, or twenty years, but I am going to write.” I started by writing songs; I started writing articles for newspapers. I had no choice but to follow the thing that I wanted to do. by Paulo cohelho When you lose touch with your heart, you lose touch with your true self. You may feel unmoored and aimless; the world around you seems colorless, dull, and bleak. You cannot remember where you are going with your life. But as soon as you reconnect with your heart, eveything begins to improve. You are never truly lost when you know your heart. ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:3:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":[""],"content":"In this article, I’ll describe the cheapest way to deploy server with GCP in a side project ","date":"2022-07-09","objectID":"/gcp_build/:0:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"tl;dr Deploy API server with Cloud run Deploy DB server with Cloud SQL Build CI/CD pipeline with github action and Cloub build ","date":"2022-07-09","objectID":"/gcp_build/:1:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Deploy MySQL Database server with Cloud SQL in Google cloud platform Cloud SQL meta At first fill in your database meta data. Set instance id Set databse password MySQL version Region (taiwan) Set single zone The myply mainly serves to korean users, but I selected Taiwan(asia-east1) because of pricing issue. detail price description Cloud SQL Status Select db-f1-micro I set a machine type to Shared core with 1vCPU, 0.614. This spec is called db-f1-micro. It costs $7.665 per month, which is the cheapest spec in cloud sql. If I calculated it in ₩, the currency of the south korea. $7.665 * 1300 = ₩9,964 per month db-f1-micro Based on Official cloud sql docs The db-f1-micro and db-g1-small machine types aren’t included in the Cloud SQL SLA. These machine types are configured to use a shared-core CPU, and are designed to provide low-cost test and development instances only. Don’t use them for production instances. Note: The db-f1-micro and db-g1-small machine types are not included in the Cloud SQL SLA. These machine types are designed to provide low-cost test and development instances only. Do not use them for production instances. Select HDD storage 10GB is the lowest storage size. $0.09 per GB/month * 10GB(min) = ₩1,170 per month Cloud SQL misc.1 Cloud SQL misc.2 Cloud SQL misc.3 So total GCP cloud SQL database server will cost ₩ 11,134($8.56) per month. ","date":"2022-07-09","objectID":"/gcp_build/:2:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Buil CI/CD pipeline with github action and Cloud Build Before deploy cloud run, you should set cloud build to apply continuous integration and continuous deployment(CICD). Link with github repository Enable Cloud Build API (almost free) Enable Container analysis API (free) Install GCP Build plugin to your repository Set your repository to cloud build Select branch to be triggered and Dockerfile locaiton Select branch to be triggered Enter Dockerfile loaction If you have multi phase (e.g. local, sandbox, beta ,prod) it would be useful to set dockerfile name as dockerfile.prod. FROMgolang:1.18-alpine AS builderLABEL maintainer=\"leoo.j \u003cminkj1992@gmail.com\u003e (https://minkj1992.github.io)\"# Move to working directory (/build).WORKDIR/build# Copy and download dependency using go mod.COPY go.mod go.sum ./RUN go mod download# Copy the code into the container.COPY . .# Set necessary environment variables needed for our image and build the API server.ENV CGO_ENABLED=0 GOOS=linux GOARCH=amd64 RUN go build -ldflags=\"-s -w\" -o apiserver ./application/cmd/main.goFROMscratch# Copy binary and config files from /build to root folder of scratch container.COPY --from=builder [\"/build/apiserver\", \"/build/.env\", \"/\"]# Command to run when starting the container.ENTRYPOINT [\"/apiserver\"] ","date":"2022-07-09","objectID":"/gcp_build/:3:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Deploy API server with Cloud run in Google cloud platform Select Continuously deploy new revisions from a source repository. Select region as Taiwan(asia-east1) Select Cpu is only allocated during request processing Set number of instance (Autoscaling) (0 ~ 4) Set Container status Set application server’s port number Set memory 128Mib(lowest) Set Number of vCPUs less than 1. Set Execution environment to First generation (slower than 2nd generation) Connect Cloud SQL instance Click Connections tab \u003e Cloud SQL connections \u003e +Add Connection button Connect Cloud SQL instance 2 ","date":"2022-07-09","objectID":"/gcp_build/:4:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Conclusion Through the steps so far, I have covered the cheapest way to deploy a gcp service for a side project topic. Now if you have followed all the steps so far, go to your github repository and merge it into the main branch. Then the service will deployed according to the Dockerfile you set. ","date":"2022-07-09","objectID":"/gcp_build/:5:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":["gcp"],"content":"사이드 프로젝트를 하면서 GCP로 배포할 때, 서버 비용이 걱정되었다면! ","date":"2022-07-07","objectID":"/gcp_pricing/:0:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"tl;dr 사이드 프로젝트 성격인 서비스에, 대부분의 사용자가 한국인이라고 가정하면 아래와 같이 설정하면 됩니다. Just use Taiwan region for every instance Check cloud run minimum instance number(set 0) Set cloud sql vCPU 1 ","date":"2022-07-07","objectID":"/gcp_pricing/:1:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Intro 2022년 6/25일(현재 날짜 7/7일) GDG 해커톤을 통해 정말 간단한 golang 서버를 배포했었다. 갑자기 문득 궁금한 생각이 들어, cloud console에 가서 금액을 확인해보니,, ₩268,826,, 말이되나? 트래픽 없는 해커톤 서비스가, 약 12일 정도 사용했는데 26만원 찍혔다는건 말도 안된다. 이에 대한 이유를 분석해보고 다음 myply 사이드 프로젝트를 할 떄, 적용해보기 위해서 정리를 해봅니다. 대부분 cloud sql이 잡아먹고 있었다. (원인: vCPU 4인 default instance가 살아있어서) cloud run은 100만건까지는 공짜인줄 알았는데, 500원씩 사용되었다. (원인: min instance count 1로 되어있었다.) ","date":"2022-07-07","objectID":"/gcp_pricing/:2:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"GCP network https://cloud.google.com/vpc/network-pricing Ingress ( users -\u003e instance ) is free egress ( kr -\u003e taiwan $0.05 ) ","date":"2022-07-07","objectID":"/gcp_pricing/:3:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Cloud run https://cloud.google.com/run/pricing Set cpu less than 1, memory 128MiB Check CPU is only allocated during request processing Execution env to set First generation Set autoscaling min number of instances field to 0. (max: 4~5?) cloud run pricing by region, FYI, seoul is 2nd grade. ","date":"2022-07-07","objectID":"/gcp_pricing/:4:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Cloud SQL https://cloud.google.com/sql/pricing Set number of vCPU 1 (4로 설정하면 대략 하루 18,000원) Seoul이 vCPU가격이 다른 region에 비해서 훨씬 높다. -\u003e Select Taiwan Taiwan의 경우 us-central들과 가격 정책이 같다. lowa seoul Data Egress(outboud) pricing Set cloud run region same as cloud sql ","date":"2022-07-07","objectID":"/gcp_pricing/:5:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Conclusion 저와 비슷한 환경에서 사이드 프로젝트를 한다면 cloud run과 cloud sql을 지금까지 분석했던 방식으로 설정하면 될 것 같습니다. 단, 트래픽이 늘어나서 taiwan \u003c-\u003e korea에 대한 이그래스 가격이 합리적이지 못하다고 느낀다면, region을 seoul로 바꾸는 것도 좋아보입니다. 간단하게 계산해보면 18GB(9/0.5)이상의 트래픽이 한달 간 발생한다면, region을 다시 seoul로 바꿔서 서비스해야 할 것 같습니다. 단 트래픽이 늘어나면 sql vCPU도 늘어나야 하기 때문에 다시 계산해야 될 수도 있습니다. (여기서 $9는 cloud sql single vCPU 한달 사용 차액 $9(taiwan - seoul, per vCPU)) 정리하면, youtube의 홈화면(최적화가 잘되어있다는 것도 감안 필요, 또한 스트리밍 시청하게 되면 영상 사이즈로 고려해야 함)은 약 613kb 네트워크 리소스를 사용하며, 이를 18GB만큼 사용하려면 29363.7846656으로 해당 서비스가 약 한달에 3만번 이상 hit를 받는 서비스라고 생각한다면, 네트워크 이그레스를 고려해야 한다. ","date":"2022-07-07","objectID":"/gcp_pricing/:6:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["life"],"content":" Life as travel 🛫 ","date":"2022-07-04","objectID":"/2022_first_half/:0:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"🗒 TL;DR Goal of 2022 2022 visionboard 해외 기업 취업 (영어) 커리어 전환 (robotics or Dao freelance) Hawaii or california 오픈소스 기여 Ros2 or Cosmos or NASA open source or Rust Based project co-project with GF Communicate Youtube Lecture Blog Earn 5억 IoT 프로젝트 제품 판매 Study Refactoring Rust Go Gin Framework grpc / Protobuf Monorepo(Bazel) Arduino IoT core Solidity Web3.0 아침 마다 명상 킥복싱 운전면허 따기 영어 free talking ","date":"2022-07-04","objectID":"/2022_first_half/:1:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"1. 🚸 카카오 퇴사 Step out of my comfort zone 21년 8월 즈음 같이 일하던 블록체인팀이 krust로 분사를 하면서 이직 제안을 받았었고(나를 제외하고 제안받은 모든 사람들은 이직을 하였고 엄청난 레거시들과 함께 혼자 남았다), 이때 부터 진지하게 이직해야지 라는 생각을 가지고 있었지만 번아웃이라는 핑계로 결정을 미루고 있었다. 그러다 보니 열심히는 살았지만 실질적으로 이직에 도움이 되는 어떤 행동들을 취하지 못했었다. 21년 12월 일기 21년 12월 어느날, 문득 회사를 다니다가 퇴사를 하고 싶다는 생각을 하게되었다. 사실 대단하게 생각한 것은 아니고, 평소에 내가 회사 업무에 대해서 얼마나 열정을 가지고 시간을 쓰고 있는지를 생각해보니, 처음 취업을 준비했던 때 만큼 열정적으로 살고 있지 않다고 생각했기 때문이다. 신기하게도 막상 퇴사를 해야겠다고 마음속으로 결정하니, 그 다음 부터는 가슴이 뛰며 새롭게 공부하고 싶은 분야들과 강의들이 눈에 들어왔다. 그렇게 한동안 카카오에서 하고 있는 일정을 바쁘게 진행하면서, 퇴근 후 복싱 그 후 해외 개발 유튜버들이 보여주는 관심있는 기술 스택들을 2배속으로 들으면서 지냈다. 퇴사를 결심하며 그렇게 약 한달 정도 시간을 보내고 부모님과 형에게 내 퇴사에 대한 내 생각을 말했다. 이렇게 1달의 시간이 필요했던 이유는 2가지 인데 그 동안 카카오라는 브랜드 뒤에 숨어서, 나는 잘하는 개발자야 라는 우월의식을 가지고 있었다. 같이 정말 바쁘게 일하고 있는 joel, scott에게 나중에 퇴사하겠다고 말할 걸 생각하니 숨이 턱 막혔다. 생각보다 1번의 마음이 있어서 인지, 카카오를 버린다고 생각하니, 내 실력에 대한 믿음이 흔들렸고 “과연 내가 이직 시장에서 통할까?” “이력서/면접 너무 귀찮다.. 나는 번아웃 상태인걸?” 같은 무섭다는 생각과 귀찮은 마음이 공존했었다. 하지만 이런 생각들 보다, 로보틱스나 web3같은 새 도전을 해보고 싶다는 생각이 더 컸기 때문에 내 의사를 가까운 지인들에게 알리기 시작했다. with father 사실 내 인생은 내 책임이라는 생각이 있기 때문에, 주변 사람들의 지지를 받을 필요는 없다고 생각하지만, 여러 사람들에게 내 의사를 전달하면서, 내가 어떤 것을 원하는지, 이직을 한다면 어떤 이유 때문에 하는 건지가 명확하게 정리가 되었다. Digital card team 그렇게 여러 면담들을 거쳐, 3월3일 카카오에 마지막 출근을 하였다. Bye Kakao ","date":"2022-07-04","objectID":"/2022_first_half/:2:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"2. ✍️ 이직 준비 그리고 합격 Hello My name is … 21년 12월 즘 퇴사 마음이 생겼을 때, 블록체인 TF때 같이 일했던 지인이 로보틱스 회사로 이직했다는 게 기억이 나 오랜만에 연락을 해 근황과 이직한 회사에 대해 알아보았다. 결과적으로 회사가 로보틱스와 영어 경험 둘 모두를 경험할 수 있는 좋은 기회라 생각 되어 그날(강릉 가족여행 중) 바로 이력서를 작성해 지원하였다. 하지만 이 때 당시 심적으로 많이 지쳐있어서, 사실 이직을 하고 싶은지 잘 판단이 서질 않았지만 그래도 퇴사 \u0026 이직준비는 자연스럽게 같이 진행하는 절차인 것 같아, 어느정도 될 건 된다는 마인드로 이력서를 준비했다. (비록 P이지만 plan c까지 준비하긴 했다.) A. Robotics B. Gitcoin freelance C. Canada Master's Degree 그렇게 서류는 통과되었고, 21년 12월 중순에 과제 전형을 시험봤다. ATM 을 만드는 과제 전형이었는데, 준비하면서 command pattern, strategy pattern, transaction 등을 구현해보면서 정말 재미있게 과제를 진행했었다. 그래서인지 면접까지 자연스럽게 진행되었다. 면접은 1/14일에 오전 7시 - 12시까지 총 5명의 면접관들과 면접을 진행하는 방식이었으나, 마지막 영어로 진행되는 CTO와의 면담은 일정 문제로 취소가 되었다. 그래서 총 4시간 면접이 진행되었는데, 온라인으로 진행되었다. 4시간이라는 압박도 있었고, 실리콘 밸리 스타트업이다 보니 기존에 경험한 면접과 다소 다른 방식으로 진행될 것 같아 면접 전까지는 개인적으로 꽤 긴장을 하였지만, 막상 면접관님들을 보니 그렇게 까지 긴장되지는 않았다. 1/14일 일기장 中 어제 너무 가슴이 뛰어서 3시까지 잠을 자지 못했다. 7시에 기상해서 면접을 보았다. 면접관 중 한 분이 과제에서 transaction을 만든 것에 칭찬을 해주셨다. 이후 긍정적인 답변을 얻어, 연봉협상과 이직 날짜를 정하였다. ","date":"2022-07-04","objectID":"/2022_first_half/:3:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"3. 🏠 성수/뚝섬 이사 Be Alone 새로운 회사가 성수에 있기 때문에, 본가(광교)에서 약 1시간 반정도 출퇴근 시간이 필요했다. 이때는 새로운 회사가 재택근무를 허용하지 않는줄 알고, 당연히 자취해야지 생각하고 방을 구했다. First day 부모님과 성수에 5곳정도 방을 보고, 그날 바로 방을 구했다. 창문이 크고, 근처에 카페가 많아서 여기로 정했다. 약 8평 정도 되어서 혼자 살기에도 적당했고, 채광이 좋았다. ","date":"2022-07-04","objectID":"/2022_first_half/:4:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"4. ⚽ 차였다 T can cry 1~2월 즈음 퇴사와 이직을 준비하는 사이, 좋아하는 사람이 생겨서 고백했는데 차였다. 친구로 접근해서 꽤 오랜기간 친해졌는데, 얄짤없었다. 그래도 차이면서 멋있고 싶어서 마지막 톡일 것 같다고 잘지내라고 하며 비운의 영화배우에 빙의되어 멋지게 돌아섰다. 그날 저녁 AJR-100 Bad days를 계속 들으며, 지하 주차장에서 울었다. 형이 미국 떠날 때 이후로 2년 만에 처음 울어본 것 같다. 그렇게 눈물을 흘리고 정확히 3일 뒤에 다시 연락해서 절교하자고 한거 무르기 가능?라고 연락했고 ㅗ라고 답변을 받았다. 그래도 다시 서로 웃으면서 친구하기로 했다. Quote 역시 멜로보단 로멘스 코미디 👍 ","date":"2022-07-04","objectID":"/2022_first_half/:5:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"5. 🐈 ExchangeDiary project Take heart github repo: Exchange Diary 카카오를 퇴사한 뒤, 가장 먼저 계획한 건 7일안에 golang공부 끝내기와 golang을 활용한 프로젝트 만들기 였다. 그렇게 go 공부를 빠르게 한 뒤, 프로젝트에 뛰어들었다. Exchange Diary Flow 생각보다 곳곳에 까다로운 로직들이 있어서 힘들었지만 재밌는 경험이었다. 그리고 무엇보다 업무가 아닌 내 자유의지로 학습하며 프로젝트를 만들면서 자신감도 많이 얻었던 것 같다. What I learned Golang Gin framework Hexagonal architecture pros/cons GCP Goodle Cloud run Cloud Build Cloud Storage Firebase notification Cloud Task Hexagonal 비록 일정이 조금씩 미뤄지고, 나 또한 회사 출근이 다가오게 되어 중간에 하차하였다. 이 프로젝트를 통해 개인적인 깨달음은 다음과 같다. Wisdom 우선순위: 프로젝트의 핵심 BM이 있어야 한다. (잡다하게 많은 feature는 필요없다.) 동기부여: 팀 멤버들이 명확하게 BM과 목표를 공유해야 한다. (1달 지나면 왜 개발해야하는지 목적성을 잃어 버림) 3개월 노력 물거품 방지: 아무리 못해도 운영될 서버 비용 정도는 수익으로 얻는 서비스가 만들어져야 한다. 여러모로 많은 것은 얻은 프로젝트여서 미안한 마음과 고마운 마음이 있다. 🙏 ","date":"2022-07-04","objectID":"/2022_first_half/:6:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"6. 🤖 Bear robotics Hello, New Bear! 실리콘밸리 로보틱스를 스타트업에 이직했다. 구글 출신 개발자분들께서 창업해주셔서 그런지 정말 좋은 개발문화를 가지고 있다고 생각했다. 그 중 크게 2가지를 꼽아보자면 Ownership: FANG처럼 회사에 기획자가 없다. 프론트/백 구분 또한 없다. 이를 통해서 본인이 서비스에서 기여하고 싶은 부분을 찾고, proposal 및 디자인 발표를 한 뒤 성과를 보여주면 된다. 결국은 개인이 회사 뒤에 숨지말고 맞든 틀리든 목소리를 내야한다는 걸 배웠다. 흘러가는데로 사는게 아니라 자기가 주도해야된다는 점에서 인생이랑 비슷하다고 생각했다. English: slack도 영어, code review도 영어, Merge request도 영어, 심지어 회의도 영어.. 나는 정말 운이 좋게 CTO 면접(영어 면접) 없이 회사에 합격했었다. 개인적으로 나는 스피킹이 정말 많이 부족한데, 그래서 해외 팀과 일을 할 때 많이 스트레스를 현재도 받고 있다. 회의에서 개발새발 영어로 말할 때면 개인적으로 많이 쪽팔리고 자존심이 상한다. 보란듯이 이겨내야지 회사에서 링글을 지원해줘서, 이 기회에 영어 스피킹을 만족스럽게 가져갈 예정이다. ","date":"2022-07-04","objectID":"/2022_first_half/:7:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"7. 🇺🇸 친형의 미국 Jika ada pertemuan, juga ada perpisahan Bro 극한직업: 동생 우애 미국에 살고 있는 형은 원래 1년에 한번씩은 한국에 왔었다. 그러다 코로나 때문에 2년 넘도록 만나질 못했는데, 이번년에는 다행히 한국에 올 수 있었다. 약 2달간 형은 한국에 있었는데 그러면서 가족끼리 제주도, 강릉여행을 다녀오며 좋은 시간을 보낼 수 있었다. 형은 중학교 때 약 1~2년 미국에서 살았고, 이후에 한국에 살다가 다시 대학교를 미국으로 다니게 되면서, 성인이 되고 난 뒤 부터는 약 1~2년에 한번씩 만나고 있다. 즉 1~2년에 한번씩 형과 이별을 해야한다. 그럼에도 불구하고 이별을 할때의 기분은 아직도 적응이 되지 않는데, 매번 형을 인천공항에서 떠나보낼 때마다, 이루 말할 수 없는 먹먹함이 몰려와서 개인적으로 많이 슬프다. 이번에도 형과 함께 여행을 다니면서도, 자기전에 문득 “몇일 지나면 형은 다시 없겠네?” 같은 슬픈 생각이 들었다. 형이 미국에 돌아갈 시간이 다가오면 올 수록, 가족원들 모두 말은 하지 않았지만 아련한 기운이 조금씩 느껴졌다. 그렇게 형이 미국가기 약 일주일전? 마냥 수동적으로 다가올 이별을 맞이하는게 아니라, 능동적으로 이별에 대처하고 싶어 가족 톡방에 제안을 했다. Proposal 제목: 민욱이의 제안 Know also that wisdom is sweet to your soul; if you find it, there is a future hope for you, and your hope will not be cut off. (Proverbs 24:14) 시간은 목표가 없으면 정말 빠르게 지나간다고 생각합니다. 제가 돌아 봤을 때 그렇게 지나간 시간들은 그것에 비례해서 정말 크게 후회를 만든다고 생각합니다. 그 만큼 저에게는 목표를 말하고 그걸 공유할 수 있는 자리가 굉장히 중요한데요. 제 나이 31살, 지금 껏 다양한 사람들을 만나봤지만 목표를 말할 수 있었던 관계는 손에 꼽을 정도라고 생각됩니다. 그러다보니 오히려 가까운 관계일 수록, 그게 가족이라면 더욱, 이런 이야기를 하는게 값진 시간일 것이라 생각해요. 그래서 한 가지 제안을 드리고 싶은 것은, 형이 미국으로 가는 시간을 수동적으로 안타까워 하면서 기다리기 보다, 능동적으로 다시 형을 만났을 때 개인적으로 가장 중요하다고 생각되는 비전과 그걸 성취했다고 남들이 말할 수 있는 객관적인 수치 이 2가지를 가족 끼리 공유했으면 좋겠어요. 제가 생각하는 공유 날짜는 6/10일 금요 예배 이후 시간입니다. 가나안 땅에 입성 시 갈렙의 추정나이는 78세(한국나이 80세) 였다고 해요. 개인적인 욕심으로는 갈렙이 “이 산지\"라는 명확한 목표가 있었 듯이, 가족들 모두 평가 받을 수 있는 뚜렷한 목표가 있었으면 좋겠습니다 🙃. 이런 글이 저의 처음이자 마지막 글일 것 같은데요? 아빠, 엄마, 형 모두 동의 한다면 진지하게 비전을 나눠서 진지하게 공유했으면 좋겠습니다. 단, 제가 생각할 때는 “개인(제발 개인)이 도전 할 수 있어야 비전이라고 생각해요, 타인에 대한 비전은 삼가 줬으면 좋겠습니다”. 기도를 하며 감동 오는 부분들을 특히 개인적인 도전들에 대해서 공유할 수 있는 자리 였으면 좋겠습니다. Family vision 나 자유롭게 살고 싶다. 경제적으로 재미있고 새로운 일을 계속 도전하고 경험하여 전문가가 되고 싶다. 사랑하고 싶고 높아지기 위해 사람을 이용하고 싶지 않다. 하고 싶은 일 강의 찍기 로봇틱스 프로젝트: 22.7월부터 별도로 시작 (5억) 매력적인 사람이 되자 금연프로그램 신청 킥복싱대회 출전 샐러드 신청 형 … 엄마 … 아빠 … 분명 가족끼리 꿈을 공유하는 건 어색한 상황이지만, 이번 기회로 가족끼리 목표를 나누고 나니 형을 떠나 보내면서 도리어 열정을 가지고 다음 만남을 기다릴 수 있어서 좋았다. (물론 인천공항에서 이별은 아직도 적응이 되지 않는다. 😢) 아 참고로 나를 제외하고 우리 가족 모두는 크리스찬이다. 그리고 나 또한 기독교인은 아니지만, 성경에서 많은 영감을 받는다. Family TMI 형과 이별을 준비하면서 느낀 감정들을 기념하고 싶어 목걸이를 구매했다. 터키석 목걸이를 찾고 있었는데 구찌 모델중에서 디자인이 과하지 않으면서 눈에 쏙들어오는 모델이 있어, 그날 바로 구매했다. Life as travel ","date":"2022-07-04","objectID":"/2022_first_half/:8:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"8. 🔓 3개월 수습 끝 Self evaluation “I am not satisfied with the MQTT task. But I love my team and bear. I think I am the right person for my position.” by minwook. 나는 MQTT 작업 때문에 매우 낮게 나를 평가했지만, TL이 좋게 나를 평가 해주었다. 감사하다. 추가로 비전에 대해서도 이야기를 나누게 되었는데 개인적으로 도전이 되었다. 과연 나의 비전은 뭘까? 버킷리스트 같은 꿈말고 크리스찬 용어를 빌려오자면, 선한 영향력을 주변에 주는 비전을 가지고 싶다. 참고로 퍼블릭 사운드 의 이 분도 우리팀이다. 많이 도전이 된다. 수습 기간 동안 주로 작업했던 방역로봇 ","date":"2022-07-04","objectID":"/2022_first_half/:9:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"9. 🤔 친한형이 회사를 차렸다. 아는 개발자 형이 1년간 준비를 거쳐, 창업하게 되었다. 현재 퇴사 절차를 진행중인데, 준비 과정을 옆에서 보면서 많은 도전을 받고 있다. 나랑 한살 밖에 차이가 나지 않는데, 개발 실력은 두말할 것 없고 바쁘게 회사를 다니면서도 창업에 필요한 프로토타입들 하나 하나 개발하는게 정말 멋지다고 생각이든다. 그러면서도 야나두?라는 생각이 문득 문득 든다. 만약 내가 열정 없이 시간을 매너리즘에 빠져서 회사를 다니고 있다라고 느끼는 순간이 생긴다면 시간 낭비 말고 창업을 해야겠다고 다짐했다. The greatest developer 고양이 Lumi ","date":"2022-07-04","objectID":"/2022_first_half/:10:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"10. 🌖 Hackaton GDG 2022 summer hackaton Github repo: pitch-backend(부제: dobby’s) GDG에서 주관하는 무박2일 오프라인 해커톤에 참여했다. 해커톤은 마켓컬리 18층 오피스에서 진행되는데, 이상하게 그 전날 잠이 오지 않아서 새벽 3시에 잠에 들어 피곤한 상태로 참가했다. 저녁을 먹고 7~8시가 정말 고비였는데, 팀원들이 아무도 이탈하지 않아서 개인적으로 정말 괴로워하면서 버텼다. 이쁘게 찍어달라고 부탁한 컷 우리팀은 해커톤에서 작업 효율을 주제로 선택했고, 이를 위해서 만든 아이디어는 Task 스퍼트 서비스이다. 한줄 설명으로는 팀원들이 약 1~2시간동안 작업할 task goal을 공유하고, 이때 들을 유튜브 노동요 플레이리스트를 공유하는 서비스이다. Instagram post Service design 다음에는 만약 참가한다면 무박2일이 아니라, 3박4일 해커톤 같은 곳에 나가보고 싶다. (새벽이 되니까, 솔직히 작업 효율이 너무 떨어지는 것 같아서) 그래도 평소에 느끼지 못했던 순수한 열정을 여기에서 많이 느낄 수 있어서 값진 시간이었다. ","date":"2022-07-04","objectID":"/2022_first_half/:11:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"11. 💾 etc 카카오 퇴사하고 붕 뜨는 기간에 전자담배 액상 도매 사업을 친구와 했다. 사이트 디자인 부터, 사업자 등록, 해외 도매처 컨택 및 판매할 상품 선정 등등… 친구와 각각 100씩 투자해서 작게작게 해보자 했는데, 나중 되니까 서로 시간이 너무 없어서 포기했다. 아직도 도매로 구매했던 상품들과 포장 박스들이 친구 자취방에 있다. github: scrapper 타 사이트들의 상품정보 스크래퍼도 개발했었다. 자동 사이트 홍보 cronjob 도 만들었었다. 사이트 로고 5년간 했던 복싱을 그만두고 킥복싱을 시작했다. GYM 88 향수에 재미들렸다. 예전에 찍어둔 사진 빅션 영상 을 봤다. Focus on 👍 ","date":"2022-07-04","objectID":"/2022_first_half/:12:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"🍀 Conclusion: Next step 넥스터즈 youtube api server (recommend songs) Develop more dobby's service IoT 프로젝트 (Arduino) 강의 찍기 Ros2 Open source 기여 Rust 배우기 또는 Golang 더 깊게 공부 “대의”, “선한 영향력”, 베품 같은 나의 소중한 비전을 찾는다. ","date":"2022-07-04","objectID":"/2022_first_half/:13:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["iot"],"content":"MQTT stands for MQ Telemetry Transport but previously was known as Message Queuing Telemetry Transport. ","date":"2022-06-11","objectID":"/mqtt/:0:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["iot"],"content":"tl;dr Lightweight and Efficient Bi-directional Communications This makes for easy broadcasting msgs to groups of things Scale to Millions of Things Reliable Message Delivery(QoS) 0, 1, 2 Support for Unreliable Networks MQTT’s support for persistent sessions reduces the time to reconnect the client with the broker. Security Enabled easy to encrypt msg using TLS also support OAuth ","date":"2022-06-11","objectID":"/mqtt/:1:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["iot"],"content":"MQTT Essentials https://www.hivemq.com/mqtt-essentials/ MQTT stands for MQ Telemetry Transport. The protocol is a set of rules that defines how IoT devices can publish and subscribe to data over the Internet. ","date":"2022-06-11","objectID":"/mqtt/:2:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["dev"],"content":"Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. ","date":"2022-06-01","objectID":"/proto_buf/:0:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"tl;dr What are protocol buffers Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. How do I start? Download and install the protocol buffer compiler. Read the overview . Try the tutorial for your chosen language. (python ) ","date":"2022-06-01","objectID":"/proto_buf/:1:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"overview https://developers.google.com/protocol-buffers/docs/overview protobuf It’s like JSON, except it’s smaller and faster, and it generates native language bindings. Protocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data that is written to a file (or sent across a network connection). These are protobuf’s main components (2) Protoc (compiler) It is for data format compile It compiles .proto files SDK each language support The proto compiler is invoked at build time on .proto files to generate code in various programming languages Each generated class contains simple accessors for each field and methods to serialize and parse the whole structure to and from raw bytes. ","date":"2022-06-01","objectID":"/proto_buf/:2:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"languages The following languages are supported directly in the protocol buffers compiler, protoc: C++ C# Java Kotlin Objective-C PHP Python Ruby The following languages are supported by Google, but the projects’ source code resides in GitHub repositories. The protoc compiler uses plugins for these languages Dart Go for other languages ","date":"2022-06-01","objectID":"/proto_buf/:2:1","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Pros language/platform-neutral (low coupling, microsevice) Compact data storage Fast Parsing (compared to json?) Availability in many programming languages Optimized functionality through automatically-generated classes You can update Proto Definitions without updating code. which refers you can control code(especially data schema) version compatibility. ","date":"2022-06-01","objectID":"/proto_buf/:2:2","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Cons Protocol buffers tend to assume that entire messages can be loaded into memory at once and are not larger than an object graph. For data that exceeds a few megabytes, consider a different solution; when working with larger data, you may effectively end up with several copies of the data due to serialized copies, which can cause surprising spikes in memory usage. When protocol buffers are serialized, the same data can have many different binary serializations. You cannot compare two messages for equality without fully parsing them. Messages are not compressed. While messages can be zipped or gzipped like any other file, special-purpose compression algorithms like the ones used by JPEG and PNG will produce much smaller files for data of the appropriate type. Protocol buffer messages are less than maximally efficient in both size and speed for many scientific and engineering uses that involve large, multi-dimensional arrays of floating point numbers. For these applications, FITS and similar formats have less overhead. Protocol buffers are not well supported in non-object-oriented languages popular in scientific computing, such as Fortran and IDL. Protocol buffer messages don’t inherently self-describe their data, but they have a fully reflective schema that you can use to implement self-description. That is, you cannot fully interpret one without access to its corresponding .proto file. Protocol buffers are not a formal standard of any organization. This makes them unsuitable for use in environments with legal or other requirements to build on top of standards. ","date":"2022-06-01","objectID":"/proto_buf/:2:3","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Flow ","date":"2022-06-01","objectID":"/proto_buf/:2:4","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":".proto definition syntax (3) optionality(field rules) optional repeated Repeated fields are represented as an object that acts like a Python sequence singular(proto3, default, 단수형) required(deprecated) reversed field type message you can nest parts of the definition, such as for repeating sets of data. enum set of values to choose from. oneof which you can use when a message has many optional fields and at most one field will be set at the same time. map field number basic scalar type additional scalar type field number Field numbers cannot be repurposed or reused. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number. from microsoft description 필드 번호는 Protobuf의 중요한 부분입니다. 이진 인코딩된 데이터의 필드를 식별하는 데 사용됩니다. 즉, 서비스 버전에서 버전으로 변경할 수 없습니다. 장점은 이전 버전과의 호환성 및 앞으로 호환성이 가능하다는 것입니다. 클라이언트 및 서비스는 누락된 값의 가능성이 처리되는 한 모르는 필드 번호를 무시합니다. 이진 형식에서 필드 번호는 형식 식별자와 결합됩니다. 1에서 15까지의 필드 번호는 해당 형식으로 단일 바이트로 인코딩할 수 있습니다. 16에서 2,047까지의 숫자는 2바이트를 사용합니다. 어떤 이유로든 메시지에 2,047개 이상의 필드가 필요한 경우 더 높아질 수 있습니다. 필드 번호 1에서 15까지의 싱글 바이트 식별자는 더 나은 성능을 제공하므로 가장 기본적으로 자주 사용되는 필드에 사용해야 합니다. ","date":"2022-06-01","objectID":"/proto_buf/:2:5","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Example This is the status.proto file used by Google. (refs ) // Copyright 2020 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. syntax = \"proto3\";package google.rpc;import \"google/protobuf/any.proto\";option cc_enable_arenas = true;option go_package = \"google.golang.org/genproto/googleapis/rpc/status;status\";option java_multiple_files = true;option java_outer_classname = \"StatusProto\";option java_package = \"com.google.rpc\";option objc_class_prefix = \"RPC\";// The `Status` type defines a logical error model that is suitable for // different programming environments, including REST APIs and RPC APIs. It is // used by [gRPC](https://github.com/grpc). Each `Status` message contains // three pieces of data: error code, error message, and error details. // // You can find out more about this error model and how to work with it in the // [API Design Guide](https://cloud.google.com/apis/design/errors). message Status { // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]. int32 code = 1; // A developer-facing error message, which should be in English. Any // user-facing error message should be localized and sent in the // [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client. string message = 2; // A list of messages that carry the error details. There is a common set of // message types for APIs to use. repeated google.protobuf.Any details = 3;} ","date":"2022-06-01","objectID":"/proto_buf/:2:6","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"protobuf: python https://developers.google.com/protocol-buffers/docs/reference/python-generated#invocation ","date":"2022-06-01","objectID":"/proto_buf/:2:7","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"protobuf vs … protobuf(grpc) vs thrift grpc vs thrift protobuf(grpc) vs graphql https://github.com/google/rejoiner 구글에서 graphql과 호환 lib 오픈소스화 시킴. https://medium.com/@lvdbrink/graphql-meets-protocol-buffers-in-go-cdbf11090934 ","date":"2022-06-01","objectID":"/proto_buf/:2:8","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"refs protobuf github ","date":"2022-06-01","objectID":"/proto_buf/:2:9","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["arduino"],"content":"Learn arduino with Arduino Step by Step: Getting Started by Dr. Peter Dalmaris lecture. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:0:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"tl;dr Build simple circuits around the Arduino Uno, that implement simple functions. Understand what is the Arduino. Understand analog and digital inputs and outputs Use the multimeter to measure voltage, current, resistance and continuity be productive with the Arduino IDE, write, compile and upload sketches, install libraries Detect and measure visible light, color, and ultraviolet light Measure the distance between the sensor and an object in front of it Detect a noise Display text on a liquid crystal display Write simple Arduino sketches that can get sensor reading, make LEDs blink, write text on an LCD screen, read the position of a potentiometer, and much more. Understand what is prototyping. Understand the ways by which the Arduino can communicate with other devices Use protoboards to make projects permanent Understand what is Arduino programming, it’s basic concepts, structures, and keywords Measure temperature, humidity and acceleration Detect a person entering a room Make noise and play music ","date":"2022-05-27","objectID":"/arduino_step_by_step/:1:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Section 2: Know your Arduino ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Getting to know the Arduino Uno Arduino Uno The Arduino UNO is the best board to get started with electronics and coding. If this is your first experience tinkering with the platform, the UNO is the most robust board you can start playing with. The UNO is the most used and documented board of the whole Arduino family. Arduino Uno is a microcontroller board based on the ATmega328P Atmega328P The ATmega328 is a single-chip microcontroller(=mcu) created by Atmel in the megaAVR family Shields add-on, plugin Shields are modular circuit boards that piggyback(하나의 운송 단위를 다른 운송 수단에 싣고 운반하는 상품 운송, 어부바) onto your Arduino to instill it with extra functionality. In general, these are called “daughter boards.” USB Pins power clock ATmega16U2 (https://mosesnah.tistory.com/5 ) USB-to-Serial Converter ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"GPIO Digital Pins output input Analog pins output Note PWM(Pulse Width Modulation) PWM is not true analog output, however. PWM “fakes” an analog-like result by applying power in pulses, or short bursts of regulated voltage. 0과 1로만 이뤄진 디지털 신호를 아날로그 신호처럼 흉내낸다. 즉 중간 값들을 만들어 낼 수 있다. input Potentiometer(가변저항) Ohm's law: V(전압) = I(전류) * R(저항) 저항이 커지면 전압이 강해진다. 직관적으로 이해하기에는 일정한 부피에 사람들 잔뜩 집어넣으면 밀도가 올라가서 압력이 쎄진다고 생각함. 흐르는(일정한 전류) 호수관 입구 손으로 막으면(저항) 압력 더 쎄져서 물 파워(전압) 쎄짐 pot는 시계방향으로 이동시키면 저항길이가 길어져서 더 큰 저항을 줄 수 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Section 3: Introduction to communications ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"UART Universal asynchronous receiver/transmitter 병렬(parallel) 데이터의 형태를 직렬(async serial) 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종이다. 두 장치 간에 직렬 데이터를 교환하기 위한 프로토콜 또는 규정을 정의합니다. UART는 매우 간단하며 양방향으로 데이터를 송신 및 수신하기 위해 송신기와 수신기 사이에 두 개의 와이어만 사용합니다. It is old fashion compare to I2C and SPI. simple, cheap, easy to make USART USART(Universal Synchronous serial Receiver and Transmitter)를 처리하기 위해서는 동기적으로 송수신 타이밍이 동기화 되어야 한다. 이런 동기화를 위해서 Clock 신호 라인이 필요하다. 클럭신호로 HIGH, LOW를 한번 반복해 보내는 동안 데이터 핀으로 한 비트의 데이터를 보내게된다. 다음은 100(2진수로 01100100)이라는 값을 보내는 방식이다. 아래를 보면 CLOCK 라인이 존재하는 것을 확인할 수 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"I²C(TWI, I2C) Inter-Integrated circuit Two Wire(sda, sck) Interface 아이 스퀘어 C I²C는 데이터를 주고 받는 선 하나와 송수신 타이밍 동기화를 위한 CLOCK 선하나로 이루어진다. Master-Slave 구조 line(2) SDA(data): 데이터 송수신 SCK(clock): Clock 시작 신호와 정지 신호를 가지고 있으며, 슬레이브마다 지정된 주소 값을 가지고 데이터를 주고 받는다. 데이터를 주고 받을 때 반드시 주소 값을 붙여서 보내야 하므로 긴 데이터를 보내기에는 적합하지 않지만, 통신 타이밍에 구애 받지 않으며 두 개의 선만으로 여러 기기와 통신할 수 있다는 장점 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"SPI Serial Peripheral(주변의) Interface line(4) MOSI: Master Out, Slave In MISO: Master In, Slave Out SCK: Clock Line SS(CS): Slave Select or Chip Select 즉 데이터를 수신할 기기 선택 신호 Full Duplex Master-Slave 구조 SPI 통신은 데이터의 송신과 수신이 동시에 이루어지기 때문에 다른 데이터 통신에 비해 속도가 빠르다는 장점이 있어서 이더넷 통신 등에 주로 사용된다. 하나의 마스터에는 여러 개의 슬레이브가 연결 될 수 있지만, 슬레이브마다 각각 하나의 SS 선을 필요로 하기 때문에 슬레이브의 개수가 많아질 경우에는 물리적으로 효율적이지 않다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:3","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Prototyping basics ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"tl;dr breadboard jumper wire power supplies multimeter soldering(납땜) protoboard ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"with images breadboard breadboard back breadboard front jumper wire male female aligator clips (=spring clips) jumper wire(female) jumper wire(aligator clips) power supplies multimeter measuring voltage measuring current measuring resistance measuring voltage measuring current measuring resistance soldering(납땜) protoboard ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["iot"],"content":"Let’s get familiar with basic features of Google pubsub service by practicing. ","date":"2022-05-21","objectID":"/pubsub/:0:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"tl;dr Google Cloud Pub/Sub: Qwik Start - Console Google Cloud Pub/Sub: Qwik Start - Command Line Google Cloud Pub/Sub: Qwik Start - Python ","date":"2022-05-21","objectID":"/pubsub/:1:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Quick start pub/sub Configure gcloud console Welcome to Cloud Shell! Type \"help\" to get started. Your Cloud Platform project in this session is set to qwiklabs-gcp-03-5549c96ad433. Use “gcloud config set project [PROJECT_ID]” to change to a different project. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud auth list Credentialed Accounts ACTIVE: * ACCOUNT: student-03-731a0523b9da@qwiklabs.net To set the active account, run: $ gcloud config set account `ACCOUNT` student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud config list project [core] project = qwiklabs-gcp-03-5549c96ad433 Your active configuration is: [cloudshell-4687] student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ Create topic Add a subscription Go to detailed topic page Publish a message to the topic View the message gcloud pubsub subscriptions pull --auto-ack MySub student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription DATA: Hello World MESSAGE_ID: 4704893166371310 ORDERING_KEY: ATTRIBUTES: DELIVERY_ATTEMPT: student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack myTopic-sub DATA: Hello World MESSAGE_ID: 4704893166371310 ORDERING_KEY: ATTRIBUTES: DELIVERY_ATTEMPT: student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack myTopic-sub Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ ","date":"2022-05-21","objectID":"/pubsub/:2:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Google Cloud Pub/Sub: Qwik Start - Command Line ","date":"2022-05-21","objectID":"/pubsub/:3:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"The Pub basics (CRD) A producer publishes messages to a topic and a consumer creates a subscription to a topic to receive messages from it. Create topics $ gcloud pubsub topics create myTopic Created topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic]. $ gcloud pubsub topics create myTopic2 $ gcloud pubsub topics create myTopic3 When duplicates topcic name, gcp returns error $ gcloud pubsub topics create myTopic2 $ gcloud pubsub topics create myTopic2 ERROR: Failed to create topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2]: Resource already exists in the project (resource=myTopic2). ERROR: (gcloud.pubsub.topics.create) Failed to create the following: [myTopic2]. List topics $ gcloud pubsub topics list --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic3 --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2 Delete topics student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics delete myTopic3 Deleted topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic3]. student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics delete myTopic2 Deleted topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2]. student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics list --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic ","date":"2022-05-21","objectID":"/pubsub/:3:1","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"The Sub basics (CRD) create student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub subscriptions create --topic myTopic mySubsciption Created subscription [projects/qwiklabs-gcp-04-82b04dcaac56/subscriptions/mySubsciption]. delete $ gcloud pubsub subscriptions delete Test1 list $ gcloud pubsub topics list-subscriptions myTopic ","date":"2022-05-21","objectID":"/pubsub/:3:2","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Pub/Sub Publishing and Pulling a Single Message $ gcloud pubsub topics publish myTopic --message \"Hello\" $ gcloud pubsub topics publish myTopic --message \"Publisher's name is minwook\" $ gcloud pubsub topics publish myTopic --message \"Publisher likes to eat love\" $ gcloud pubsub topics publish myTopic --message \"Publisher thinks Pub/Sub is awesome\" # pull subscription $ gcloud pubsub subscriptions pull mySubscription --auto-ack What’s going on here? You published 4 messages to your topic, but only 1 was outputted. Now there are important features of the pull command that often trip developers up Using the pull command without any flags will output only one message, even if you are subscribed to a topic that has more held in it. Once an individual message has been outputted from a particular subscription based pull command, you cannot access that message again with the pull command (maybe this happens ack) Run the last command three more times. You will see that it will output the other messages you published before. Now run the command a 4th time. $ gcloud pubsub subscriptions pull mySubscription --auto-ack ","date":"2022-05-21","objectID":"/pubsub/:3:3","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Pub/Sub pulling all messages from subscriptions with flag $ gcloud pubsub subscriptions pull mySubscription --auto-ack --limit=3 Here, notice that gcp pubsub important features. about --auto-ack (BETA) Acknowledges one or more messages as having been successfully received. If a delivered message is not acknowledged within the Subscription’s ack deadline, Cloud Pub/Sub will attempt to deliver it again. To automatically acknowledge messages when pulling from a Subscription, you can use the –auto-ack flag on gcloud pubsub subscriptions pull. ","date":"2022-05-21","objectID":"/pubsub/:3:4","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Google Cloud Pub/Sub: Qwik Start - Python https://www.cloudskillsboost.google/focuses/2775?catalog_rank=%7B%22rank%22%3A3%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D\u0026parent=catalog\u0026qlcampaign=yt18-gsp095-11078 Project setup \u003e git clone https://github.com/googleapis/python-pubsub.git \u003e cd python-pubsub/samples/snippets \u003e ls README.rst noxfile.py requirements-test.txt subscriber.py README.rst.in noxfile_config.py requirements.txt subscriber_test.py iam.py publisher.py resources utilities iam_test.py publisher_test.py schema.py mypy.ini quickstart schema_test.py \u003e python3 -m venv venv \u003e source venv/bin/activate \u003e pip list Package Version ---------- ------- pip 22.0.4 setuptools 47.1.0 WARNING: You are using pip version 22.0.4; however, version 22.1 is available. You should consider upgrading via the '/Users/minwook/code/python-pubsub/samples/snippets/venv/bin/python3 -m pip install --upgrade pip' command. \u003e cat requirements.txt google-cloud-pubsub==2.12.1 avro==1.11.0 \u003e pip install --upgrade pip \u003e pip install -r requirements.txt Create a topic # you must authorize google cloud auth before create a topic $ echo $GOOGLE_CLOUD_PROJECT $ python publisher.py $GOOGLE_CLOUD_PROJECT create MyTopic $ python publisher.py $GOOGLE_CLOUD_PROJECT list Create a subscription $ python subscriber.py $GOOGLE_CLOUD_PROJECT create MyTopic MySub list subscription $ python subscriber.py $GOOGLE_CLOUD_PROJECT list-in-project Subscribe messages $ python subscriber.py $GOOGLE_CLOUD_PROJECT receive MySub Listening for messages on projects/qwiklabs-gcp-7877af129f04d8b3/subscriptions/MySub Received message: Message { data: 'Publisher thinks Pub/Sub is awesome' attributes: {} } Received message: Message { data: 'Hello' attributes: {} } Received message: Message { data: \"Publisher's name is Harry\" attributes: {} } Received message: Message { data: 'Publisher likes to eat cheese' attributes: {} } pub.py #!/usr/bin/env python # Copyright 2019 Google LLC # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import argparse from google.cloud import pubsub_v1 def pub(project_id: str, topic_id: str) -\u003e None: \"\"\"Publishes a message to a Pub/Sub topic.\"\"\" # Initialize a Publisher client. client = pubsub_v1.PublisherClient() # Create a fully qualified identifier of form `projects/{project_id}/topics/{topic_id}` topic_path = client.topic_path(project_id, topic_id) # Data sent to Cloud Pub/Sub must be a bytestring. data = b\"Hello, World!\" # When you publish a message, the client returns a future. api_future = client.publish(topic_path, data) message_id = api_future.result() print(f\"Published {data.decode()}to {topic_path}: {message_id}\") if __name__ == \"__main__\": parser = argparse.ArgumentParser( description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter, ) parser.add_argument(\"project_id\", help=\"Google Cloud project ID\") parser.add_argument(\"topic_id\", help=\"Pub/Sub topic ID\") args = parser.parse_args() pub(args.project_id, args.topic_id) Wow.. it looks simple, I think the variable naming api_future is a key to this script. api_future is returned value of google.cloud.pubsub_v1.PublisherClient.publish() and a variable message_id is type of api_future.result() Let’s deep dive into below logics. google.cloud.pubsub_v1.PublisherClient.publish() google.cloud.pubsub_v1.PublisherClient.publish.result() class PublisherClient(metaclass=PublisherClientMeta): \"\"\"The service that an application uses to manipulate topics, and to send messages to a topic. \"\"\" ... def publish( sel","date":"2022-05-21","objectID":"/pubsub/:4:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Conclusion This is so impressive that pubsub_v1’s client generates Future object which needs client should supports async features. Eventually gcp pubsub_v1’s clients inherit official python concurrent Future object, so I’m wondering that can pubsub_v1 handle python2.x? because python future object is not supported on python2.x version. If it does not support python2.x version than, how do I mock Future based async flow to gevent logic. Through this journey, I would like to study Python’s concurrent-related features to an advanced level. https://docs.python.org/ko/3/library/concurrent.futures.html ","date":"2022-05-21","objectID":"/pubsub/:5:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"This post is a summary of lectures taken in coursera on the topic of Google IoT core. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:0:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day 1 ~ 2 ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"What is IoT? Internet of Things is a sprawling set of technologies and use that has no clear, single definition. But one workable view frames IoT as the use of network-connected devices, embedded in the physical env, to improve some existing process or to enable a new scenario not previously possible. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"IoT cloud The general structure of an IoT cloud Devices gathering data performing an action interact with users Gateway A gateway ensures that devices are securely connected to the cloud. It can be a cell phone. It controls messaging between the device and the cloud Cloud u na mean ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Challenges in IoT When designing an IoT network, below topics should be considered. connectivity At present IoT relies on a server/client model to authenticate, authorize and connect devices to nodes in the network It will become unworkable as numbers grow to the millions and billions per network. In the future, off-loading tasks to the edge will become important. This means that IoT networks will need devices capable of handling data analysis, ML, and data gathering. brownfield deployment(legacy infra) Companies will need to confront the task of integrating new devices and technologies into existing networks. security and compilance non-standard communication protocol Dealing with non-standard communication protocol will increase in importance as networks need to handle ever-increasing amounts of data from sensors. Data handling, processing, and storing will increase as data input loads increase, while at the same time, the value of data increases with the size, depth, and frequency of data available to data analytics. IT/OT convergence IT has traditionally been data-centric OT has been used to monitor events. get actionable intelligence from data. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"IoT Architecture IoT architecturesmust be capable of scaling connectivity of devices, data ingestion, data processing, and data storage. They must be able to do this quickly while still producing real-time data insights. To migrate this demand, distributed computing known as fog or edge computing is gaining popularity. The edge refers to the geographic distribution of computing nodes in the network as sIoT devices, which are at the “edge” of a network. This in turn increases the demand for devices that are capable of cleaning, processing and analyzing data locally. The result is that only cleaned metadata is sent to the cloud. An asynchronous, scalable communication stack is crucial in bidirectional communication with devices. https://k21academy.com/google-cloud/cloud-sql-vs-cloud-spanner/ ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day 3 ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Types of sensors ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Devices A “Thing” in the “Internet of Things” is a processing unit that is capable of connecting to the internet and exchanging data with the cloud. Devices are often called “smart devices” or “connected devices.” They communicate two types of data: telemetry and state. Device information is mainly composed of three types as follows. Device metadata: Most metadata rarely, if ever, changes. Identifier (ID) -An identifier that uniquely identifies a device. Class or type Model Revision Date manufactured Hardware serial numbe Telemetry: Data collected by the device is called telemetry Telemetry is read-only data about the environment usually collected through sensors e.g. Temperature(35.4oC) State information Describes the current status of the device, not of the environment can be read/write. It is updated, but usually not frequently. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Device commands Commands are actions performed by a device. So tye should include a time-to-live(TTL) or other expiration value Operational information is data that’s most relevant to the operation of the device as opposed to the business application. This might include things such as CPU operating temperature and battery state. it has short-term value to help maintain the os It can be transmitted as telemetry or state data ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Defining devices For example, consider a project for monitoring the temperature in hotel rooms. Each room has three sensors: one near the floor, one near the bed, and one near the ceiling. option1 {deviceID: \"dh28dslkja\", \"location\": \"floor\", \"room\": 128, \"temp\": 22 } {deviceID: \"8d3kiuhs8a\", \"location\": \"bedside\", \"room\": 128, \"temp\": 24 } {deviceID: \"kd8s8hh3o\", \"location\": \"ceiling\", \"room\": 128, \"temp\": 20 } option2 {deviceID: \"dh28dslkja\", \"room\": 128, \"temp_floor\": 22, \"temp_bedside\": 24, \"temp_ceiling\": 20, \"average_temp\": 22 } ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Google IoT developer prototyping kits Google works with partners to build device starter kits that make connecting to Google Cloud IoT Platform easy for developers. At this time, Google has partnered with fourteen companies to offer a wide variety of IoT developer prototyping kits . ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:5","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"MQTT protocol https://cloud.google.com/iot/docs/concepts/protocols MQTT is an industry-standard IoT protocol (Message Queue Telelmetry Transport). Messages include the topic in the message, which is used for routing information by the broker. This means that subscribers do not need to know the publisher, because all communication is done through messages Messages are pushed to subscribers, so there must be an open TCP connection to the broker (subscriber \u003c-\u003e broker) If the connection is broken, the broker can hold messages for later transmission. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:6","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"HTTP protocl HTTP is a “connectionless” protocol: with the HTTP bridge, devices do not maintain a connection to the cloud. In connectionless communication, client requests are sent without having to first check that the recipient is available. Therefore devices have no way of knowing whether they are in a conversation with the server, and vice versa. This means some of the features that Cloud IoT Core provides, for example, last Heartbeat detected, will not be available with an HTTP connection. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:7","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Comparison of MQTT and HTTP general features MQTT is considered to be data focused, while HTTP is document focused. Which means MQTT is better suited to the rigors of IoT. In addition, MQTT has three levels of service(QoS) At most once. Guarantees at least one attempt at delivery, (no guarantee of delivery). At least once. Guarantees the message will be delivered at least once. Exactly once. Guarantees the message is delivered only once. MQTT also has Last will and testament(유언, LWT). If a client (ie device) is disconnected unexpectedly, the subscribers will be notified by the MQTT broker. Retained(보관) messages. New subscribers will get an immediate status update. LWT 통신에서 중요하지만 구현이 까다로운 문제로 “상대방이 예상치 못한 상황으로 인하여 접속이 끊어졌을때\"의 처리가 있다. 그래서 전통적 방식으로는 자신의 생존 여부를 계속 ping을 통해 서버가 물어보고 timeout 시간안에 pong이 안올 경우 서버에서 접속 종료를 인식하는 번거로운 방식을 취하는데, MQTT의 경우 subscribe 시점에서 자신이 접속 종료가 되었을 때 특정 topic으로 지정한 메시지를 보내도록 미리 설정할 수 있다. 이를 LWT(Last will and testament) 라고 한다. 선언을 먼저하고 브로커가 처리하게 하는 방식인 것이다. $ mqtt help subscribe Usage: mqtt subscribe [opts] [topic] Available options: ... 중략 ... --will-topic TOPIC the will topic --will-message BODY the will message --will-qos 0/1/2 the will qos --will-retain send a will retained message Both MQTT and HTTP use pub key(asymmetric) device authentication, and JWT. In more detail ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:8","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day4: Google Cloud’s IoT Platform This section covers the ingest and process stages of IoT architecture. Learning Objectives Create Cloud IoT registries and devices Create Pub/Sub topics and sobscriptions Create and manage Cloud Storage buckets Manage device credentials and access control Create a Dataflow pipeline ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Pub/Sub The Subscriber sends the acknowledgement to the Subscription Use Cases Balancing workloads in network clusters Implementing async workflows Distirbuting event notifications Refreshing distributed caches Logging to multiple systems Data streaming from various processes or devices Reliabiltiy(신뢰할 수 있음) improvement FYI use case Balancing workloads in network clusters, for example, a large queue of tasks can be efficiently distributed among multiple workers such as Google Compute Engine instances. Implementing asynchronous workflows, for example, an order processing application can place an order on a topic from which it can be processed by one or more workers. Distributing event notifications, for example, a service that accepts user sign-ups can send notifications whenever a new user registers and a downstream services can subscribe to receive notifications of the event. Refreshing distributed caches, for example, an application can publish invalidation(캐시 무효화) events to update the IDs of objects that have changed. Logging into multiple systems, for example, a Google Compute Engine instance can write logs to the monitoring system, to a database for later querying and so on. Data streaming from various processes or devices, for example, a residential(주거, 숙박) sensor can stream data to backend services hosted in the Cloud. Also, reliability improvement, for example, a single-zone Compute Engine service can operate in additional zones by subscribing to a common topic to recover from failures in a zone or region. gcp pubsub labs in practice https://minkj1992.github.io/pubsub/ ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Cloud IoT Core Full Ingest and Process and Analyze process Cloud IoT combines both protocol bridge and device manager. Protocol Bridge MQTT protocol with single Global endpoint(mqtt.googleapis.com) Automatic load balancing Global data access with Pub/Sub Device Manager Configure individual devices Update and control devices Role level access control (authrization) Console and APIs for device deployment and monitoring Cloud IoT Core fully integrates your devices make decision Device telemetry data is forwarded to a Pub/Sub topic, which can then be used to trigger Cloud Functions. You can also perform streaming analysis with Dataflow or custom analysis with your own subscribers. secure Cloud IoT uses automatic load balancing and horizontal scaling to ensure smooth data ingestion under any condition. Cloud IoT Core follows industry-standard security protocols. Registration connects devices to Google IoT Cloud tl;dr Device registry: belong to cloud project so single region Device: belong to device registry so single region (registry : device = 1 : n) topic: global single endpoint (belong to pubsub) In order for a device to connect, it must first be registered in the device manager. The device manager lets you create and configure device registries and the devices within them. A device registry is a container of devices. When you create a device registry, you select which protocols to enable: MQTT, HTTP, or both. Each device registry is created in a specific cloud region and belongs to a cloud project. A registry is identified in the cloudiot.googleapis.com service by its full name. as projects/{project-id}/locations/{cloud-region}/registries/{registry-id} The device registry is configured with one or more Pub/Sub topics to which telemetry events are published for all devices in that registry. A single topic can be used to collect data across all regions. Cloud monitoring is automatically enabled for each registry. For details, seeDeviceRegistry resource reference Protocol bridges Devices communicate with Cloud IoT Core across a “bridge” — either the MQTT bridge or the HTTP bridge. Note that GCP Cloud IoT Core supports HTTP 1.1 only. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Cloud Storage ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Dataflow","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["python"],"content":"Let's deep dive into gevent based python programming","date":"2022-04-24","objectID":"/gevent/","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Let’s deep dive into gevent based python programming ","date":"2022-04-24","objectID":"/gevent/:0:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"tl;dr from gevent import ( event, joinall, queue, sleep, threadpool, Timeout, wait, kill, get_hub, signal, ) ","date":"2022-04-24","objectID":"/gevent/:1:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"gevent gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop. deterministic ","date":"2022-04-24","objectID":"/gevent/:2:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Intro ","date":"2022-04-24","objectID":"/gevent/:3:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"gevent vs eventlet gevent is inspired by eventlet has some diff gevent is built on top of libevent event loop epoll on Linux Signal handling is integrated with the event loop. Other libevent-based libraries can integrate with your app through single event loop. DNS requests are resolved asynchronously rather than via a threadpool of blocking calls. WSGI server is based on the libevent’s built-in HTTP server gevent’s interface follows the conventions set by the standard library ","date":"2022-04-24","objectID":"/gevent/:3:1","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"backgrounds greenlet Greenlet은 C 확장 모듈 형태로 제공되는 경량 코루틴 입니다. Greenlet들은 메인 프로그램을 실행하는 OS process 안에서 모두 실행되지만 상호작용하며 스케줄링됩니다. 운영체제에 의해 스케줄링되는 process들과 POSIX 쓰레드들을 사용하여 실제로 병렬로 실행되는 multiprocessing 나 threading을 이용한 병렬처리들과는 달리 한 번에 오직 하나의 greenlet만이 실행됩니다. greenlet은 deterministic 합니다. 같은 greenlet 세팅과 같은 입력이 주어졌을때, 언제나 같은 결과를 출력합니다. import time def echo(i): time.sleep(0.001) return i # Non Deterministic Process Pool from multiprocessing.pool import Pool p = Pool(10) run1 = [a for a in p.imap_unordered(echo, range(10))] run2 = [a for a in p.imap_unordered(echo, range(10))] run3 = [a for a in p.imap_unordered(echo, range(10))] run4 = [a for a in p.imap_unordered(echo, range(10))] print(run1 == run2 == run3 == run4) # Deterministic Gevent Pool from gevent.pool import Pool p = Pool(10) run1 = [a for a in p.imap_unordered(echo, range(10))] run2 = [a for a in p.imap_unordered(echo, range(10))] run3 = [a for a in p.imap_unordered(echo, range(10))] run4 = [a for a in p.imap_unordered(echo, range(10))] print(run1 == run2 == run3 == run4) False True libev vs libuv vs libevent The three network libraries Libevent , libev , and libuv are all asynchronous event libraries implemented in C language. ( Asynchronousevent library ). Libevent: the most famous, most widely used and long-standing cross-platform event library; libev: Compared with libevent , the design is more concise and the performance is better, but the support for Windows is not good enough; libuv: A cross-platform event library is needed in the process of developing node . They preferred libev , but they also need to support Windows , so they repackaged a set, implemented with libev under Linux , and IOCP under Windows ","date":"2022-04-24","objectID":"/gevent/:3:2","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"key features refs ","date":"2022-04-24","objectID":"/gevent/:4:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Synchronous \u0026 Asynchronous Execution on gevent 동시성 처리의 핵심 개념은 큰 단위의 task를 한번에 동기로 처리하는 대신, 작은 단위의 subtask들로 쪼개서 동시에 비동기로 실행시키는 것입니다. 두 subtask간의 스위칭을 컨텍스트 스위칭이라고 합니다. gevent에서는 컨텍스트 스위칭을 yielding을 이용해서 합니다. gevent의 진짜 힘은 상호작용 하며 스케쥴링 될 수 있는 네트워크와 IO bound 함수들을 작성할때 발휘됩니다. gevent는 네트워크 라이브러리들이 암시적으로 greenlet 컨텍스트들이 가능한 시점에 암시적으로 yield 하도록 보장합니다. import time import gevent from gevent import select start = time.time() tic = lambda: 'at %1.1fseconds' % (time.time() - start) def gr1(): # Busy waits for a second, but we don't want to stick around... print('Started Polling: %s' % tic()) select.select([], [], [], 2) print('Ended Polling: %s' % tic()) def gr2(): # Busy waits for a second, but we don't want to stick around... print('Started Polling: %s' % tic()) select.select([], [], [], 2) print('Ended Polling: %s' % tic()) def gr3(): print(\"Hey lets do some stuff while the greenlets poll, %s\" % tic()) gevent.sleep(1) print('gr3 fin') gevent.joinall([ gevent.spawn(gr1), gevent.spawn(gr2), gevent.spawn(gr3), ]) Started Polling: at 0.0 seconds Started Polling: at 0.0 seconds Hey lets do some stuff while the greenlets poll, at 0.0 seconds Ended Polling: at 2.0 seconds Ended Polling: at 2.0 seconds ","date":"2022-04-24","objectID":"/gevent/:4:1","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Determinism greenlet은 deterministic 합니다. 같은 greenlet 세팅과 같은 입력이 주어졌을때, 언제나 같은 결과를 출력합니다. gevent가 일반적으로 deterministic 하다고 해도, 소켓과 파일과 같은 외부 서비스와 연동할 때 non-deterministic한 입력들이 들어올 수 있습니다. 그러므로 green 쓰레드가 “deterministic concurrency” 형태라고 해도, POSIX 쓰레드들과 프로세스들을 다룰 때 만나는 문제들을 경험할 수 있습니다. 동시성을 다룰 때 만날 수 있는 문제로 race condition이 있습니다. 간단히 요약하자면, race condition은 두 개의 동시에 실행되는 쓰레드나 프로세스들이 같은 공유 자원을 수정하려고 할 때 발생합니다. 이때 해당 공유자원의 결과 값은 실행 순서에 따라 달라지게 됩니다. 이런 결과는 non-deterministic한 프로그램 동작을 야기하기 때문에 발생시키지 않기 위해 노력해야 합니다. Best practice는 공유자원을 사용하지 않도록 하는 것입니다. ","date":"2022-04-24","objectID":"/gevent/:4:2","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Spawning Greenlets gevent는 greenlet 초기화를 위한 몇 가지 wrapper들을 제공합니다. import gevent from gevent import Greenlet def foo(message, n): gevent.sleep(n) print(message) c1 = Greenlet.spawn(foo, \"Hello\", 1) c2 = gevent.spawn(foo, \"Hello2\", 2) c3 = gevent.spawn(lambda x: (x+1), 5) coroutines = [c1,c2, c3] gevent.joinall(coroutines) 6 Hello Hello2 Greenlet 클래스를 상속하고 _run 함수를 override 하는 방법도 있습니다. import gevent from gevent import Greenlet class MyGreenlet(Greenlet): def __init__(self, message, n): Greenlet.__init__(self) self.message = message self.n = n def _run(self): print(self.message) gevent.sleep(self.n) g = MyGreenlet(\"Hi there!\", 3) g.start() g.join() Hi there! ","date":"2022-04-24","objectID":"/gevent/:4:3","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Greenlet State 다른 코드 예시들처럼, greenlet도 다양한 경우에 실패할 수 있습니다. greenlet은 예외를 발생시키는것이 실패하거나, 정지에 실패할 수도 있고, 시스템 자원을 과도하게 사용할 수도 있습니다. greenlet의 내부 상태는 대체로 time-dependent합니다. greenlet에는 쓰레드의 상태를 모니터링 할 수 있는 다양한 flag들이 있습니다. started: bool Greenlet이 실행되었는지 여부를 나타냅니다 ready(): bool Greenlet이 정지되었는지 여부를 나타냅니다 successful(): bool Greenlet이 예외를 발생시키지 않고 정지되었는지 여부를 나타냅니다. value: Any Greenlet에 의해서 리턴된 값입니다. exception: Exception Greenlet안에서 발생한 예외입니다. import gevent def win(): return 'You win!' def fail(): raise Exception('You fail at failing.') winner = gevent.spawn(win) loser = gevent.spawn(fail) print(winner.started) # True print(loser.started) # True try: gevent.joinall([winner, loser]) except Exception as e: print('This will never be reached') print(winner.value) # 'You win!' print(loser.value) # None print(winner.ready()) # True print(loser.ready()) # True print(winner.successful()) # True print(loser.successful()) # False # It is possible though to raise the exception again outside # raise loser.exception # or with # loser.get() print(loser.exception) # You fail at failing. ","date":"2022-04-24","objectID":"/gevent/:4:4","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Program Shutdown 메인 프로그램이 SIGQUIT 시그널을 받은 시점에 yield를 실패한 Greenlet은 예상보다 오래 실행이 정지되어 있을 수 있습니다. 이런 프로세스는 “좀비 프로세스\"라고 불리고, 파이썬 인터프리터 외부에서 kill되어야 합니다. 일반적인 패턴은 메인 프로그램에서 SIGQUIT 시그널에 대기하고 있다가 프로그램이 종료되기 전에 gevent.shutdown 호출하는 것입니다. import gevent import signal def run_forever(): gevent.sleep(1000) if __name__ == '__main__': # gevent.signal(signal.SIGQUIT, gevent.shutdown) gevent.signal(signal.SIGQUIT, gevent.kill) thread = gevent.spawn(run_forever) thread.join() 아래는 realworld example입니다. def main(): parser = ArgumentParser() parser.add_argument(\"--start\", action=\"something start\", help=\"Launch the processes\") args = parser.parse_args() threading.currentThread().setName('something') launcher = Launcher() launcher.setup_procmanager() if args.start: launcher.start_proc_manager() try: gevent.signal.signal(gevent.signal.SIGTERM, sig_handler) gevent.signal.signal(gevent.signal.SIGINT, sig_handler) gevent.wait() except KeyboardInterrupt: print('Shutdown requested. Exiting...') launcher.shutdown() if __name__ == '__main__': main() ","date":"2022-04-24","objectID":"/gevent/:4:5","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Timeouts import gevent from gevent import Timeout seconds = 10 timeout = Timeout(seconds) timeout.start() def wait(): gevent.sleep(10) try: gevent.spawn(wait).join() except Timeout: print('Could not complete') with statement import gevent from gevent import Timeout time_to_wait = 5 # seconds class TooLong(Exception): pass with Timeout(time_to_wait, TooLong): gevent.sleep(10) ","date":"2022-04-24","objectID":"/gevent/:4:6","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Events Event는 Greenlet 간의 비동기 통신에 사용됩니다. import gevent from gevent.event import Event ''' Illustrates the use of events ''' evt = Event() def setter(): '''After 3 seconds, wake all threads waiting on the value of evt''' print('A: Hey wait for me, I have to do something') gevent.sleep(3) print(\"Ok, I'm done\") evt.set() def waiter(): '''After 3 seconds the get call will unblock''' print(\"I'll wait for you\") evt.wait() # blocking print(\"It's about time\") def main(): gevent.joinall([ gevent.spawn(setter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter) ]) if __name__ == '__main__': main() A: Hey wait for me, I have to do something I'll wait for you I'll wait for you I'll wait for you I'll wait for you I'll wait for you Ok, I'm done It's about time It's about time It's about time It's about time It's about time Event 객체의 확장은 wakeup call과 함께 값을 전송할 수 있는 AsyncResult입니다. AsyncResult는 임의의 시간에 할당될 미래 값에 대한 레퍼런스를 갖고 있기 때문에, 때때로 future나 deferred로 불리기도 합니다. import gevent from gevent.event import AsyncResult a = AsyncResult() def setter(): a.set('leoo is cool') gevent.sleep(0.5) a.set('minwook is cool') def waiter(): print(a.get()) gevent.sleep(1) print(a.get()) gevent.joinall([ gevent.spawn(setter), gevent.spawn(waiter), ]) leoo is cool minwook is cool ","date":"2022-04-24","objectID":"/gevent/:4:7","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Queues Queue는 일반적인 put 과 get 연산을 지원하지만 Greenlet 사이에서 안전하게 조작되는 것이 보장되는 순서를 가진 데이터들의 집합입니다. import gevent from gevent.queue import Queue tasks = Queue() def worker(n): while not tasks.empty(): task = tasks.get() print('Worker %sgot task %s' % (n, task)) gevent.sleep(0) print('Quitting time!') def boss(): for i in xrange(1,25): tasks.put_nowait(i) gevent.spawn(boss).join() gevent.joinall([ gevent.spawn(worker, 'steve'), gevent.spawn(worker, 'john'), gevent.spawn(worker, 'nancy'), ]) Worker steve got task 1 Worker john got task 2 Worker nancy got task 3 Worker steve got task 4 Worker john got task 5 Worker nancy got task 6 Worker steve got task 7 Worker john got task 8 Worker nancy got task 9 Worker steve got task 10 Worker john got task 11 Worker nancy got task 12 Worker steve got task 13 Worker john got task 14 Worker nancy got task 15 Worker steve got task 16 Worker john got task 17 Worker nancy got task 18 Worker steve got task 19 Worker john got task 20 Worker nancy got task 21 Worker steve got task 22 Worker john got task 23 Worker nancy got task 24 Quitting time! Quitting time! Quitting time! 즉 Queue는 put이나 get 연산 시 block 됩니다. 만약 non-blocking 연산이 필요할 때는 block이 되지 않는 put_nowait과 get_nowait을 사용할 수 있습니다. 대신 연산이 불가능할 때는 gevent.queue.Empty 나 gevent.queue.Full 예외를 발생시킵니다. 아래 코드는 상사가 3명의 작업자(steve, john, nancy)에게 동시에 일을 시키는데 Queue가 3개 이상의 요소를 담지 않도록 제한하는 예시입니다. 이 제한은 put연산이 Queue에 남은 공간이 있을 때 까지 block 되어야 함을 의미합니다. 반대로 get 연산은 Queue에 요소가 없으면 block 되는데, 일정 시간이 지날 때 까지 요소가 들어오지 않으면 gevent.queue.Empty 예외를 발생시키면서 종료될 수 있도록 타임아웃 파라미터를 설정할 수 있습니다. import gevent from gevent.queue import Queue, Empty tasks = Queue(maxsize=3) def worker(name): try: while True: task = tasks.get(timeout=1) # decrements queue size by 1 print('Worker %sgot task %s' % (name, task)) gevent.sleep(0) except Empty: print('Quitting time!') def boss(): \"\"\" Boss will wait to hand out work until a individual worker is free since the maxsize of the task queue is 3. \"\"\" for i in xrange(1,10): tasks.put(i) print('Assigned all work in iteration 1') for i in xrange(10,20): tasks.put(i) print('Assigned all work in iteration 2') gevent.joinall([ gevent.spawn(boss), gevent.spawn(worker, 'steve'), gevent.spawn(worker, 'john'), gevent.spawn(worker, 'bob'), ]) Worker steve got task 1 Worker john got task 2 Worker bob got task 3 Worker steve got task 4 Worker john got task 5 Worker bob got task 6 Assigned all work in iteration 1 Worker steve got task 7 Worker john got task 8 Worker bob got task 9 Worker steve got task 10 Worker john got task 11 Worker bob got task 12 Worker steve got task 13 Worker john got task 14 Worker bob got task 15 Worker steve got task 16 Worker john got task 17 Worker bob got task 18 Assigned all work in iteration 2 Worker steve got task 19 Quitting time! Quitting time! Quitting time! ","date":"2022-04-24","objectID":"/gevent/:4:8","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["dao","ohso"],"content":"Daoist 도의 사람은 장애물이 없이 행한다. 그는 자신의 행동으로 남을 상처 주지 않는다. 그럼에도 그는 자신의 부드러움과 따뜻함을 알지 못한다. 그는 재물을 모으고자 애쓰지 않으며 그렇다고 청빈의 덕을 내세우지도 않는다. 그는 남에게 의존함 없이 자신의 길을 걸어가며 또한 홀로 걸어감을 자랑하지도 않는다. 도의 사람은 알려짐 없이 머물러 있다. 완전한 덕은 아무것도 만들어 내지 않는다. 자아가 사라진 것이 진정한 자아. 가장 위대한 자는 아무도 아닌 자다. 도의 사람 by Zhuang Zhou 마음의 본성은 한 극에서 반대편 극으로 움직여 가는 것이다. 누군가를 사랑할 때 그대는 곧 그를 미워하기 위한 반동력을 모으고 있는 것이다. 그래서 오직 친구만이 적이 될 수 잇다. 먼저 친구가 되지 않으면 갑자기 적으로 될 수가 없다. 사랑하는 이들만이 말다툼을 할 수 있고 싸울 수 있다. 삶 속에서는 온갖 반대되는것들이 하나로 합쳐진다. 그것들은 함께 존재한다. 마음은 늘 거리를 갈망한다. 결코 가까워지기를 바라지 않는다. 가까워지면 권태로워지고 싫증을 느낀다. 거리를 가지면 꿈과 희망들을, 즐거움의 가능성들을 품을 수 있다. 매력적이고 아름다워 보이는 것은 언제나 거리가 있다. 모든 관계는 사랑과 미움의 관계다. 순수한 사랑의 관계는 없다. 순수한 미움의 관계도 없다. 사랑과 미움 둘 다이다. 그대가 정직하다면 곤란에 빠질 것이다. 살아오면서 너무나 긴장해 있었기 때문에 이제 명상을 하고 있는 것이다. 그러나 그것은 긴장의 반대편이지 진정한 명상이 아니다. 그대는 가까이 오기 위해 멀리 가야만 한다. 명상하기 위해 긴장해야만 한다. 그것은 명상이 아니다. 반대편으로 옮겨가지 말라. 중간에 멈춰 서서. 이것이 줄곧 속임수였음을 지켜보라 그것들이 서로 연결되어 있음을, 한 과정의 양면으로 이어져 있음을 자각하라. ","date":"2022-04-24","objectID":"/daoist/:0:0","tags":["love","삶의 길 흰구름의 길"],"title":"Daoist","uri":"/daoist/"},{"categories":["script","shell"],"content":"List up some useful shell scripts","date":"2022-04-23","objectID":"/shell_script/","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"Useful shell script commands :) ","date":"2022-04-23","objectID":"/shell_script/:0:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"Shebang #!: Shebang #!/usr/bin/\u003cbash|python|perl|php...\u003e 스크립트를 실행시켜줄 인터프리터의 절대경로를 지정하는 역할 #!/usr/bin/env \u003clanguate\u003e env는 환경 변수에서 지정한 언어의 위치를 찾아서 실행됩니다. 다양한 환경에서 실행되는 스크립트라면 “env\"를 사용하는 것이 좋습니다. e.g. #!/usr/bin/env bash ","date":"2022-04-23","objectID":"/shell_script/:1:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"set commands refs #!/usr/bin/env bash set -o nounset -o errexit -o errtrace -o pipefail 만일, 미리 선언되지 않은 변수를 사용했을 때 스크립트를 종료시키고 싶은 경우 $ set -o nounset or $ set -u exit if a command yields a non-zero exit status. (exit when the command fails.) $ set -o errexit or $ set -e prints commands arguments during execution. Useful for debugging $ set -o xtrace or $ set -x 파이프 사용시, 이전 단계의 오류(non-zero exit code)를 승계하도록 하는 설정 파이프 사용시 오류 코드(non-zero exit code)를 이어받는다. e.g. $ mysqldump | gzip commands fails, than gzip commands returns non-zero -e option과 함께 사용된다. $ set -o pipefail When errtrace is enabled, the ERR trap is also triggered when the error (a command returning a nonzero code) occurs inside a function or a subshell. $ set -o errtrace # or $ set -E e.g. #!/bin/bash set -o errtrace function x { echo \"X begins.\" false echo \"X ends.\" } function y { echo \"Y begins.\" false echo \"Y ends.\" } trap 'echo \"ERR trap called in ${FUNCNAME-main context}.\"' ERR x y false true if set -o errtrace enabled X begins. ERR trap called in x. X ends. Y begins. ERR trap called in y. Y ends. ERR trap called in main context. disabled X begins. X ends. Y begins. Y ends. ERR trap called in main context. ","date":"2022-04-23","objectID":"/shell_script/:2:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"trap trap defines and activates handlers to run when the shell receives signals or other special conditions. # trap [action] [signal] trap 'echo \"Fatal: Exits abnormally at line #$(caller 0 || echo ${LINENO})\" \u003e\u00262' ERR ERR A SIGNAL_SPEC of ERR means to execute [action] each time a command’s failure would cause the shell to exit when the -e option is enabled. #$(caller 0 || echo ${LINENO}) ","date":"2022-04-23","objectID":"/shell_script/:3:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"redirection (\u003e) # \u003e1은 커맨드의 표준 출력을 다음에 나오는 파일 디스크립터에 전달한다. $ \u003e 1 # 쉘 스크립트의 표준 에러를 다음에 나오는 파일 디스크립터에 전달한다. $ \u003e2 # \u003e\u00262는 모든 출력을 강제로 쉘 스크립트의 표준 에러로 출력한다. $ \u003e\u00262 ","date":"2022-04-23","objectID":"/shell_script/:4:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["robotics"],"content":"tl;dr ","date":"2022-04-23","objectID":"/iot_core/:1:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"Terminology referenced Technical overview of Internet of Things article. top-level components(3) device: hardware itself and sw gateway: connect to cloud services without internet cloud: google cloud type of message state information(data) current status of the device read/write telemetry device metric (i.g sensor data, gps …) read only Each source of telemetry results in a channel Telemetry data might be preserved as a stateful variable on the device or in the cloud. commnads actions performed by a device. commands are often not idempotent which means each duplicate message usually results in a different outcome operational information i.g. CPU operating temperature and battery state can be transmitted as telemetry or state data. serial interface process of sending data one bit at a time, sequentially, over a communication channel or computer bus contrast to parallel communication GPIO General-purpose input/output pin can be designed to carry digital or analog signals, and digital pins have only two states: HIGH or LOW. PWM pulse width modulation The effect in the device can be a lower or higher power level ADC analog to digital conversion analog -\u003e binary I2C Inter Integrated Circuit Inter-Integrated Circuit serial bus uses a protocol that enables multiple modules to be assigned a discrete address on the bus pronounced “I two C”, “I-I-C”, or “I squared C”. OTA update over the air updates ","date":"2022-04-23","objectID":"/iot_core/:2:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"GCP IoT Core conecpts Devices, Configuration and State ","date":"2022-04-23","objectID":"/iot_core/:3:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"1. Device metadata metadata serves primarily as a label or identifier for devices. (or classifies devices) more secure than device state or device configuration because device metadata is never sent to or from a device shouldn’t change often (best: update it no more often than once per day) 500 key-value pairs (each key must be unique) Cloud IoT Core does not interpret or index device metadata e.g. hardware thumbprint, serial number, manufacturer information ","date":"2022-04-23","objectID":"/iot_core/:3:1","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"2. Device configuration IoT Core → device Sends desired state to robot with pre-defined commands like e.g. Device configuration is an arbitrary, user-defined blob of data sent from Cloud IoT Core to a device Device configuration is persisted in storage by Cloud IoT Core (64KB) After a configuration has been applied to a device, the device can report its state to Cloud IoT Core. A device configuration should focus on desired values or results, rather than on a sequence of commands Updates a device’s state by sending the expected state as a configuration Note that a device is not guaranteed to receive every configuration update If a configuration is being updated rapidly, devices may not receive intermediate versions. Configuration versions A device receives configurations only in increasing order of version numbers; in other words, it will never be sent a configuration older than its current version If the device reconnects to the MQTT bridge, it may receive an older configuration than it did during the earlier connection (rare case) ","date":"2022-04-23","objectID":"/iot_core/:3:2","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"3. Device state device → IoT Core Captures the current status of the device, not the environment Devices can describe their state with an arbitrary user-defined blob of data sent from the device to the cloud Device state information is not updated frequently. Configuration and state data can have the same schema and encoding, or they can be different e.g. health of the device or its firmware version ","date":"2022-04-23","objectID":"/iot_core/:3:3","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["python"],"content":"Describes python google style editor settings on vscode ","date":"2022-04-17","objectID":"/python_formatter/:0:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"tl;dr full settings.json settings.json { \"security.workspace.trust.banner\": \"always\", \"security.workspace.trust.untrustedFiles\": \"open\", \"python.formatting.yapfPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/yapf\", \"python.sortImports.path\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/isort\", \"python.linting.pylintPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/pylint\", \"editor.tokenColorCustomizations\": { \"textMateRules\": [ { \"scope\": \"text.html.markdown.journal.task.open.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.task.open.marker\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.task.open.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.task.open.text\", \"settings\": {} }, { \"scope\": \"text.html.markdown.journal.task.completed.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.marker\", \"settings\": { \"foreground\": \"#AAAAAA\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.text\", \"settings\": { \"foreground\": \"#AAAAAA\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.memo.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.memo.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.scope\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.link.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.link.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } } ] }, \"editor.fontSize\": 13, \"terminal.integrated.fontFamily\": \"'MesloLGS NF'\", \"editor.fontFamily\": \"Menlo, Monaco, 'Courier New', monospace\", \"editor.tabCompletion\": \"on\", \"editor.suggestSelection\": \"first\", \"vsintellicode.modify.editor.suggestSelection\": \"automaticallyOverrodeDefaultValue\", \"[markdown]\": { \"editor.tabCompletion\": \"onlySnippets\", \"editor.quickSuggestions\": { \"other\": \"on\", \"comments\": \"on\", \"strings\": \"on\" } }, \"[python]\": { \"editor.defaultFormatter\": \"ms-python.python\", \"editor.formatOnSave\": true, \"editor.codeActionsOnSave\": { \"source.organizeImports\": true, }, \"editor.rulers\": [ { \"column\": 80, \"color\": \"#5a5a5a80\" }, ] }, \"python.formatting.provider\": \"yapf\", // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/yapf\", \"python.formatting.yapfArgs\": [ \"--style\", \"google\", ], // or \"python.sortImports.path\": \"${workspaceFolder}/.venv/bin/isort\", \"python.sortImports.args\": [ \"--settings-file=${workspaceFolder}/.isort.cfg\", ], \"python.linting.enabled\": true, \"python.linting.lintOnSave\": true, \"python.linting.pylintEnabled\": true, // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/pylint\", \"python.linting.pylintArgs\": [ \"--load-plugins\", \"pylint_django\", \"pylint_quotes\", // related string quotes ], \"workbench.colorTheme\": \"Community Material Theme Palenight High Contrast\", \"[jsonc]\": { \"editor.defaultFormatter\": \"vscode.json-language-features\" }, } ","date":"2022-04-17","objectID":"/python_formatter/:1:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Yapf { ... \"python.formatting.provider\": \"yapf\", // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/yapf\", \"python.formatting.yapfPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/yapf\", ... \"python.formatting.yapfArgs\": [ \"--style\", \"google\", ], } ","date":"2022-04-17","objectID":"/python_formatter/:2:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Isort It helps to sort automatically whenever file is saved google import formatting guide vscode’s settings.json { ... \"python.sortImports.path\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/isort\", // or // \"python.sortImports.path\": \"${workspaceFolder}/.venv/bin/isort\", \"python.sortImports.args\": [ \"--settings-file=${workspaceFolder}/.isort.cfg\", ], ... } ${workspaceFolder}/.isort.cfg [settings] py_version=37 profile=google src_paths=api,common,core,infra,logs,tests,universe_z # 3 - Vertical Hanging Indent multi_line_output=3 include_trailing_comma=True force_single_line=False # profile google default # force_single_line: True # force_sort_within_sections: True # lexicographical: True # single_line_exclusions: ('typing',) # order_by_type: False # group_by_package: True readable references below isort options isort configs ","date":"2022-04-17","objectID":"/python_formatter/:3:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Pylint TODO: force to avoid string double quotes { ... \"python.linting.enabled\": true, \"python.linting.lintOnSave\": true, \"python.linting.pylintEnabled\": true, // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/pylint\", \"python.linting.pylintPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/pylint\", \"python.linting.pylintArgs\": [ \"--load-plugins\", \"pylint_django\", \"pylint_quotes\", // related string quotes ], ... } ","date":"2022-04-17","objectID":"/python_formatter/:4:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"IntelliSense general term for various code editing features including: code completion, parameter info, quick info, and member lists ","date":"2022-04-17","objectID":"/python_formatter/:5:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["go"],"content":"gin framework로 crud 서버를 만들며 배운 내용들을 기록해보겠습니다. ","date":"2022-02-12","objectID":"/ch03_real_world/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"TIL go에서는 모든 type을 나타내고자 할 때 비어진 interface를 사용합니다.(dynamic typing) gin-gonic/context.go // MustBindWith binds the passed struct pointer using the specified binding engine. // It will abort the request with HTTP 400 if any error occurs. // See the binding package. func (c *Context) MustBindWith(obj interface{}, b binding.Binding) error { if err := c.ShouldBindWith(obj, b); err != nil { c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck return err } return nil } ","date":"2022-02-12","objectID":"/ch03_real_world/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Update crud를 만들면 update 부분을 깔끔하게 짜는것이 신경쓰입니다. 아래는 todo에서 짜본 update 코드입니다. func UpdateTodo(c *gin.Context) { var todo models.Todo id := c.Params.ByName(\"id\") err := models.GetTodoById(\u0026todo, id) if err != nil { c.JSON(http.StatusNotFound, todo) } c.BindJSON(\u0026todo) err = models.UpdateTodo(\u0026todo, id) if err != nil { c.AbortWithStatus(http.StatusNotFound) } else { c.JSON(http.StatusOK, todo) } } c.BindJSON(\u0026todo)를 ","date":"2022-02-12","objectID":"/ch03_real_world/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"conclustion 프로젝트 일정이 다가와서, gin 공식문서는 대충보고 프로젝트를 1달동안 만들어보았습니다. https://github.com/ExchangeDiary/exchange-diary . 만들면서 배우는게 가장 재밌게 배울 수 있는 거 같아서 만족스럽습니다. - 끝 -","date":"2022-02-12","objectID":"/ch03_real_world/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Effective go 를 통해 go 핵심 문법을 빠르게 배워보겠습니다. 또한 나중에 레퍼런스 개념으로 개발할 때 찾아보기 위해서 필요해 보이는 정보들을 모으는 개념으로 글을 작성합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Formatting gofmt 패키지 아래 코드는 소스 파일이 아닌 패키지 레벨에서 실행됩니다. $ go fmt 들여쓰기 들여쓰기를 위해 탭(tabs)을 사용하며, gofmt는 기본값으로 탭을 사용한다. 만약 꼭 써야하는 경우에만 스페이스(spaces)를 사용하라. 한 줄 길이 Go는 한 줄 길이에 제한이 없다. 길이가 길어지는것에 대해 걱정하지 마라. 만약 라인 길이가 너무 길게 느껴진다면, 별도의 탭을 가지고 들여쓰기를하여 감싸라 괄호 Go는 C와 Java에 비해 적은 수의 괄호가 필요하다. 제어 구조들(if, for, switch)의 문법엔 괄호가 없다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Comment godoc package 주석 패키지에서 최상위 선언의 바로 앞에있는 주석이 그 선언의 문서주석으로 처리된다. 패키지 내부에서 최상위 선언 바로 이전의 주석은 그 선언을 위한 문서주석이다. 프로그램에서 모든 외부로 노출되는 (대문자로 시작되는) 이름은 문서주석이 필요하다. 첫 문장은 선언된 이름으로 시작하는 한 줄짜리 문장으로 요약되어야 한다. // Compile parses a regular expression and returns, if successful, // a Regexp that can be used to match against text. func Compile(str string) (*Regexp, error) { 패키지는 각각의 문서 주석을 패키지명과 함께 시작하기 때문에 만약 아래와 같은 명령을 터미널에 활용하면 효율적이다. $ godoc regexp | grep parse Compile parses a regular expression and returns, if successful, a Regexp parsed. It simplifies safe initialization of global variables holding cannot be parsed. It simplifies safe initialization of global variables ","date":"2022-02-07","objectID":"/ch02_go_basic/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Names ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Package Name Go에서는 이름의 첫 문자가 대문자인지 아닌지에 따라서 이름의 패키지 밖에서의 노출여부가 결정된다. package name 패키지가 임포트되면, 패키지명은 패키지 내용들에 대한 접근자가 된다. import \"bytes\" bytes.Buffer // usage 관례적으로, 패키지명은 소문자, 한 단어로만 부여하며 언더바(_)나 대소문자 혼용에 대한 필요가 없어야한다. 또 다른 규칙은 패키지명은 소스 디렉토리 이름 기반이라는 것이다. src/encoding/base64에 있는 패키지는 encoding/base64로 임포트가 된다. base64라는 이름을 가지고 있지만, encoding_base64나 encodingBase64를 쓰지 않는다. import .표현을 사용하지 말라. Package Naming Convention bufio 패키지에 있는 버퍼 리더는 BufReader가 아닌 Reader로 불린다. 왜냐하면 사용자는 이를 bufio.Reader로 보게되며, 이것이 더 명확하고 간결하기 때문이다. 게다가 임포트된 객체들은 항상 패키지명과 함께 불려지기 때문에 bufio.Reader는 io.Reader와 충돌하지 않는다. … 중략 … Go에 존재하는 ring.Ring이라는 구조체의 인스턴스를 만드는 함수는 보통은 NewRing으로 불릴테지만, Ring은 패키지 밖으로 노출된 유일한 타입이며, 패키지가 ring으로 불리기 때문에, 이 함수는 그냥 New라고 부르고 ring.New와 같이 사용한다. Comment is better than long naming 또 다른 간단한 예시는 once.Do이다. once.Do(setup)는 읽기가 쉬우며 once.DoOrWaitUntilDone(setup)으로 개선될게 없다. 긴 이름은 좀 더 쉽게 읽는것을 방해한다. 문서에 주석을 다는것이 긴 이름을 사용하는 것보다 더 좋을 것이다. 클린코드에서는 네이밍을 길게 가져가고 주석을 없애는, 즉 코드로 설명이 가능하도록 하자는 적략을 취하는데 Effective go를 쓴 저자는 무조건 짧은게 최고다는 느낌을 준다. 이러다 보니 history 차원이 아닌 설명을 위한 주석을 달때는 죄의식을 느꼈는데, 개인적으로 미니멀리즘을 좋아하니 go 방식이 더 끌리는 것 같다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Getter and Setter Go는 getters와 setters를 자체적으로 제공하지 않는다. getter and setter naming getter의 이름에 Get을 넣는건 Go언어 답지도, 필수적이지도 않다. 만약 owner(첫 문자가 소문자이며 패키지 밖으로 노출되지 않는다.)라는 필드를 가지고 있다면 getter 메서드는 GetOwner가 아닌 Owner(첫 문자가 대문자이며, 패키지 밖으로 노출됨)라고 불러야한다. … 중략 … 만약 필요하다면, setter 함수는 SetOwner라고 불릴 것이다 owner := obj.Owner() if owner != user { obj.SetOwner(user) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface 관례적으로, 하나의 메서드를 갖는 인터페이스는 메서드 이름에 -er 접미사를 붙이거나 에이전트 명사를 구성하는 방식을 사용한다. Reader Writer Formatter CloseNotifier … ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"MixedCaps go는 camelCase를 사용한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Semicolons C언어 처럼, Go의 정식문법은 구문을 종료하기 위하여 세미콜론을 사용한다. 하지만 C언어와는 달리 세미콜론은 소스상에 나타나지 않는다. 대신 구문분석기(lexer)는 간단한 규칙을 써서 스캔을 하는 과정에 자동으로 세미콜론을 삽입한다. 그래서 소스작성시 대부분 세미콜론을 사용하지 않는다. 세미콜론과 중괄호 세미콜론 입력규칙의 중요한 한가지는 제어문(if, for, switch, 혹은 select)의 여는 중괄호({)를 다음 라인에 사용하지 말아야 한다. // This is good if i \u003c f() { g() } // This sucks if i \u003c f() // wrong! { // wrong! g() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Control structures Go언어에서는 do 나 while 반복문이 존재하지 않으며, for, switch select가 존재한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"if 중괄호를 의무적으로 사용해야 하기 때문에, 다중 라인에서 if 구문들이 간단하게 작성된다. if x \u003e 0 { return y } if와 switch가 초기화 구문을 허용하므로 지역변수를 설정하기 위해 사용된 초기화 구문을 흔히 볼 수 있다. if err := file.Chmod(0664); err != nil { log.Print(err) return err } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Redeclaration and reassignment 먼저 아래의 코드를 보자 f, err := os.Open(name) d, err := f.Stat() 이런 경우처럼 err가 위/아래 곳 모두에서 사용되는데, 이런 선언 중복은 허용된다. Function variable Go언어에서 함수 파라미터와 리턴 값들은, 함수를 감싸고 있는 브래이스들(braces)밖에 위치해 있음에도, 그 스코프는 함수 body의 스코프와 동일하다는 점을 주목할 가치가 있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"for // C언어와 같은 경우 for init; condition; post { } // C언어의 while 처럼 사용 for condition { } // C언어의 for(;;) 처럼 사용 for { } 아래는 go-style for문들입니다. sum := 0 for i := 0; i \u003c 10; i++ { sum += i } 만약 배열, slice, string, map, 채널로 부터 읽어 들이는 반복문을 작성한다면, range 구문이 이 반복문을 관리가능합니다. for key, value := range oldMap { newMap[key] = value } 이렇게 index를 날릴수도 있습니다. for key := range m { if key.expired() { delete(m, key) } } UTF-8 파싱이 덜된 string의 경우 rune으로 변환된다. for pos, char := range \"日本\\x80語\" { // \\x80 은 합법적인 UTF-8 인코딩이다 fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos) } /* character U+65E5 '日' starts at byte position 0 character U+672C '本' starts at byte position 3 character U+FFFD '�' starts at byte position 6 character U+8A9E '語' starts at byte position 7 */ 다음은 parallel assignment를 사용한 for문이다. for i, j := 0, len(a) -1; i\u003cj; i,j = i+1, j-1 { a[i], a[j] = a[j], a[i] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Switch func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } go에서는 switch에 Label(예시에서는 Label)을 넣어서 escape하는 방식도 가끔이지만 쓰인다. Loop: for n := 0; n \u003c len(src); n += size { switch { case src[n] \u003c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \u003c sizeTwo: if n+1 \u003e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]\u003c\u003cshift) } } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Type switch 스위치 구문은 인터페이스 변수의 동적 타입을 확인하는데 사용될 수도 있다. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Functions ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Multiple return values 값과 에러를 같이 내리는 signature func (file \\*File) Write(b []byte) (n int, err error) index와 value를 return func nextInt(b []byte, i int) (int, int) { for ; i \u003c len(b) \u0026\u0026 !isDigit(b[i]); i++ { } x := 0 for ; i \u003c len(b) \u0026\u0026 isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Named result parameters Go 함수에서는 반환 “인자\"나 결과 “인자\"에 이름을 부여하고 인자로 들어온 매개변수처럼 일반 변수로 사용할 수 있다. 이름을 부여하면, 해당 변수는 함수가 시작될 때 해당 타입의 제로 값으로 초기화 된다. func nextInt(b []byte, pos int) (value, nextPos int) { } return parameter는 선언되기 때문에 다음과 같이 사용될 수도 있다. func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) \u003e 0 \u0026\u0026 err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } return } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Defer Go 의 defer 문은 defer 를 실행하는 함수가 반환되기 전에 즉각 함수 호출(연기된 함수)을 실행하도록 예약한다. 이를 통해 기존의 언어가 자원 해제를 context를 사용했던 것과 달리 defer라는 키워드를 통해서 자원 해지가 가능해진다. (python에서는 with을 사용해서 context가 끝날때 exit 호출을 처리해 주었다.) 다음은 mutex에 lock을 풀거나 잠그는 코드입니다. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(resut, buf[0:n]...) if err != nil { if err == io.EOF { break } return \"\", err } } return string(result), nil } close를 delay 시킴으로써 크게 2가지 장점을 얻게된다. 파일을 닫는 것을 잊어버리는 실수를 하지 않도록 보장해 준다. open 근처에 close 가 위치하면 함수 맨 끝에 위치하는 것 보다 훨씬 명확한 코드가 되는것을 의미한다. defer는 함수가 종료될 때 실행되기 때문에 하나의 defer 호출 위치에서 여러개의 함수 호출을 delay 시킬 수 있다. for i:=0; i \u003c 5; i++ { defer fmt.Println(i) } 지연된 함수는 LIFO 순서로 실행된다. (4 3 2 1 0) (와우 궁금했던 부분인데) 추가로 defer안에 인자들에 대한 평가는 기존 함수 실행 순서에 따라 진행된다. 다음은 조금 더 복잡한 defer 예시이다. func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } 위 함수들에 대한 결과는 아래와 같다. entering: b in b entering: a in a leaving: a leaving: b 나중에 나올 panic 과 recover를 사용하면 더욱 멋진 것들을 만들 수 있다고 한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Data ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with new Go에는 메모리를 할당하는 두가지 기본 방식이 있는데, 내장(built-in) 함수인 new와 make이다. new: 새로 제로값으로 할당된 타입 T를 가리키는 포인터를 반환 new(File) == \u0026File{} make: 내부 데이터 구조를 초기화하고 사용될 값을 준비한다. 먼저 new부터 살펴보면, 내장 함수로 메모리를 할당하지만 다른 언어에 존재하는 같은 이름의 기능과는 다르게 메모리를 초기화하지 않고, 단지 값을 제로화(zero) 한다. 다시 말하면, new(T)는 타입 T의 새로운 객체에 제로값이 저장된 공간(zeroed storage)을 할당하고 그 객체의 주소인, *T값을 반환한다. 제로값의 유용함은 전이적인(transitive) 특성이 있다. type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } p := new(SyncedBuffer) // type *SyncedBuffer var v SyncedBuffer // type SyncedBuffer ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constructors and composite literals(합성 리터럴) 때로 제로값만으로는 충분치 않고 생성자(constructor)로 초기화해야 할 필요가 생긴다. 먼저 불필요한 boiler plate 코드 부터 확인해보자. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } 아래는 constructor를 활용한 방식이다. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := File{fd, name, nil, 0} return \u0026f } C와는 달리, 로컬 변수의 주소를 반환해도 아무 문제가 없음을 주목하라; 변수에 연결된 저장공간은 함수가 반환해도 살아 남는다. 실제로, 합성 리터럴의 주소를 취하는 표현은 매번 실행될 때마다 새로운 인스턴스에 연결된다. 그러므로 마지막 두 줄을 묶어 버릴 수 있다. return \u0026File{fd, name, nil, 0} 합성 리터럴의 필드들은 순서대로 배열되고 반드시 입력해야 한다. 하지만, 요소들에 레이블을 붙여 필드:값 식으로 명시적으로 짝을 만들면, 초기화는 순서에 관계 없이 나타날 수 있다. 입력되지 않은 요소들은 각자에 맞는 제로값을 갖는다. 그러므로 아래와 같이 쓸 수 있다. return \u0026File{fd: fd, name: name} Composite literals(합성 리터럴)이란? Composite literals are used to construct the values for arrays, structs, slices, and maps a := [...]string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // array s := []string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // slice m := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // map ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with make new와 달리 make는 slices, maps, 그리고 channels에만 사용하고 (*T가 아닌) 타입 T의 (제로값이 아닌) 초기화된 값을 반환한다. 아래는 new와 make의 차이점을 보여준다. var p *[]int = new([]int) // slice 구조체를 할당한다; *p == nil; 거의 유용하지 않다 var v []int = make([]int, 100) // slice v는 이제 100개의 int를 갖는 배열을 참조한다 // 불필요하게 복잡한 경우: var p *[]int = new([]int) *p = make([]int, 100, 100) // Go 언어다운 경우: v := make([]int, 100) make는 maps, slices 그리고 channels에만 적용되며 포인터를 반환하지 않음을 기억해야 합니다. 포인터를 얻고 싶으면 new를 사용해서 메모리를 할당하거나 변수의 주소를 명시적으로 취해야 합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Arrays Go와 C에서는 배열의 작동원리에 큰 차이가 있다. Go에서는, 배열은 값이다. 한 배열을 다른 배열에 assign할 때 모든 값이 복사된다. 함수의 argument로 배열을 패스하면, 포인터가 아닌 copy된 array를 받는다. 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다. 개인적으로 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다.가 무슨 말인지 잘 모르겠다. 배열을 값(value)으로 사용하는 것이 유용할 수도 있지만 또한 비용이 큰 연산이 될 수도 있다; 만약 C와 같은 실행이나 효율성을 원한다면, 아래와 같이 배열 포인터를 보낼 수도 있다. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\u0026array) // 명시적인 주소 연산자(\u0026)를 주목하라. 하지만 이런 스타일조차 Go언어 답지는 않다. 대신 slice를 사용하라. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Slices Go에서는 변환 메스릭스와 같이 뚜렷한 차원(dimension)을 갖고 있는 항목들을 제외하고는, 거의 모든 배열 프로그래밍은 단순한 배열보다는 slice를 사용한다. Slice는 내부의 배열을 가리키는 레퍼런스를 쥐고 있어, 만약에 다른 slice에 할당(assign)되어도, 둘 다 같은 배열을 가리킨다. 함수가 slice를 받아 그 요소에 변화를 주면 호출자도 볼 수 있는데, 이것은 내부의 배열를 가리키는 포인터를 함수에 보내는 것과 유사하다. slice의 용량은, 내장함수 cap을 통해 얻을 수 있는데, slice가 가질 수 있는 최대 크기를 보고한다. 아래를 보면 slice에 데이터를 부착(append)할 수 있는 함수가 있다. 만약 데이터가 용량을 초과하면, slice의 메모리는 재할당된다. 결과물인 slice는 반환된다. func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } slice는 꼭 처리후 반환되어야 한다. Append가 slice의 요소들을 변경할 수 있지만, slice 자체(포인터, 크기, 용량을 갖고 있는 런타임 데이터 구조)는 값으로 패스되었기 때문이다. 참고로 slice에는 append가 구현되어있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Two-dimensional slices 다음은 go에서 이차원 slices 또는 배열을 정의하고 init하는 방법입니다. type Transform [3][3]float64 type LinesOfText [][]byte text := LinesOfText{ []byte(\"Leoo is awesome\"), []byte(\"Life is fun\"), []byte(\"Life is full of love\"), []byte(\"Let's give our love and fire to the world\") } 예를 들어 사진을 스캔하는 상황이 온다면 2가지 방식으로 이를 해결할 수 있다. 일반적으로 2차원 배열을 만들어 사용하는 방식 height := 300 width := 300 picture := make([][]uint8, height) for i:= range picture { picture[i] = make([]uint8, width) } 하나의 긴 slice에 width만큼 자르면서 이차원 배열에 포인터를 전달하는 방식 picture := make([][]uint8, height) pixels := make([]uint8, width * height) for i := range picture { picture[i], pixels = pixels[:width], pixels[width:] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:6","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Maps {key: value} key는 equality연산이 정의되어 있는 어떤 타입이라도 가능하다. int float string pointer interface(equality 구현된) structs array slice의 경우에는 map의 key로 사용이 될 수 없는데, 이유는 equality가 정의되어 있지 않기 때문이다. 왜 slice에는 equality가 없을까? go에 제시되었던 issue 에 레퍼런스된 slice equality에 대한 golang discussion 링크 를 보면서 일부분을 정리하면, slice가 value로 비교해야할지, pointer타입으로 비교해야할지 혼돈을 줄 수 있기 때문이라고 합니다. This would probably introduce unnecessary confusion. People are used to the equality operator comparing values in go, as opposed to references. It’s much better if the slices finally support the equality operator, even though the comparison speed will depend on the number of items in the slices. Slice와 마찬가지로 map 역시 내부 데이터 구조를 가진다. 함수에 map을 입력하고 map의 내용물을 변경하면, 그 변화는 호출자에게도 보인다. Map 또한 콜론으로 분리된 key-value 짝을 이용한 합성 리터럴로 생성될 수 있으며, 초기화중에 쉽게 만들 수 있다. var timeZone = map[string]int{ \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60, } offset := timeZone[\"EST\"] go는 keyError를 내지 않고 타입별로 0을 의미하는 값을 리턴한다. 그러므로 아래와 같은 경우가 가능하다. attended := map[string]bool{ \"Ann\": true, \"Joe\": true, ... } if attended[person] { // 만약 person이 맵에 없다면 false일 것이다. fmt.Println(person, \"was at the meeting\") } 만약 value가 bool인 경우같이 keyError와 value(false)를 구분하고 싶다면 아래와 같이한다. 이것을 “comma ok” 관용구라고 부른다. 이 예제에서, 만약 tz가 있다면, seconds는 적절히 세팅될 것이고 ok는 true가 된다 var seconds int var ok bool seconds, ok = timeZone[tz] 다음은 에러헨들링 하는 방식이다. func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\"unknown time zone:\", tz) return 0 } 값이 필요없다면 이렇게 한다. _, present := timeZone[tz] Map의 엔트리를 제거하기 위해서는, 내장 함수 delete을 쓰는데, map과 제거할 key를 인수로 쓴다. map에 key가 이미 부재하는 경우에도 안전하게 사용할 수 있다. delete(timeZone, \"PDT\") // Now on Standard Time ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:7","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Printing 정수(integer)를 소수로 바꾸는 예와 같은 기본적인 변환을 원할 경우는, 다목적 용도 포맷인 %v(value라는 의미로)를 사용할 수 있다 fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) // map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200] 물론, map의 경우 key들은 무작위로 출력될 수 있다. struct를 출력할 때는, 수정된 포맷인 %+v를 통해 구조체의 필드에 주석으로 이름을 달며, 대안 포맷인 %#v를 사용하면 어떤 값이든 완전한 Go 문법을 출력한다. type T struct { a int b float64 c string } t := \u0026T{ 7, -2.35, \"abc\\tdef\" } fmt.Printf(\"%v\\n\", t) fmt.Printf(\"%+v\\n\", t) fmt.Printf(\"%#v\\n\", t) fmt.Printf(\"%#v\\n\", timeZone) \u0026{7 -2.35 abc def} \u0026{a:7 b:-2.35 c:abc def} \u0026main.T{a:7, b:-2.35, c:\"abc\\tdef\"} map[string] int{\"CST\":-21600, \"PST\":-28800, \"EST\":-18000, \"UTC\":0, \"MST\":-25200} 또 다른 유용한 포맷은 %T로, 값의 타입을 출력한다. fmt.Printf(\"%T\\n\", timeZone) // map[string] int 커스텀 타입 print 포맷 지정하는 방법 커스텀 타입의 기본 포맷을 조종하기 위해 해야할 것은 단지 String() string의 시그너처를 갖는 메서드를 정의해 주는 것이다. (위에 정의된) 단순한 타입 T는 아래와 같은 포맷을 가질 수 있다. func (t *T) String() string { return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c) } fmt.Printf(\"%v\\n\", t) // 7/-2.35/\"abc\\tdef\" 위에 예제에서 struct 타입에 포인터를 사용한 이유는 더 효율적이고 Go 언어다운 선택이기 때문이다. String 메서드가 Sprintf를 호출할 수 있는 이유는 print 루틴들의 재진입(reentrant)이 충분히 가능하고 예제와 같이 감싸도 되기 때문이다. 하지만 이 방식에 대해 한가지 이해하고 넘어가야 하는 매우 중요한 디테일이 있는데: String 매서드를 만들면서 Sprintf를 호출할 때 다시 String 매서드로 영구히 재귀하는 방식은 안 된다는 것이다. Sprintf가 리시버를 string처럼 직접 출력하는 경우에 이런 일이 발생할 수 있는데, 그렇게 되면 다시 같은 메서드를 호출하게 되고 말 것이다. 흔하고 쉽게 하는 실수로, 다음의 예제에서 살펴보자. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", m) // 에러: 영원히 재귀할 것임. } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 해결책은 string() 시켜주면 된다. 인수를 기본적인 문자열 타입으로 변환하면, 같은 메서드가 없기 때문이다. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", string(m)) } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 또 다른 출력 기법으로는 출력 루틴의 인수들을 직접 또 다른 유사한 루틴으로 대입하는 것이다. Printf의 시그너처는 마지막 인수로 임의적인 숫자의 파라미터가 포맷 다음에 나타날 수 있음을 명시하기 위해 타입 ...interface{}를 사용한다. // Println 함수는 fmt.Println처럼 표준 로거에 출력한다. func Println(v ...interface{}) { std.Output(2, fmt.Sprintln(v...)) // Output 함수는 (int, string) 파라미터를 받게된다. } log.Println(\"Hello\", \"世界\", 1, 2, 3, 4, 5, 6, 7, 8) // 2009/11/10 23:00:00 Hello 世界 1 2 3 4 5 6 7 8 Sprintln을 부르는 중첩된 호출안에 v 다음에 오는 ...는 컴파일러에게 v를 인수 리스트로 취급하라고 말하는 것이고; 그렇지 않은 경우는 v를 하나의 slice 인수로 대입한다. ... 파라미터는 특정한 타입을 가질 수도 있는데, 예로 integer 리스트에서 최소값을 선택하는 함수인 min에 대한 ...int를 살펴보자 func Min(a ...int) int { min := int(^uint(0) \u0026gt; \u0026gt; 1) // wtf???? for _, i := range a { if i \u003c min { min = i } } return min } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:8","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Append go에 내장되어있는 append 함수의 signature는 다음과 같다. // slice는 func append(slice []T, elements ...T) []T 기본적인 사용법 x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) slice 끼리 append x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:9","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Initialization ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constants 상수는 -함수 내에서 지역적으로 정의된 상수조차도- 컴파일할 때 생성되며, 아래 중 하나가 되어야 한다. 숫자(number) 문자(rune) 문자열(string) 참/거짓(boolean) 상수를 정의하는 표현식은 컴파일 타임에 실행가능한 constant expression이어야 한다. 예를 들어 1\u003c\u003c3은 상수 표현식이지만 math.Sin(math.Pi/4)는 상수 표현식이 아니다. math 패키지의 Sin 함수에 대한 호출이 런타임 시에만 가능하기 때문이다. type ByteSize float64 const ( _ = iota // 공백 식별자를 이용해서 값인 0을 무시 KB ByteSize = 1 \u003c\u003c (10 * iota) MB GB TB PB EB ZB YB ) func (b ByteSize) String() string { switch { case b \u003e= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b \u003e= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b \u003e= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b \u003e= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b \u003e= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b \u003e= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b \u003e= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b \u003e= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) } return fmt.Sprintf(\"%.2fB\", b) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Variables 변수의 초기화는 상수와 같은 방식이지만, 초기화는 런타임에 계산되는 일반적인 표현식이어도 된다. var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\") ) ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"init() 최종적으로, 각 소스파일은 필요한 어떤 상태든지 셋업하기 위해서 각자의 init 함수를 정의할 수 있다. 여기서 “최종적으로” 라는 말은 정말로 마지막을 가리킨다: init 함수는 모든 임포트된 패키지들이 초기화되고 패키지 내의 모든 변수 선언이 평가된 이후에 호출된다. 선언의 형태로 표현할 수 없는 것들을 초기화하는 것 외에도, init 함수는 실제 프로그램의 실행이 일어나기 전에 프로그램의 상태를 검증하고 올바르게 복구하는데 자주 사용된다. init init 함수는 매개변수를 가지지 않으며, 각 파일은 여러 개의 init 함수를 가질 수 있다 func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath may be overridden by --gopath flag on command line. flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Methods ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Pointer vs Value 이전에 만들었던 append 함수와 비교하며 새로운 append 함수를 정의해보자. 들어가기 앞서 앞전에 만들었던 Append 부터 다시 살펴보자 func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } 자 이제 append함수를 슬라이스의 메서드로 재정의 하는 방법 type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { ... 이전과 동일 ... } 위와 같이 할 경우, 값을 return해서 재할당 시켜줘야한다. 이를 피하기 위해 포인터를 사용할 수도 있다. func (p *ByteSlice) Append(data []byte) { slice := *p // 함수 내용은 위와 같지만, return이 없다. *p = slice } 마지막으로 표준 write 메서드 처럼 구현을 해보면 더 멋진 코드를 만들 수 있다. func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p // 내용은 위와 같다. *p = slice return len(data), nil } 타입 *ByteSlice는 표준 인터페이스 io.Writer를 따르게되며, 다루기가 편해진다. 예를 들면, 다음처럼 ByteSlice에 값을 넣을 수 있다. var b ByteSlice fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) ByteSlice의 주소만 넘긴 이유는, 오직 포인터 타입인 *ByteSlice만이 io.Writer 인터페이스를 만족시키기 때문이다. 리시버로 포인터를 쓸 것인가 값을 쓸 것인가에 대한 규칙은 값을 사용하는 메서드는 포인터와 값에서 모두 사용할 수 있으며, 포인터 메서드의 경우 포인터에서만 사용이 가능하다는 것이다. 이러한 규칙은 포인터 메서드는 리시버를 변형시킬 수 있는데 메서드를 값에서 호출하게 되면 값의 복사본을 받기 때문에 원래값을 변형할 수 없기 때문에 생겨났다. Go언어는 이러한 실수(값에서 포인터 메서드를 실행하는 일)를 허용하지 않는다. 하지만 편리한 예외도 있다. 주소를 얻을 수 있는 값의 경우에, Go언어는 포인터 메서드를 값 위에서 실행할 경우 자동으로 주소 연산을 넣어준다. 위의 예시에서, 변수 b는 주소로 접근이 가능하기 때문에 단순히 b.Write만으로 Write메서드를 호출할 수 있다. 컴파일러는 이것을 (\u0026b).Write로 재작성할 것이다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface Go언어의 인터페이스는 객체의 행위(behavior)를 지정해 주는 하나의 방법이다: 만약 어떤 객체가 정해진 행동를 할 수 있다면 호환되는 타입으로 쓸 수 있다는 뜻이다. (Duck typing, Go는 런타임에 duck typing하는 파이썬과 달리 Compile time duck typing이 가능하므로, 성능의 문제가 없다) 인터페이스의 이름(명사)은 보통 메서드(동사)에서 파생된다: Write 메서드를 구현하면 io.Writer가 인터페이스의 이름이 되는 경우. 타입은 복수개의 인터페이스를 구현할 수 있다. sort.Interface 와 Stringer 두개의 interface를 구현하는 타입의 예시를 보자면 아래와 같다. sort.Interface type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } Stringer type Stringer interface { String() string } sort.Interface와 Stringer를 만족하는 type type Sequence []int // sort.Interface func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \u003c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } // Stringer func (s Sequence) String() string { sort.Sort(s) // Sequence 타입은 []int와 네이밍 외에는 모두같은 타입이기 때문에 변환 가능하다. return fmt.Sprint([]int(s)) // type converted (Sequence -\u003e []int) } 위의 코드의 Len(), Less(), Swap() 함수는 실제로, sort.Sort()에 들어가는 sort.Interface를 만족시키기 위해 사용하기 위해 작성된 메서드들이다. 그러므로 아래와 같이 간단하게 코드를 간소화 시킬 수 있다. type Sequence []int func (s Sequence) String() string { sort.IntSlice(s).Sort() return fmt.Spring([]int(s)) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface conversions and type assertions 타입 스위치는 Interface conversions(변환)의 한 형태이다: 인터페이스를 받았을 때, switch문의 각 case에 맞게 타입 변환을 한다 아래 예제는 fmt.Printf가 타입 스위치를 써서 어떻게 주어진 값을 string으로 변환시키는 지를 단순화된 버전으로 보여 주고 있다. 만약에 값이 이미 string인 경우는 인터페이스가 잡고 있는 실제 string 값을 원하고, 그렇지 않고 값이 String 메서드를 가지고 있을 경우는 메서드를 실행한 결과를 원한다. type Stringer interface { String() string } var value interface{} switch str := value.(type) { case string: return str case Stringer: return str.String() } 오로지 한 타입만에만 관심이 있는 경우는 어떨까? 만약 주어진 값이 string을 저장하는 걸 알고 있고 그냥 그 string 값을 추출하고자 한다면? 단 하나의 case만을 갖는 타입 스위치면 해결 할 수 있지만 타입 단언 표현을 쓸 수도 있다. Type Assertion(타입 단언)은 인테페이스 값을 가지고 지정된 명확한 타입의 값을 추출한다. 문법은 타입 스위치를 열 때와 비슷하지만 type 키워드 대신 명확한 타입을 사용한다 //value.(typeName) str := value.(string) 여기에서 typeName은 static type이다. 만약 위의 예시에서 value가 string 타입을 가지고 있지 않을 경우, 프로그램은 런타임 에러를 내고 죽는다. 이런 참사에 대비하기 위해서, “comma, ok” 관용구를 사용하여 안전하게 값이 string인지 검사 해야 한다. str, ok := value.(string) if ok { fmt.Printf(\"string value is: %q\\n\", str) } else { fmt.Printf(\"value is not a string\\n\") } 아래는 위에서 보여준 타입 스위치와 동일한 기능을 하는 if-else문 예시이다. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Generality 만약 어떤 타입이 오로지 인터페이스를 구현하기 위해서만 존재한다면, 즉 인터페이스외 어떤 메서드도 외부에 노츨시키지 않은 경우, 타입 자체를 노출 시킬 필요가 없다. 그런 경우에, constructor는 구현 타입보다는 인터페이스 값을 반환해야 한다. 설명에 좋은 예시가 있어 인용하자면 Quote 각종 crypto 패키지내의 스트리밍 cipher 알고리즘들을, 이들이 연결해 쓰는 block cipher들로 부터 분리시킬 수 있다. crypto/cipher 패키지내 Block 인터페이스는 한 block의 데이터를 암호화하는 block cipher의 행위를 정의한다. 그런 다음, bufio 패키지에서 유추해 볼 수 있듯이, Block 인터페이스를 구현하는 cipher 패키지들은, Stream 인터페이스로 대표되는 스트리밍 cipher들을 건설할 때, block 암호화의 자세한 내용을 알지 못하더라도, 사용될 수 있다. type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) } type Stream interface { XORKeyStream(dst, src []byte) } block cipher를 스트리밍 cipher로 바꾸어 주는 카운터 모드 (CTR) 스트림의 정의가 있다. 주의해야할 점은 input과 output이 모두 interface 타입이다. // NewCTR은 카운더 모드로 주어진 Block을 이용하여 암호화하고/해독하는 스트림을 반환한다. // iv의 길이는 Block의 block 크기와 같아야 한다. func NewCTR(block Block, iv []byte) Stream ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interfaces and methods Quote Since almost anything can have methods attached, almost anything can satisfy an interface. 거의 모든 것에 메서드를 첨부할 수 있다는 말은 거의 모든 것이 인터페이스를 만족 시킬 수 있다는 말이기도 합니다. 심지어 함수에도 메서드를 첨부시킬 수 있다. 대표적인 예가 http 패키지이다. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ... // 단순한 카운터 서버. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr) } ... import \"net/http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) ... // 채널이 매 방문마다 알린다. // (아마 이 채널에는 버퍼를 사용해야 할 것이다.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \u003c- req fmt.Fprint(w, \"notification sent\") } // 마지막으로, 서버를 구동할 때 사용한 명령줄 인수들을 /args에 보여주려는 경우를 상상해 보자. // 명령줄 인수를 출력하는 함수를 쓰는 것은 간단하다. func ArgServer() { fmt.Println(os.Args) } 이것을 어떻게 HTTP 서버로 바꿀 수 있을까? 어떤 타입에다가 값은 무시하면서 ArgServer를 메서드로 만들 수 있을 것이다. 하지만 더 좋은 방법이 있다. 포인터와 인터페이스만 빼고는 어떤 타입에도 메서드를 정의할 수 있는 사실을 이용해서, 함수에 메서드를 쓸 수 있다. http 패키지에 다음과 같은 코드가 있다: // HandlerFunc는 어뎁터로써 평범한 함수를 HTTP handler로 쓸 수 있게 해 준다. // 만약에 f가 적절한 함수 signature를 가지면, // HandlerFunc(f)는 f를 부르는 Handler 객체인 것이다. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc는 ServeHTTP라는 매서드를 같는 타입으로, 이 타입의 값은 HTTP request에 서비스를 제공한다. 메서드의 구현을 한번 살펴 보자. 리시버는 함수, f이고 메서드가 f를 부른다. 이상해 보일 수도 있지만, 리시버가 채널이고 메서드가 채널에 데이터를 보내는 예와 비교해도 크게 다르지 않다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"The blank identifier https://gosudaweb.gitbooks.io/effective-go-in-korean/content/the_blank_identifier.html ","date":"2022-02-07","objectID":"/ch02_go_basic/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"conclustion [2022-02-08T19:21:29+09:00] effective go로 공부하니까, 문서가 정말 좋긴한데, 예상보다 몇시간은 더 걸렸던 것 같습니다. 하지만 양질의 정보를 이렇게 빠르게 읽을 수 있어서 유익한 시간인 것 같네요. - 끝 -","date":"2022-02-07","objectID":"/ch02_go_basic/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Go at Google: Language Design in the Service of Software Engineering 를 기반으로Go에 녹아있는 배경/철학을 분석합니다. 이후 사용되는 필드들을 정리하고 학습에 도움되는 best practice 레퍼런스들을 정리합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"tl;dr Go is a compiled, concurrent, garbage-collected, statically typed language developed at Google ","date":"2022-02-05","objectID":"/ch01_go_design/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Introduction 웹 서비스가 많아지고 컴퓨터 환경이 발전하면서 관리해야 할 코드와 서비스가 많아졌고 이를 효율적으로 관리하기 위해 go는 만들어졌습니다. 공식문서의 go 디자인 레퍼런스를 발견해, 이를 토대로 분석글을 작성합니다.Go at Google: Language Design in the Service of Software Engineering 추가로 FAQ 를 참조하였습니다. go를 개발한 이유 The Go programming language was conceived in late 2007 … 중략 … mostly C++, Java, and Python, had been created … 중략 … We were not alone in our concerns. After many years with a pretty quiet landscape for programming languages, Go was among the first of several new languages—Rust, Elixir, Swift, and more—that have made programming language development an active, almost mainstream field again. … 중략 … The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today’s server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. go는 2007년에 만들어졌습니다. 이 당시의 언어로써는 다음과 같은 문제들을 해결하기 어려웠기 때문에 go를 개발하기 시작했다고 보입니다. multicore processors 고려 개발자들의 수요 증가(코드의 scale 증가 -\u003e 깔끔한 코드 니즈 증가) 서버 scale increase build time too long 이때는 참고로 Rust, Elixir, Swift 같은 대안 언어들이 없었다고 합니다. go 디자인 목표 Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go’s design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. built-in concurrency garbage collection dependency management adaptability of software architecture google at go The goals of the Go project were to eliminate the slowness and clumsiness of software development at Google, and thereby to make the process more productive and scalable. The language was designed by and for people who write—and read and debug and maintain—large software systems. 구글의 현존하는 수많은 legacy 코드들과 앞으로 늘어날 코드들을 효율적으로 관리하기 위해서 go를 개발하기 시작했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Pain points 아래는 go를 만들 때 고려되었던 pain point들입니다. slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds ","date":"2022-02-05","objectID":"/ch01_go_design/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"c.f go는 왜 { }를 사용하나요? 안정성과 신뢰성을 위해 python style indentation 편의성을 포기하고 {}를 그래도 도입함. go는 왜 중괄호를 사용하나요? Our position is therefore that, although spaces for indentation is nice for small programs, it doesn’t scale well, and the bigger and more heterogeneous the code base, the more trouble it can cause. It is better to forgo convenience for safety and dependability, so Go has brace-bounded blocks. 구글이 가진 노하우에 따르면 작은 프로그램에서는 python의 indentation이 좋지만, 코드 기반이 클수록 \u0026 cross-language build 환경에서는 python 스타일이 좋지 않기 때문에 { }를 그대로 쓰기로 결정했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Dependencies in Go go가 의존성을 대하는 전략에 대해서 정리합니다. 아래와 같은 c의 guard기능으로 인해 불필요하게 의존성을 읽어들이는 현상이 발생했습니다. /* Large copyright and licensing notice */ #ifndef _SYS_STAT_H_ #define _SYS_STAT_H_ /* Types and other definitions */ #endif Note The first step to making Go scale, dependency-wise, is that the language defines that unused dependencies are a compile-time error (not a warning, an error). … 중략 … This guarantees by construction that the dependency tree for any Go program is precise, that it has no extraneous edges. That, in turn, guarantees that no extra code will be compiled when building the program, which minimizes compilation time. 구글 같이 코드 베이스가 많은 경우, 빌드타임이 오래걸리는 것은 업무의 효율성을 떨어뜨리기 때문에 go에서는 사용하지 않는 dependency들에 대해서 compile-time error를 뱉어내도록 하고 있습니다. 더 나아가서 go는 include of include file와 같은 상황에도 효율적인 전략을 취하고 있습니다. package A imports package B; package B imports package C; package A does not import package C 다음과 같이 A에서 B를 직접 참조하고, C는 간접적으로 참조하는 상황이 있을 때, go 컴파일러는 2가지 전략을 취합니다. C -\u003e B -\u003e A 순으로 compile한다. A에서 B를 참조할 때, 컴파일 시 생성된 B Object 파일에 B public interface가 영향받을 dependency들의 type information을 넣어둔다. Note In other words, when B is compiled, the generated object file includes type information for all dependencies of B that affect the public interface of B. 예를 들어서 A에서 B안에 들어있는 I/O package를 import하고, B안에 들어있는 I/O 패키지는 C에 정의되어있는 buffered I/O를 사용해서 구현(implementation)되어있을 때, C -\u003e B -\u003e A 순으로 컴파일되면서 link됩니다. 이때 A가 컴파일될 때 컴파일러는 B의 Object file을 읽어(주의! 소스코드를 읽는게 아님)들이는데, 이때 해당 파일에는 A에서 import B를 실행할 때 컴파일러에 필요한 필요한 모든 타입 정보가 들어있습니다. This is, of course, reminiscent of the Plan 9 C (as opposed to ANSI C) approach to dependency management, except that, in effect, the compiler writes the header file when the Go source file is compiled 이런 종속성 관리 접근 방식은 Plan 9 C(ANSI C와 반대) 접근 방식과 유사하며, 단 실제로 Go 소스 파일이 컴파일될 때 컴파일러가 헤더 파일을 작성해 준다는 점만 다릅니다. Note To make compilation even more efficient, the object file is arranged so the export data is the first thing in the file, so the compiler can stop reading as soon as it reaches the end of that section. 참고로 컴파일 할 때 고언어 컴파일러는 export할 data를 Object file 맨 앞단에 위치시켜서 export 해줄 정보만 빠르게 찾아볼 수 있도록 구현되어 있다고 합니다. Note Go places the export data in the object file; some languages require the author to write or the compiler to generate a second file with that information. That’s twice as many files to open. In Go there is only one file to open to import a package. Also, the single file approach means that the export data (or header file, in C/C++) can never go out of date relative to the object file. 또한 export data를 object파일에 위치시키기 때문에 import package시킬 때, 컴파일러는 파일 당 하나의 object 파일만 읽어들이면 되며 부가적으로 관리해야 할 포인트가 하나로 줄어든다는 장점이 있습니다. Note Another feature of the Go dependency graph is that it has no cycles. …중략… The lack of circular imports causes occasional annoyance but keeps the tree clean, forcing a clear demarcation between packages. As with many of the design decisions in Go, it forces the programmer to think earlier about a larger-scale issue (in this case, package boundaries) that if left until later may never be addressed satisfactorily. 마지막으로 go언어는 circular import(= cyclic import)를 컴파일 타임에 에러를 내 줌으로써 효율적인 package boundaries에 대해서 개발자가 고민할 수 있도록 해줍니다. 이런 방식들을 통해 go는 기존 언어보다 획기적으로 build time을 줄일 수 있었습니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Packages Note It’s important to recognize that package paths are unique, but there is no such requirement for package names. The path must uniquely identify the package to be imported, while the name is just a convention for how clients of the package can refer to its contents. The package name need not be unique and can be overridden in each importing source file by providing a local identifier in the import clause. These two imports both reference packages that call themselves package log, but to import them in a single source file one must be (locally) renamed: package의 path는 unique해야 합니다. package name은 unique할 필요없으며, 중복 될 경우 이를 사용하는(import) 영역에서 naming을 override해서 사용합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"remote package 개인적으로 신기했던 부분인데, go에서는 import 해주는 package path가 url이 될 수도 있습니다. 예를 들어서 github에서 doozer 패키지를 가져오고 싶으면 아래와 같이 해주면 됩니다. $ go get github.com/4ad/doozer // Shell command to fetch package import \"github.com/4ad/doozer\" // Doozer client's import statement var client doozer.Conn // Client's use of package 이렇게 한번 fetch(package를 install)해주면 그 다음부터는 일반적인 package와 마찬가지로 import 해주면 됩니다. 이런 방식을 도입함으로써 explicit하게 dependencies들을 보여줄 수 있게 되었습니다. Note Also, the allocation of the space of import paths is delegated to URLs, which makes the naming of packages decentralized and therefore scalable, in contrast to centralized registries used by other languages. 또한 URL로 allocation of the space of import paths가 위임됨으로써, package의 naming이 decentralized \u0026 scalable하게 만들었습니다. (저는 allocation of the space of import paths라는 뜻을 url의 unique한 장점을 package path로 그대로 가져와서 global하게 unique한 decentralized system을 만들었다고 이해했습니다.) ","date":"2022-02-05","objectID":"/ch01_go_design/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Syntax Go was therefore designed with clarity and tooling in mind, and has a clean syntax. go declaration(선언) 문법중에서 C 스타일 프로그래머들을 놀라게 하는 부분이 있습니다. go style var fn func([]int) int type T struct { a, b int } c style int (*fn)(int[]); struct T { int a, b; } The declared name appears before the type and there are more keywords. 이런 Declarations introduced by keyword 문법은 Pascal에 더 가깝다고 합니다. 이를 통해 개발자는 더 수월하게 코드 분석이 가능하며, type syntax를 가지는 것이 C언어 같이 expression syntax 보다 컴퓨터가 parsing 성능에 상당히 더 유리하다고 합니다. go는 type syntax라는 문법을 추가해서 코드가 늘어나지만, 이를 통해 모호성을 제거하였습니다. 단 편의를 위해 go에서는 var 키워드를 삭제하고 :=라는 키워드를 관용적으로 사용합니다. var buf *bytes.Buffer = bytes.NewBuffer(x) // explicit buf := bytes.NewBuffer(x) // derived 마지막으로 Go에서는 default function arguments를 의도적으로 누락시켰습니다. 기본 인자가 가지는 모호성으로 코드를 사용하는 부분이 명시적이지 못할 경우가 많다는 단점이 있기 때문입니다. 물론 같은 네이밍을 가질 함수가 가질 수 있는 모든 interface(function signature)를 구현해줘야 한다는 단점을 가지긴합니다. 아래는 go에서 함수 / 메서드를 표현하는 방법입니다. 코트린 처럼 fun을 키워드로 가졌으면 더 좋았을 것 같네요. func Abs(x T) float64 // function declaration func (x T) Abs() float64 // method declaration go는 first-class function / closures를 지원합니다. negativeAbs := func(x T) float64 { return -Abs(x)} // lambda go는 multiple value return이 가능합니다. func ReadByte() (c byte, err error) c, err := ReadByte() if err != nil { ... } Note Those functions all need separate names, too, which makes it clear which combinations exist, as well as encouraging more thought about naming, a critical aspect of clarity and readability. 엇? java 처럼 오버로딩을 하는게 아니라 signature 바뀔때마다 모두 새로운 함수명을 만들어줘야한다는 의미일까요? 아무튼 go는 clarity를 가장 최우선으로 두는 것 같습니다. Tip 개인적으로 default argument가 사라진 건 너무 좋은 것 같은게, python기준으로 함수가 여기저기 많이 사용될수록 default argument 때문에 불필요하게 사용되는 모든 코드들을 뒤져야 할 때가 많았습니다. 예를 들어 def create_person(name, age=30): if age \u003c 30: ... else: ... 이런 함수가 있고 이 함수 관련해서 에러가 나면 create_person를 호출하는 모든 코드들을 다 뒤져봐야 할 경우가 있었습니다. 특히 mongodb처럼 데이터의 스키마가 고정되지 않은 데이터를 함수의 dto로 받는 경우에는 정말 짜증납니다. (kotlin migration 과정에서 엄청 스트레스를 줬던 콘 mcard…) ","date":"2022-02-05","objectID":"/ch01_go_design/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Naming Go에서는 신기하게도 visibility of an identifier를 대소문자로 구별합니다. (타 언어에서는 private / public따위의 키워드를 씀) name as visibility identifier Go the name itself carries the information: the case of the initial letter of the identifier determines the visibility. If the initial character is an upper case letter, the identifier is exported (public); otherwise it is not: upper case initial letter: Name is visible to clients of package otherwise: name (or _Name) is not visible to clients of package 이런 rule은 모든 곳에 적용됩니다. variables types functions methods constants fields 이런 특이한 전략을 취한데에는 naming으로 visibility를 관리하는 것이 identifier에 비해 더욱 깔끔한 Public api관리에 도움되는 전략이라고 판단한 google의 노하우가 반영되었다고 합니다. 개인적으로는 코드 검색을 할 때, identifier를 가지고 검색하면 관련 identifier 리스트들을 한번에 확인이 가능한 반면 네이밍으로 visibility를 관리하면 정확한 네이밍을 알아야 가능하다는 점에서 솔직히 별로 인 것 같습니다. scope hierarchy Another simplification is that Go has a very compact scope hierarchy: universe (predeclared identifiers such as int and string) package (all the source files of a package live at the same scope) file (for package import renames only) function block naming scope There is no scope for name space or class or other wrapping construct. Names come from very few places in Go, and all names follow the same scope hierarchy: at any given location in the source, an identifier denotes exactly one language object, independent of how it is used. (The only exception is statement labels, the targets of break statements and the like; they always have function scope.) …중략… top-level predefined names such as int, (the first component of) every name is always declared in the current package. go에서는 일부 예외(statement labels, argets of break statements는 function scope)를 제외하면 naming은 package scope로 관리됩니다. package scope로 naming이 관리되는 이유 exported name to a package can never break a client of that package. The naming rules decouple packages, providing scaling, clarity, and robustness. function / method 오버로딩 불가능 method lookup is always by name only, not by signature (type) of the method. In other words, a single type can never have two methods with the same name java와 달리 go에서는 function signature만 다르고 네이밍이 같은 메서드 / 함수를 만드는 것은 불가능합니다. 개발자가 네이밍을 좀 더 신경써야 된다는 불편함은 있겠지만, 개인적으로 더 깔끔하게 함수들을 관리할 수 있는 방법이라고 생각되네요 (왠지 function naming관련된 convention tip들이 있을 것 같음) effective go about Functions ","date":"2022-02-05","objectID":"/ch01_go_design/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Semantics go는 기본적으로 c와 많이 닮아 있지만, modern언어에 익숙한 개발자들을 위해 몇가지 차이점을 두었습니다. there is no pointer arithmetic there are no implicit numeric conversions array bounds are always checked there are no type aliases (after type X int, X and int are distinct types not aliases) ++ and – are statements not expressions assignment is not an expression it is legal (encouraged even) to take the address of a stack variable 아래는 C, C++, and even Java와 비교했을 때, 크게 변화한 부분입니다. (참고로 go 초기 개발자인 Robert Griesemer. Java hotspot compiler(JVM)을 개발했었습니다. ) concurrency gc interface type reflection type switches ","date":"2022-02-05","objectID":"/ch01_go_design/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Concurrency Go is not purely memory safe in the presence of concurrency. Sharing is legal and passing a pointer over a channel is idiomatic (and efficient). Go는 Communicating sequential processes, CSP 의 first-class channel개념을 가져왔습니다. (which is about message passing via channels in concurrent system) Don't communicate by sharing memory, share memory by communicating Some concurrency and functional programming experts are disappointed that Go does not take a write-once approach to value semantics in the context of concurrent computation, that Go is not more like Erlang for example. Again, the reason is largely about familiarity and suitability for the problem domain. Go’s concurrent features work well in a context familiar to most programmers. Go enables simple, safe concurrent programming but does not forbid bad programming. We compensate by convention, training programmers to think about message passing as a version of ownership control. Go는 concurrency context에 write-once 접근을 하지 않습니다. 이는 의도적으로 bad programming을 막지 않은 것인데요, convention으로 이런 bad practice를 방지하고, 프로그래머들이 message passing에 대해서 더 생각하도록 유도하기 위함이라고 합니다. 이런 철학은 go의 motto에서도 드러나 있습니다. “Don’t communicate by sharing memory, share memory by communicating.” ","date":"2022-02-05","objectID":"/ch01_go_design/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Garbage collection go는 jvm 개발자가 있어서 그런지 c / c++ / rust와 달리 gc를 가져왔습니다. interior pointer The X.buf field in the example above lives within the struct but it is legal to capture the address of this inner field, for instance to pass it to an I/O routine. In Java, as in many garbage-collected languages, it is not possible to construct an interior pointer like this, but in Go it is idiomatic. java와 비교해 interior pointers(interior pointers to objects allocated in the heap) 기능을 추가해 커스텀하게 gc 기능이 동작하도록 적용했다고 합니다. interior 디자인이 끼칠 영향 This design point affects which collection algorithms can be used, and may make them more difficult, but after careful thought we decided that it was necessary to allow interior pointers because of the benefits to the programmer and the ability to reduce pressure on the (perhaps harder to implement) collector. … 중략 … The garbage collector remains an active area of development. The current design is a parallel mark-and-sweep collector and there remain opportunities to improve its performance or perhaps even its design. (The language specification does not mandate any particular implementation of the collector.) Still, if the programmer takes care to use memory wisely, the current implementation works well for production use. 듣기로는 gc기능이 퍼포먼스 이슈가 있어 Discord에서는 기존에 go로 짜여있는 코드들을 rust로 옮겼다고 하네요. ","date":"2022-02-05","objectID":"/ch01_go_design/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Composition not inheritance there is no type hierarchy go에는 기존 oop 언어들과 달리 type hierarchy가 없습니다. interface In Go an interface is just a set of methods …중략… All data types that implement these methods satisfy this interface implicitly; there is no implements declaration. That said, interface satisfaction is statically checked at compile time so despite this decoupling interfaces are type-safe. 자바와 달리 고의 interface는 behavior만 정의하며 subclassing이 없으므로 상속이란 개념이 존재하지 않습니다. 대신 composition(embedding)을 활용한다고 합니다. subclassing vsv subtyping go에는 subclassing이 없다고 하는데요, subclassing이 무엇인지 그리고 subtyping 또한 무엇인지 비교해보겠습니다. 서브클래싱은 구현되어 있는 클래스를 상속하는 것 서브타이핑은 정의되어 있는 인터페이스를 구현하는 것 먼저 좀 더 Subclassing이란 ? Superr Class에 구현된 코드와 내부 표현 구조를 Sub Class(하위 클래스)가 이어받는 기능을 뜻합니다. 클래스 inheritance라고도 불리며, 이를 통해 하위클래스에서 슈퍼 클래스에 구현된 코드의 재사용이 가능합니다. 그렇기 때문에 sub class는 overriding을 통해 같은 이름의 비슷하지만 커스텀한 행동들을 정의할 수 있습니다. 이와 달리 Subtying이란, Super Type의 객체가 수행할 행동(behavior only)의 약속(프로토콜, api)를 Sub Type이 이어 받습니다. 행동들을 공통된 타입으로 묶어 runtime에 super type의 객체의 타입으로 sub type을 대체가능하도록 합니다. 이를 통해 프로그램 변경에 대한 영향을 최소화 할 수 있습니다. 즉 core한 behavior들을 공통적으로 관리 가능합니다. go가 inheritance를 버린 이유 that the behavior of data can be generalized independently of the representation of that data. The model works best when the behavior (method set) is fixed, but once you subclass a type and add a method, the behaviors are no longer identical. If instead the set of behaviors is fixed, such as in Go’s statically defined interfaces, the uniformity of behavior enables data and programs to be composed uniformly, orthogonally, and safely. 이런 전략을 취했던 이유는 behavior가 fix되어 코드가 작성되면 data representation을 담당하는 model이 works best한다는 철학이 녹아들어있다고 합니다. TODO: 글을 읽다보니 composition에 대해서는 어느정도 이해가 되는데, 이런 철학이 왜 고려되어야 하는지가 정확하게 와닫지는 않는 것 같아서 나머지 부분은 실제 코드를 만져보고 다시 읽어보려고 합니다. Composition not inheritance ","date":"2022-02-05","objectID":"/ch01_go_design/:13:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Errors Go에는 일반적인 의미의 예외 기능이 없습니다. 즉, 오류 처리와 관련된 제어 구조가 없습니다. go가 error를 보는 방식 Errors are just values and programs compute with them as they would compute with values of any other type go가 error를 value로 취급하는 첫번째 이유 First, there is nothing truly exceptional about errors in computer programs. For instance, the inability to open a file is a common issue that does not deserve special linguistic constructs; if and return are fine. f, err := os.Open(fileName) if err != nil { return err } go 철학에서는 error를 특별한 예외라고 생각할 필요가 전혀 없다고 생각하기 떄문입니다. 그냥 value가 return되고 if 분기로 이를 핸들링해주면 그만이라고 주장합니다. go가 error를 value로 취급하는 두번째 이유 There is no question the resulting code can be longer, but the clarity and simplicity of such code offsets its verbosity. Explicit error checking forces the programmer to think about errors—and deal with them—when they arise. 결과 코드가 더 길어질 수 있다는 점에는 의심의 여지가 없지만 그러한 코드의 명확성과 단순성은 장황함을 상쇄합니다. 명시적 오류 검사는 프로그래머가 오류에 대해 생각하고 오류가 발생할 때 처리하도록 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:14:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Useful references Go at Google: Language Design in the Service of Software Engineering golang cheat sheet gin ","date":"2022-02-05","objectID":"/ch01_go_design/:15:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"conclustion 이상으로 go의 디자인 철학에 대해서 분석해보았습니다. 개인적으로 하루정도를 투자하려 했지만, 실제로는 와닿지 않는 내용들 때문에 시간이 조금 더 지체되었던 것 같네요 (소요시간: 대략 2일) - 끝 -","date":"2022-02-05","objectID":"/ch01_go_design/:16:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"새로운 언어를 공부하다보면, 생각보다 기초를 공부하는 시간이 소모적이라는 생각이 들어 조금 더 효율적인 학습방법을 정리해보고 싶어 글로 남겨둡니다. 최근 오픈소스에 기여하고 싶다는 생각이 점점 커지다 보니, 이직 전에 golang에 더 익숙해지고 싶다는 생각을 하게되었습니다. 또 혹시 새로운 프로젝트의 백엔드 웹 서버를 만들어야 될 수도 있어, 이 프로젝트 또한 go와 gin을 사용해 개발해보고 싶다는 생각들이 변곡점을 이루면서 변곡점(變曲點, inflection point) 부랴부랴 나는 어떻게 Go 언어를 배웠나 를 토대로 계획해본 go 학습 계획입니다. ","date":"2022-02-05","objectID":"/go_study_plan/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"tl;dr 영상에서 니꼬가 새로운 언어를 학습하는 합리적인 방법을 공유해주고 있는데요, 정리하면 다음과 같습니다. 공식문서 기초 문법 익숙한 언어들과 비교 (✍️ python과 공통점 차이점 비교글 작성) ASAP code (✍️ graph Tree관련 1문제) 튜토리얼 (✍️ best practice copy) 나만의 프로젝트 (✍️ migration tidify) ","date":"2022-02-05","objectID":"/go_study_plan/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"Go plan 가장 먼저 공식문서에서는 언어가 등장한 배경과 철학을 분석합니다. 또한 어떤 필드에서 해당 언어가 사용되는지를 파악하여 커뮤니티의 특성과 채용/이직에 대한 목표를 세울수 있습니다. 마지막으로 해당 언어가 사용되는 레퍼런스를 리서치합니다. 공식문서 언어 철학 who used (사용 필드/커뮤니티 분석) best practice 레퍼런스 리서치 1의 과정에서 배경지식을 얻었다면, 기초문법을 빠르게 훓어봅니다. 익숙하지 않은 키워드들만 terminology로 정리해보는 것도 좋고, cheatsheet를 훑어보는 것 또한 좋은 방법이라 생각합니다. 기초 문법 키워드 위주로 최대한 빠르게 이후 익숙한 언어와 비교해보면서, 기존의 정보들과 link를 만들어갑니다. 이 방법은 기억력 측면에서 유용한 방법이라 생각합니다. 익숙한 언어들과 비교 equvalance 3의 과정에서 공통/차이점을 훝어 보았다면 바로 기초문법들을 사용해서 코드를 작성해봅니다. 익숙한 graph(tree)관련 알고리즘을 풀어보면 class를 사용해볼 수 있어서 유리할 것 같습니다. code ASAP 2-3에서 배운 문법 활용 기초 문법을 빠르게 쳐보았다면 best practice를 분석해봅니다. 튜토리얼 1에서 찾은 best practice 또는 유명한 오픈소스 / 튜토리얼 fork 후 일부분 로컬에서 재조립 마지막으로 나만의 프로젝트를 빠르게 만들어봅니다. 프로젝트의 규모는 TODO 따위의 간단한 crud 비즈니스 로직을 가진 주제면 더 좋을 것 같습니다. 저의 경우에는 tidify 프로젝트가 가장 비슷한 규모라고 생각되어 tidify 프로젝트를 migration 해보는 걸 목표로 해보고 싶습니다. 하지만 현실적인 시간을 고려해서 tidify가 부담스럽다면 (gin프레임워크를 따로 배우는 시간이 필요) 간단한 TODO 프로젝트 만드는 걸 1차 목표로 진행해보겠습니다. 나만의 프로젝트 최대한 익숙한 프로젝트 주제 i.g TODO 또는 기존 프로젝트 migration ","date":"2022-02-05","objectID":"/go_study_plan/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"conclustion 개인적으로 계획을 세우는 걸 좋아하지만, 금방 싫증을 느끼다 보니 더 현실적이고 체계적으로 계획을 세우고 싶은 니즈가 생겼던 것 같습니다. 이렇게 6가지 순서를 진행하는데 제게 가장 맞는 방법은 스피드라고 생각이 됩니다. 저 같은 경우는 흥미가 빨리 바뀌기 때문에 해당 과정을 일주일동안 해보는 걸 목표로 잡고 진행해볼까 생각합니다. 1~4: 1일 5: 2일 6: 4일 총 일주일 과정을 목표로 기록해보겠습니다. - 끝 -","date":"2022-02-05","objectID":"/go_study_plan/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":[""],"content":"Hardhat를 통해 local에서 스마트 컨트랙트를 작성해본 뒤, contract를 upgrade시켜봅니다. 이후 rinkeby 테스트넷에 proxy 컨트랙트를 배포해보고, verify시켜봅니다. 환경에 사용된 레포는 github link 입니다. hardhat과 openzeppelin 환경에서 간단한 Upgradable contract를 생성해봅니다. ","date":"2022-02-02","objectID":"/hardhat/:0:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"setup 먼저 프로젝트 환경을 로컬에서 세팅해줍니다. ","date":"2022-02-02","objectID":"/hardhat/:1:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"init $ yarn init -y $ yarn add hardhat --dev $ yarn add @openzeppelin/hardhat-upgrades --dev 테스트는 다음과 같이 할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:1","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"test $ npx hardhat test ","date":"2022-02-02","objectID":"/hardhat/:1:2","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy 로컬에서 ganache같은 내부 노드를 실행할 수 있습니다. $ npx hardhat node 로컬에서 이제 배포를 해봅시다. deploy $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgrade.deploy.js SimpleStorageUpgrade deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 런타임에 콘솔에서 붙어서 제대로 배포되었는지 검증해봅니다. check $ npx hardhat console --network localhost Welcome to Node.js v14.15.1. Type \".help\" for more information. \u003e const f = await ethers.getContractFactory(\"SimpleStorageUpgrade\") undefined \u003e const ssu = await f.attach(\"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0\") undefined \u003e ssu.address '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0' \u003e (await ssu.get()).toString() '500' \u003e let tx = await ssu.set(1000) undefined \u003e (await ssu.get()).toString() '1000' 다음과 같이 활용하면 스마트 컨트랙트를 upgrade 시켜줄 수 있습니다. upgrade contract version $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgradeV2.deploy.js Compiling 1 file with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade version 2 deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 ","date":"2022-02-02","objectID":"/hardhat/:1:3","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy to remote network hardhat docs 이제 실제 remote 환경에서 배포해보겠습니다. hardhat.config.js require(\"dotenv\").config(); // yarn add dotenv // ... 중략 ... module.exports = { networks: { rinkeby: { url: `https://eth-rinkeby.alchemyapi.io/v2/${process.env.ALCHEMY_API_KEY}`, // 0x20CE8B2190949f48F5D32d5BbbfE7E3760811F61 accounts: [process.env.TEST_ACCOUNT_PRIVATE_KEY], }, }, solidity: \"0.8.4\", etherscan: { apiKey: process.env.ETHERSCAN_API_KEY, }, }; ALCHEMY_API_KEY: alchemy 에서 demo app을 생성하게 될 경우 view key를 하면 확인가능합니다. TEST_ACCOUNT_PRIVATE_KEY: metamask에서 rinkeby 네트워크에 계정을 생성한 뒤 아래와 같이 비공개키 export를 누르면 확인 가능합니다. ETHERSCAN_API_KEY register etherscan 에서 회원 가입을 한 뒤 create etherscan api key 에서 My API Keys \u003e + Add해주어서 얻어줍니다. 추가로 rinkeby faucet 에 들어가게되면 address 기반으로 rinkeby 계정에 이더를 넣어줄 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:4","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy remote blockchain network rinkeby network (test-net) $ npx hardhat run --network rinkeby ./scripts/SimpleStorageUpgrade.deploy.js Downloading compiler 0.8.4 Compiling 3 files with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade deployed to: 0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 테스트넷이기 때문에 약간의 시간이 소요됩니다. (약 30초) 이후 deploy된 address는 rinkeby etherscan 에서 확인가능합니다. https://rinkeby.etherscan.io/address/0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 proxy contract check The implementation contract at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 does not seem to be verified. 아직 implementation이 검증되지 않았다고 뜬다. 이렇게 proxy가 아닌 implementation contract를 검증해주기 위해서는 아래와 같이 추가 작업해주면 됩니다. ","date":"2022-02-02","objectID":"/hardhat/:2:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"verify implementation docs 먼저 hardhat에서 제공해주는 etherscan 의존성을 설치해줍니다. $ yarn add @nomiclabs/hardhat-etherscan --dev 이후 아래 명령어를 통해서, 로컬의 deploy된 컨트랙트와 실제 rinkeby에 배포된 컨트랙트를 비교해서 검증해주는 로직을 타줍니다. //npx hardhat verify --network rinkeby \"\u003c리모트 배포된 implementation address\u003e\" $ npx hardhat verify --network rinkeby \"0x92a949706c10fd221b9a073f4284b4bdbc47e6d7\" Compiling 3 files with 0.8.4 Solidity compilation finished successfully Compiling 1 file with 0.8.4 Successfully submitted source code for contract contracts/SimpleStorageUpgrade.sol:SimpleStorageUpgrade at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 for verification on the block explorer. Waiting for verification result... Successfully verified contract SimpleStorageUpgrade on Etherscan. https://rinkeby.etherscan.io/address/0x92a949706c10fd221b9a073f4284b4bdbc47e6d7#code 이상으로 배포된 컨트랙트 에서 정상적으로 배포된 컨트랙트를 확인할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:3:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH03] 이더리움 기초를 정리합니다. 인용글들은 원문 을 참조하였습니다. Note An Ethereum client is a software application that implements the Ethereum specification and communicates over the peer-to-peer network with other Ethereum clients … 중략 … Ethereum is defined by a formal specification called the “Yellow Paper” (see [references]). 이더리움 클라이언트는 sw application으로 yellowpaper 에 명시된 ethereum spec들을 만족시키는 구현체입니다. p2p network상에서 서로 통신하며 이더리움 생태계를 이끌어갑니다. This is in contrast to, for example, Bitcoin, which is not defined in any formal way. ","date":"2022-01-29","objectID":"/ch03_eth_client/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Ethereum Networks Note There exist a variety of Ethereum-based networks that largely conform to the formal specification defined in the Ethereum Yellow Paper … 중략 … Among these Ethereum-based networks are Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin, and many others. Yellow Paper에 기제된 스펙을 기반으로 구현된 Ethereum based 네트워크들은 많이 존재합니다. (Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin…) 대부분 프로토콜 수준에서는 호환되지만, 각 네트워크 마다 세세한 부분에서 다른 점들이 존재하기 때문에 이더리움 클라이언트 maintainers들이 각 네트워크를 지원하기 위해 약간씩의 코드 변경작업이 필요합니다. 이 때문에 모든 버전의 이더리움 클라이언트 소프트웨어가 모든 이더리움 기반 블록체인을 실행하는 것은 아닙니다. 책에서 소개하는 대표적인 Ethereum protocol 구현체는 다음과 같습니다. Parity, written in Rust Geth, written in Go cpp-ethereum, written in C++ 현재는 aleth라고 레포가 되어있으며 deprecated됨 pyethereum, written in Python 현재는 py-evm로 관리되고 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Should I Run a Full Node? The health, resilience, and censorship resistance of blockchains depend on them having many independently operated and geographically dispersed full nodes. Each full node can help other new nodes obtain the block data to bootstrap their operation, as well as offering the operator an authoritative and independent verification of all transactions and contracts. 글을 읽고 보니, 이더리움에서 말하는 Node와 Client개념이 헷갈려 먼저 정리하고 들어가겠습니다. Client vs Node 공식문서 에 따르면 Node 분산된 이더리움 네트워크 컴퓨터들에서 동작하는 소프트웨어를 지칭합니다. “Node” refers to a running piece of client software. features: verify blocks, transaction data Types full node: block 전부 copy light node: header만 copy archive node Client 사용자들의 컴퓨터에서 node를 실행할 수 있도록 하는 application을 뜻합니다 node는 piece of client입니다. A client is an implementation of Ethereum that verifies all transactions in each block, keeping the network secure and the data accurate. Note Full client Full clients store the entire Ethereum blockchain; a process that can take several days to synchronize and requires a huge amount of disk space – over 1 Terabyte to be exact, according to the latest figures. Full clients allow connected nodes to perform all tasks on the network, including mining, transaction and block-header validation and running smart contracts. Light client Ethereum clients may be implemented in full or in part. The above overview gives an explanation of how a “full” client works, however it is important to know that you don’t always need to run a full client. Typically when data storage and speed are at issue, developers will elect to use what are called “light clients.” Light clients offer a subset of the functionality of a full client. Light clients can provide faster speeds and free up data storage availability because, unlike the full clients, they do not store the full Ethereum blockchain. The scope of a light client’s functionality is tailored toward the goals of the Ethereum client. For example, light clients are frequently used for private keys and Ethereum address management within a wallet. Additionally, they tend to handle smart contract interactions and transaction broadcasts. Other uses for remote clients include web3 instances within JavaScript objects, dapp browsers and retrieving exchange rate data. Remote client There is a third type of client called a remote client which is similar to a light client. The main difference being, a remote client does not store its own copy of the blockchain, nor does it validate transactions or block headers. Instead, remote clients fully rely on a full or light client to provide them with access to the Ethereum blockchain network. These types of clients are predominantly used as a wallet for sending and receiving transactions. The terms “remote client” and “wallet” are used interchangeably, though there are some differences. Usually, a remote client offers an API (such as the web3.js API) in addition to the transaction functionality of a wallet 참고로 remote client라는 용어와 wallet은 interchangeably하게 사용되는데, 둘의 미묘한 차이점으로는 remote client는 api(such as web3.js)를 제공한다는 점이다. remote client = wallet + api Ethereum remote clients do not validate block headers or transactions. They entirely trust a full client to give them access to the blockchain, and hence lose significant security and anonymity guarantees. 이더리움 remote clients는 light client 처럼 block header 검증하지 않습니다. 이 덕분에 local hw 스펙을 줄일 수 있으나, 외부 full client들에게 depend한다는 특징이 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"The JSON-RPC interface 왜 JSON-RPC를 사용할까? 글을 읽다가 왜 이더리움은 json-rpc를 사용하는지 궁금해서 찾아보게 되었습니다. REST와 json-rpc의 차이점에 대해서 정리하겠습니다. JSON-RPC: tcp base로 원격/로컬 프로세스 procedure(함수)에 직접 접근하는 방식 over tcp only single endpoint crud외 표현 가능 REST over http(s) crud(http method)를 벗어난 표현에 제한적이다. rpc는 소스코드 \u003e idl(interface definition language) \u003e rpcgen\u003e stub 코드 생성 \u003e rpc runtime을 통한 packet 통신 (tcp L4) 과정을 통해서 서버와 클라이언트간 통신을 하게 만듭니다. http(L7)보다 더 낮은 레벨(L4)에서 동작하기 때문에 기능이 덜 할 수 있지만, 제약이 덜합니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Conclusion 뭔가 3장은 내심 겉할기 식의 설명들이 많았던 것 같습니다. rpc-json을 굳이 쓰는 이유도 없었고 client와 node에 대한 설명도 크게 와닿지 않은 것 같아 답답하네요. 예를 들면 full client를 실행하는 방법을 알려주면서, full client를 사용자가 왜 운용해야하는지를 light client와 비교하는 핵심이 빠진 느낌이 듭니다. (full client를 사용해야지 reward가 들어오는 걸까요..? 좀 더 공부가 필요하네요) - 끝 - ","date":"2022-01-29","objectID":"/ch03_eth_client/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH02] 이더리움 기초를 정리합니다. 인용글들은 원문 을 참조하였습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"tl;dr 이번 챕터에서는 실제 solidity코드를 작성한 뒤, 실제 eth를 전송하고 회수하는 contract를 테스트넷에 배포해보겠습니다. 이를 위해 크게 3가지를 다루게 됩니다. 가장 먼저 Metamask wallet을 생성하고, Ropsten test network기반의 faucet으로 부터 ether를 받습니다. 그 뒤 faucet contract코드를 solidity로 작성한 뒤 Remix를 활용해 EVM-bytecode로 compile한 뒤 Faucet contract on Ropsten 네트워크로 등록합니다. (이때 withdraw() 함수를 추가) 마지막으로 Faucet contract address로 ether를 보낸 뒤, withdraw()를 실행해 봅니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Ether Currency Units 이더 화폐 단위 이더리움의 화폐 단위는 ether(이더)라고 불리며, ETH 심볼을 사용합니다. 또한 이더의 최소 단위는 wei(웨이)라고 불립니다. $$ 10^{18} wei = 1 ETH $$ 이더리움 내부에서는 항상 웨이를 부호 없는 정수를 사용합니다. Ethereum’s currency unit is called ether, identified also as “ETH” or with the symbols Ξ (from the Greek letter “Xi” that looks like a stylized capital E) or, less often, ♦ ","date":"2022-01-28","objectID":"/ch02_eth_basic/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Choosing an Ethereum Wallet 이더리움 지갑이란 이더리움 계정을 관리하는 데 사용되는 소프트웨어 애플리케이션이라고 생각하시면 됩니다. In short, an Ethereum wallet is your gateway to the Ethereum system. It holds your keys and can create and broadcast transactions on your behalf. 사용자의 개인키를 보관 사용자를 대신하여 트랜잭션 생성 및 브로드캐스트 시행 이더리움 공식 홈페이지 의 정의에 따르면 지갑을 아래와 같이 정의 내리고 있습니다. Quote 지갑은 이더를 전송할 수 있고 보유할 수도 있는 애플리케이션입니다. 또한 이더리움 디앱에서도 사용할 수 있습니다. 또한 현재(2022.01.28)기준으로 아래 지갑들을 추천합니다. 메타마스크(MetaMask) iOS와 Android용 브라우저 확장 프로그램 및 모바일 지갑 마이크립토(MyCrypto) 웹 기반 지갑 트러스트월렛(TrustWallet) iOS와 Android용 모바일 지갑 마이이더월렛(MyEtherWallet) 클라이언트 측 지갑 오페라(Opera) 지갑이 통합된 주요 브라우저 지갑의 대표주자인 Metamask와 TrustWallet를 trust wallet vs metamask 글을 토대로 요약 정리 해보겠습니다. Trust Wallet Metamask Cost Free Free Desktop Software Yes Yes Mobile App Yes No Built-in exchange Yes (Kyber Network and Web3 browser) No NFT Support Yes No Staking Options Yes No Available Cryptocurrencies Bitcoin, BNB, and all ERC20 Tokens All ERC-20 Tokens Security Medium Medium Compatible with hardware wallets No Yes 아직 어떤게 더 좋아보이는지는 모르겠지만, 개인적으로 metamask에 개발 레퍼런스가 더 많이 있는 것 같아, 메타마스크를 사용해볼 예정입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Wallet Metamask with Ropsten test network Chrome extension에 MetaMask를 치면 메타마스크 애플리케이션을 크롬에 추가할 수 있습니다. 메타마스크 익스텐션 설치 및 가입이 끝났다는 전제하에 설명을 진행하도록 하겠습니다. 테스트를 하기 위해 Ropsten테스트 네트워크로 설정해줍니다. “구매\"를 누르고 “포시트(수도꼭지)테스트\"에서 [Ether 얻기]를 눌러줍니다. 이 경우 아래와 같이 새로운 웹페이지가 열립니다. Faucet 파우셋(Faucet)이란 수도꼭지란 뜻으로 코인 무료 지급 하는곳 으로 사용되고 있다. 이더리움 생태계에서는 대표적으로 Ropsten, Kovan이 존재합니다. 새 웹페이지에서 request 1 ether from faucet(초록 버튼)을 클릭하게 되면 자신의 address로 1eth가 들어오게 됩니다. 몇 초간의 대기 시간이 지나면, 이더 지급이 완료된 transaction을 확인할 수 있습니다. 이 때 트랜잭션 링크를 누르게 되면 아래와 같은 EtherScan 링크로 이동 되고, 트랜잭션 상세내용을 확인하실 수 있습니다. 다음과 같이 faucet으로 돌려보내기 또한 가능합니다. 참고로 test 네트워크도 마찬가지로 gas비를 받는데요, 이는 real 이더 메인넷과 동일한 환경을 제공하기 위해서 입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Introducing the World Computer 지금까지 이더리움 지갑에 대해서 살펴보았습니다. 앞서 이야기 하였듯 이더리움은 cryptocurrency 기능외에도 튜링 complete한 하나의 컴퓨터입니다. Ether는 smart contract를 사용하기 위해 소모되는 payment의 개념이며, 이런 smart contract프로그램은 emplated computer called Ethereum Virtual Machine(EVM)위에서 동작합니다. The EVM is a global singleton, meaning that it operates as if it were a global, single-instance computer, running everywhere. Each node on the Ethereum network runs a local copy of the EVM to validate contract execution, while the Ethereum blockchain records the changing state of this world computer as it processes transactions and smart contracts. EVM 요약 Global singleton Each node validate broadcasted contracts execution Ethereum blockchain records changing state. (tx, smart contract) ","date":"2022-01-28","objectID":"/ch02_eth_basic/:5:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Externally Owned Accounts (EOAs) and Contracts 이더리움에는 2가지 타입의 account가 존재합니다. EOA Contract Account The type of account you created in the MetaMask wallet is called an externally owned account (EOA). 먼저 EOA란 사용자를 대변하는 account입니다. Externally owned accounts are those that have a private key; having the private key means control over access to funds or contracts. EOA는 사용자의 private key를 소유하고 있으며, 이는 contract 또는 account의 코인에 접근 권한이 있다는 뜻입니다. Has private key Has address Simple EOA can’t have smart contract code That other type of account is a contract account. A contract account has smart contract code, which a simple EOA can’t have. Furthermore, a contract account does not have a private key. Instead, it is owned (and controlled) by the logic of its smart contract code: the software program recorded on the Ethereum blockchain at the contract account’s creation and executed by the EVM Contract Account는 스마트 컨트랙트의 주소에 해당되며, 스마트 컨트랙트가 블록에 포함되어 배포될때 해당 스마트 컨트랙트에 대한 주소가 생성이 되며, 이 주소를 통해서 메세지 전송이나 특정함수를 실행 할 수 있습니다. Has smart Contract Has address Does not have private key Owned by smart contract itself However, when a transaction destination is a contract address, it causes that contract to run in the EVM, using the transaction, and the transaction’s data, as its input. In addition to ether, transactions can contain data indicating which specific function in the contract to run and what parameters to pass to that function. In this way, transactions can call functions within contracts. 트랜잭션의 destination이 contract address일 경우, 이는 트랜잭션을 통해 컨트랙트가 EVM에서 실행되도록 트리거 합니다. 트랜잭션 안에는 특정 contract function안에 어떤 parameter가 전달되는지를 기록함으로 써 특정 위치의 contract의 함수가 어떤 인자를 가지고 실행해야 할지를 지정할 수 있습니다. Private key가 없다는 의미 Note that because a contract account does not have a private key, it cannot initiate a transaction. Only EOAs can initiate transactions, but contracts can react to transactions by calling other contracts, building complex execution paths. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:6:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"A Simple Contract: A Test Ether Faucet // SPDX-License-Identifier: CC-BY-SA-4.0 // Version of Solidity compiler this program was written for pragma solidity 0.6.4; // Our first contract is a faucet! contract Faucet { // Accept any incoming amount receive() external payable {} // receive는 키워드 // Give out ether to anyone who asks function withdraw(uint withdraw_amount) public { // Limit withdrawal amount require(withdraw_amount \u003c= 100000000000000000); // Send the amount to the address that requested it msg.sender.transfer(withdraw_amount); } } receive() external payable {} // receive는 키워드 solidity 0.6 버전 이후 fallback기능은 2가지로 나눠지게 되었습니다. receive() external payable — for empty calldata (and any value) fallback() external payable — when no other function matches (not even the receive function). Optionally payable. Tip fallback a.k.a default function이라고도 불리며, 이름 그대로 대비책 함수입니다. 특징 먼저 무기명 함수, 이름이 없는 함수입니다. external 필수 payable 필수 왜 쓰는가 ? 스마트 컨트랙이 이더를 받을 수 있게 한다. 이더 받고 난 후 어떠한 행동을 취하게 할 수 있다. call함수로 없는 함수가 불려질때, 어떠한 행동을 취하게 할 수 있다. msg.sender.transfer(withdraw_amount); msg object는 one of the inputs로 모든 contracts가 접근 가능한 객체입니다. transaction이 실행되도록 trigger 시킨 주체를 의미합니다. 또한 attribute인 sender는 sender address of the transaction를 의미합니다. 마지막으로 transfer()는 built-in 함수로 ether를 current contract -\u003e 누군가.transfer()의 누군가에게 전달하는 것을 의미하며 이 코드에서 누군가는 address of the sender입니다. 즉 코드를 한줄로 설명하면 contract --eth--\u003e msg.sender로 작동해라는 명령어 입니다. This meas transfer ether from current contract to the sender of the msg that triggered this contract execution ","date":"2022-01-28","objectID":"/ch02_eth_basic/:7:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Compiling the Faucet Contract 자 이제 우리가 처음 작성한 스마트 컨트랙트 코드를 Solidity Compiler를 통해 EVM bytecode로 변환을 하여 EVM에서 실행 될 수 있도록 만들어보겠습니다. Solidity Compiler로는 대표적으로 아래의 것들이 있습니다. 저희는 이 중 solidity 공식문서에서 권유하는 Remix IDE를 사용해보겠습니다. We recommend Remix for small contracts and for quickly learning Solidity. 참고로 대안으로 급부상하고 있는 Hardhat 이라는 개발환경 또한 존재합니다. web3.js 대신 (ethers.js )를 default로 사용함. Remix에서 코드를 작성한 뒤, Remix 좌측 2번째 탭을 클릭한 뒤, 적절한 compiler 버전(이번 예제는 0.6.4)를 설정해주고 compile Faucet.sol 버튼을 클릭해주면 아래와 같은 화면을 볼 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:8:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Creating the Contract on the Blockchain Now, we need to “register” the contract on the Ethereum blockchain. 이제 robsten test 네트워크에 생성해준 contract를 등록해보겠습니다. Registering a contract on the blockchain involves creating a special transaction whose destination is the address 0x0000000000000000000000000000000000000000, also known as the zero address. The zero address is a special address that tells the Ether‐ eum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask. 자 Remix의 3번째 탭(DEPLOY \u0026 RUN TRANSACTIONS)을 클릭하여 아래와 같이 세팅해줍니다. Account는 앞서 metamask에서 계정을 생성해주었다면 remix에서 metamask 요청페이지를 열어주어, 계정을 연결시켜줄 것입니다. 여기에서 “Deploy\"버튼을 누르게 되면 이렇게 Deployed Contract가 등록요청하는 metamask 창이 열리고 확인을 누릅니다. 확인을 눌러주면 Remix상에서 contract가 생성된 것을 보실 수 있습니다. 우측의 copy버튼을 눌러 Contract address를 복사해서 etherscan에서 확인해보겠습니다. 생성한 컨트렉트 에서 보여지듯이 잘 생성된 것을 확인하실 수 있습니다. 자 그럼 1eth를 해당 컨트랙트로 보내보겠습니다. metamask를 통해서 이더를 보낸뒤, etherscan을 통해서 확인해보면 정상적으로 value 1eth가 전송된 것을 확인할 수 있습니다. 자 이제 튜토리얼의 마지막 단계인 0.1eth를 회수 해보겠습니다. Remix의 버튼에 “100000000000000000” (10*17 wei = 0.1eth)를 기입하고 withdraw버튼을 클릭해줍니다. etherscan을 통해서 보면 다음과 같이 0.1 eth를 전송한 트랜잭션을 확인할 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:9:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Conclusion 이상으로 마스터링 이더리움 ch02인 기초적인 이더리움에 대해서 정리해보았습니다. 개인적으로 스마트 컨트랙트가 어떻게 배포되는 지 궁금했었는데 staging 개념으로 테스트를 해볼 수 있는 테스트넷이 있다는 점과, 실제 컨트랙트를 배포해서 metamask 계정과 연동해서 동작시켜볼 수 있었던 점이 재밌었던 것 같습니다. - 끝 - ","date":"2022-01-28","objectID":"/ch02_eth_basic/:10:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-21","objectID":"/ch03/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Quote 나만의 좀비 덱을 만들어보자. ","date":"2022-01-21","objectID":"/ch03/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"[ch03] Advanced Solidity Concepts 챕터3를 통과하게 되면 나만의 좀비 덱 을 가지게 됩니다. ","date":"2022-01-21","objectID":"/ch03/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Ownable Contracts external function으로 setter를 열어두게 되면, 아무나 내 컨트랙트 안의 state variable을 수정할 수 있게 되는 보안적인 이슈가 생기게 된다. 이를 대처하기 위해 주로 사용하는 방식은 contract를 ownable하게 만들어 특별한 권리를 가지는 특정 소유자가 있음을 지정할 수 있다. /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } function Ownable()는 Constructor(생성자)입니다. 컨트랙트와 동일한 이름을 가졌으며 default로 제공되어 특별한 작업을 할 게 아니라면 생략가능합니다. 생성자는 컨트랙트 생성시 단 한번만 실행됩니다. modifier onlyOwner()에서 modifier는 function modifier(함수 제어자)입니다. 함수에 대한 접근을 제어하기 위해 사용되는 함수의 일종으로, 보통 함수 실행 전 요구사항 충족여부를 확인하는 데 사용됩니다. 예시의 onlyOwner() 함수는 컨트랙트의 소유자에 한해서만 해당 함수를 실행할 수 있도록 하기 위해 제어해주는 기능을 해줍니다. 즉 transferOwnership(소유권 이전) 함수는 onlyOwner 조건을 만족시킬 때만 실행됩니다. _ 키워드는 쉽게 modifier 검사를 마친 뒤, 실행 될 함수가 들어가게 된다 생각하면 됩니다. indexed 키워드에 대해서는 추후에 더 알아보겠습니다. ","date":"2022-01-21","objectID":"/ch03/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas 이더리움 DApp이 사용하는 연료 솔리디티에서는 사용자들이 만든 DApp의 함수를 실행할 때마다 Gas라 불리는 화폐(ETH, 이더)를 지불해야합니다. 엄밀히 말해서는 사용자가 ETH(이더)를 이용해 Gas를 구매한다. Gas비는 연산비용에 따라 다릅니다. 즉 함수의 로직이 얼마나 복잡한지에 따라 연산이 소모되는 gas cost가 상승합니다. 이런 시스템이기 때문에 코드 최적화가 암묵적으로 강제된다 할 수 있습니다. 가스는 함수를 실행하는 사용자들이 실제 돈을 쓰기 때문에 코드 최적화가 되지 않았다면 당연히 많은 사용자들이 생성한 코드를 사용하지 않게 됩니다. Gas가필요한이유 이더리움 진영에서는 이더림움을 World Computer라고 소개합니다. 전세계에 퍼져있는 개별 노드들이 누군가가 만든 함수를 실행할 때 네트워크 상의 모든 노드 각각이 함수의 output을 검증하기 위해 그 함수를 실행해야 합니다. 이더리움은 Turing complete하기 때문에 무한 루프와 같이 컴퓨팅 자원을 많이 소모되는 코드가 악의적으로 생성된다면 이더리움이라는 하나의 컴퓨터에 악영향을 끼칠것입니다. 이런 이유로 이더리움 개발자들은 연산 처리에 각각 비용을 할당했으며 사용자들은 space / time complexity에 비례하여 gas를 지불해야 합니다. 추가로 크립토 좀비에 따르면 side-chain에서는 반드시 gas를 지불하지는 않는다고 하네요, Loom Network를 사용하는 크립토 좀비가 대표적인 예시라고 합니다. 이더리움 메인넷에서 롤 같은 게임을 직접 돌리게 되면 말도 안되게 엄청 높은 가스 비용이 들테니까요. 하지만 다른 합의 알고리즘을 가진 사이드체인에서는 가능하다고 합니다. ","date":"2022-01-21","objectID":"/ch03/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas비 절약법 기본적으로 uint256이 아닌 uint8과 같은하위 타입들로 저장소를 절약하는 것은 아무런 이득이 없다고 합니다. 왜냐면 솔리디티에서 uint의 크기에 상관없이 256bit 저장공간을 미리 잡아두기 때문입니다. 단 struct 안에서 uint를 사용한다면 더 작은 크기를 사용할 때, storage 절약이 가능하다고 합니다. struct NormalStruct { uint a; uint b; uint c; } struct MiniMe { uint32 a; uint32 b; uint c; } // `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용하게 됩니다. NormalStruct normal = NormalStruct(10, 20, 30); MiniMe mini = MiniMe(10, 20, 30); 이런 이유로, 구조체 안에서는 가능한 작은 크기의 정수 타입을 쓰는 것이 좋다고 할 수 있습니다.또한 동일한 데이터 타입은 하나로 묶어놓는 것이 좋습니다. 즉 구조체에서 서로 가까이 있도록 선언하면 솔리디티에서 사용하는 저장 공간을 최소화해줍니다. 예를 들면, uint c; uint32 a; uint32 b;라는 필드로 구성된 구조체가 uint32 a; uint c; uint32 b; 필드로 구성된 구조체보다 uint32 필드들이 묶여있기 때문에 가스를 덜 소모합니다. ","date":"2022-01-21","objectID":"/ch03/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Time Units Solidity provides some native units for dealing with time. now now를 사용하게 되면 unix timestamp(1970년 1월 1일부터 지금까지의 초 단위 합)을 uint256타입으로 얻을 수 있습니다. 참고로 unix time은 전통적으로 32bit로 저장되는데 이 경우 Year 2038 문제가 발생할 것입니다. 만약 우리 DApp이 2038년까지 운영되길 원한다면 어쩔 수 없이 64bit를 써야하지만, trade of로 유저들은 저장하는데 더 많은 gas를 소모하게 됩니다. 2038년_문제 year 2038 problem 란? POSIX 시간 표기법은 시간을 1970년 1월 1일 자정 UTC 이후 경과된 초 시간을 이용하여 표현하는데,대부분의 32비트 시스템에서 초 시간을 저장하는 데 이용되는 time_t 자료 형식은 부호 있는 32비트 정수형이다. 즉 이 형식을 이용하여 나타낼 수 있는 최후의 시각은 1970년 1월 1일 자정에서 정확히 2147483647초가 지난 2038년 1월 19일 화요일 03:14:07 UTC이다. 이 시각 이후의 시각은 범위를 초과하여 내부적으로 음수로 표현되며, 프로그램의 이상 작동을 유발하는데, 왜냐하면 이러한 값은 2038년 대신 프로그램의 구현 방법에 따라 1970년 또는 1901년을 가리키기 때문입니다. uint lastUpdated; // `lastUpdated`를 `now`로 설정 function updateTimestamp() public { lastUpdated = now; } // 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환 function fiveMinutesHavePassed() public view returns (bool) { return (now \u003e= (lastUpdated + 5 minutes)); } ","date":"2022-01-21","objectID":"/ch03/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Passing structs as arguments 솔리디티에서는 private 또는 internal 함수의 인자로서 구조체의 storage 포인터를 전달할 수 있습니다. 이때 구조체는 포인터타입이며, 솔리디티에서는 이를 storage pointer라고 부르고 있습니다. 문득 memory pointer명칭도 존재하는지 찾아보니 서치하지 못한걸 보면 storage pointer라는 명칭만 있는 것 같습니다. storage pointer라는 명칭을 처음 접해서 개념을 정리하기 위해서 이곳저곳을 찾다, Storage Pointers in Solidity 라는 글을 읽었습니다. 이해한 부분까지 정리해보면 struct타입은 기본적으로 pointer 타입인 것고 이를 function에서 local variable로 참조해서 사용하면 storage형태로 저장되는 것 같습니다. 아래의 코드를 보면 contract FirstSurprise { struct Camper { bool isHappy; } mapping(uint =\u003e Camper) public campers; function setHappy(uint index) public { campers[index].isHappy = true; } function surpriseOne(uint index) public { Camper c = campers[index]; c.isHappy = false; } } setHappy를 통하지 않고도, surpriseOne()의 Camper c = campers[index] c가 storage pointer타입이기 때문에 side-effect가 생길 수 있다는 점이 핵심인 듯합니다. 최근에 이런 목소리를 반영해서 solidity compiler는 이런 상황일 때 아래와 같은 warning을 띄워준다고 합니다. Variable is declared as storage pointer. Use explicit “storage” keyword to silence this warning. 이런 맥락에서 크립토 좀비에서는 구조체를 함수의 인자로 전달하면 storage pointer라고 설명하고 있으며, 아래와 같이 함수 인자에 명시적으로 storage를 쓰도록 하고 있습니다. function _doStuff(Zombie storage _zombie) internal { // _zombie로 할 수 있는 것들을 처리 } 그럼 이런 배경지식을 기억한채 다시 좀비로 넘어와보겠습니다. 우리는 좀비들이 끊임없이 kitty를 먹고 증식하는 것을 막기 위해서 feedAndMultiply에 다음 제약조건을 추가해보려고 합니다. 먹이를 먹으면 좀비가 재사용 대기에 들어간다. 좀비는 재사용 대기 시간이 지날 때까지 고양이들을 먹을 수 없다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime \u003c= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); // 새로 추가 된정보 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; } _createZombie(\"NoName\", newDna); _triggerCooldown(myZombie); // 새로 추가 된정보 } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 우선 Zombie storage pointer를 인자로 받는 _isReady(), _triggerCooldown()함수를 만듭니다. _isReady(): 좀비가 재사용 대기시간을 넘겼는지 확인 _triggerCooldown(): 좀비가 kitty와 조합(eat) 되었다면, 좀비의 readyTimed을 now + cooldownTime(1일)로 업데이트 해줍니다. 이후 좀비에게 먹이를 공급하는 feedAndMultiply()함수에 아무나 접근하지 못하도록 internal로 함수를 지정해줍니다. ","date":"2022-01-21","objectID":"/ch03/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Function modifiers with arguments 앞서 modifier onlyOwner같은 커스텀 function modifier를 보았는데, 이에 더해 function modifier에 argument를 넣어주는 법을 배워봅시다. // usrId =\u003e age mapping mapping (uint =\u003e uint) public age; modifier olderThan(uint _age, uint _userId) { require(age[_userId] \u003e= _age); _; } function buyCigarette(uint _userId) public olderthan(19, _userId) { 🚬() } 위의 코드는 담배를 판매하는 간단한 contract입니다. functio nmodifier의 인자로 나이와 userId를 제공하여 나이를 검사를 구현해주었습니다. 이 기능을 활용하여 우리의 zombie에게 level 속성을 부여해보고, 속성에 따라서 아래와 같은 능력치 제한을 두는 modifier를 만들어보겠습니다. 레벨 2 이상인 좀비인 경우, 사용자들은 그 좀비의 이름을 바꿀 수 있네. 레벨 20 이상인 좀비인 경우, 사용자들은 그 좀비에게 임의의 DNA를 줄 수 있네. zombieHelper.sol pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level \u003e= _level); _; } function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; } } ","date":"2022-01-21","objectID":"/ch03/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Saving Gas With ‘View’ Functions View functions don’t cost gas view 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않는다. 블록체인에 상태를 기록한다는 것은, 모든 single node들에게 트랜잭션이 추가되어야 한다는 것을 의미합니다. 하지만 반대로 view / pure function의 경우 블록체인 상에 어떤 것도 수정하지 않기 때문에 gas 소모가 없습니다. 만약 web3.js에게 view function를 호출해달라 요청하는 것은 실제로는 로컬 이더리움 노드에 query만 날리면 되기 때문에 가스 소모가 없게 됩니다. Warning 앞부분 설명을 보다보니 문득 view function gas가 들지 않는다면, view function을 infinite 호출하게되면 이더리움 망가뜨릴수 있지 않을까하는 생각에 검색하게 되었고 확인해보니 pure / view function은 internally call 해주게 되면 gas비가 든다고 한다. 즉 크립토좀비가 이번 세션에서 설명하는 것은 blockchain 외부(i.g web3.js)에서 호출하면 free gas cost라는 의미이다. Pure and view functions still cost gas if they are called internally from another function. They are only free if they are called externally, from outside of the blockchain. This View/Pure Gas usage - Cost gas if called internally by another function? goes into greater depth on this topic. 자세히 보니 크립토 좀비의 참고에도 아래와 같은 hint가 작성되어있네요. (데헷 😧) Tip 만약 view 함수가 동일 컨트랙트 내에 있는, view 함수가 아닌 다른 함수에서 내부적으로 호출될 경우, 여전히 가스를 소모할 것이네. 이것은 다른 함수가 이더리움에 트랜잭션을 생성하고, 이는 모든 개별 노드에서 검증되어야 하기 때문이네. 그러니 view 함수는 외부에서 호출됐을 때에만 무료라네. 이제 우리의 좀비 DApp에 사용자의 전체 좀비 군대를 볼 수 있는 메소드를 추가해보자. getZombiesByOwner()라는 네이밍에 external view function으로 만들어 보겠습니다. Declaring arrays in memory 솔리디티에서 storage에 write하는 것은 비싼 연산 중 하나입니다. 이더리움은 World computer이기 때문에 main-net기준으로 storage를 사용할 경우, 연결되어 있는 전세계 수많은 node들에 update를 시키게 되기 때문이죠. 이러다 보니 대부분의 프로그래밍 언어가 크기가 상당한 collection에 각각 접근( O(N) )하는 것을 지양하는 것과 달리, 솔리디티는 그 접근이 external view함수라면 storage를 쓰는 것보다 memoery를 써서 각각 element에 접근하는 것이 더 저렴한 방법입니다. (이는 gas비 때문인데, 훗날 이더리움 가격이 떨어진다면 달라질지도) Tip 생각해보니 실제로 storage에 write하는 것은 O(N) * per_gas_cost는 아닌것 같네요. 만약 1만명이 사용하는 contract라고 가정했을 떄 N=element갯수라면, gas_cost = (O(N) * 하나의_write_연산에_사용되는_gas_cost) * 10000이 되기 때문에 만약 1만명이 아닌 사용하고자 하는 사람의 숫자가 많아진다면, 즉 if 10000 \u003e= storage's element size라면 N의 정의가 달라지게 될 것 같습니다. Storage에 아무것도 쓰지 않고도 함수 안에서 새로운 배열을 만들기 위해서는 memory키워드를 사용하면 됩니다. 이는 storage배열을 직접 업데이트하는 것보다 gas_cost 측면에서 훨씬 (크립토 좀비에 따르면) 저렴하다고 합니다. 그러므로 collection을 storage로 관리하지 말고 memory로 전환하여 관리합시다. pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { ... 중략 ... function getZombiesByOwner(address _owner) external view returns(uint[]) { uint[] memory result = new uint[](ownerZombieCount[_owner]); return result; } } ","date":"2022-01-21","objectID":"/ch03/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-20","objectID":"/ch02/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Quote 좀비에게 먹이를 주어서 조합이 가능하게 해보자. ","date":"2022-01-20","objectID":"/ch02/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"[ch02] Zombies Attack Their Victims 이번 장을 마치면 다음과 같은 고양이를 먹은 좀비를 생성할 수 있다. ","date":"2022-01-20","objectID":"/ch02/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Mappings and Addresses 이더리움 블록체인은 은행계좌와 같은 account를 사용해서 유저를 식별합니다. 이때 각 account들은 이더리움 블록체인상의 coin인 ether를 단위로 balance를 가지게 됩니다. 이를 통화를 통해 각 계정은 송금/인출 등의 은행과 같은 기능들을 할 수 있습니다. 이를 위해 이더리움에서 각 계정은 은행 계좌 번호와 같은 address를 가지고 있으며, 여기서 말하는 address는 EOA(Extenally Owned Account)의 address입니다. 보통은 EOA간의 메세지는 이더를 보내지만, EOA는 컨트랙트 어카운트에 메세지를 보내 해당 코드를 실행 시킬 수 도 있습니다. Mapping은 기본적으로 python의 dict와 같은 key-value 저장소입니다. contract ZombieFactory { ... mapping (uint =\u003e address) public zombieToOwner; mapping (address =\u003e uint) ownerZombieCount; ... } ","date":"2022-01-20","objectID":"/ch02/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Msg.sender solidity에는 모든 함수에서 이용 가능한 특정 전역 변수들이 있는데, 그 중의 하나가 현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소를 가리키는 msg.sender이다. Tip solidity에서 함수 실행은 항상 external caller(외부 호출자)가 시작하며, 컨트랙트는 외부에서 함수를 호출 하기 전까지 블록체인 상에서 아무것도 하지 않는다. 즉 스마트 컨트랙트는 msg.sender(호출자)가 항상 존재합니다. mapping (address =\u003e uint) favoriteNumber; function setMyNumber(uint _myNumber) public { favoriteNumber[msg.sender] = _myNumber; } function getMyNumber() public view returns (uint) { return favoriteNumber[msg.sender]; } ","date":"2022-01-20","objectID":"/ch02/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Require 특정 조건이 True가 아닐 경우, 에러를 발생시키고 함수를 벗어나게 됩니다. function sayHiToLeoo(string _name) public returns (string) { // solidity는 고유의 스트링 비교 기능이 없다. 그러므로 keccak256 해시값을 // 비교해 스트링이 같은 값인지 판단하는 코드 require(keccak256(_name) == keccak256(\"Leoo.j\")); return \"Hi\"; } ","date":"2022-01-20","objectID":"/ch02/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Inheritance contract Animal { function cry() public returns (string) { return \"Default cry\"; } } contract Dog is Animal { function cry() public returns (string) { return \"Bark\"; } } ","date":"2022-01-20","objectID":"/ch02/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Import 파일들로 코드를 분리하고, 다른 파일에 있는 코드를 불러오고 싶을 때, 솔리디티는 import라는 keyword를 사용합니다. import \"./someothercontract.sol\"; // SomeOtherContract contract newContract is SomeOtherContract { } ","date":"2022-01-20","objectID":"/ch02/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Storage vs Memory solidity가 변수를 저장할 수 있는 공간에는 2가지 종류가 있습니다. storage memory Storage는 블록체인 상에 영구적으로 저장되는 변수들입니다. state variable(함수 외부에 선언된 변수)인 경우 초기 설정상 Storage로 관리되어 블록체인 상에 영구적으로 저장됩니다. 이와 반대로 함수 내부에 선언된 변수는 memory로 자동 선언되어 함수 호출 종료시 사라지게 됩니다. 단 명시적으로 storage, memory 키워드들을 사용해주어야 하는 상황이 존재하는데, 바로 함수 내에서 struct, 배열을 처리할 때 입니다. contract SandwichFactory { struct Sandwich { string name; string status; } Sandwich[] sandwiches; // state variable (storage) function eat(uint _idx) public { string defaultState = \"NOT EATEN\"; // implicit memory Sandwich storage mySandwich = sandwiches[_idx]; // arr should explict Sandwich memory anotherSandwich = sandwiches[_idx + 1]; sandwiches[_idx + 1] = anotherSandwich; } } pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract ZombieFeeding is ZombieFactory { function feedAndMultiply(uint _zombieId, uint _targetDna) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; } } ","date":"2022-01-20","objectID":"/ch02/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Extra Function Visibility solidity에는 public과 private 이외에도 internal과 external이라는 함수 접근 제어자가 있다. internal 상속하는 컨트랙트에서도 접근 가능 (java protected와 비슷해 보임?) 나머지는 private과 동의 external 컨트랙트 바깥에서만 호출 될 수 있음 컨트랙트 내의 다른 함수에 의해 호출될 수 없다. 나머지는 public과 동의 internal은 상속하는 컨트랙트에서도 접근 가능하다는 점을 제외하면 private과 같다. 느낌 상 java의 protected와 유사해 보이며, state variable은 default로 internal 접근자를 가진다. external은 함수가 컨트랙트 바깥에서만 호출 될 수 있고 컨트랙트 내의 다른 함수에 의해서 호출 될 수 없다는 부분만 제외하면 public과 같다. contract Sandwich { uint private sandwichesEaten = 0; function eat() internal { sandwichesEaten++; } } contract BLT is Sandwich { uint private baconSandwichesEaten = 0; function eatWithBacon() public returns (string) { baconSandwichesEaten++; // eat 함수가 internal로 선언되었기 때문에 여기서 호출이 가능하다 eat(); } } ","date":"2022-01-20","objectID":"/ch02/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"interface 블록체인 상에서, 다른 컨트랙트와 상호작용을 하고 싶다면 Interface를 정의해야 합니다. contract LuckyNumber { mapping(address =\u003e uint) numbers; function setNum(uint _num) public { numbers[msg.sender] = _num; } function getNum(address _myAddress) public view returns (uint) { return numbers[_myAddress]; } } 예를 들어 다음과 같은 외부 컨트랙트가 있다고 가정 할 때, 우리는 다음과 같은 interface를 만들 수 있습니다. // 예시에서는 contract NumberInterface {}를 사용한다. interface NumberInterface { function getNum(address _myAddress) public view returns (uint); } 크립토 좀비에 제공된 예시에서는 contract NumberInterface {}를 사용하고 있는데, interface키워드가 추가 된 것인지 아니면 contract보다 interface가 제약조건이 많기 때문에 간단하게 contract로 구현했는지 모르겠지만, 좀 더 명확한 표현이 좋아서 예제를 변경하였습니다. 실제 interface 사용은 다음과 같습니다. contract MyContract { address NumberInterfaceAddress = 0xab38... // ^ 이더리움상의 FavoriteNumber 컨트랙트 주소이다 NumberInterface numberContract = NumberInterface(NumberInterfaceAddress) // 이제 `numberContract`는 다른 컨트랙트를 가리키고 있다. function someFunction() public { // 이제 `numberContract`가 가리키고 있는 컨트랙트에서 `getNum` 함수를 호출할 수 있다: uint num = numberContract.getNum(msg.sender); // ...그리고 여기서 `num`으로 무언가를 할 수 있다 } } interface라는 키워드는 아래와 같은 제약조건이 있습니다. 다른 Contract로 부터 상속받을 수 없습니다, 하지만 다른 interface로부터는 상속받을 수 있습니다. 모든 function들은 public, external이어야 합니다. constructor를 선언할 수 없습니다. variable를 선언할 수 없습니다. struct를 선언할 수 없습니다. enum를 선언할 수 없습니다. 내부에는 추상함수, 즉 함수 시그니처만 존재합니다. Interfaces cannot have any functions implemented ","date":"2022-01-20","objectID":"/ch02/:1:8","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"summary 최종적으로 다음과 같은 코드가 만들어집니다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; // 끝에 2자리를 99로 변경한다. } _createZombie(\"NoName\", newDna); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 요구사항 고양이 좀비(kitty zombie)는 DNA 마지막 2자리로 99를 갖는다고 가정한다. 그러면 우리 코드에서는 만약(if) 좀비가 고양이에서 생성되면 좀비 DNA의 마지막 2자리를 99로 설정한다. 자바스크립트와 web3.js를 활용하여 우리의 컨트랙트와 상호작용하는 예시 var abi = /* abi generated by the compiler */ var ZombieFeedingContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFeeding = ZombieFeedingContract.at(contractAddress) // 우리 좀비의 ID와 타겟 고양이 ID를 가지고 있다고 가정하면 let zombieId = 1; let kittyId = 1; // 크립토키티의 이미지를 얻기 위해 웹 API에 쿼리를 할 필요가 있다. // 이 정보는 블록체인이 아닌 크립토키티 웹 서버에 저장되어 있다. // 모든 것이 블록체인에 저장되어 있으면 서버가 다운되거나 크립토키티 API가 바뀌는 것이나 // 크립토키티 회사가 크립토좀비를 싫어해서 고양이 이미지를 로딩하는 걸 막는 등을 걱정할 필요가 없다 ;) let apiUrl = \"https://api.cryptokitties.co/kitties/\" + kittyId $.get(apiUrl, function(data) { let imgUrl = data.image_url // 이미지를 제시하기 위해 무언가를 한다 }) // 유저가 고양이를 클릭할 때: $(\".kittyImage\").click(function(e) { // 우리 컨트랙트의 `feedOnKitty` 메소드를 호출한다 ZombieFeeding.feedOnKitty(zombieId, kittyId) }) // 우리의 컨트랙트에서 발생 가능한 NewZombie 이벤트에 귀를 기울여서 이벤트 발생 시 이벤트를 제시할 수 있도록 한다: ZombieFactory.NewZombie(function(error, result) { if (error) return // 이 함수는 레슨 1에서와 같이 좀비를 제시한다: generateZombie(result.zombieId, result.name, result.dna) }) ","date":"2022-01-20","objectID":"/ch02/:1:9","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["ros"],"content":"ros2 Foxy 실행에 필요한 개발 환경을 ubuntu, vm환경에 세팅해봅니다. ","date":"2022-01-18","objectID":"/ch02_setup/:0:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup zsh sudo apt-get install zsh chsh -s /usr/bin/zsh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" .zshrc update ZSH_THEME=\"Theme_Name\" 4. powerlevel10k install https://github.com/romkatv/powerlevel10k#meslo-nerd-font-patched-for-powerlevel10k install fonts wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf update fonts terminal vscode install powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k Set ZSH_THEME=“powerlevel10k/powerlevel10k” in ~/.zshrc. plugins git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\ ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting plugins=( # other plugins... zsh-autosuggestions ) 최종 ~/.basrc 파일 # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) [ -x /usr/bin/lesspipe ] \u0026\u0026 eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] \u0026\u0026 [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] \u0026\u0026 tput setaf 1 \u003e\u0026/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026\u0026 eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases alias ll='ls -alF' alias la=","date":"2022-01-18","objectID":"/ch02_setup/:1:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup workspace 먼저 ros를 실행하기 위해서는 workspace가 필요합니다. 필요한 작업공간을 만들어 보겠습니다. # ros2-sandbox on vmware $ colcon build $ echo 'source /home/leoo/shared/ros2-sandbox/install/setup.bash' \u003e\u003e ~/.bashrc sudo ros2를 하니 command not found가 나왔다. 만약 sudo를 써야 한다면, $ sudo echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e /root/.bashrc \u0026\u0026 sudo reboot host디렉토리를 mount 해버리니, .bashrc에서 commad가 permission denied되었다. 그러므로 매번 vmware에서는 sudo -i를 해주고, /root 디렉토리에 symlink를 생성해주자(편리함)s $ sudo -i # 생성하지 않았다면 $ ln -s /home/leoo/shared/ros2-sandbox ros2-sandbox $ cd ros2-sandbox ","date":"2022-01-18","objectID":"/ch02_setup/:2:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"ros2 Foxy를 mac pro 로컬 환경에 설치해봅니다. ","date":"2022-01-18","objectID":"/ch01_install/:0:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"1. tl;dr 실행환경: virtualbox(ubuntu 20.04) mount: 현재 디렉토리 코드작성 vm vs code에서 실행 host에서 코드 작성을 하려하였으나, lint와 링크 기능이 제대로 동작하지 않음 ","date":"2022-01-18","objectID":"/ch01_install/:1:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2. setup on virtual box (✅) setup mac like keyboard on virtual box 최종적으로 성공한 방식은 vm에 ubuntu를 설치해서 foxy를 실행하는 방식입니다. 아래 절차를 거쳐 세팅을 진행하였습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.1. ubuntu iso download 가장 먼저 ubuntu iso 이미지를 다운 받습니다. https://mirror.kakao.com/ubuntu-releases/focal/ 에서 ubuntu 20.04 lts download ","date":"2022-01-18","objectID":"/ch01_install/:2:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.2. vritualbox download 다음으로 virtualbox 를 최신버전으로 다운 받습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.3. virtual box 셋업 가장 먼저 설치한 iso를 연결해줍니다. 2.3.1. iso 등록 다음으로 아래 스펙으로 virtualbox를 세팅해줍니다. mem: 8192MB HDD: 30 GB 키보드 / 드래그앤 드롭 Bidirectional 설정 2.3.2. 일반 \u003e 기본 2.3.3. 일반 \u003e 고급 2.3.4. 시스템 \u003e 마더보드 2.3.5. 시스템 \u003e 프로세서 2.3.6. 디스플레이 2.3.7. 공유폴더 설정 2.3.8. 전체 설정 여기까지 기본적인 ubuntu 설정이 완료되었습니다. 다음으로 ubuntu 자체 설정을 해주겠습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.4. ubuntu install ubuntu는 한글설정 / 맥북 키보드 shortcut 설정 / zsh 등, 처음 세팅하게 되면 설정해주어야 할 것들이 존재합니다. 가장 먼저는 apt 저장소를 카카오 미러 로 변경해주세요. (이렇게 하면 더 빠르게 apt 설치가 가능합니다.) virtual box cmd right로 변경 [키보드 세팅(mac like)] $ sudo apt-get install keyboard-configuration $ sudo dpkg-reconfigure keyboard-configuration # select macbook pro(intel) # MacIntosh # English # English (Macintosh) # Both Alt keys # No compose key # Terminal preference에서 copy \u0026 paste 설정 mount host folder(소스코드) to ubuntu # 이건 임시이며, 항상 mount시키고 싶다면, vmware에 공유 폴더 설정해주어야 한다. $ sudo mount -t vboxsf ros2-sandbox /home/leoo/shared/ros2-sandbox/ ","date":"2022-01-18","objectID":"/ch01_install/:2:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.5. install ros dependencies $ sudo apt update $ sudo apt install build-essential gcc make perl dkms $ sudo apt update \u0026\u0026 sudo apt upgrade $ sudo apt install terminator $ sudo add-apt-repository universe $ sudo apt-get update $ sudo apt-get install python3-pip ","date":"2022-01-18","objectID":"/ch01_install/:2:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.6. install ros2 binary $ locale # check for UTF-8 $ sudo apt update \u0026\u0026 sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 $ export LANG=en_US.UTF-8 $ locale # verify settings $ sudo apt update \u0026\u0026 sudo apt install curl gnupg2 lsb-release $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg $ echo \"deb [arch=$(dpkg --print-architecture)signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs)main\" | sudo tee /etc/apt/sources.list.d/ros2.list \u003e /dev/null $ sudo apt update $ sudo apt install ros-foxy-desktop $ echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e ~/.bashrc $ sudo apt install python3-argcomplete 만약 이렇게 세팅하였을 때 자신의 vm이 너무 느리다고 판단 된다면 vm 설정방법 을 참고해주세요. 지금까지 세팅을 완료하였으면 예쁘게 동작하는 vm을 보실 수 있습니다. :) 2.6.1. vm에서 동작하는 화면 ","date":"2022-01-18","objectID":"/ch01_install/:2:6","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"3. setup with Docker (🚫) docker 설치 refs Host로 설정하는 방식이 실패하여, 그 다음으로 선택한 방식입니다. 도커를 사용한 방식은 문제없이 동작하였지만, 추후 터미널을 여러개 띄워 네트워크 통신이 많아지는 걸 고려하면, 추가적으로 설정해야 할 부분들이 많아 보였습니다. 추가로 문서 또한 리눅스 문서들이 많으므로 vm ware 사용 $ docker pull osrf/ros:noetic-desktop-full-buster $ brew install socat # https://www.cyberciti.biz/faq/apple-osx-mountain-lion-mavericks-install-xquartz-server/ $ brew install --cask xquartz $ sudo reboot # xquartz 보안 설정 모두 열어주기 host 터미널에서 아래 명령어 실행 # ip 확인 후 xhost에 추가 $ ip=$(ifconfig en0 | grep inet | awk '$1==\"inet\" {print $2}') $ xhost + $ip # 컨테이너 생성 $ docker run -it -e DISPLAY=$ip:0 --name ros osrf/ros:noetic-desktop-full-buster ","date":"2022-01-18","objectID":"/ch01_install/:3:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4. setup on Host (🚫) This was failed 이 방식은 맥북에 바로 설치하는 방식으로 mac os에 ros에 필요한 dependencies들을 바로 추가해주었습니다. ","date":"2022-01-18","objectID":"/ch01_install/:4:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.1. Pre-Install ROS2 on mac $ brew doctor $ softwareupdate --all --install --force $ sudo rm -rf /Library/Developer/CommandLineTools $ sudo xcode-select --install $ brew link kubernetes-cli $ brew link python@3.9 $ echo 'export PATH=\"/usr/local/sbin:$PATH\"' \u003e\u003e ~/.zshrc ","date":"2022-01-18","objectID":"/ch01_install/:4:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.2. Install ROS2 on mac brew install python@3.8 brew unlink python \u0026\u0026 brew link --force python@3.8 echo 'export PATH=\"/usr/local/opt/python@3.8/bin:$PATH\"' \u003e\u003e ~/.zshrc export LDFLAGS=\"-L/usr/local/opt/python@3.8/lib\" export PKG_CONFIG_PATH=\"/usr/local/opt/python@3.8/lib/pkgconfig\" brew install asio tinyxml2 tinyxml eigen pcre poco brew install openssl \u0026\u0026 echo \"export OPENSSL_ROOT_DIR=$(brew --prefix openssl)\" \u003e\u003e ~/.zshrc brew install qt freetype assimp sip pyqt5 brew install console_bridge log4cxx spdlog cunit graphviz python3 -m pip install pygraphviz pydot catkin_pkg empy ifcfg lark-parser lxml netifaces numpy pyparsing pyyaml setuptools argcomplete pip3 install -U colcon-common-extensions # OpenCV는 필수는 아닙니다. 설치시 시간이 엄청 오래 걸리니 고민해보세요. brew install opencv ","date":"2022-01-18","objectID":"/ch01_install/:4:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.3. Download ROS Foxy Binary # https://github.com/ros2/ros2/releases mkdir -p ~/ros2_foxy cd ~/ros2_foxy tar xf ~/Downloads/ros2-foxy-20211013-macos-amd64.tar.bz2 ","date":"2022-01-18","objectID":"/ch01_install/:4:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.4. Check installed $ . ~/ros2_foxy/ros2-osx/local_setup.zsh ","date":"2022-01-18","objectID":"/ch01_install/:4:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.5. Error $ . ~/ros2_foxy/ros2-osx/local_setup.zsh [connext_cmake_module] Warning: The location at which Connext was found when the workspace was built [[/Applications/rti_connext_dds-5.3.1]] does not point to a valid directory, and the NDDSHOME environment variable has not been set. Support for Connext will not be available. csrutil disable로 시도해보았지만 실패 ros2 바이너리 버전을 낮춰서 시도해보았지만 역시 실패 big sur과 맞지 않는 source code에러가 있는 듯하다. 아래는 host에 설치하기 위해서 참조했던 문서들입니다. 공식 how-to-install-ros2-foxy-on-macos building-ros2-on-macos-big-sur-m1 ","date":"2022-01-18","objectID":"/ch01_install/:4:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["blockchain"],"content":"이번장에서는 Mastering Ethereum과 김혐남님의 세미나 내용 을 기반으로 이더리움이란 무엇인가에 대해서 정리합니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"tl;dr Ethereum is a Blockchain Platform. 이더리움을 블록체인 생태계에서 포지션을 생각한다면 플랫폼으로 구분할 수 있습니다. Ethereum is “the world computer” 이더리움 진영에서 내새우는 정의는 (합의를 기반으로 동작하는) World Computer입니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:1","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"1. What is Ethereum Quote Ethereum is often described as “the world computer” 이더리움 진영에서 정의하는 이더리움이란 (탈 중앙화된) 월드 컴퓨터입니다. World와 Computer에 집중해본다면, World라는 단어처럼 이더리움은 “전세계를 하나로 묶어줄 수 있는 connection\"을 제공해주어야 할 것으로 보입니다. 묶어준 다는 점에서 p2p 네트워크가 필요해 보입니다. Computer라는 단어는 program, 그리고 이 프로그램을 개발할 수 있는 language가 필요해 보입니다. 또한 그 프로그램은 decentralized 성격을 가져야 하기 때문에, 일반 프로그램과 비교해 특별한 성질을 가질 것으로 보입니다. Ethereum is an open source with globally decentralized computing infrastructure that executes programs called smart contracts. It uses a blockchain to synchronize and store the system’s state changes. smart contract라는 특별한 program을 사용해 globally decentralized computing infrastructure 이면서도, 하나의 world computer 즉 state가 sync되는 시스템을 구현합니다. Tip Ethereum is a deterministic but practically unbounded state machine, Which means consisting of a globally accessible singleton state and a virtual machine. p2p로 퍼져있으면서도, 하나의 컴퓨터로 동작하기 위해서 스마트 컨트랙트는 globally accessible singleton state와 virtual machine 개념이 존재합니다. It uses a blockchain to synchronize and store the system’s state changes, along with a cryptocurrency called ether to meter and constrain execution resource costs. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"2. Compared to Bitcoin in common p2p network connecting participants. to synchronize PoW they uses Byzantine fault-tolerant consensus algorithm. uses cryptographic primitives hashes digital signatures digital currency Tip PoW(proof of work) is a form of adding new blocks of transactions to a cryptocurrency’s blockchain. in contrast Ethereum’s purpose is not primarily to be a digital currency payment network. ether is intended as a utility currency to pay for use of the Ethereum platform as the world computer. Bitcoin’s Script language is intentionally constrained to simple true/false evaluation of spending conditions, but ethereum’s language is Turing complete Tip A Turing complete system means a system in which a program can be written that will find an answer (although with no guarantees regarding runtime or memory). So, if somebody says “my new thing is Turing Complete” that means in principle (although often not in practice) it could be used to solve any computation problem. 프로그래밍 언어는 이와 비슷하게 Turing complete하다 왜냐하면 프로그램이 실행될 충분한 메모리와 시간이 주어진다면 특정 computational problem을 풀어낼 수 있기 때문이다. 김혐남님의 말을 빌리자면, 이더리움을 간단히 블록체인의 플랫폼이라 소개합니다. 블록체인 플랫폼이 되려다보니 이더리움은 블록체인 튜링 완전 프로그래밍이 가능해야 했고, Turing Complete해지니 application을 만들 수 있게 되었고, 이 앱은 block chain 위에서 실행되니 블록체인의 특성을 지닌 앱이 될 수 있었습니다. 이더리움은 이런 블록체인의 기능을 플랫폼처럼 추상화 시켜, 참여하는 개발자들이 쉽게 블록체인의 특성을 지닌 애플리케이션을 개발할 수 있도록 도와줍니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"3. Components of a Blockchain The components of an open, public blockchain are: A peer-to-peer (P2P) network connecting participants and propagating transactions and blocks of verified transactions, based on a standardized “gossip” protocol Messages, in the form of transactions, representing state transitions A set of consensus rules, governing what constitutes a transaction and what makes for a valid state transition A state machine that processes transactions according to the consensus rules A chain of cryptographically secured blocks that acts as a journal of all the verified and accepted state transitions A consensus algorithm that decentralizes control over the blockchain, by forcing participants to cooperate in the enforcement of the consensus rules A game-theoretically sound incentivization scheme (e.g., proof-of-work costs plus block rewards) to economically secure the state machine in an open environment One or more open source software implementations of the above (“clients”) ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"4. The Birth of Ethereum 이더리움 창립자들은 프로그래밍을 통해 다양한 애플리케이션을 지원할 수 있는 특정 목적에 국한되지 않는 블록체인에 대해 생각하고 있었다. 이 생각은 이더리움과 같은 범용 블록체인을 사용하여 개발자가 피어투피어 네트워크, 블록체인, 합의 알고리즘 등의 기본 메커니즘을 구현하지 않고도, 특정 애플리케이션을 프로그래밍할 수 있다는 것이다. 이더리움 플랫폼은 세부사항을 추상화하고 탈중앙화 블록체인 애플리케이션을 위한 결정적이고 안전한 프로그래밍 환경을 제공한다. 이더리움은 범용 블록체인(=블록체인 플랫폼)으로서 위치하고 있다는 것을 확인할 수 있습니다. 탈중앙화의 첫 번째 대상은 ‘가치의 이동’입니다. 디파이라 불리는 탈중앙 금융이 블록체인의 성공적인 킬러 앱이 될 수 있는 이유는 바로 가치의 이동에서 찾을 수 있습니다. 블록체인이 왜 탈중앙화할 수 밖에 없었는지를 고민해 보면 정보의 이동이 아닌 핵심은 가치의 이동이 필요했기 때문입니다. The original blockchain, namely Bitcoin’s blockchain, tracks the state of units of bitcoin and their ownership. You can think of Bitcoin as a distributed consensus state machine, where transactions cause a global state transition, altering the ownership of coins. The state transitions are constrained by the rules of consensus, allowing all participants to (eventually) converge on a common (consensus) state of the system, after several blocks are mined. Ethereum answers the question: “What if we could track any arbitrary state and program the state machine to create a world-wide computer operating under consensus?” ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-14","objectID":"/ch01/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Quote 크립토 좀비 에서 Solidity를 학습해보자. ","date":"2022-01-14","objectID":"/ch01/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"[ch01] Making the Zombie Factory 챕터1을 통과하게 되면 나만의 좀비 를 가질 수 있다. :) 솔리디티 코드는 Contract안에 싸여져 있다. 컨트랙트는 이더리움 app의 기본 구성 요소로, 모든 변수/함수는 하나의 컨트랙트안에 속해 있어야 한다. 즉 컨트랙트는 모든 프로젝트의 시작 지점이라고 할 수 있다. contract ZombieFactory { } 모든 솔리디티 코드는 솔리디티의 버전을 선언 해주어야 한다. 이를 통해 새로운 컴파일러 버전이 나오더라도 코드가 깨지지 않도록 한다. pragma solidity ^0.4.19; contract ZombieFactory { } 솔리디티에서 state variable는 컨트랙트 저장소에 영구적으로 저장된다. 즉 이더리움 블록체인에 기록이 된다. uint는 unsigned 즉 부호가 없는 정수로, 음이 아닌 정수이다. (\u003c-\u003e int) uint는 uint256를 의미하며, 256비트 정수를 표현한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } 솔리디티는 c++과 마찬가지롤 struct를 제공한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } array안에 크기를 주지 않으면 동적할당 가능하다. // 2개의 원소를 담을 수 있는 고정 길이의 배열: uint[2] fixedArray; // 또다른 고정 배열으로 5개의 스트링을 담을 수 있다: string[5] stringArray; // 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다: uint[] dynamicArray; public으로 배열을 선언할 수 있으며 솔리디티는 이런 배열을 위해 getter 메소드를 자동적으로 생성해준다. Person[] public people; 함수의 경우 param명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례이다. 마찬가지로 private 함수명 또한 _를 쓰는 것이 convention이다. function _createZombie(string _name, uint _dna) private { } function createRandomZombie(string _name) public { } 참고로 솔리디티에서 함수는 기본적으로 public이다. 누구나 또는 다른 컨트랙트가 나의 컨트랙트 함수를 호출하고 코드를 실행할 수 있다. 솔라디티는 함수가 데이터를 read만 하고 state change를 하지 않을 때 view 함수를 사용한다. function sayHello() public view returns (string) { } 또한 pure 함수도 가지고 있는데, 이는 함수가 앱에서 어떤 데이터도 접근하지 않는(read, write둘다 하지 x) 것을 의미한다. function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 이더리움은 SHA3의 버전 중 하나인 keccak256를 내장 해시 함수로 가지고 있다. 해시 함수는 기본적으로 입력 스트링을 랜덤 256bit 16진수로 매핑한다. Question 블록체인에서 안전한 의사 난수 발생기는 어려운 문제라고 한다고 하는데 hash collision과 관련해서 어렵다고 하는 걸까? 아니면 안전하다고 하는게 Oracle?과 관련이 있는 걸까? //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(\"aaaab\"); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(\"aaaac\"); event는 생성한 컨트랙트가 블록체인 상에서 앱에 접근하는 사용자 layer에서 액션이 발생했을 때, 통신하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는지 “listen\"하며, 그 이벤트가 발생하면 action을 취한다. // 이벤트를 선언한다 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다: IntegersAdded(_x, _y, result); return result; } ","date":"2022-01-14","objectID":"/ch01/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Summary 지금까지의 과정을 정리하면 아래와 같은 코드가 최종적으로 만들어진다. pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; // push returns length NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } // 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다: var abi = /* abi generated by the compiler */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다. // 일종의 이벤트 리스너가 텍스트 입력값을 취한다: $(\"#ourButton\").click(function(e) { var name = $(\"#nameInput\").val() // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다: ZombieFactory.createRandomZombie(name) }) // `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다 var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 좀비 DNA 값을 받아서 이미지를 업데이트한다 function generateZombie(id, name, dna) { let dnaStr = String(dna) // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다 while (dnaStr.length \u003c 16) dnaStr = \"0\" + dnaStr let zombieDetails = { // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여 // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. // 이를 기초로 \"head1.png\"에서 \"head7.png\" 중 하나의 이미지를 불러온다: headChoice: dnaStr.substring(0, 2) % 7 + 1, // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 셔츠 타입에는 6가지가 있다: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 \"filter: hue-rotate\"를 이용하여 아래와 같이 업데이트된다: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: \"A Level 1 CryptoZombie\", } return zombieDetails } ","date":"2022-01-14","objectID":"/ch01/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["algorithm"],"content":"Sorting algorithms","date":"2022-01-12","objectID":"/sorting/","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":" Let’s summary list of Sorting Algorithms ","date":"2022-01-12","objectID":"/sorting/:0:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"tl;dr index sorting name time space description 1 Bubble O(n^2) O(1) 루프당 max가 가장 뒤, swap O(n^2) 2 Selection O(n^2) O(1) 루프당 min 맨 앞, swap O(n) 3 Insertion O(n^2) O(1) I까지 sort 보장, 정렬이 어느정도 되어있다면 사용할 것 4 Merge O(nlogn) O(n) nlogn 알고리즘 중 유일한 stable 5 Heap O(nlogn) O(1) insert(O(logn) * n개 원소, space가 1이 포인트 6 Quick O(nlogn) O(n) piv기준 작으면 left 크거나 같으면 right,balanced partition을 위해 random piv를 해준다. ","date":"2022-01-12","objectID":"/sorting/:1:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Bubble Sort ","date":"2022-01-12","objectID":"/sorting/:2:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Selection Sort ","date":"2022-01-12","objectID":"/sorting/:3:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Insertion Sort 이미 정렬된 상태라면 O(n)의 빠른 속도를 보인다. 정렬된 상태에서 빠른 이유는 각 insert마다 1번의 비교만 하면 되기 때문이다. reversed를 사용하면 insert시 arr re-arrange를 방지 가능하다. 단점: 삽입을 하게 되면 데이터가 하나씩 뒤로 밀려야 되기 때문에 배열이 길어질수록 효율이 떨어진다. 개인적으로 input()받을 때 insertionSort를 사용하면 입력과 정렬을 동시에 할 수 있어서 더욱 효율적인 것 같다. def insertion_sort(arr): n = len(arr) for i in range(1, n): val = arr[i] j = i - 1 if arr[j] \u003c val: continue while j \u003e= 0 and val \u003c arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = val return arr ","date":"2022-01-12","objectID":"/sorting/:4:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Merge Sort def merge_sort(arr): def merge(left, right): l = r = 0 result = [] while l \u003c len(left) and r \u003c len(right): if left[l] \u003c right[r]: result.append(left[l]) l+=1 else: result.append(right[r]) r+=1 return result + left[l:] + right[r:] # 나머지 (left over) if len(arr) \u003c= 1: return arr mid = len(arr) // 2 return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:])) ","date":"2022-01-12","objectID":"/sorting/:5:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Heap Sort ","date":"2022-01-12","objectID":"/sorting/:6:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Quick Sort 성능을 생각하면 piv를 random으로 찾아야 한다. from __future__ import annotations def quick_sort(arr: list[int]) -\u003e list[int]: if len(arr) \u003c= 1: return arr piv = arr[0] others = arr[1:] left = [v for v in others if v \u003c= piv] right = [v for v in others if v \u003e piv] return quick_sort(left) + [piv] + quick_sort(right) ","date":"2022-01-12","objectID":"/sorting/:7:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"About Binary Search and BST","date":"2022-01-08","objectID":"/binary_search/","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":" Binary Search와 BST에 대해서 정리합니다. Binary Search는 divide conquer의 일종으로 검색 범위를 binary하게 줄여나가면서 원하는 데이터를 검색하는 알고리즘입니다. def binary_search(sorted_arr, target): n = len(sorted_arr) if n == 0: return -1 low, high = 0, n-1 while low \u003c=high: mid = (low + high) // 2 if sorted_arr[mid] == target: return mid if sorted_arr[mid] \u003e target: high = mid -1 else: low = mid + 1 return -1 # low == high + 1 == mid 눈여겨 봐야할 포인트는 다음 2가지이다. 검색 대상이 되는 arr가 sorted되어있다. while의 조건으로 low \u003c= high 등호가 들어있다. 검색의 범위 element가 2개로 좁혀졌을 때 // 2 연산에 의해서 왼쪽만 탐색이 될 텐데, 찾아야하는 값이 우측 값에 존재한다면 low와 high가 같아야만(low == high == mid) 검색이 가능하다. ","date":"2022-01-08","objectID":"/binary_search/:0:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search 특징 retrieve Time complexity: O(log N) retrieve Space complexity: O(1) 삽입 / 삭제 불가 ","date":"2022-01-08","objectID":"/binary_search/:1:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search Tree (BST) n= number of elements, h = tree height 들어가기 앞서, ratsgo 를 참조하여 정리했음을 알려드립니다. 이진 탐색 트리란 Binary Search와 Linked list를 결합한 자료구조 입니다. 특히 Binary Search의 탐색 속도(O(log n)) 와 링크드리스트의 삽입/삭제 O(1)의 장점을 결합했다는 특징이 있습니다. 참고로 binary search는 삽입/삭제가 불가하며, 링크드리스트는 탐색 속도가 O(n)이라는 단점들이 있습니다. BST는 서로의 장점을 사용해 각각의 단점을 O(h)로 보완합니다. ","date":"2022-01-08","objectID":"/binary_search/:2:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"주요 특징 left.val \u003c root \u003c right.val inorder traverse(중위 순회)시 결과가 정렬된 리스트가 주어진다. left -\u003e node -\u003e right 구성하는 노드에서 중복된 노드가 없어야 한다. (unique 보장) 노드 끼리 우선순위 대소 비교가 가능해야 한다. retrieve, insert, delete의 계산복잡성은 모두 𝑂(ℎ) ","date":"2022-01-08","objectID":"/binary_search/:2:1","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"기본 데이터 형태 class Node: def __init__(self, val): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root: Optional[Node] = None def set_root(self, val): self.root = Node(val) ","date":"2022-01-08","objectID":"/binary_search/:2:2","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"retrieve / find Time Complexity: O(h) 탐색 대상과 root를 비교하여 left / right를 찾아나간다. 이 경우 Binary Search와 비슷하게 O(h) 시간 복잡도를 가진다. (아래와 같은 극단적 불균형 트리인 경우이면서, min/max값을 탐색한다면 O(n)) def find(self, val): node = self.find_node(self.root, val): return True if node else False def find_node(self, node, val) -\u003e Optional[Node]: if not node: return None elif val == node.val: return node elif val \u003c node.val: return self.find_node(node.left, val) else: return self.find_node(node.right, val) ","date":"2022-01-08","objectID":"/binary_search/:2:3","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"insert Time Complexity: O(h) O(logn)이 아닌 이유는 비대칭(Unbalanced Binary Tree)인 경우 tree의 높이가 n까지도 가능하기 때문이다. (sorted arr를 차례대로 insert 시킬경우) 이를 해결하기 위해서는 BF(balance factor)를 사용해 balance를 맞추는 AVL 또는 B-같은 트리를 사용해야 한다. def insert(self, val): if not self.root: self.set_root(val) else: self.insert_node(self.root, val) def insert_node(self, node, val): if val \u003c= node.val: if node.left: self.insert_node(node.left, val) else: node.left = Node(val) elif val \u003e node.val: if node.right: self.insert_node(node.right, val) else: node.right = Node(val) Tip AVL 트리는 rotation을 사용해 tree의 insert / delete 시 balance를 맞춘다. 그러므로 검색의 경우 항상 O(log n)을 보장한다. 특별한 점은 single rotation, double rotation을 통해서 tree의 balance를 맞추어 주는데 자세한 설명 을 참조하세요 ","date":"2022-01-08","objectID":"/binary_search/:2:4","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"delete Time Complexity: O(h) 삭제는 총 3가지 경우가 존재합니다. leaf node (자식노드가 없는 경우) -\u003e 그냥 제거 자식노드가 하나 존재하는 경우 -\u003e 제거 후, 자식 노드를 삭제된 노드의 부모로 연결 자식노드가 둘 존재하는 경우 이 경우에는 predecessor 또는 successor를 삭제할 노드와 위치를 뒤 바꾼 다음, 1와 2의 삭제 방법을 사용하면 됩니다. (참고로 successor와 predecessor는 자식노드가 1개 또는 없는 경우 밖에 존재하지 않습니다.) predecessor로 제거, successor로 제거 둘다 가능 합니다. Tip predecessor: 삭제 대상 노드의 왼쪽 서브트리 가운데 최대값 successor: 삭제 대상 노드의 오른쪽 서브트리 가운데 최소값 그림 기준으로 16을 inorder traverse를 해보면 다음과 같습니다. 4, 10, 13, 16, 20, 22, 25, 28, 30, 42 이때, predecessor(13), successor(20)가 됩니다. # delete 방법 (d = 삭제 대상 노드의 레벨) 1. 삭제 대상 노드의 오른쪽 서브트리를 찾는다. 2. successor(1에서 찾은 서브트리의 최소값) 노드를 찾는다. 3. 2에서 찾은 successor의 값을 삭제 대상 노드에 복사한다. 4. successor 노드를 삭제한다. 가장 계산이 복잡한 자식 노드가 둘 모두 존재하는 경우의 시간 복잡도를 분서해보겠습니다. 1에서 d레벨(트리 높이) 만큼 이동을 해주어야 하며, 2에서 최대 h-d 레벨(트리높이)만큼 이동해주어야 합니다. 3과 4의 연산은 계산에서 제외한다면 O(d + h -d) =\u003e O(h)가 만들어집니다. e.g) 간단히 가장 복잡할 것 같은 root를 지운다 가정하였을 때, d = 1, h = h이므로 O(1 + h - 1)이 됩니다. ","date":"2022-01-08","objectID":"/binary_search/:2:5","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"traverse (inorder) Time Complexity: O(n) 위의 그림의 경우 1 -\u003e 3 -\u003e 5 -\u003e 7 -\u003e 8 -\u003e 10로 순회 가능하다. def traverse(self): return self.traverse_node(self.root) def traverse_node(self, node): result = [] if node.left: result.extend(self.traverse_node(node.left)) if node: result.extend([node.val]) if node.right: result.extend(self.traverse_node(node.right)) return result ","date":"2022-01-08","objectID":"/binary_search/:2:6","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Conclusion 이상으로 binary search와 bst에 대하여 알아 보았습니다. 관련해서 leetcode문제는 binary search 에 정리를 해두었습니다. - 끝 - ","date":"2022-01-08","objectID":"/binary_search/:3:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"About DFS and BFS","date":"2022-01-06","objectID":"/dfs_bfs/","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":" 간단하게 bfs와 dfs를 python으로 구현해보고, 상황별 장단점을 분석해본다. ","date":"2022-01-06","objectID":"/dfs_bfs/:0:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1. Graph Traverse ","date":"2022-01-06","objectID":"/dfs_bfs/:1:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.1. BFS from collections import deque graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } def bfs(start_node=\"5\"): queue = deque([start_node,]) visited = set() while queue: node = queue.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: queue.appendleft(neighbor) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:1","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.2. DFS graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } # 5 8 7 3 4 2 def dfs(start_node=\"5\"): stack = [start_node,] visited = set() while stack: node = stack.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: stack.append(neighbor) def recursive_dfs(node=\"5\", visited = set()): visited.add(node) for neighbor in graph[node]: if neighbor in visited: continue recursive_dfs(neighbor, visited) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:2","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.3. BFS vs DFS 문제 유형별로 어떤 알고리즘이 더 유리한지 서술합니다.  : impossible  : good and possible  : bad but possible index Problem BFS DFS 1 그래프의 모든 정점을 방문 하는 문제 2 각 경로 마다 특징을 저장해둬야 하는 문제 3 최단 거리 문제 4 문제의 그래프가 매우 클 경우 5 검색 시작 지점과 원하는 대상이 가까이 있을 경우 단순히 모든 node 방문이라면 둘 모두 사용가능합니다. a-\u003eb로 가는 경로를 구할 때, 경로 안에서 같은 숫자가 x번 이상 없어야 하는 경우, dfs는 함수의 인자에 local 변수들을 좀 더 손 쉽게 줄 수 있는 반면, queue를 활용하는 bfs는 상태를 기억하기 좀 더 까다롭다. 물론 queue에 node를 넣을 때, local state를 같이 넣어주면 되긴 하지만, 이는 명시적이지 못하므로 dfs가 더 유리하다 생각된다. bfs의 경우 level(e.g 이동 count, tree의 level, ) 단위로 확장되기 때문에 목적지에 도착하는 순간 return한 값이 최소 이동거리가 되지만, dfs의 경우에는 깊이 있게 하나씩 파니까 상대적으로 bfs보다 오래 걸린다. Python의 경우 하나의 리스트가 가질 수 있는 Py_ssize_t는 536870912인 반면, 함수에 대한 메모리 제한은 두지 않고 있다. 그러므로 queue를 이용해서 구현하는 bfs의 경우 그래프가 크다면, 제한이 있는 반면 recursive function으로 구현한 dfs한정(stack으로 구현한 경우 동일한 문제발생)해서 function call stack을 사용해서 메모리 관리를 하기 때문에 상대적으로 더 큰 그래프 탐색에 사용될 수 있다. 3.의 경우와 같은 원리이다. ","date":"2022-01-06","objectID":"/dfs_bfs/:1:3","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"Conclusion 필자는 왠만하면 bfs를 좀 더 선호하는 경향이 있는데, 과거의 경험을 떠올려 보면, (정확하게 기억은 나지 않지만) path가 연속적으로 이어져야하는 로직에서 bfs가 불편했던 것 같다. DFS의 경우에는 처음부터 끝까지 연속적으로 탐색하기 때문에 비교적 쉽게 구현이 되었는데, BFS는 spread 하면서 이동하기 때문에 해당 상황에서 불리 했던 것 같다. dfs, bfs를 언제 써야하는지 개인적으로 헷갈렸었는데 표로 정리하고 나니 나중에도 유용하게 볼 것 같다. - 끝 - ","date":"2022-01-06","objectID":"/dfs_bfs/:2:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"About Binary Tree","date":"2022-01-06","objectID":"/binary_tree/","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":" Binary Tree관련 알고리즘들을 학습하고 정리합니다. ","date":"2022-01-06","objectID":"/binary_tree/:0:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Binary Tree child \u003e 2면 안된다. parent \u003e 1이면 안된다. root(부모가 없는 노드)는 한개만 존재해야 한다. array로 구현하면 편의를 위해 0인덱스를 비워둔다. parent = child % 2 lchild = parent * 2 rchild = parent * 2 + 1 ","date":"2022-01-06","objectID":"/binary_tree/:1:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap max heap, min heap (등호도 고려된다.) 대소 관계는 부모-자녀 간에만 고려된다. left child 먼저 삽입된다. (즉 leaf 중에 left 없이 right가 있는 경우는 없다.) ","date":"2022-01-06","objectID":"/binary_tree/:2:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap insert 인덱스 마지막에 새로운 요소 append (if parent is exist) 부모와 대소 비교 하여 exchange. (아래 -\u003e 위 heapify) ","date":"2022-01-06","objectID":"/binary_tree/:2:1","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap pop root pop 힙의 마지막 element를 root로 이동 힙 재구성 (= 위 -\u003e 아래 heapify) (if child exist) l, r 비교하여 현재 노드가 작다면 exchange (max heap 기준) 재귀적으로 반복 ","date":"2022-01-06","objectID":"/binary_tree/:2:2","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap sort O(n + n*logn) =\u003e O(nlogn) Max heap 구성(O(n)) 루트와 말단 노드 교체 후 heapify (O(nlogn)) O(logn) = 트리 최대 높이 = heapify시 depth n = 모든 노드들에 대하여 검사 ","date":"2022-01-06","objectID":"/binary_tree/:2:3","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["todo"],"content":" This article is a simple list of todos that I will write to blog in my future. ","date":"2022-01-02","objectID":"/todo/:0:0","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1. TODO LIST ","date":"2022-01-02","objectID":"/todo/:1:0","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.1. Plan 21년 회고 22년 목표 ","date":"2022-01-02","objectID":"/todo/:1:1","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.2. Diary 나는 누구이고, 지금 어디에 존재하는가? 오쇼 글귀 정리 과거 네이버 / 커스텀 블로그 / 일기 글 migration 지금 나에겐 가치없는 글. ","date":"2022-01-02","objectID":"/todo/:1:2","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.3. Server Dev hugo 블로그 구축기 kotlin 공부했던 글 정리 우선순위가 떨어진다. c++ 7장까지 들었던 글 정리 kotlin in action ","date":"2022-01-02","objectID":"/todo/:1:3","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.4. Block chain binance academy gall dcinside 이더리움 크립토 좀비 디파이 로드맵 book: Mastering bitcoin, Mastering etherium web3.0 coin: 폴리곤, 폴카닷, 루나 etc coin: 솔라나 ","date":"2022-01-02","objectID":"/todo/:1:4","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.5. Startup 온라인 전자담배 도매부터 판매까지 사업자 등록 도매 물품 구매 사이트 도메인 등록 및 사이트 운영 사이트 관련 홍보 및 상품 소개 글 작성 및 크롤러 확보 결제 시스템 부착 상품 관련 법률사항 검토 및 사이트 명시 Honestly, 판매전까지의 모든 단계를 완성. 즉 판매를 실패했다. 이유는 이직이 되어서도 있고, 친구와 내 가치관이 달라서 준비하는 과정과 업무 분배에 있어서 명확학지 않았다. 2022년을 마무리하며 돌아보니, 그때는 내가 멋져보이고 싶었고, 돈을 빨리 벌고 싶었던 것 같다. ","date":"2022-01-02","objectID":"/todo/:1:5","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.6. Phrase 내 어록 쓰기 ","date":"2022-01-02","objectID":"/todo/:1:6","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["hugo"],"content":"Hugo로 블로그 만들기","date":"2022-01-02","objectID":"/initial_hugo/","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":" This article describes a series of technical steps to building this serious blog using the hugo framework . 사실 Hugo는 20년도에 혼자 제주도 여행을 가면서, 생각을 정리하고 싶어서 눈여겨 봤던 프레임워크이다. 당시 go를 공부하고 있었기 때문에 go로 만들어진 프레임워크라는 점에서 호감 +99점을 받았고, 이름이 다른 프레임워크들에 비해서 짧다는 장점이 있다. 🤔 Gatsby는 무슨 왁스 이름같고, Jekyll는 스펠링도 어렵고 사실 어떻게 발음해야 될지도 잘 모를정도로 이름이 못생김 이 블로그는 hugo와 LoveIt 을 사용해 만들었다. keywords Hugo LoveIt git submodule github workflows shell script ","date":"2022-01-02","objectID":"/initial_hugo/:0:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1. Pre-Init Blog MacBook Pro (16-inch, 2019) Big Sur ","date":"2022-01-02","objectID":"/initial_hugo/:1:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.1. Install hugo install hugo docs # Install brew $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # download hugo $ brew install hugo # check hugo is successfully downloaded $ hugo version ","date":"2022-01-02","objectID":"/initial_hugo/:1:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.2. Select hugo templaate github에서 hugo를 검색하고, star많은 순으로 정렬 겉보기 이쁘다고 무턱대고 템플릿 가져다 쓰면, 아마 빠른시일 안에 블로그를 포기할 것임.. 1k 넘는 레포 중에서 이쁜거 찾는다. 검색 카테고리 기능 dark/light mode 댓글 기능 추천하는 테마들은 다음과 같다. ✅ https://github.com/dillonzq/LoveIt 👍 https://github.com/zzossig/hugo-theme-zzo https://github.com/luizdepra/hugo-coder https://github.com/adityatelange/hugo-PaperMod ","date":"2022-01-02","objectID":"/initial_hugo/:1:2","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.3. Generate your profile image 프로필 이미지 생성한 곳 이말년 스타일 프로필 이미지 필자는 프로필 사진에 cartoonize를 써보고 싶어서 github에서 ML 모델 위주로 검색했는데 원하는 곳을 찾지 못해서 대안으로 여기 를 사용 하게 되었다. 이말년 그림체로 프로필 만들고 싶은데 뭔가 해줘야 할게 많아서 포기… 누가 online 서버 만들어주면 좋겠다…🥺 기타 작품들 열정적인 스터디원들 ","date":"2022-01-02","objectID":"/initial_hugo/:1:3","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2. Init Blog 자 본격적으로 블로그 만들어보자. ","date":"2022-01-02","objectID":"/initial_hugo/:2:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2.1. Generate Blog 먼저 블로그용 폴더를 만들고 템플릿을 submodule로 추가해보자. # hugo new site \u003cYOUR FOLDER NAME\u003e $ hugo new site love $ cd love $ git init $ git branch -M main # git remote add origin \u003cYOUR ROOT REPOSITORY\u003e $ git remote add origin https://github.com/minkj1992/love.git # git submodule add \u003cTHEME REPOSITORY\u003e themes/\u003cTHEME_NAME\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # + 사내 계정이라 config 변경 $ git config user.email minkj1992@gmail.com $ git config user.name \"minkj1992\" 필자의 경우 github page를 사용해서 블로그를 운영할 것이기 때문에, 미리 생성했던 YOUR_ID.github.io레포지토리를 submodule로 등록한다. # git submodule add \u003cYOUR_ID.github.io\u003e public $ git submodule add https://github.com/minkj1992/minkj1992.github.io public Warning $ git submodule add \u003cYOUR_ID.github.io\u003e public 명령어를 칠 때, 꼭 public을 디렉토리로 넣어주어야 한다! hugo는 스태틱 파일들을 public/ 디렉토리로 빌드해주고, 우리의 *.github.io는 블로그의 스태틱 파일들을 가지고 있어야 하니까 :) LoveIt config.toml 의 example config.toml을 참조해서, 본인의 블로그 루트 디렉토리에 config.toml을 생성하고 필요한 설정들을 추가해주자. $ cp ./themes/LoveIt/exampleSite/config.toml ./config.toml # if you want to add image to site home $ mkdir -p assets/images # after this command, paste your profile \u0026 log image to images and change config.toml # (OPTIONAL) If you want to change css font-famiully and size, customize scss file. $ touch assets/_override.scss 자 이제 첫 글을 작성해보자. 주의할점은 draft:false가 되어있어야 hugo를 github page 배포했을 때, 깨지지 않고 배포 된다. # *.md draft must be falsed! $ hugo new posts/initial_post.md 글을 작성했다면, 로컬에서 실행시켜보자 (hot-reload적용 됨) 참고로 commit이 안되서, 실행이 안된다고 하니 이쯤에서 우선 커밋 먼저 해준다. (fatal: your current branch 'main' does not have any commits yet) $ git add . \u0026\u0026 git commit -m\"Initial commit\" # hot reload debug run server $ hugo server -D 정상적으로 블로그가 동작하는걸 확인했다면 배포를 해보자. 배포는 아래 과정을 거쳐 진행된다. hugo build ($ hugo) ./public commit \u0026 push (submodule e.g minkj1992.github.io) root repository push 먼저 hugo를 빌드하면 public/ 디렉토리에 파일들이 추가 된다. 추가된 파이들을 public의 remote로 push해주고, root 레포지토리로 돌아가서 push 해주면 된다. 필자는 아래의 스크립트를 사용해서 해당 과정을 진행해주고 있다. 2.1.1. git-push.sh #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32m I Love Leoo.j \\033[0m\\n\" printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" printf \"\\033[0;32mBuild the project.\\033[0m\\n\" hugo -D # hugo -t timeline # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m Go To Public folder \\033[0m\\n\" cd public printf \"\\033[0;32m Setting for submodule commit \\033[0m\\n\" git config --local user.name \"minkj1992\" git config --local user.email \"minkj1992@gmail.com\" git submodule update --init --recursive printf \"\\033[0;32m Add changes to git. \\033[0m\\n\" git add . printf \"\\033[0;32m Commit changes.. \\033[0m\\n\" msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" printf \"\\033[0;32m Push blog(presentation) source and build repos. \\033[0m\\n\" git push origin main printf \"\\033[0;32m Come Back up to the Project Root \\033[0m\\n\" cd .. echo $pwd printf \"\\033[0;32m root repository Commit \u0026 Push. \\033[0m\\n\" git add . msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" git push origin main shell을 만들었다면, 이제 배포 해보자. $ sh git-push.sh \u003cCOMMIT_MSG\u003e Tip 만약 github action을 사용하고 싶다면, https://github.com/minkj1992/love/blob/main/.github/samples/gh-pages.sample 를 사용 해보라. (단 secrets.PERSONAL_TOKEN은 github setting에서 ENV등록해 주어야 함) git hook을 쓰면 커밋이 편하긴 하지만, 개인적으로는 hook을 쓰면 로컬의 public/ 디렉토리의 git 버저닝이 관리되지 않고 있는게 눈에 거슬려서 shell을 사용 중이다. ","date":"2022-01-02","objectID":"/initial_hugo/:2:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"3. Conclusion Nexters에서 2021년 회고글 작성하는 모임에 참석해서, 많은 개발자 분들이 notion으로 글을 정리하는 것에 자극 받아서, 바로 블로그를 만들게 되었는데 개인적으로 만족스럽다. 생각보다 에러 잡는데 시간을 많이 지체한 것 같고, github hook부분 기능을 잘 몰라 커스터마이징 하고 싶어 이것 저것 만져보다가 토요일 하루가 꼬박 걸렸는데 이 글을 읽는 여러분은 제가 했던 삽질을 경험하지 않길 바란다. - 끝 - ","date":"2022-01-02","objectID":"/initial_hugo/:3:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["Markdown"],"content":"This article shows the basic Markdown syntax and format.","date":"2022-01-01","objectID":"/first_post/","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":" This article offers a sample of basic Markdown syntax that can be used in Hugo content files. Note This article is a shameful copy of the great Grav original page . If you want to know about the extented Markdown syntax of LoveIt theme, please read extended Markdown syntax page . Let’s face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages. Markdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it. Some of the key benefits are: Markdown is simple to learn, with minimal extra characters, so it’s also quicker to write content. Less chance of errors when writing in Markdown. Produces valid XHTML output. Keeps the content and the visual display separate, so you cannot mess up the look of your site. Write in any text editor or Markdown application you like. Markdown is a joy to use! John Gruber, the author of Markdown, puts it like this: The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email. – John Gruber Without further delay, let us go over the main elements of Markdown and what the resulting HTML looks like! Tip  Bookmark this page for easy future reference! ","date":"2022-01-01","objectID":"/first_post/:0:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"1. Headings Headings from h2 through h6 are constructed with a # for each level: ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading The HTML looks like this: \u003ch2\u003eh2 Heading\u003c/h2\u003e \u003ch3\u003eh3 Heading\u003c/h3\u003e \u003ch4\u003eh4 Heading\u003c/h4\u003e \u003ch5\u003eh5 Heading\u003c/h5\u003e \u003ch6\u003eh6 Heading\u003c/h6\u003e Heading IDs To add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading: ### A Great Heading {#custom-id} The HTML looks like this: \u003ch3 id=\"custom-id\"\u003eA Great Heading\u003c/h3\u003e ","date":"2022-01-01","objectID":"/first_post/:1:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"2. Comments Comments should be HTML compatible. \u003c!-- This is a comment --\u003e Comment below should NOT be seen: ","date":"2022-01-01","objectID":"/first_post/:2:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"3. Horizontal Rules The HTML \u003chr\u003e element is for creating a “thematic break” between paragraph-level elements. In Markdown, you can create a \u003chr\u003e with any of the following: ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks The rendered output looks like this: ","date":"2022-01-01","objectID":"/first_post/:3:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"4. Body Copy Body copy written as normal, plain text will be wrapped with \u003cp\u003e\u003c/p\u003e tags in the rendered HTML. So this body copy: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. The HTML looks like this: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e A line break can be done with one blank line. ","date":"2022-01-01","objectID":"/first_post/:4:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"5. Inline HTML If you need a certain HTML tag (with a class) you can simply use HTML: Paragraph in Markdown. \u003cdiv class=\"class\"\u003e This is \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Paragraph in Markdown. ","date":"2022-01-01","objectID":"/first_post/:5:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6. Emphasis ","date":"2022-01-01","objectID":"/first_post/:6:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.1. Bold For emphasizing a snippet of text with a heavier font-weight. The following snippet of text is rendered as bold text. **rendered as bold text** __rendered as bold text__ The HTML looks like this: \u003cstrong\u003erendered as bold text\u003c/strong\u003e ","date":"2022-01-01","objectID":"/first_post/:6:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.2. Italics For emphasizing a snippet of text with italics. The following snippet of text is rendered as italicized text. *rendered as italicized text* _rendered as italicized text_ The HTML looks like this: \u003cem\u003erendered as italicized text\u003c/em\u003e ","date":"2022-01-01","objectID":"/first_post/:6:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.3. Strikethrough In GFMGitHub flavored Markdown you can do strikethroughs. ~~Strike through this text.~~ The rendered output looks like this: Strike through this text. The HTML looks like this: \u003cdel\u003eStrike through this text.\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.4. Combination Bold, italics, and strikethrough can be used in combination. ***bold and italics*** ~~**strikethrough and bold**~~ ~~*strikethrough and italics*~~ ~~***bold, italics and strikethrough***~~ The rendered output looks like this: bold and italics strikethrough and bold strikethrough and italics bold, italics and strikethrough The HTML looks like this: \u003cem\u003e\u003cstrong\u003ebold and italics\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003estrikethrough and bold\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003estrikethrough and italics\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003ebold, italics and strikethrough\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"7. Blockquotes For quoting blocks of content from another source within your document. Add \u003e before any text you want to quote: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The rendered output looks like this: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The HTML looks like this: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e Blockquotes can also be nested: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. The rendered output looks like this: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2022-01-01","objectID":"/first_post/:7:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8. Lists ","date":"2022-01-01","objectID":"/first_post/:8:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.1. Unordered A list of items in which the order of the items does not explicitly matter. You may use any of the following symbols to denote bullets for each list item: * valid bullet - valid bullet + valid bullet For example: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2022-01-01","objectID":"/first_post/:8:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.2. Ordered A list of items in which the order of items does explicitly matter. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e Tip If you just use 1. for each number, Markdown will automatically number each item. For example: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2022-01-01","objectID":"/first_post/:8:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.3. Task Lists Task lists allow you to create a list of items with checkboxes. To create a task list, add dashes (-) and brackets with a space ([ ]) before task list items. To select a checkbox, add an x in between the brackets ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media The rendered output looks like this: Write the press release Update the website Contact the media ","date":"2022-01-01","objectID":"/first_post/:8:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9. Code ","date":"2022-01-01","objectID":"/first_post/:9:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.1. Inline Code Wrap inline snippets of code with `. In this example, `\u003csection\u003e\u003c/section\u003e` should be wrapped as **code**. The rendered output looks like this: In this example, \u003csection\u003e\u003c/section\u003e should be wrapped as code. The HTML looks like this: \u003cp\u003e In this example, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e should be wrapped with \u003cstrong\u003ecode\u003c/strong\u003e. \u003c/p\u003e ","date":"2022-01-01","objectID":"/first_post/:9:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.2. Indented Code Or indent several lines of code by at least four spaces, as in: // Some comments line 1 of code line 2 of code line 3 of code The rendered output looks like this: // Some comments line 1 of code line 2 of code line 3 of code The HTML looks like this: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.3. Block Fenced Code Use “fences” ``` to block in multiple lines of code with a language attribute. ```markdown Sample text here... ``` The HTML looks like this: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.4. Syntax Highlighting GFMGitHub Flavored Markdown also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code “fence”, ```bash, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code: ```bash grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` The rendered output looks like this: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Note Syntax highlighting page in Hugo Docs introduces more about syntax highlighting, including highlight shortcode. ","date":"2022-01-01","objectID":"/first_post/:9:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"10. Tables Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned. | Option | Description | | ------ | ------------------------------------------------------------------------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. The HTML looks like this: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Right or center aligned text Adding a colon on the right side of the dashes below any heading will right align text for that column. Adding colons on both sides of the dashes below any heading will center align text for that column. | Option | Description | | :----: | ------------------------------------------------------------------------: | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2022-01-01","objectID":"/first_post/:10:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11. Links ","date":"2022-01-01","objectID":"/first_post/:11:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.1. Basic Link \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) The rendered output looks like this (hover over the link, there is no tooltip): https://assemble.io contact@revolunet.com Assemble The HTML looks like this: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.2. Add a Title [Upstage](https://github.com/upstage/ \"Visit Upstage!\") The rendered output looks like this (hover over the link, there should be a tooltip): Upstage The HTML looks like this: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.3. Named Anchors Named anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) will jump to these sections: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. Note The specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works. ","date":"2022-01-01","objectID":"/first_post/:11:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"12. Footnotes Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. This is a digital footnote[^1]. This is a footnote with \"label\"[^label] [^1]: This is a digital footnote [^label]: This is a footnote with \"label\" This is a digital footnote1. This is a footnote with “label”2 ","date":"2022-01-01","objectID":"/first_post/:12:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"13. Images Images have a similar syntax to links but include a preceding exclamation point. ![Minion](https://octodex.github.com/images/minion.png) or: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat Like links, images also have a footnote style syntax: ![Alt text][id] The DojocatAlt text \" The Dojocat With a reference later in the document defining the URL location: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" This is a digital footnote ↩︎ This is a footnote with “label” ↩︎ ","date":"2022-01-01","objectID":"/first_post/:13:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"}]