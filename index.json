[{"categories":["robotics"],"content":"referenced Technical overview of Internet of Things article. ","date":"2022-04-16","objectID":"/iot_core/:0:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"tl;dr ","date":"2022-04-16","objectID":"/iot_core/:1:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"Terminology top-level components(3) device: hardware itself and sw gateway: connect to cloud services without internet cloud: google cloud type of message state information(data) current status of the device read/write telemetry device metric (i.g sensor data, gps …) read only Each source of telemetry results in a channel Telemetry data might be preserved as a stateful variable on the device or in the cloud. commnads actions performed by a device. commands are often not idempotent which means each duplicate message usually results in a different outcome operational information i.g. CPU operating temperature and battery state can be transmitted as telemetry or state data. serial interface process of sending data one bit at a time, sequentially, over a communication channel or computer bus contrast to parallel communication GPIO General-purpose input/output pin can be designed to carry digital or analog signals, and digital pins have only two states: HIGH or LOW. PWM pulse width modulation The effect in the device can be a lower or higher power level ADC analog to digital conversion analog -\u003e binary I2C Inter Integrated Circuit Inter-Integrated Circuit serial bus uses a protocol that enables multiple modules to be assigned a discrete address on the bus pronounced “I two C”, “I-I-C”, or “I squared C”. OTA update over the air updates ","date":"2022-04-16","objectID":"/iot_core/:2:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"Next mqtt iot core gcp ","date":"2022-04-16","objectID":"/iot_core/:3:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["go"],"content":"gin framework로 crud 서버를 만들며 배운 내용들을 기록해보겠습니다. ","date":"2022-02-12","objectID":"/ch03_real_world/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"TIL go에서는 모든 type을 나타내고자 할 때 비어진 interface를 사용합니다.(dynamic typing) gin-gonic/context.go // MustBindWith binds the passed struct pointer using the specified binding engine. // It will abort the request with HTTP 400 if any error occurs. // See the binding package. func (c *Context) MustBindWith(obj interface{}, b binding.Binding) error { if err := c.ShouldBindWith(obj, b); err != nil { c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck return err } return nil } ","date":"2022-02-12","objectID":"/ch03_real_world/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Update crud를 만들면 update 부분을 깔끔하게 짜는것이 신경쓰입니다. 아래는 todo에서 짜본 update 코드입니다. func UpdateTodo(c *gin.Context) { var todo models.Todo id := c.Params.ByName(\"id\") err := models.GetTodoById(\u0026todo, id) if err != nil { c.JSON(http.StatusNotFound, todo) } c.BindJSON(\u0026todo) err = models.UpdateTodo(\u0026todo, id) if err != nil { c.AbortWithStatus(http.StatusNotFound) } else { c.JSON(http.StatusOK, todo) } } c.BindJSON(\u0026todo)를 ","date":"2022-02-12","objectID":"/ch03_real_world/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"conclustion [2022-02-08T19:21:29+09:00] effective go로 공부하니까, 문서가 정말 좋긴한데, 예상보다 몇시간은 더 걸렸던 것 같습니다. 하지만 양질의 정보를 이렇게 빠르게 읽을 수 있어서 유익한 시간인 것 같네요. - 끝 -","date":"2022-02-12","objectID":"/ch03_real_world/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Effective go를 통해 go 핵심 문법을 빠르게 배워보겠습니다. 또한 나중에 레퍼런스 개념으로 개발할 때 찾아보기 위해서 필요해 보이는 정보들을 모으는 개념으로 글을 작성합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Formatting gofmt 패키지 아래 코드는 소스 파일이 아닌 패키지 레벨에서 실행됩니다. $ go fmt 들여쓰기 들여쓰기를 위해 탭(tabs)을 사용하며, gofmt는 기본값으로 탭을 사용한다. 만약 꼭 써야하는 경우에만 스페이스(spaces)를 사용하라. 한 줄 길이 Go는 한 줄 길이에 제한이 없다. 길이가 길어지는것에 대해 걱정하지 마라. 만약 라인 길이가 너무 길게 느껴진다면, 별도의 탭을 가지고 들여쓰기를하여 감싸라 괄호 Go는 C와 Java에 비해 적은 수의 괄호가 필요하다. 제어 구조들(if, for, switch)의 문법엔 괄호가 없다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Comment godoc package 주석 패키지에서 최상위 선언의 바로 앞에있는 주석이 그 선언의 문서주석으로 처리된다. 패키지 내부에서 최상위 선언 바로 이전의 주석은 그 선언을 위한 문서주석이다. 프로그램에서 모든 외부로 노출되는 (대문자로 시작되는) 이름은 문서주석이 필요하다. 첫 문장은 선언된 이름으로 시작하는 한 줄짜리 문장으로 요약되어야 한다. // Compile parses a regular expression and returns, if successful, // a Regexp that can be used to match against text. func Compile(str string) (*Regexp, error) { 패키지는 각각의 문서 주석을 패키지명과 함께 시작하기 때문에 만약 아래와 같은 명령을 터미널에 활용하면 효율적이다. $ godoc regexp | grep parse Compile parses a regular expression and returns, if successful, a Regexp parsed. It simplifies safe initialization of global variables holding cannot be parsed. It simplifies safe initialization of global variables ","date":"2022-02-07","objectID":"/ch02_go_basic/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Names ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Package Name Go에서는 이름의 첫 문자가 대문자인지 아닌지에 따라서 이름의 패키지 밖에서의 노출여부가 결정된다. package name 패키지가 임포트되면, 패키지명은 패키지 내용들에 대한 접근자가 된다. import \"bytes\" bytes.Buffer // usage 관례적으로, 패키지명은 소문자, 한 단어로만 부여하며 언더바(_)나 대소문자 혼용에 대한 필요가 없어야한다. 또 다른 규칙은 패키지명은 소스 디렉토리 이름 기반이라는 것이다. src/encoding/base64에 있는 패키지는 encoding/base64로 임포트가 된다. base64라는 이름을 가지고 있지만, encoding_base64나 encodingBase64를 쓰지 않는다. import .표현을 사용하지 말라. Package Naming Convention bufio 패키지에 있는 버퍼 리더는 BufReader가 아닌 Reader로 불린다. 왜냐하면 사용자는 이를 bufio.Reader로 보게되며, 이것이 더 명확하고 간결하기 때문이다. 게다가 임포트된 객체들은 항상 패키지명과 함께 불려지기 때문에 bufio.Reader는 io.Reader와 충돌하지 않는다. … 중략 … Go에 존재하는 ring.Ring이라는 구조체의 인스턴스를 만드는 함수는 보통은 NewRing으로 불릴테지만, Ring은 패키지 밖으로 노출된 유일한 타입이며, 패키지가 ring으로 불리기 때문에, 이 함수는 그냥 New라고 부르고 ring.New와 같이 사용한다. Comment is better than long naming 또 다른 간단한 예시는 once.Do이다. once.Do(setup)는 읽기가 쉬우며 once.DoOrWaitUntilDone(setup)으로 개선될게 없다. 긴 이름은 좀 더 쉽게 읽는것을 방해한다. 문서에 주석을 다는것이 긴 이름을 사용하는 것보다 더 좋을 것이다. 클린코드에서는 네이밍을 길게 가져가고 주석을 없애는, 즉 코드로 설명이 가능하도록 하자는 적략을 취하는데 Effective go를 쓴 저자는 무조건 짧은게 최고다는 느낌을 준다. 이러다 보니 history 차원이 아닌 설명을 위한 주석을 달때는 죄의식을 느꼈는데, 개인적으로 미니멀리즘을 좋아하니 go 방식이 더 끌리는 것 같다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Getter and Setter Go는 getters와 setters를 자체적으로 제공하지 않는다. getter and setter naming getter의 이름에 Get을 넣는건 Go언어 답지도, 필수적이지도 않다. 만약 owner(첫 문자가 소문자이며 패키지 밖으로 노출되지 않는다.)라는 필드를 가지고 있다면 getter 메서드는 GetOwner가 아닌 Owner(첫 문자가 대문자이며, 패키지 밖으로 노출됨)라고 불러야한다. … 중략 … 만약 필요하다면, setter 함수는 SetOwner라고 불릴 것이다 owner := obj.Owner() if owner != user { obj.SetOwner(user) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface 관례적으로, 하나의 메서드를 갖는 인터페이스는 메서드 이름에 -er 접미사를 붙이거나 에이전트 명사를 구성하는 방식을 사용한다. Reader Writer Formatter CloseNotifier … ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"MixedCaps go는 camelCase를 사용한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Semicolons C언어 처럼, Go의 정식문법은 구문을 종료하기 위하여 세미콜론을 사용한다. 하지만 C언어와는 달리 세미콜론은 소스상에 나타나지 않는다. 대신 구문분석기(lexer)는 간단한 규칙을 써서 스캔을 하는 과정에 자동으로 세미콜론을 삽입한다. 그래서 소스작성시 대부분 세미콜론을 사용하지 않는다. 세미콜론과 중괄호 세미콜론 입력규칙의 중요한 한가지는 제어문(if, for, switch, 혹은 select)의 여는 중괄호({)를 다음 라인에 사용하지 말아야 한다. // This is good if i \u003c f() { g() } // This sucks if i \u003c f() // wrong! { // wrong! g() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Control structures Go언어에서는 do 나 while 반복문이 존재하지 않으며, for, switch select가 존재한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"if 중괄호를 의무적으로 사용해야 하기 때문에, 다중 라인에서 if 구문들이 간단하게 작성된다. if x \u003e 0 { return y } if와 switch가 초기화 구문을 허용하므로 지역변수를 설정하기 위해 사용된 초기화 구문을 흔히 볼 수 있다. if err := file.Chmod(0664); err != nil { log.Print(err) return err } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Redeclaration and reassignment 먼저 아래의 코드를 보자 f, err := os.Open(name) d, err := f.Stat() 이런 경우처럼 err가 위/아래 곳 모두에서 사용되는데, 이런 선언 중복은 허용된다. Function variable Go언어에서 함수 파라미터와 리턴 값들은, 함수를 감싸고 있는 브래이스들(braces)밖에 위치해 있음에도, 그 스코프는 함수 body의 스코프와 동일하다는 점을 주목할 가치가 있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"for // C언어와 같은 경우 for init; condition; post { } // C언어의 while 처럼 사용 for condition { } // C언어의 for(;;) 처럼 사용 for { } 아래는 go-style for문들입니다. sum := 0 for i := 0; i \u003c 10; i++ { sum += i } 만약 배열, slice, string, map, 채널로 부터 읽어 들이는 반복문을 작성한다면, range 구문이 이 반복문을 관리가능합니다. for key, value := range oldMap { newMap[key] = value } 이렇게 index를 날릴수도 있습니다. for key := range m { if key.expired() { delete(m, key) } } UTF-8 파싱이 덜된 string의 경우 rune으로 변환된다. for pos, char := range \"日本\\x80語\" { // \\x80 은 합법적인 UTF-8 인코딩이다 fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos) } /* character U+65E5 '日' starts at byte position 0 character U+672C '本' starts at byte position 3 character U+FFFD '�' starts at byte position 6 character U+8A9E '語' starts at byte position 7 */ 다음은 parallel assignment를 사용한 for문이다. for i, j := 0, len(a) -1; i\u003cj; i,j = i+1, j-1 { a[i], a[j] = a[j], a[i] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Switch func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } go에서는 switch에 Label(예시에서는 Label)을 넣어서 escape하는 방식도 가끔이지만 쓰인다. Loop: for n := 0; n \u003c len(src); n += size { switch { case src[n] \u003c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \u003c sizeTwo: if n+1 \u003e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]\u003c\u003cshift) } } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Type switch 스위치 구문은 인터페이스 변수의 동적 타입을 확인하는데 사용될 수도 있다. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Functions ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Multiple return values 값과 에러를 같이 내리는 signature func (file \\*File) Write(b []byte) (n int, err error) index와 value를 return func nextInt(b []byte, i int) (int, int) { for ; i \u003c len(b) \u0026\u0026 !isDigit(b[i]); i++ { } x := 0 for ; i \u003c len(b) \u0026\u0026 isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Named result parameters Go 함수에서는 반환 “인자\"나 결과 “인자\"에 이름을 부여하고 인자로 들어온 매개변수처럼 일반 변수로 사용할 수 있다. 이름을 부여하면, 해당 변수는 함수가 시작될 때 해당 타입의 제로 값으로 초기화 된다. func nextInt(b []byte, pos int) (value, nextPos int) { } return parameter는 선언되기 때문에 다음과 같이 사용될 수도 있다. func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) \u003e 0 \u0026\u0026 err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } return } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Defer Go 의 defer 문은 defer 를 실행하는 함수가 반환되기 전에 즉각 함수 호출(연기된 함수)을 실행하도록 예약한다. 이를 통해 기존의 언어가 자원 해제를 context를 사용했던 것과 달리 defer라는 키워드를 통해서 자원 해지가 가능해진다. (python에서는 with을 사용해서 context가 끝날때 exit 호출을 처리해 주었다.) 다음은 mutex에 lock을 풀거나 잠그는 코드입니다. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(resut, buf[0:n]...) if err != nil { if err == io.EOF { break } return \"\", err } } return string(result), nil } close를 delay 시킴으로써 크게 2가지 장점을 얻게된다. 파일을 닫는 것을 잊어버리는 실수를 하지 않도록 보장해 준다. open 근처에 close 가 위치하면 함수 맨 끝에 위치하는 것 보다 훨씬 명확한 코드가 되는것을 의미한다. defer는 함수가 종료될 때 실행되기 때문에 하나의 defer 호출 위치에서 여러개의 함수 호출을 delay 시킬 수 있다. for i:=0; i \u003c 5; i++ { defer fmt.Println(i) } 지연된 함수는 LIFO 순서로 실행된다. (4 3 2 1 0) (와우 궁금했던 부분인데) 추가로 defer안에 인자들에 대한 평가는 기존 함수 실행 순서에 따라 진행된다. 다음은 조금 더 복잡한 defer 예시이다. func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } 위 함수들에 대한 결과는 아래와 같다. entering: b in b entering: a in a leaving: a leaving: b 나중에 나올 panic 과 recover를 사용하면 더욱 멋진 것들을 만들 수 있다고 한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Data ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with new Go에는 메모리를 할당하는 두가지 기본 방식이 있는데, 내장(built-in) 함수인 new와 make이다. new: 새로 제로값으로 할당된 타입 T를 가리키는 포인터를 반환 new(File) == \u0026File{} make: 내부 데이터 구조를 초기화하고 사용될 값을 준비한다. 먼저 new부터 살펴보면, 내장 함수로 메모리를 할당하지만 다른 언어에 존재하는 같은 이름의 기능과는 다르게 메모리를 초기화하지 않고, 단지 값을 제로화(zero) 한다. 다시 말하면, new(T)는 타입 T의 새로운 객체에 제로값이 저장된 공간(zeroed storage)을 할당하고 그 객체의 주소인, *T값을 반환한다. 제로값의 유용함은 전이적인(transitive) 특성이 있다. type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } p := new(SyncedBuffer) // type *SyncedBuffer var v SyncedBuffer // type SyncedBuffer ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constructors and composite literals(합성 리터럴) 때로 제로값만으로는 충분치 않고 생성자(constructor)로 초기화해야 할 필요가 생긴다. 먼저 불필요한 boiler plate 코드 부터 확인해보자. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } 아래는 constructor를 활용한 방식이다. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := File{fd, name, nil, 0} return \u0026f } C와는 달리, 로컬 변수의 주소를 반환해도 아무 문제가 없음을 주목하라; 변수에 연결된 저장공간은 함수가 반환해도 살아 남는다. 실제로, 합성 리터럴의 주소를 취하는 표현은 매번 실행될 때마다 새로운 인스턴스에 연결된다. 그러므로 마지막 두 줄을 묶어 버릴 수 있다. return \u0026File{fd, name, nil, 0} 합성 리터럴의 필드들은 순서대로 배열되고 반드시 입력해야 한다. 하지만, 요소들에 레이블을 붙여 필드:값 식으로 명시적으로 짝을 만들면, 초기화는 순서에 관계 없이 나타날 수 있다. 입력되지 않은 요소들은 각자에 맞는 제로값을 갖는다. 그러므로 아래와 같이 쓸 수 있다. return \u0026File{fd: fd, name: name} Composite literals(합성 리터럴)이란? Composite literals are used to construct the values for arrays, structs, slices, and maps a := [...]string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // array s := []string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // slice m := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // map ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with make new와 달리 make는 slices, maps, 그리고 channels에만 사용하고 (*T가 아닌) 타입 T의 (제로값이 아닌) 초기화된 값을 반환한다. 아래는 new와 make의 차이점을 보여준다. var p *[]int = new([]int) // slice 구조체를 할당한다; *p == nil; 거의 유용하지 않다 var v []int = make([]int, 100) // slice v는 이제 100개의 int를 갖는 배열을 참조한다 // 불필요하게 복잡한 경우: var p *[]int = new([]int) *p = make([]int, 100, 100) // Go 언어다운 경우: v := make([]int, 100) make는 maps, slices 그리고 channels에만 적용되며 포인터를 반환하지 않음을 기억해야 합니다. 포인터를 얻고 싶으면 new를 사용해서 메모리를 할당하거나 변수의 주소를 명시적으로 취해야 합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Arrays Go와 C에서는 배열의 작동원리에 큰 차이가 있다. Go에서는, 배열은 값이다. 한 배열을 다른 배열에 assign할 때 모든 값이 복사된다. 함수의 argument로 배열을 패스하면, 포인터가 아닌 copy된 array를 받는다. 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다. 개인적으로 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다.가 무슨 말인지 잘 모르겠다. 배열을 값(value)으로 사용하는 것이 유용할 수도 있지만 또한 비용이 큰 연산이 될 수도 있다; 만약 C와 같은 실행이나 효율성을 원한다면, 아래와 같이 배열 포인터를 보낼 수도 있다. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\u0026array) // 명시적인 주소 연산자(\u0026)를 주목하라. 하지만 이런 스타일조차 Go언어 답지는 않다. 대신 slice를 사용하라. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Slices Go에서는 변환 메스릭스와 같이 뚜렷한 차원(dimension)을 갖고 있는 항목들을 제외하고는, 거의 모든 배열 프로그래밍은 단순한 배열보다는 slice를 사용한다. Slice는 내부의 배열을 가리키는 레퍼런스를 쥐고 있어, 만약에 다른 slice에 할당(assign)되어도, 둘 다 같은 배열을 가리킨다. 함수가 slice를 받아 그 요소에 변화를 주면 호출자도 볼 수 있는데, 이것은 내부의 배열를 가리키는 포인터를 함수에 보내는 것과 유사하다. slice의 용량은, 내장함수 cap을 통해 얻을 수 있는데, slice가 가질 수 있는 최대 크기를 보고한다. 아래를 보면 slice에 데이터를 부착(append)할 수 있는 함수가 있다. 만약 데이터가 용량을 초과하면, slice의 메모리는 재할당된다. 결과물인 slice는 반환된다. func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } slice는 꼭 처리후 반환되어야 한다. Append가 slice의 요소들을 변경할 수 있지만, slice 자체(포인터, 크기, 용량을 갖고 있는 런타임 데이터 구조)는 값으로 패스되었기 때문이다. 참고로 slice에는 append가 구현되어있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Two-dimensional slices 다음은 go에서 이차원 slices 또는 배열을 정의하고 init하는 방법입니다. type Transform [3][3]float64 type LinesOfText [][]byte text := LinesOfText{ []byte(\"Leoo is awesome\"), []byte(\"Life is fun\"), []byte(\"Life is full of love\"), []byte(\"Let's give our love and fire to the world\") } 예를 들어 사진을 스캔하는 상황이 온다면 2가지 방식으로 이를 해결할 수 있다. 일반적으로 2차원 배열을 만들어 사용하는 방식 height := 300 width := 300 picture := make([][]uint8, height) for i:= range picture { picture[i] = make([]uint8, width) } 하나의 긴 slice에 width만큼 자르면서 이차원 배열에 포인터를 전달하는 방식 picture := make([][]uint8, height) pixels := make([]uint8, width * height) for i := range picture { picture[i], pixels = pixels[:width], pixels[width:] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:6","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Maps {key: value} key는 equality연산이 정의되어 있는 어떤 타입이라도 가능하다. int float string pointer interface(equality 구현된) structs array slice의 경우에는 map의 key로 사용이 될 수 없는데, 이유는 equality가 정의되어 있지 않기 때문이다. 왜 slice에는 equality가 없을까? go에 제시되었던 issue에 레퍼런스된 slice equality에 대한 golang discussion 링크를 보면서 일부분을 정리하면, slice가 value로 비교해야할지, pointer타입으로 비교해야할지 혼돈을 줄 수 있기 때문이라고 합니다. This would probably introduce unnecessary confusion. People are used to the equality operator comparing values in go, as opposed to references. It’s much better if the slices finally support the equality operator, even though the comparison speed will depend on the number of items in the slices. Slice와 마찬가지로 map 역시 내부 데이터 구조를 가진다. 함수에 map을 입력하고 map의 내용물을 변경하면, 그 변화는 호출자에게도 보인다. Map 또한 콜론으로 분리된 key-value 짝을 이용한 합성 리터럴로 생성될 수 있으며, 초기화중에 쉽게 만들 수 있다. var timeZone = map[string]int{ \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60, } offset := timeZone[\"EST\"] go는 keyError를 내지 않고 타입별로 0을 의미하는 값을 리턴한다. 그러므로 아래와 같은 경우가 가능하다. attended := map[string]bool{ \"Ann\": true, \"Joe\": true, ... } if attended[person] { // 만약 person이 맵에 없다면 false일 것이다. fmt.Println(person, \"was at the meeting\") } 만약 value가 bool인 경우같이 keyError와 value(false)를 구분하고 싶다면 아래와 같이한다. 이것을 “comma ok” 관용구라고 부른다. 이 예제에서, 만약 tz가 있다면, seconds는 적절히 세팅될 것이고 ok는 true가 된다 var seconds int var ok bool seconds, ok = timeZone[tz] 다음은 에러헨들링 하는 방식이다. func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\"unknown time zone:\", tz) return 0 } 값이 필요없다면 이렇게 한다. _, present := timeZone[tz] Map의 엔트리를 제거하기 위해서는, 내장 함수 delete을 쓰는데, map과 제거할 key를 인수로 쓴다. map에 key가 이미 부재하는 경우에도 안전하게 사용할 수 있다. delete(timeZone, \"PDT\") // Now on Standard Time ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:7","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Printing 정수(integer)를 소수로 바꾸는 예와 같은 기본적인 변환을 원할 경우는, 다목적 용도 포맷인 %v(value라는 의미로)를 사용할 수 있다 fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) // map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200] 물론, map의 경우 key들은 무작위로 출력될 수 있다. struct를 출력할 때는, 수정된 포맷인 %+v를 통해 구조체의 필드에 주석으로 이름을 달며, 대안 포맷인 %#v를 사용하면 어떤 값이든 완전한 Go 문법을 출력한다. type T struct { a int b float64 c string } t := \u0026T{ 7, -2.35, \"abc\\tdef\" } fmt.Printf(\"%v\\n\", t) fmt.Printf(\"%+v\\n\", t) fmt.Printf(\"%#v\\n\", t) fmt.Printf(\"%#v\\n\", timeZone) \u0026{7 -2.35 abc def} \u0026{a:7 b:-2.35 c:abc def} \u0026main.T{a:7, b:-2.35, c:\"abc\\tdef\"} map[string] int{\"CST\":-21600, \"PST\":-28800, \"EST\":-18000, \"UTC\":0, \"MST\":-25200} 또 다른 유용한 포맷은 %T로, 값의 타입을 출력한다. fmt.Printf(\"%T\\n\", timeZone) // map[string] int 커스텀 타입 print 포맷 지정하는 방법 커스텀 타입의 기본 포맷을 조종하기 위해 해야할 것은 단지 String() string의 시그너처를 갖는 메서드를 정의해 주는 것이다. (위에 정의된) 단순한 타입 T는 아래와 같은 포맷을 가질 수 있다. func (t *T) String() string { return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c) } fmt.Printf(\"%v\\n\", t) // 7/-2.35/\"abc\\tdef\" 위에 예제에서 struct 타입에 포인터를 사용한 이유는 더 효율적이고 Go 언어다운 선택이기 때문이다. String 메서드가 Sprintf를 호출할 수 있는 이유는 print 루틴들의 재진입(reentrant)이 충분히 가능하고 예제와 같이 감싸도 되기 때문이다. 하지만 이 방식에 대해 한가지 이해하고 넘어가야 하는 매우 중요한 디테일이 있는데: String 매서드를 만들면서 Sprintf를 호출할 때 다시 String 매서드로 영구히 재귀하는 방식은 안 된다는 것이다. Sprintf가 리시버를 string처럼 직접 출력하는 경우에 이런 일이 발생할 수 있는데, 그렇게 되면 다시 같은 메서드를 호출하게 되고 말 것이다. 흔하고 쉽게 하는 실수로, 다음의 예제에서 살펴보자. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", m) // 에러: 영원히 재귀할 것임. } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 해결책은 string() 시켜주면 된다. 인수를 기본적인 문자열 타입으로 변환하면, 같은 메서드가 없기 때문이다. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", string(m)) } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 또 다른 출력 기법으로는 출력 루틴의 인수들을 직접 또 다른 유사한 루틴으로 대입하는 것이다. Printf의 시그너처는 마지막 인수로 임의적인 숫자의 파라미터가 포맷 다음에 나타날 수 있음을 명시하기 위해 타입 ...interface{}를 사용한다. // Println 함수는 fmt.Println처럼 표준 로거에 출력한다. func Println(v ...interface{}) { std.Output(2, fmt.Sprintln(v...)) // Output 함수는 (int, string) 파라미터를 받게된다. } log.Println(\"Hello\", \"世界\", 1, 2, 3, 4, 5, 6, 7, 8) // 2009/11/10 23:00:00 Hello 世界 1 2 3 4 5 6 7 8 Sprintln을 부르는 중첩된 호출안에 v 다음에 오는 ...는 컴파일러에게 v를 인수 리스트로 취급하라고 말하는 것이고; 그렇지 않은 경우는 v를 하나의 slice 인수로 대입한다. ... 파라미터는 특정한 타입을 가질 수도 있는데, 예로 integer 리스트에서 최소값을 선택하는 함수인 min에 대한 ...int를 살펴보자 func Min(a ...int) int { min := int(^uint(0) \u0026gt; \u0026gt; 1) // wtf???? for _, i := range a { if i \u003c min { min = i } } return min } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:8","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Append go에 내장되어있는 append 함수의 signature는 다음과 같다. // slice는 func append(slice []T, elements ...T) []T 기본적인 사용법 x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) slice 끼리 append x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:9","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Initialization ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constants 상수는 -함수 내에서 지역적으로 정의된 상수조차도- 컴파일할 때 생성되며, 아래 중 하나가 되어야 한다. 숫자(number) 문자(rune) 문자열(string) 참/거짓(boolean) 상수를 정의하는 표현식은 컴파일 타임에 실행가능한 constant expression이어야 한다. 예를 들어 1\u003c\u003c3은 상수 표현식이지만 math.Sin(math.Pi/4)는 상수 표현식이 아니다. math 패키지의 Sin 함수에 대한 호출이 런타임 시에만 가능하기 때문이다. type ByteSize float64 const ( _ = iota // 공백 식별자를 이용해서 값인 0을 무시 KB ByteSize = 1 \u003c\u003c (10 * iota) MB GB TB PB EB ZB YB ) func (b ByteSize) String() string { switch { case b \u003e= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b \u003e= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b \u003e= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b \u003e= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b \u003e= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b \u003e= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b \u003e= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b \u003e= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) } return fmt.Sprintf(\"%.2fB\", b) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Variables 변수의 초기화는 상수와 같은 방식이지만, 초기화는 런타임에 계산되는 일반적인 표현식이어도 된다. var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\") ) ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"init() 최종적으로, 각 소스파일은 필요한 어떤 상태든지 셋업하기 위해서 각자의 init 함수를 정의할 수 있다. 여기서 “최종적으로” 라는 말은 정말로 마지막을 가리킨다: init 함수는 모든 임포트된 패키지들이 초기화되고 패키지 내의 모든 변수 선언이 평가된 이후에 호출된다. 선언의 형태로 표현할 수 없는 것들을 초기화하는 것 외에도, init 함수는 실제 프로그램의 실행이 일어나기 전에 프로그램의 상태를 검증하고 올바르게 복구하는데 자주 사용된다. init init 함수는 매개변수를 가지지 않으며, 각 파일은 여러 개의 init 함수를 가질 수 있다 func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath may be overridden by --gopath flag on command line. flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Methods ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Pointer vs Value 이전에 만들었던 append 함수와 비교하며 새로운 append 함수를 정의해보자. 들어가기 앞서 앞전에 만들었던 Append 부터 다시 살펴보자 func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } 자 이제 append함수를 슬라이스의 메서드로 재정의 하는 방법 type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { ... 이전과 동일 ... } 위와 같이 할 경우, 값을 return해서 재할당 시켜줘야한다. 이를 피하기 위해 포인터를 사용할 수도 있다. func (p *ByteSlice) Append(data []byte) { slice := *p // 함수 내용은 위와 같지만, return이 없다. *p = slice } 마지막으로 표준 write 메서드 처럼 구현을 해보면 더 멋진 코드를 만들 수 있다. func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p // 내용은 위와 같다. *p = slice return len(data), nil } 타입 *ByteSlice는 표준 인터페이스 io.Writer를 따르게되며, 다루기가 편해진다. 예를 들면, 다음처럼 ByteSlice에 값을 넣을 수 있다. var b ByteSlice fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) ByteSlice의 주소만 넘긴 이유는, 오직 포인터 타입인 *ByteSlice만이 io.Writer 인터페이스를 만족시키기 때문이다. 리시버로 포인터를 쓸 것인가 값을 쓸 것인가에 대한 규칙은 값을 사용하는 메서드는 포인터와 값에서 모두 사용할 수 있으며, 포인터 메서드의 경우 포인터에서만 사용이 가능하다는 것이다. 이러한 규칙은 포인터 메서드는 리시버를 변형시킬 수 있는데 메서드를 값에서 호출하게 되면 값의 복사본을 받기 때문에 원래값을 변형할 수 없기 때문에 생겨났다. Go언어는 이러한 실수(값에서 포인터 메서드를 실행하는 일)를 허용하지 않는다. 하지만 편리한 예외도 있다. 주소를 얻을 수 있는 값의 경우에, Go언어는 포인터 메서드를 값 위에서 실행할 경우 자동으로 주소 연산을 넣어준다. 위의 예시에서, 변수 b는 주소로 접근이 가능하기 때문에 단순히 b.Write만으로 Write메서드를 호출할 수 있다. 컴파일러는 이것을 (\u0026b).Write로 재작성할 것이다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface Go언어의 인터페이스는 객체의 행위(behavior)를 지정해 주는 하나의 방법이다: 만약 어떤 객체가 정해진 행동를 할 수 있다면 호환되는 타입으로 쓸 수 있다는 뜻이다. (Duck typing, Go는 런타임에 duck typing하는 파이썬과 달리 Compile time duck typing이 가능하므로, 성능의 문제가 없다) 인터페이스의 이름(명사)은 보통 메서드(동사)에서 파생된다: Write 메서드를 구현하면 io.Writer가 인터페이스의 이름이 되는 경우. 타입은 복수개의 인터페이스를 구현할 수 있다. sort.Interface와 Stringer 두개의 interface를 구현하는 타입의 예시를 보자면 아래와 같다. sort.Interface type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } Stringer type Stringer interface { String() string } sort.Interface와 Stringer를 만족하는 type type Sequence []int // sort.Interface func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \u003c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } // Stringer func (s Sequence) String() string { sort.Sort(s) // Sequence 타입은 []int와 네이밍 외에는 모두같은 타입이기 때문에 변환 가능하다. return fmt.Sprint([]int(s)) // type converted (Sequence -\u003e []int) } 위의 코드의 Len(), Less(), Swap() 함수는 실제로, sort.Sort()에 들어가는 sort.Interface를 만족시키기 위해 사용하기 위해 작성된 메서드들이다. 그러므로 아래와 같이 간단하게 코드를 간소화 시킬 수 있다. type Sequence []int func (s Sequence) String() string { sort.IntSlice(s).Sort() return fmt.Spring([]int(s)) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface conversions and type assertions 타입 스위치는 Interface conversions(변환)의 한 형태이다: 인터페이스를 받았을 때, switch문의 각 case에 맞게 타입 변환을 한다 아래 예제는 fmt.Printf가 타입 스위치를 써서 어떻게 주어진 값을 string으로 변환시키는 지를 단순화된 버전으로 보여 주고 있다. 만약에 값이 이미 string인 경우는 인터페이스가 잡고 있는 실제 string 값을 원하고, 그렇지 않고 값이 String 메서드를 가지고 있을 경우는 메서드를 실행한 결과를 원한다. type Stringer interface { String() string } var value interface{} switch str := value.(type) { case string: return str case Stringer: return str.String() } 오로지 한 타입만에만 관심이 있는 경우는 어떨까? 만약 주어진 값이 string을 저장하는 걸 알고 있고 그냥 그 string 값을 추출하고자 한다면? 단 하나의 case만을 갖는 타입 스위치면 해결 할 수 있지만 타입 단언 표현을 쓸 수도 있다. Type Assertion(타입 단언)은 인테페이스 값을 가지고 지정된 명확한 타입의 값을 추출한다. 문법은 타입 스위치를 열 때와 비슷하지만 type 키워드 대신 명확한 타입을 사용한다 //value.(typeName) str := value.(string) 여기에서 typeName은 static type이다. 만약 위의 예시에서 value가 string 타입을 가지고 있지 않을 경우, 프로그램은 런타임 에러를 내고 죽는다. 이런 참사에 대비하기 위해서, “comma, ok” 관용구를 사용하여 안전하게 값이 string인지 검사 해야 한다. str, ok := value.(string) if ok { fmt.Printf(\"string value is: %q\\n\", str) } else { fmt.Printf(\"value is not a string\\n\") } 아래는 위에서 보여준 타입 스위치와 동일한 기능을 하는 if-else문 예시이다. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Generality 만약 어떤 타입이 오로지 인터페이스를 구현하기 위해서만 존재한다면, 즉 인터페이스외 어떤 메서드도 외부에 노츨시키지 않은 경우, 타입 자체를 노출 시킬 필요가 없다. 그런 경우에, constructor는 구현 타입보다는 인터페이스 값을 반환해야 한다. 설명에 좋은 예시가 있어 인용하자면 Quote 각종 crypto 패키지내의 스트리밍 cipher 알고리즘들을, 이들이 연결해 쓰는 block cipher들로 부터 분리시킬 수 있다. crypto/cipher 패키지내 Block 인터페이스는 한 block의 데이터를 암호화하는 block cipher의 행위를 정의한다. 그런 다음, bufio 패키지에서 유추해 볼 수 있듯이, Block 인터페이스를 구현하는 cipher 패키지들은, Stream 인터페이스로 대표되는 스트리밍 cipher들을 건설할 때, block 암호화의 자세한 내용을 알지 못하더라도, 사용될 수 있다. type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) } type Stream interface { XORKeyStream(dst, src []byte) } block cipher를 스트리밍 cipher로 바꾸어 주는 카운터 모드 (CTR) 스트림의 정의가 있다. 주의해야할 점은 input과 output이 모두 interface 타입이다. // NewCTR은 카운더 모드로 주어진 Block을 이용하여 암호화하고/해독하는 스트림을 반환한다. // iv의 길이는 Block의 block 크기와 같아야 한다. func NewCTR(block Block, iv []byte) Stream ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interfaces and methods Quote Since almost anything can have methods attached, almost anything can satisfy an interface. 거의 모든 것에 메서드를 첨부할 수 있다는 말은 거의 모든 것이 인터페이스를 만족 시킬 수 있다는 말이기도 합니다. 심지어 함수에도 메서드를 첨부시킬 수 있다. 대표적인 예가 http패키지이다. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ... // 단순한 카운터 서버. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr) } ... import \"net/http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) ... // 채널이 매 방문마다 알린다. // (아마 이 채널에는 버퍼를 사용해야 할 것이다.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \u003c- req fmt.Fprint(w, \"notification sent\") } // 마지막으로, 서버를 구동할 때 사용한 명령줄 인수들을 /args에 보여주려는 경우를 상상해 보자. // 명령줄 인수를 출력하는 함수를 쓰는 것은 간단하다. func ArgServer() { fmt.Println(os.Args) } 이것을 어떻게 HTTP 서버로 바꿀 수 있을까? 어떤 타입에다가 값은 무시하면서 ArgServer를 메서드로 만들 수 있을 것이다. 하지만 더 좋은 방법이 있다. 포인터와 인터페이스만 빼고는 어떤 타입에도 메서드를 정의할 수 있는 사실을 이용해서, 함수에 메서드를 쓸 수 있다. http 패키지에 다음과 같은 코드가 있다: // HandlerFunc는 어뎁터로써 평범한 함수를 HTTP handler로 쓸 수 있게 해 준다. // 만약에 f가 적절한 함수 signature를 가지면, // HandlerFunc(f)는 f를 부르는 Handler 객체인 것이다. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc는 ServeHTTP라는 매서드를 같는 타입으로, 이 타입의 값은 HTTP request에 서비스를 제공한다. 메서드의 구현을 한번 살펴 보자. 리시버는 함수, f이고 메서드가 f를 부른다. 이상해 보일 수도 있지만, 리시버가 채널이고 메서드가 채널에 데이터를 보내는 예와 비교해도 크게 다르지 않다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"The blank identifier https://gosudaweb.gitbooks.io/effective-go-in-korean/content/the_blank_identifier.html ","date":"2022-02-07","objectID":"/ch02_go_basic/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"conclustion [2022-02-08T19:21:29+09:00] effective go로 공부하니까, 문서가 정말 좋긴한데, 예상보다 몇시간은 더 걸렸던 것 같습니다. 하지만 양질의 정보를 이렇게 빠르게 읽을 수 있어서 유익한 시간인 것 같네요. - 끝 -","date":"2022-02-07","objectID":"/ch02_go_basic/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Go at Google: Language Design in the Service of Software Engineering를 기반으로Go에 녹아있는 배경/철학을 분석합니다. 이후 사용되는 필드들을 정리하고 학습에 도움되는 best practice 레퍼런스들을 정리합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"tl;dr Go is a compiled, concurrent, garbage-collected, statically typed language developed at Google ","date":"2022-02-05","objectID":"/ch01_go_design/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Introduction 웹 서비스가 많아지고 컴퓨터 환경이 발전하면서 관리해야 할 코드와 서비스가 많아졌고 이를 효율적으로 관리하기 위해 go는 만들어졌습니다. 공식문서의 go 디자인 레퍼런스를 발견해, 이를 토대로 분석글을 작성합니다.Go at Google: Language Design in the Service of Software Engineering 추가로 FAQ를 참조하였습니다. go를 개발한 이유 The Go programming language was conceived in late 2007 … 중략 … mostly C++, Java, and Python, had been created … 중략 … We were not alone in our concerns. After many years with a pretty quiet landscape for programming languages, Go was among the first of several new languages—Rust, Elixir, Swift, and more—that have made programming language development an active, almost mainstream field again. … 중략 … The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today’s server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. go는 2007년에 만들어졌습니다. 이 당시의 언어로써는 다음과 같은 문제들을 해결하기 어려웠기 때문에 go를 개발하기 시작했다고 보입니다. multicore processors 고려 개발자들의 수요 증가(코드의 scale 증가 -\u003e 깔끔한 코드 니즈 증가) 서버 scale increase build time too long 이때는 참고로 Rust, Elixir, Swift 같은 대안 언어들이 없었다고 합니다. go 디자인 목표 Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go’s design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. built-in concurrency garbage collection dependency management adaptability of software architecture google at go The goals of the Go project were to eliminate the slowness and clumsiness of software development at Google, and thereby to make the process more productive and scalable. The language was designed by and for people who write—and read and debug and maintain—large software systems. 구글의 현존하는 수많은 legacy 코드들과 앞으로 늘어날 코드들을 효율적으로 관리하기 위해서 go를 개발하기 시작했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Pain points 아래는 go를 만들 때 고려되었던 pain point들입니다. slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds ","date":"2022-02-05","objectID":"/ch01_go_design/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"c.f go는 왜 { }를 사용하나요? 안정성과 신뢰성을 위해 python style indentation 편의성을 포기하고 {}를 그래도 도입함. go는 왜 중괄호를 사용하나요? Our position is therefore that, although spaces for indentation is nice for small programs, it doesn’t scale well, and the bigger and more heterogeneous the code base, the more trouble it can cause. It is better to forgo convenience for safety and dependability, so Go has brace-bounded blocks. 구글이 가진 노하우에 따르면 작은 프로그램에서는 python의 indentation이 좋지만, 코드 기반이 클수록 \u0026 cross-language build 환경에서는 python 스타일이 좋지 않기 때문에 { }를 그대로 쓰기로 결정했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Dependencies in Go go가 의존성을 대하는 전략에 대해서 정리합니다. 아래와 같은 c의 guard기능으로 인해 불필요하게 의존성을 읽어들이는 현상이 발생했습니다. /* Large copyright and licensing notice */ #ifndef _SYS_STAT_H_ #define _SYS_STAT_H_ /* Types and other definitions */ #endif Note The first step to making Go scale, dependency-wise, is that the language defines that unused dependencies are a compile-time error (not a warning, an error). … 중략 … This guarantees by construction that the dependency tree for any Go program is precise, that it has no extraneous edges. That, in turn, guarantees that no extra code will be compiled when building the program, which minimizes compilation time. 구글 같이 코드 베이스가 많은 경우, 빌드타임이 오래걸리는 것은 업무의 효율성을 떨어뜨리기 때문에 go에서는 사용하지 않는 dependency들에 대해서 compile-time error를 뱉어내도록 하고 있습니다. 더 나아가서 go는 include of include file와 같은 상황에도 효율적인 전략을 취하고 있습니다. package A imports package B; package B imports package C; package A does not import package C 다음과 같이 A에서 B를 직접 참조하고, C는 간접적으로 참조하는 상황이 있을 때, go 컴파일러는 2가지 전략을 취합니다. C -\u003e B -\u003e A 순으로 compile한다. A에서 B를 참조할 때, 컴파일 시 생성된 B Object 파일에 B public interface가 영향받을 dependency들의 type information을 넣어둔다. Note In other words, when B is compiled, the generated object file includes type information for all dependencies of B that affect the public interface of B. 예를 들어서 A에서 B안에 들어있는 I/O package를 import하고, B안에 들어있는 I/O 패키지는 C에 정의되어있는 buffered I/O를 사용해서 구현(implementation)되어있을 때, C -\u003e B -\u003e A 순으로 컴파일되면서 link됩니다. 이때 A가 컴파일될 때 컴파일러는 B의 Object file을 읽어(주의! 소스코드를 읽는게 아님)들이는데, 이때 해당 파일에는 A에서 import B를 실행할 때 컴파일러에 필요한 필요한 모든 타입 정보가 들어있습니다. This is, of course, reminiscent of the Plan 9 C (as opposed to ANSI C) approach to dependency management, except that, in effect, the compiler writes the header file when the Go source file is compiled 이런 종속성 관리 접근 방식은 Plan 9 C(ANSI C와 반대) 접근 방식과 유사하며, 단 실제로 Go 소스 파일이 컴파일될 때 컴파일러가 헤더 파일을 작성해 준다는 점만 다릅니다. Note To make compilation even more efficient, the object file is arranged so the export data is the first thing in the file, so the compiler can stop reading as soon as it reaches the end of that section. 참고로 컴파일 할 때 고언어 컴파일러는 export할 data를 Object file 맨 앞단에 위치시켜서 export 해줄 정보만 빠르게 찾아볼 수 있도록 구현되어 있다고 합니다. Note Go places the export data in the object file; some languages require the author to write or the compiler to generate a second file with that information. That’s twice as many files to open. In Go there is only one file to open to import a package. Also, the single file approach means that the export data (or header file, in C/C++) can never go out of date relative to the object file. 또한 export data를 object파일에 위치시키기 때문에 import package시킬 때, 컴파일러는 파일 당 하나의 object 파일만 읽어들이면 되며 부가적으로 관리해야 할 포인트가 하나로 줄어든다는 장점이 있습니다. Note Another feature of the Go dependency graph is that it has no cycles. …중략… The lack of circular imports causes occasional annoyance but keeps the tree clean, forcing a clear demarcation between packages. As with many of the design decisions in Go, it forces the programmer to think earlier about a larger-scale issue (in this case, package boundaries) that if left until later may never be addressed satisfactorily. 마지막으로 go언어는 circular import(= cyclic import)를 컴파일 타임에 에러를 내 줌으로써 효율적인 package boundaries에 대해서 개발자가 고민할 수 있도록 해줍니다. 이런 방식들을 통해 go는 기존 언어보다 획기적으로 build time을 줄일 수 있었습니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Packages Note It’s important to recognize that package paths are unique, but there is no such requirement for package names. The path must uniquely identify the package to be imported, while the name is just a convention for how clients of the package can refer to its contents. The package name need not be unique and can be overridden in each importing source file by providing a local identifier in the import clause. These two imports both reference packages that call themselves package log, but to import them in a single source file one must be (locally) renamed: package의 path는 unique해야 합니다. package name은 unique할 필요없으며, 중복 될 경우 이를 사용하는(import) 영역에서 naming을 override해서 사용합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"remote package 개인적으로 신기했던 부분인데, go에서는 import 해주는 package path가 url이 될 수도 있습니다. 예를 들어서 github에서 doozer 패키지를 가져오고 싶으면 아래와 같이 해주면 됩니다. $ go get github.com/4ad/doozer // Shell command to fetch package import \"github.com/4ad/doozer\" // Doozer client's import statement var client doozer.Conn // Client's use of package 이렇게 한번 fetch(package를 install)해주면 그 다음부터는 일반적인 package와 마찬가지로 import 해주면 됩니다. 이런 방식을 도입함으로써 explicit하게 dependencies들을 보여줄 수 있게 되었습니다. Note Also, the allocation of the space of import paths is delegated to URLs, which makes the naming of packages decentralized and therefore scalable, in contrast to centralized registries used by other languages. 또한 URL로 allocation of the space of import paths가 위임됨으로써, package의 naming이 decentralized \u0026 scalable하게 만들었습니다. (저는 allocation of the space of import paths라는 뜻을 url의 unique한 장점을 package path로 그대로 가져와서 global하게 unique한 decentralized system을 만들었다고 이해했습니다.) ","date":"2022-02-05","objectID":"/ch01_go_design/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Syntax Go was therefore designed with clarity and tooling in mind, and has a clean syntax. go declaration(선언) 문법중에서 C 스타일 프로그래머들을 놀라게 하는 부분이 있습니다. go style var fn func([]int) int type T struct { a, b int } c style int (*fn)(int[]); struct T { int a, b; } The declared name appears before the type and there are more keywords. 이런 Declarations introduced by keyword 문법은 Pascal에 더 가깝다고 합니다. 이를 통해 개발자는 더 수월하게 코드 분석이 가능하며, type syntax를 가지는 것이 C언어 같이 expression syntax 보다 컴퓨터가 parsing 성능에 상당히 더 유리하다고 합니다. go는 type syntax라는 문법을 추가해서 코드가 늘어나지만, 이를 통해 모호성을 제거하였습니다. 단 편의를 위해 go에서는 var 키워드를 삭제하고 :=라는 키워드를 관용적으로 사용합니다. var buf *bytes.Buffer = bytes.NewBuffer(x) // explicit buf := bytes.NewBuffer(x) // derived 마지막으로 Go에서는 default function arguments를 의도적으로 누락시켰습니다. 기본 인자가 가지는 모호성으로 코드를 사용하는 부분이 명시적이지 못할 경우가 많다는 단점이 있기 때문입니다. 물론 같은 네이밍을 가질 함수가 가질 수 있는 모든 interface(function signature)를 구현해줘야 한다는 단점을 가지긴합니다. 아래는 go에서 함수 / 메서드를 표현하는 방법입니다. 코트린 처럼 fun을 키워드로 가졌으면 더 좋았을 것 같네요. func Abs(x T) float64 // function declaration func (x T) Abs() float64 // method declaration go는 first-class function / closures를 지원합니다. negativeAbs := func(x T) float64 { return -Abs(x)} // lambda go는 multiple value return이 가능합니다. func ReadByte() (c byte, err error) c, err := ReadByte() if err != nil { ... } Note Those functions all need separate names, too, which makes it clear which combinations exist, as well as encouraging more thought about naming, a critical aspect of clarity and readability. 엇? java 처럼 오버로딩을 하는게 아니라 signature 바뀔때마다 모두 새로운 함수명을 만들어줘야한다는 의미일까요? 아무튼 go는 clarity를 가장 최우선으로 두는 것 같습니다. Tip 개인적으로 default argument가 사라진 건 너무 좋은 것 같은게, python기준으로 함수가 여기저기 많이 사용될수록 default argument 때문에 불필요하게 사용되는 모든 코드들을 뒤져야 할 때가 많았습니다. 예를 들어 def create_person(name, age=30): if age \u003c 30: ... else: ... 이런 함수가 있고 이 함수 관련해서 에러가 나면 create_person를 호출하는 모든 코드들을 다 뒤져봐야 할 경우가 있었습니다. 특히 mongodb처럼 데이터의 스키마가 고정되지 않은 데이터를 함수의 dto로 받는 경우에는 정말 짜증납니다. (kotlin migration 과정에서 엄청 스트레스를 줬던 콘 mcard…) ","date":"2022-02-05","objectID":"/ch01_go_design/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Naming Go에서는 신기하게도 visibility of an identifier를 대소문자로 구별합니다. (타 언어에서는 private / public따위의 키워드를 씀) name as visibility identifier Go the name itself carries the information: the case of the initial letter of the identifier determines the visibility. If the initial character is an upper case letter, the identifier is exported (public); otherwise it is not: upper case initial letter: Name is visible to clients of package otherwise: name (or _Name) is not visible to clients of package 이런 rule은 모든 곳에 적용됩니다. variables types functions methods constants fields 이런 특이한 전략을 취한데에는 naming으로 visibility를 관리하는 것이 identifier에 비해 더욱 깔끔한 Public api관리에 도움되는 전략이라고 판단한 google의 노하우가 반영되었다고 합니다. 개인적으로는 코드 검색을 할 때, identifier를 가지고 검색하면 관련 identifier 리스트들을 한번에 확인이 가능한 반면 네이밍으로 visibility를 관리하면 정확한 네이밍을 알아야 가능하다는 점에서 솔직히 별로 인 것 같습니다. scope hierarchy Another simplification is that Go has a very compact scope hierarchy: universe (predeclared identifiers such as int and string) package (all the source files of a package live at the same scope) file (for package import renames only) function block naming scope There is no scope for name space or class or other wrapping construct. Names come from very few places in Go, and all names follow the same scope hierarchy: at any given location in the source, an identifier denotes exactly one language object, independent of how it is used. (The only exception is statement labels, the targets of break statements and the like; they always have function scope.) …중략… top-level predefined names such as int, (the first component of) every name is always declared in the current package. go에서는 일부 예외(statement labels, argets of break statements는 function scope)를 제외하면 naming은 package scope로 관리됩니다. package scope로 naming이 관리되는 이유 exported name to a package can never break a client of that package. The naming rules decouple packages, providing scaling, clarity, and robustness. function / method 오버로딩 불가능 method lookup is always by name only, not by signature (type) of the method. In other words, a single type can never have two methods with the same name java와 달리 go에서는 function signature만 다르고 네이밍이 같은 메서드 / 함수를 만드는 것은 불가능합니다. 개발자가 네이밍을 좀 더 신경써야 된다는 불편함은 있겠지만, 개인적으로 더 깔끔하게 함수들을 관리할 수 있는 방법이라고 생각되네요 (왠지 function naming관련된 convention tip들이 있을 것 같음) effective go about Functions ","date":"2022-02-05","objectID":"/ch01_go_design/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Semantics go는 기본적으로 c와 많이 닮아 있지만, modern언어에 익숙한 개발자들을 위해 몇가지 차이점을 두었습니다. there is no pointer arithmetic there are no implicit numeric conversions array bounds are always checked there are no type aliases (after type X int, X and int are distinct types not aliases) ++ and – are statements not expressions assignment is not an expression it is legal (encouraged even) to take the address of a stack variable 아래는 C, C++, and even Java와 비교했을 때, 크게 변화한 부분입니다. (참고로 go 초기 개발자인 Robert Griesemer. Java hotspot compiler(JVM)을 개발했었습니다. ) concurrency gc interface type reflection type switches ","date":"2022-02-05","objectID":"/ch01_go_design/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Concurrency Go is not purely memory safe in the presence of concurrency. Sharing is legal and passing a pointer over a channel is idiomatic (and efficient). Go는 Communicating sequential processes, CSP의 first-class channel개념을 가져왔습니다. (which is about message passing via channels in concurrent system) Don't communicate by sharing memory, share memory by communicating Some concurrency and functional programming experts are disappointed that Go does not take a write-once approach to value semantics in the context of concurrent computation, that Go is not more like Erlang for example. Again, the reason is largely about familiarity and suitability for the problem domain. Go’s concurrent features work well in a context familiar to most programmers. Go enables simple, safe concurrent programming but does not forbid bad programming. We compensate by convention, training programmers to think about message passing as a version of ownership control. Go는 concurrency context에 write-once 접근을 하지 않습니다. 이는 의도적으로 bad programming을 막지 않은 것인데요, convention으로 이런 bad practice를 방지하고, 프로그래머들이 message passing에 대해서 더 생각하도록 유도하기 위함이라고 합니다. 이런 철학은 go의 motto에서도 드러나 있습니다. “Don’t communicate by sharing memory, share memory by communicating.” ","date":"2022-02-05","objectID":"/ch01_go_design/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Garbage collection go는 jvm 개발자가 있어서 그런지 c / c++ / rust와 달리 gc를 가져왔습니다. interior pointer The X.buf field in the example above lives within the struct but it is legal to capture the address of this inner field, for instance to pass it to an I/O routine. In Java, as in many garbage-collected languages, it is not possible to construct an interior pointer like this, but in Go it is idiomatic. java와 비교해 interior pointers(interior pointers to objects allocated in the heap) 기능을 추가해 커스텀하게 gc 기능이 동작하도록 적용했다고 합니다. interior 디자인이 끼칠 영향 This design point affects which collection algorithms can be used, and may make them more difficult, but after careful thought we decided that it was necessary to allow interior pointers because of the benefits to the programmer and the ability to reduce pressure on the (perhaps harder to implement) collector. … 중략 … The garbage collector remains an active area of development. The current design is a parallel mark-and-sweep collector and there remain opportunities to improve its performance or perhaps even its design. (The language specification does not mandate any particular implementation of the collector.) Still, if the programmer takes care to use memory wisely, the current implementation works well for production use. 듣기로는 gc기능이 퍼포먼스 이슈가 있어 Discord에서는 기존에 go로 짜여있는 코드들을 rust로 옮겼다고 하네요. ","date":"2022-02-05","objectID":"/ch01_go_design/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Composition not inheritance there is no type hierarchy go에는 기존 oop 언어들과 달리 type hierarchy가 없습니다. interface In Go an interface is just a set of methods …중략… All data types that implement these methods satisfy this interface implicitly; there is no implements declaration. That said, interface satisfaction is statically checked at compile time so despite this decoupling interfaces are type-safe. 자바와 달리 고의 interface는 behavior만 정의하며 subclassing이 없으므로 상속이란 개념이 존재하지 않습니다. 대신 composition(embedding)을 활용한다고 합니다. subclassing vsv subtyping go에는 subclassing이 없다고 하는데요, subclassing이 무엇인지 그리고 subtyping 또한 무엇인지 비교해보겠습니다. 서브클래싱은 구현되어 있는 클래스를 상속하는 것 서브타이핑은 정의되어 있는 인터페이스를 구현하는 것 먼저 좀 더 Subclassing이란 ? Superr Class에 구현된 코드와 내부 표현 구조를 Sub Class(하위 클래스)가 이어받는 기능을 뜻합니다. 클래스 inheritance라고도 불리며, 이를 통해 하위클래스에서 슈퍼 클래스에 구현된 코드의 재사용이 가능합니다. 그렇기 때문에 sub class는 overriding을 통해 같은 이름의 비슷하지만 커스텀한 행동들을 정의할 수 있습니다. 이와 달리 Subtying이란, Super Type의 객체가 수행할 행동(behavior only)의 약속(프로토콜, api)를 Sub Type이 이어 받습니다. 행동들을 공통된 타입으로 묶어 runtime에 super type의 객체의 타입으로 sub type을 대체가능하도록 합니다. 이를 통해 프로그램 변경에 대한 영향을 최소화 할 수 있습니다. 즉 core한 behavior들을 공통적으로 관리 가능합니다. go가 inheritance를 버린 이유 that the behavior of data can be generalized independently of the representation of that data. The model works best when the behavior (method set) is fixed, but once you subclass a type and add a method, the behaviors are no longer identical. If instead the set of behaviors is fixed, such as in Go’s statically defined interfaces, the uniformity of behavior enables data and programs to be composed uniformly, orthogonally, and safely. 이런 전략을 취했던 이유는 behavior가 fix되어 코드가 작성되면 data representation을 담당하는 model이 works best한다는 철학이 녹아들어있다고 합니다. TODO: 글을 읽다보니 composition에 대해서는 어느정도 이해가 되는데, 이런 철학이 왜 고려되어야 하는지가 정확하게 와닫지는 않는 것 같아서 나머지 부분은 실제 코드를 만져보고 다시 읽어보려고 합니다. Composition not inheritance ","date":"2022-02-05","objectID":"/ch01_go_design/:13:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Errors Go에는 일반적인 의미의 예외 기능이 없습니다. 즉, 오류 처리와 관련된 제어 구조가 없습니다. go가 error를 보는 방식 Errors are just values and programs compute with them as they would compute with values of any other type go가 error를 value로 취급하는 첫번째 이유 First, there is nothing truly exceptional about errors in computer programs. For instance, the inability to open a file is a common issue that does not deserve special linguistic constructs; if and return are fine. f, err := os.Open(fileName) if err != nil { return err } go 철학에서는 error를 특별한 예외라고 생각할 필요가 전혀 없다고 생각하기 떄문입니다. 그냥 value가 return되고 if 분기로 이를 핸들링해주면 그만이라고 주장합니다. go가 error를 value로 취급하는 두번째 이유 There is no question the resulting code can be longer, but the clarity and simplicity of such code offsets its verbosity. Explicit error checking forces the programmer to think about errors—and deal with them—when they arise. 결과 코드가 더 길어질 수 있다는 점에는 의심의 여지가 없지만 그러한 코드의 명확성과 단순성은 장황함을 상쇄합니다. 명시적 오류 검사는 프로그래머가 오류에 대해 생각하고 오류가 발생할 때 처리하도록 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:14:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Useful references Go at Google: Language Design in the Service of Software Engineering golang cheat sheet gin ","date":"2022-02-05","objectID":"/ch01_go_design/:15:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"conclustion 이상으로 go의 디자인 철학에 대해서 분석해보았습니다. 개인적으로 하루정도를 투자하려 했지만, 실제로는 와닿지 않는 내용들 때문에 시간이 조금 더 지체되었던 것 같네요 (소요시간: 대략 2일) - 끝 -","date":"2022-02-05","objectID":"/ch01_go_design/:16:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"새로운 언어를 공부하다보면, 생각보다 기초를 공부하는 시간이 소모적이라는 생각이 들어 조금 더 효율적인 학습방법을 정리해보고 싶어 글로 남겨둡니다. 최근 오픈소스에 기여하고 싶다는 생각이 점점 커지다 보니, 이직 전에 golang에 더 익숙해지고 싶다는 생각을 하게되었습니다. 또 혹시 새로운 프로젝트의 백엔드 웹 서버를 만들어야 될 수도 있어, 이 프로젝트 또한 go와 gin을 사용해 개발해보고 싶다는 생각들이 변곡점을 이루면서 변곡점(變曲點, inflection point) 부랴부랴 나는 어떻게 Go 언어를 배웠나를 토대로 계획해본 go 학습 계획입니다. ","date":"2022-02-05","objectID":"/go_study_plan/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"tl;dr 영상에서 니꼬가 새로운 언어를 학습하는 합리적인 방법을 공유해주고 있는데요, 정리하면 다음과 같습니다. 공식문서 기초 문법 익숙한 언어들과 비교 (✍️ python과 공통점 차이점 비교글 작성) ASAP code (✍️ graph Tree관련 1문제) 튜토리얼 (✍️ best practice copy) 나만의 프로젝트 (✍️ migration tidify) ","date":"2022-02-05","objectID":"/go_study_plan/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"Go plan 가장 먼저 공식문서에서는 언어가 등장한 배경과 철학을 분석합니다. 또한 어떤 필드에서 해당 언어가 사용되는지를 파악하여 커뮤니티의 특성과 채용/이직에 대한 목표를 세울수 있습니다. 마지막으로 해당 언어가 사용되는 레퍼런스를 리서치합니다. 공식문서 언어 철학 who used (사용 필드/커뮤니티 분석) best practice 레퍼런스 리서치 1의 과정에서 배경지식을 얻었다면, 기초문법을 빠르게 훓어봅니다. 익숙하지 않은 키워드들만 terminology로 정리해보는 것도 좋고, cheatsheet를 훑어보는 것 또한 좋은 방법이라 생각합니다. 기초 문법 키워드 위주로 최대한 빠르게 이후 익숙한 언어와 비교해보면서, 기존의 정보들과 link를 만들어갑니다. 이 방법은 기억력 측면에서 유용한 방법이라 생각합니다. 익숙한 언어들과 비교 equvalance 3의 과정에서 공통/차이점을 훝어 보았다면 바로 기초문법들을 사용해서 코드를 작성해봅니다. 익숙한 graph(tree)관련 알고리즘을 풀어보면 class를 사용해볼 수 있어서 유리할 것 같습니다. code ASAP 2-3에서 배운 문법 활용 기초 문법을 빠르게 쳐보았다면 best practice를 분석해봅니다. 튜토리얼 1에서 찾은 best practice 또는 유명한 오픈소스 / 튜토리얼 fork 후 일부분 로컬에서 재조립 마지막으로 나만의 프로젝트를 빠르게 만들어봅니다. 프로젝트의 규모는 TODO 따위의 간단한 crud 비즈니스 로직을 가진 주제면 더 좋을 것 같습니다. 저의 경우에는 tidify 프로젝트가 가장 비슷한 규모라고 생각되어 tidify 프로젝트를 migration 해보는 걸 목표로 해보고 싶습니다. 하지만 현실적인 시간을 고려해서 tidify가 부담스럽다면 (gin프레임워크를 따로 배우는 시간이 필요) 간단한 TODO 프로젝트 만드는 걸 1차 목표로 진행해보겠습니다. 나만의 프로젝트 최대한 익숙한 프로젝트 주제 i.g TODO 또는 기존 프로젝트 migration ","date":"2022-02-05","objectID":"/go_study_plan/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"conclustion 개인적으로 계획을 세우는 걸 좋아하지만, 금방 싫증을 느끼다 보니 더 현실적이고 체계적으로 계획을 세우고 싶은 니즈가 생겼던 것 같습니다. 이렇게 6가지 순서를 진행하는데 제게 가장 맞는 방법은 스피드라고 생각이 됩니다. 저 같은 경우는 흥미가 빨리 바뀌기 때문에 해당 과정을 일주일동안 해보는 걸 목표로 잡고 진행해볼까 생각합니다. 1~4: 1일 5: 2일 6: 4일 총 일주일 과정을 목표로 기록해보겠습니다. - 끝 -","date":"2022-02-05","objectID":"/go_study_plan/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":[""],"content":"Hardhat를 통해 local에서 스마트 컨트랙트를 작성해본 뒤, contract를 upgrade시켜봅니다. 이후 rinkeby 테스트넷에 proxy 컨트랙트를 배포해보고, verify시켜봅니다. 환경에 사용된 레포는 github link입니다. hardhat과 openzeppelin 환경에서 간단한 Upgradable contract를 생성해봅니다. ","date":"2022-02-02","objectID":"/hardhat/:0:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"setup 먼저 프로젝트 환경을 로컬에서 세팅해줍니다. ","date":"2022-02-02","objectID":"/hardhat/:1:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"init $ yarn init -y $ yarn add hardhat --dev $ yarn add @openzeppelin/hardhat-upgrades --dev 테스트는 다음과 같이 할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:1","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"test $ npx hardhat test ","date":"2022-02-02","objectID":"/hardhat/:1:2","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy 로컬에서 ganache같은 내부 노드를 실행할 수 있습니다. $ npx hardhat node 로컬에서 이제 배포를 해봅시다. deploy $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgrade.deploy.js SimpleStorageUpgrade deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 런타임에 콘솔에서 붙어서 제대로 배포되었는지 검증해봅니다. check $ npx hardhat console --network localhost Welcome to Node.js v14.15.1. Type \".help\" for more information. \u003e const f = await ethers.getContractFactory(\"SimpleStorageUpgrade\") undefined \u003e const ssu = await f.attach(\"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0\") undefined \u003e ssu.address '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0' \u003e (await ssu.get()).toString() '500' \u003e let tx = await ssu.set(1000) undefined \u003e (await ssu.get()).toString() '1000' 다음과 같이 활용하면 스마트 컨트랙트를 upgrade 시켜줄 수 있습니다. upgrade contract version $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgradeV2.deploy.js Compiling 1 file with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade version 2 deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 ","date":"2022-02-02","objectID":"/hardhat/:1:3","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy to remote network hardhat docs 이제 실제 remote 환경에서 배포해보겠습니다. hardhat.config.js require(\"dotenv\").config(); // yarn add dotenv // ... 중략 ... module.exports = { networks: { rinkeby: { url: `https://eth-rinkeby.alchemyapi.io/v2/${process.env.ALCHEMY_API_KEY}`, // 0x20CE8B2190949f48F5D32d5BbbfE7E3760811F61 accounts: [process.env.TEST_ACCOUNT_PRIVATE_KEY], }, }, solidity: \"0.8.4\", etherscan: { apiKey: process.env.ETHERSCAN_API_KEY, }, }; ALCHEMY_API_KEY: alchemy에서 demo app을 생성하게 될 경우 view key를 하면 확인가능합니다. TEST_ACCOUNT_PRIVATE_KEY: metamask에서 rinkeby 네트워크에 계정을 생성한 뒤 아래와 같이 비공개키 export를 누르면 확인 가능합니다. ETHERSCAN_API_KEY register etherscan에서 회원 가입을 한 뒤 create etherscan api key에서 My API Keys \u003e + Add해주어서 얻어줍니다. 추가로 rinkeby faucet에 들어가게되면 address 기반으로 rinkeby 계정에 이더를 넣어줄 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:4","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy remote blockchain network rinkeby network (test-net) $ npx hardhat run --network rinkeby ./scripts/SimpleStorageUpgrade.deploy.js Downloading compiler 0.8.4 Compiling 3 files with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade deployed to: 0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 테스트넷이기 때문에 약간의 시간이 소요됩니다. (약 30초) 이후 deploy된 address는 rinkeby etherscan에서 확인가능합니다. https://rinkeby.etherscan.io/address/0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 proxy contract check The implementation contract at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 does not seem to be verified. 아직 implementation이 검증되지 않았다고 뜬다. 이렇게 proxy가 아닌 implementation contract를 검증해주기 위해서는 아래와 같이 추가 작업해주면 됩니다. ","date":"2022-02-02","objectID":"/hardhat/:2:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"verify implementation docs 먼저 hardhat에서 제공해주는 etherscan 의존성을 설치해줍니다. $ yarn add @nomiclabs/hardhat-etherscan --dev 이후 아래 명령어를 통해서, 로컬의 deploy된 컨트랙트와 실제 rinkeby에 배포된 컨트랙트를 비교해서 검증해주는 로직을 타줍니다. //npx hardhat verify --network rinkeby \"\u003c리모트 배포된 implementation address\u003e\" $ npx hardhat verify --network rinkeby \"0x92a949706c10fd221b9a073f4284b4bdbc47e6d7\" Compiling 3 files with 0.8.4 Solidity compilation finished successfully Compiling 1 file with 0.8.4 Successfully submitted source code for contract contracts/SimpleStorageUpgrade.sol:SimpleStorageUpgrade at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 for verification on the block explorer. Waiting for verification result... Successfully verified contract SimpleStorageUpgrade on Etherscan. https://rinkeby.etherscan.io/address/0x92a949706c10fd221b9a073f4284b4bdbc47e6d7#code 이상으로 배포된 컨트랙트에서 정상적으로 배포된 컨트랙트를 확인할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:3:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH03] 이더리움 기초를 정리합니다. 인용글들은 원문을 참조하였습니다. Note An Ethereum client is a software application that implements the Ethereum specification and communicates over the peer-to-peer network with other Ethereum clients … 중략 … Ethereum is defined by a formal specification called the “Yellow Paper” (see [references]). 이더리움 클라이언트는 sw application으로 yellowpaper에 명시된 ethereum spec들을 만족시키는 구현체입니다. p2p network상에서 서로 통신하며 이더리움 생태계를 이끌어갑니다. This is in contrast to, for example, Bitcoin, which is not defined in any formal way. ","date":"2022-01-29","objectID":"/ch03_eth_client/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Ethereum Networks Note There exist a variety of Ethereum-based networks that largely conform to the formal specification defined in the Ethereum Yellow Paper … 중략 … Among these Ethereum-based networks are Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin, and many others. Yellow Paper에 기제된 스펙을 기반으로 구현된 Ethereum based 네트워크들은 많이 존재합니다. (Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin…) 대부분 프로토콜 수준에서는 호환되지만, 각 네트워크 마다 세세한 부분에서 다른 점들이 존재하기 때문에 이더리움 클라이언트 maintainers들이 각 네트워크를 지원하기 위해 약간씩의 코드 변경작업이 필요합니다. 이 때문에 모든 버전의 이더리움 클라이언트 소프트웨어가 모든 이더리움 기반 블록체인을 실행하는 것은 아닙니다. 책에서 소개하는 대표적인 Ethereum protocol 구현체는 다음과 같습니다. Parity, written in Rust Geth, written in Go cpp-ethereum, written in C++ 현재는 aleth라고 레포가 되어있으며 deprecated됨 pyethereum, written in Python 현재는 py-evm로 관리되고 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Should I Run a Full Node? The health, resilience, and censorship resistance of blockchains depend on them having many independently operated and geographically dispersed full nodes. Each full node can help other new nodes obtain the block data to bootstrap their operation, as well as offering the operator an authoritative and independent verification of all transactions and contracts. 글을 읽고 보니, 이더리움에서 말하는 Node와 Client개념이 헷갈려 먼저 정리하고 들어가겠습니다. Client vs Node 공식문서에 따르면 Node 분산된 이더리움 네트워크 컴퓨터들에서 동작하는 소프트웨어를 지칭합니다. “Node” refers to a running piece of client software. features: verify blocks, transaction data Types full node: block 전부 copy light node: header만 copy archive node Client 사용자들의 컴퓨터에서 node를 실행할 수 있도록 하는 application을 뜻합니다 node는 piece of client입니다. A client is an implementation of Ethereum that verifies all transactions in each block, keeping the network secure and the data accurate. Note Full client Full clients store the entire Ethereum blockchain; a process that can take several days to synchronize and requires a huge amount of disk space – over 1 Terabyte to be exact, according to the latest figures. Full clients allow connected nodes to perform all tasks on the network, including mining, transaction and block-header validation and running smart contracts. Light client Ethereum clients may be implemented in full or in part. The above overview gives an explanation of how a “full” client works, however it is important to know that you don’t always need to run a full client. Typically when data storage and speed are at issue, developers will elect to use what are called “light clients.” Light clients offer a subset of the functionality of a full client. Light clients can provide faster speeds and free up data storage availability because, unlike the full clients, they do not store the full Ethereum blockchain. The scope of a light client’s functionality is tailored toward the goals of the Ethereum client. For example, light clients are frequently used for private keys and Ethereum address management within a wallet. Additionally, they tend to handle smart contract interactions and transaction broadcasts. Other uses for remote clients include web3 instances within JavaScript objects, dapp browsers and retrieving exchange rate data. Remote client There is a third type of client called a remote client which is similar to a light client. The main difference being, a remote client does not store its own copy of the blockchain, nor does it validate transactions or block headers. Instead, remote clients fully rely on a full or light client to provide them with access to the Ethereum blockchain network. These types of clients are predominantly used as a wallet for sending and receiving transactions. The terms “remote client” and “wallet” are used interchangeably, though there are some differences. Usually, a remote client offers an API (such as the web3.js API) in addition to the transaction functionality of a wallet 참고로 remote client라는 용어와 wallet은 interchangeably하게 사용되는데, 둘의 미묘한 차이점으로는 remote client는 api(such as web3.js)를 제공한다는 점이다. remote client = wallet + api Ethereum remote clients do not validate block headers or transactions. They entirely trust a full client to give them access to the blockchain, and hence lose significant security and anonymity guarantees. 이더리움 remote clients는 light client 처럼 block header 검증하지 않습니다. 이 덕분에 local hw 스펙을 줄일 수 있으나, 외부 full client들에게 depend한다는 특징이 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"The JSON-RPC interface 왜 JSON-RPC를 사용할까? 글을 읽다가 왜 이더리움은 json-rpc를 사용하는지 궁금해서 찾아보게 되었습니다. REST와 json-rpc의 차이점에 대해서 정리하겠습니다. JSON-RPC: tcp base로 원격/로컬 프로세스 procedure(함수)에 직접 접근하는 방식 over tcp only single endpoint crud외 표현 가능 REST over http(s) crud(http method)를 벗어난 표현에 제한적이다. rpc는 소스코드 \u003e idl(interface definition language) \u003e rpcgen\u003e stub 코드 생성 \u003e rpc runtime을 통한 packet 통신 (tcp L4) 과정을 통해서 서버와 클라이언트간 통신을 하게 만듭니다. http(L7)보다 더 낮은 레벨(L4)에서 동작하기 때문에 기능이 덜 할 수 있지만, 제약이 덜합니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Conclusion 뭔가 3장은 내심 겉할기 식의 설명들이 많았던 것 같습니다. rpc-json을 굳이 쓰는 이유도 없었고 client와 node에 대한 설명도 크게 와닿지 않은 것 같아 답답하네요. 예를 들면 full client를 실행하는 방법을 알려주면서, full client를 사용자가 왜 운용해야하는지를 light client와 비교하는 핵심이 빠진 느낌이 듭니다. (full client를 사용해야지 reward가 들어오는 걸까요..? 좀 더 공부가 필요하네요) - 끝 - ","date":"2022-01-29","objectID":"/ch03_eth_client/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH02] 이더리움 기초를 정리합니다. 인용글들은 원문을 참조하였습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"tl;dr 이번 챕터에서는 실제 solidity코드를 작성한 뒤, 실제 eth를 전송하고 회수하는 contract를 테스트넷에 배포해보겠습니다. 이를 위해 크게 3가지를 다루게 됩니다. 가장 먼저 Metamask wallet을 생성하고, Ropsten test network기반의 faucet으로 부터 ether를 받습니다. 그 뒤 faucet contract코드를 solidity로 작성한 뒤 Remix를 활용해 EVM-bytecode로 compile한 뒤 Faucet contract on Ropsten 네트워크로 등록합니다. (이때 withdraw() 함수를 추가) 마지막으로 Faucet contract address로 ether를 보낸 뒤, withdraw()를 실행해 봅니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Ether Currency Units 이더 화폐 단위 이더리움의 화폐 단위는 ether(이더)라고 불리며, ETH 심볼을 사용합니다. 또한 이더의 최소 단위는 wei(웨이)라고 불립니다. $$ 10^{18} wei = 1 ETH $$ 이더리움 내부에서는 항상 웨이를 부호 없는 정수를 사용합니다. Ethereum’s currency unit is called ether, identified also as “ETH” or with the symbols Ξ (from the Greek letter “Xi” that looks like a stylized capital E) or, less often, ♦ ","date":"2022-01-28","objectID":"/ch02_eth_basic/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Choosing an Ethereum Wallet 이더리움 지갑이란 이더리움 계정을 관리하는 데 사용되는 소프트웨어 애플리케이션이라고 생각하시면 됩니다. In short, an Ethereum wallet is your gateway to the Ethereum system. It holds your keys and can create and broadcast transactions on your behalf. 사용자의 개인키를 보관 사용자를 대신하여 트랜잭션 생성 및 브로드캐스트 시행 이더리움 공식 홈페이지의 정의에 따르면 지갑을 아래와 같이 정의 내리고 있습니다. Quote 지갑은 이더를 전송할 수 있고 보유할 수도 있는 애플리케이션입니다. 또한 이더리움 디앱에서도 사용할 수 있습니다. 또한 현재(2022.01.28)기준으로 아래 지갑들을 추천합니다. 메타마스크(MetaMask) iOS와 Android용 브라우저 확장 프로그램 및 모바일 지갑 마이크립토(MyCrypto) 웹 기반 지갑 트러스트월렛(TrustWallet) iOS와 Android용 모바일 지갑 마이이더월렛(MyEtherWallet) 클라이언트 측 지갑 오페라(Opera) 지갑이 통합된 주요 브라우저 지갑의 대표주자인 Metamask와 TrustWallet를 trust wallet vs metamask글을 토대로 요약 정리 해보겠습니다. Trust Wallet Metamask Cost Free Free Desktop Software Yes Yes Mobile App Yes No Built-in exchange Yes (Kyber Network and Web3 browser) No NFT Support Yes No Staking Options Yes No Available Cryptocurrencies Bitcoin, BNB, and all ERC20 Tokens All ERC-20 Tokens Security Medium Medium Compatible with hardware wallets No Yes 아직 어떤게 더 좋아보이는지는 모르겠지만, 개인적으로 metamask에 개발 레퍼런스가 더 많이 있는 것 같아, 메타마스크를 사용해볼 예정입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Wallet Metamask with Ropsten test network Chrome extension에 MetaMask를 치면 메타마스크 애플리케이션을 크롬에 추가할 수 있습니다. 메타마스크 익스텐션 설치 및 가입이 끝났다는 전제하에 설명을 진행하도록 하겠습니다. 테스트를 하기 위해 Ropsten테스트 네트워크로 설정해줍니다. “구매\"를 누르고 “포시트(수도꼭지)테스트\"에서 [Ether 얻기]를 눌러줍니다. 이 경우 아래와 같이 새로운 웹페이지가 열립니다. Faucet 파우셋(Faucet)이란 수도꼭지란 뜻으로 코인 무료 지급 하는곳 으로 사용되고 있다. 이더리움 생태계에서는 대표적으로 Ropsten, Kovan이 존재합니다. 새 웹페이지에서 request 1 ether from faucet(초록 버튼)을 클릭하게 되면 자신의 address로 1eth가 들어오게 됩니다. 몇 초간의 대기 시간이 지나면, 이더 지급이 완료된 transaction을 확인할 수 있습니다. 이 때 트랜잭션 링크를 누르게 되면 아래와 같은 EtherScan 링크로 이동 되고, 트랜잭션 상세내용을 확인하실 수 있습니다. 다음과 같이 faucet으로 돌려보내기 또한 가능합니다. 참고로 test 네트워크도 마찬가지로 gas비를 받는데요, 이는 real 이더 메인넷과 동일한 환경을 제공하기 위해서 입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Introducing the World Computer 지금까지 이더리움 지갑에 대해서 살펴보았습니다. 앞서 이야기 하였듯 이더리움은 cryptocurrency 기능외에도 튜링 complete한 하나의 컴퓨터입니다. Ether는 smart contract를 사용하기 위해 소모되는 payment의 개념이며, 이런 smart contract프로그램은 emplated computer called Ethereum Virtual Machine(EVM)위에서 동작합니다. The EVM is a global singleton, meaning that it operates as if it were a global, single-instance computer, running everywhere. Each node on the Ethereum network runs a local copy of the EVM to validate contract execution, while the Ethereum blockchain records the changing state of this world computer as it processes transactions and smart contracts. EVM 요약 Global singleton Each node validate broadcasted contracts execution Ethereum blockchain records changing state. (tx, smart contract) ","date":"2022-01-28","objectID":"/ch02_eth_basic/:5:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Externally Owned Accounts (EOAs) and Contracts 이더리움에는 2가지 타입의 account가 존재합니다. EOA Contract Account The type of account you created in the MetaMask wallet is called an externally owned account (EOA). 먼저 EOA란 사용자를 대변하는 account입니다. Externally owned accounts are those that have a private key; having the private key means control over access to funds or contracts. EOA는 사용자의 private key를 소유하고 있으며, 이는 contract 또는 account의 코인에 접근 권한이 있다는 뜻입니다. Has private key Has address Simple EOA can’t have smart contract code That other type of account is a contract account. A contract account has smart contract code, which a simple EOA can’t have. Furthermore, a contract account does not have a private key. Instead, it is owned (and controlled) by the logic of its smart contract code: the software program recorded on the Ethereum blockchain at the contract account’s creation and executed by the EVM Contract Account는 스마트 컨트랙트의 주소에 해당되며, 스마트 컨트랙트가 블록에 포함되어 배포될때 해당 스마트 컨트랙트에 대한 주소가 생성이 되며, 이 주소를 통해서 메세지 전송이나 특정함수를 실행 할 수 있습니다. Has smart Contract Has address Does not have private key Owned by smart contract itself However, when a transaction destination is a contract address, it causes that contract to run in the EVM, using the transaction, and the transaction’s data, as its input. In addition to ether, transactions can contain data indicating which specific function in the contract to run and what parameters to pass to that function. In this way, transactions can call functions within contracts. 트랜잭션의 destination이 contract address일 경우, 이는 트랜잭션을 통해 컨트랙트가 EVM에서 실행되도록 트리거 합니다. 트랜잭션 안에는 특정 contract function안에 어떤 parameter가 전달되는지를 기록함으로 써 특정 위치의 contract의 함수가 어떤 인자를 가지고 실행해야 할지를 지정할 수 있습니다. Private key가 없다는 의미 Note that because a contract account does not have a private key, it cannot initiate a transaction. Only EOAs can initiate transactions, but contracts can react to transactions by calling other contracts, building complex execution paths. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:6:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"A Simple Contract: A Test Ether Faucet // SPDX-License-Identifier: CC-BY-SA-4.0 // Version of Solidity compiler this program was written for pragma solidity 0.6.4; // Our first contract is a faucet! contract Faucet { // Accept any incoming amount receive() external payable {} // receive는 키워드 // Give out ether to anyone who asks function withdraw(uint withdraw_amount) public { // Limit withdrawal amount require(withdraw_amount \u003c= 100000000000000000); // Send the amount to the address that requested it msg.sender.transfer(withdraw_amount); } } receive() external payable {} // receive는 키워드 solidity 0.6 버전 이후 fallback기능은 2가지로 나눠지게 되었습니다. receive() external payable — for empty calldata (and any value) fallback() external payable — when no other function matches (not even the receive function). Optionally payable. Tip fallback a.k.a default function이라고도 불리며, 이름 그대로 대비책 함수입니다. 특징 먼저 무기명 함수, 이름이 없는 함수입니다. external 필수 payable 필수 왜 쓰는가 ? 스마트 컨트랙이 이더를 받을 수 있게 한다. 이더 받고 난 후 어떠한 행동을 취하게 할 수 있다. call함수로 없는 함수가 불려질때, 어떠한 행동을 취하게 할 수 있다. msg.sender.transfer(withdraw_amount); msg object는 one of the inputs로 모든 contracts가 접근 가능한 객체입니다. transaction이 실행되도록 trigger 시킨 주체를 의미합니다. 또한 attribute인 sender는 sender address of the transaction를 의미합니다. 마지막으로 transfer()는 built-in 함수로 ether를 current contract -\u003e 누군가.transfer()의 누군가에게 전달하는 것을 의미하며 이 코드에서 누군가는 address of the sender입니다. 즉 코드를 한줄로 설명하면 contract --eth--\u003e msg.sender로 작동해라는 명령어 입니다. This meas transfer ether from current contract to the sender of the msg that triggered this contract execution ","date":"2022-01-28","objectID":"/ch02_eth_basic/:7:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Compiling the Faucet Contract 자 이제 우리가 처음 작성한 스마트 컨트랙트 코드를 Solidity Compiler를 통해 EVM bytecode로 변환을 하여 EVM에서 실행 될 수 있도록 만들어보겠습니다. Solidity Compiler로는 대표적으로 아래의 것들이 있습니다. 저희는 이 중 solidity 공식문서에서 권유하는 Remix IDE를 사용해보겠습니다. We recommend Remix for small contracts and for quickly learning Solidity. 참고로 대안으로 급부상하고 있는 Hardhat이라는 개발환경 또한 존재합니다. web3.js 대신 (ethers.js)를 default로 사용함. Remix에서 코드를 작성한 뒤, Remix 좌측 2번째 탭을 클릭한 뒤, 적절한 compiler 버전(이번 예제는 0.6.4)를 설정해주고 compile Faucet.sol 버튼을 클릭해주면 아래와 같은 화면을 볼 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:8:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Creating the Contract on the Blockchain Now, we need to “register” the contract on the Ethereum blockchain. 이제 robsten test 네트워크에 생성해준 contract를 등록해보겠습니다. Registering a contract on the blockchain involves creating a special transaction whose destination is the address 0x0000000000000000000000000000000000000000, also known as the zero address. The zero address is a special address that tells the Ether‐ eum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask. 자 Remix의 3번째 탭(DEPLOY \u0026 RUN TRANSACTIONS)을 클릭하여 아래와 같이 세팅해줍니다. Account는 앞서 metamask에서 계정을 생성해주었다면 remix에서 metamask 요청페이지를 열어주어, 계정을 연결시켜줄 것입니다. 여기에서 “Deploy\"버튼을 누르게 되면 이렇게 Deployed Contract가 등록요청하는 metamask 창이 열리고 확인을 누릅니다. 확인을 눌러주면 Remix상에서 contract가 생성된 것을 보실 수 있습니다. 우측의 copy버튼을 눌러 Contract address를 복사해서 etherscan에서 확인해보겠습니다. 생성한 컨트렉트에서 보여지듯이 잘 생성된 것을 확인하실 수 있습니다. 자 그럼 1eth를 해당 컨트랙트로 보내보겠습니다. metamask를 통해서 이더를 보낸뒤, etherscan을 통해서 확인해보면 정상적으로 value 1eth가 전송된 것을 확인할 수 있습니다. 자 이제 튜토리얼의 마지막 단계인 0.1eth를 회수 해보겠습니다. Remix의 버튼에 “100000000000000000” (10*17 wei = 0.1eth)를 기입하고 withdraw버튼을 클릭해줍니다. etherscan을 통해서 보면 다음과 같이 0.1 eth를 전송한 트랜잭션을 확인할 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:9:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Conclusion 이상으로 마스터링 이더리움 ch02인 기초적인 이더리움에 대해서 정리해보았습니다. 개인적으로 스마트 컨트랙트가 어떻게 배포되는 지 궁금했었는데 staging 개념으로 테스트를 해볼 수 있는 테스트넷이 있다는 점과, 실제 컨트랙트를 배포해서 metamask 계정과 연동해서 동작시켜볼 수 있었던 점이 재밌었던 것 같습니다. - 끝 - ","date":"2022-01-28","objectID":"/ch02_eth_basic/:10:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-21","objectID":"/ch03/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Quote 나만의 좀비 덱을 만들어보자. ","date":"2022-01-21","objectID":"/ch03/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"[ch03] Advanced Solidity Concepts 챕터3를 통과하게 되면 나만의 좀비 덱을 가지게 됩니다. ","date":"2022-01-21","objectID":"/ch03/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Ownable Contracts external function으로 setter를 열어두게 되면, 아무나 내 컨트랙트 안의 state variable을 수정할 수 있게 되는 보안적인 이슈가 생기게 된다. 이를 대처하기 위해 주로 사용하는 방식은 contract를 ownable하게 만들어 특별한 권리를 가지는 특정 소유자가 있음을 지정할 수 있다. /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } function Ownable()는 Constructor(생성자)입니다. 컨트랙트와 동일한 이름을 가졌으며 default로 제공되어 특별한 작업을 할 게 아니라면 생략가능합니다. 생성자는 컨트랙트 생성시 단 한번만 실행됩니다. modifier onlyOwner()에서 modifier는 function modifier(함수 제어자)입니다. 함수에 대한 접근을 제어하기 위해 사용되는 함수의 일종으로, 보통 함수 실행 전 요구사항 충족여부를 확인하는 데 사용됩니다. 예시의 onlyOwner() 함수는 컨트랙트의 소유자에 한해서만 해당 함수를 실행할 수 있도록 하기 위해 제어해주는 기능을 해줍니다. 즉 transferOwnership(소유권 이전) 함수는 onlyOwner 조건을 만족시킬 때만 실행됩니다. _ 키워드는 쉽게 modifier 검사를 마친 뒤, 실행 될 함수가 들어가게 된다 생각하면 됩니다. indexed 키워드에 대해서는 추후에 더 알아보겠습니다. ","date":"2022-01-21","objectID":"/ch03/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas 이더리움 DApp이 사용하는 연료 솔리디티에서는 사용자들이 만든 DApp의 함수를 실행할 때마다 Gas라 불리는 화폐(ETH, 이더)를 지불해야합니다. 엄밀히 말해서는 사용자가 ETH(이더)를 이용해 Gas를 구매한다. Gas비는 연산비용에 따라 다릅니다. 즉 함수의 로직이 얼마나 복잡한지에 따라 연산이 소모되는 gas cost가 상승합니다. 이런 시스템이기 때문에 코드 최적화가 암묵적으로 강제된다 할 수 있습니다. 가스는 함수를 실행하는 사용자들이 실제 돈을 쓰기 때문에 코드 최적화가 되지 않았다면 당연히 많은 사용자들이 생성한 코드를 사용하지 않게 됩니다. Gas가필요한이유 이더리움 진영에서는 이더림움을 World Computer라고 소개합니다. 전세계에 퍼져있는 개별 노드들이 누군가가 만든 함수를 실행할 때 네트워크 상의 모든 노드 각각이 함수의 output을 검증하기 위해 그 함수를 실행해야 합니다. 이더리움은 Turing complete하기 때문에 무한 루프와 같이 컴퓨팅 자원을 많이 소모되는 코드가 악의적으로 생성된다면 이더리움이라는 하나의 컴퓨터에 악영향을 끼칠것입니다. 이런 이유로 이더리움 개발자들은 연산 처리에 각각 비용을 할당했으며 사용자들은 space / time complexity에 비례하여 gas를 지불해야 합니다. 추가로 크립토 좀비에 따르면 side-chain에서는 반드시 gas를 지불하지는 않는다고 하네요, Loom Network를 사용하는 크립토 좀비가 대표적인 예시라고 합니다. 이더리움 메인넷에서 롤 같은 게임을 직접 돌리게 되면 말도 안되게 엄청 높은 가스 비용이 들테니까요. 하지만 다른 합의 알고리즘을 가진 사이드체인에서는 가능하다고 합니다. ","date":"2022-01-21","objectID":"/ch03/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas비 절약법 기본적으로 uint256이 아닌 uint8과 같은하위 타입들로 저장소를 절약하는 것은 아무런 이득이 없다고 합니다. 왜냐면 솔리디티에서 uint의 크기에 상관없이 256bit 저장공간을 미리 잡아두기 때문입니다. 단 struct 안에서 uint를 사용한다면 더 작은 크기를 사용할 때, storage 절약이 가능하다고 합니다. struct NormalStruct { uint a; uint b; uint c; } struct MiniMe { uint32 a; uint32 b; uint c; } // `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용하게 됩니다. NormalStruct normal = NormalStruct(10, 20, 30); MiniMe mini = MiniMe(10, 20, 30); 이런 이유로, 구조체 안에서는 가능한 작은 크기의 정수 타입을 쓰는 것이 좋다고 할 수 있습니다.또한 동일한 데이터 타입은 하나로 묶어놓는 것이 좋습니다. 즉 구조체에서 서로 가까이 있도록 선언하면 솔리디티에서 사용하는 저장 공간을 최소화해줍니다. 예를 들면, uint c; uint32 a; uint32 b;라는 필드로 구성된 구조체가 uint32 a; uint c; uint32 b; 필드로 구성된 구조체보다 uint32 필드들이 묶여있기 때문에 가스를 덜 소모합니다. ","date":"2022-01-21","objectID":"/ch03/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Time Units Solidity provides some native units for dealing with time. now now를 사용하게 되면 unix timestamp(1970년 1월 1일부터 지금까지의 초 단위 합)을 uint256타입으로 얻을 수 있습니다. 참고로 unix time은 전통적으로 32bit로 저장되는데 이 경우 Year 2038 문제가 발생할 것입니다. 만약 우리 DApp이 2038년까지 운영되길 원한다면 어쩔 수 없이 64bit를 써야하지만, trade of로 유저들은 저장하는데 더 많은 gas를 소모하게 됩니다. 2038년_문제 year 2038 problem란? POSIX 시간 표기법은 시간을 1970년 1월 1일 자정 UTC 이후 경과된 초 시간을 이용하여 표현하는데,대부분의 32비트 시스템에서 초 시간을 저장하는 데 이용되는 time_t 자료 형식은 부호 있는 32비트 정수형이다. 즉 이 형식을 이용하여 나타낼 수 있는 최후의 시각은 1970년 1월 1일 자정에서 정확히 2147483647초가 지난 2038년 1월 19일 화요일 03:14:07 UTC이다. 이 시각 이후의 시각은 범위를 초과하여 내부적으로 음수로 표현되며, 프로그램의 이상 작동을 유발하는데, 왜냐하면 이러한 값은 2038년 대신 프로그램의 구현 방법에 따라 1970년 또는 1901년을 가리키기 때문입니다. uint lastUpdated; // `lastUpdated`를 `now`로 설정 function updateTimestamp() public { lastUpdated = now; } // 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환 function fiveMinutesHavePassed() public view returns (bool) { return (now \u003e= (lastUpdated + 5 minutes)); } ","date":"2022-01-21","objectID":"/ch03/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Passing structs as arguments 솔리디티에서는 private 또는 internal 함수의 인자로서 구조체의 storage 포인터를 전달할 수 있습니다. 이때 구조체는 포인터타입이며, 솔리디티에서는 이를 storage pointer라고 부르고 있습니다. 문득 memory pointer명칭도 존재하는지 찾아보니 서치하지 못한걸 보면 storage pointer라는 명칭만 있는 것 같습니다. storage pointer라는 명칭을 처음 접해서 개념을 정리하기 위해서 이곳저곳을 찾다, Storage Pointers in Solidity라는 글을 읽었습니다. 이해한 부분까지 정리해보면 struct타입은 기본적으로 pointer 타입인 것고 이를 function에서 local variable로 참조해서 사용하면 storage형태로 저장되는 것 같습니다. 아래의 코드를 보면 contract FirstSurprise { struct Camper { bool isHappy; } mapping(uint =\u003e Camper) public campers; function setHappy(uint index) public { campers[index].isHappy = true; } function surpriseOne(uint index) public { Camper c = campers[index]; c.isHappy = false; } } setHappy를 통하지 않고도, surpriseOne()의 Camper c = campers[index] c가 storage pointer타입이기 때문에 side-effect가 생길 수 있다는 점이 핵심인 듯합니다. 최근에 이런 목소리를 반영해서 solidity compiler는 이런 상황일 때 아래와 같은 warning을 띄워준다고 합니다. Variable is declared as storage pointer. Use explicit “storage” keyword to silence this warning. 이런 맥락에서 크립토 좀비에서는 구조체를 함수의 인자로 전달하면 storage pointer라고 설명하고 있으며, 아래와 같이 함수 인자에 명시적으로 storage를 쓰도록 하고 있습니다. function _doStuff(Zombie storage _zombie) internal { // _zombie로 할 수 있는 것들을 처리 } 그럼 이런 배경지식을 기억한채 다시 좀비로 넘어와보겠습니다. 우리는 좀비들이 끊임없이 kitty를 먹고 증식하는 것을 막기 위해서 feedAndMultiply에 다음 제약조건을 추가해보려고 합니다. 먹이를 먹으면 좀비가 재사용 대기에 들어간다. 좀비는 재사용 대기 시간이 지날 때까지 고양이들을 먹을 수 없다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime \u003c= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); // 새로 추가 된정보 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; } _createZombie(\"NoName\", newDna); _triggerCooldown(myZombie); // 새로 추가 된정보 } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 우선 Zombie storage pointer를 인자로 받는 _isReady(), _triggerCooldown()함수를 만듭니다. _isReady(): 좀비가 재사용 대기시간을 넘겼는지 확인 _triggerCooldown(): 좀비가 kitty와 조합(eat) 되었다면, 좀비의 readyTimed을 now + cooldownTime(1일)로 업데이트 해줍니다. 이후 좀비에게 먹이를 공급하는 feedAndMultiply()함수에 아무나 접근하지 못하도록 internal로 함수를 지정해줍니다. ","date":"2022-01-21","objectID":"/ch03/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Function modifiers with arguments 앞서 modifier onlyOwner같은 커스텀 function modifier를 보았는데, 이에 더해 function modifier에 argument를 넣어주는 법을 배워봅시다. // usrId =\u003e age mapping mapping (uint =\u003e uint) public age; modifier olderThan(uint _age, uint _userId) { require(age[_userId] \u003e= _age); _; } function buyCigarette(uint _userId) public olderthan(19, _userId) { 🚬() } 위의 코드는 담배를 판매하는 간단한 contract입니다. functio nmodifier의 인자로 나이와 userId를 제공하여 나이를 검사를 구현해주었습니다. 이 기능을 활용하여 우리의 zombie에게 level 속성을 부여해보고, 속성에 따라서 아래와 같은 능력치 제한을 두는 modifier를 만들어보겠습니다. 레벨 2 이상인 좀비인 경우, 사용자들은 그 좀비의 이름을 바꿀 수 있네. 레벨 20 이상인 좀비인 경우, 사용자들은 그 좀비에게 임의의 DNA를 줄 수 있네. zombieHelper.sol pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level \u003e= _level); _; } function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; } } ","date":"2022-01-21","objectID":"/ch03/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Saving Gas With ‘View’ Functions View functions don’t cost gas view 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않는다. 블록체인에 상태를 기록한다는 것은, 모든 single node들에게 트랜잭션이 추가되어야 한다는 것을 의미합니다. 하지만 반대로 view / pure function의 경우 블록체인 상에 어떤 것도 수정하지 않기 때문에 gas 소모가 없습니다. 만약 web3.js에게 view function를 호출해달라 요청하는 것은 실제로는 로컬 이더리움 노드에 query만 날리면 되기 때문에 가스 소모가 없게 됩니다. Warning 앞부분 설명을 보다보니 문득 view function gas가 들지 않는다면, view function을 infinite 호출하게되면 이더리움 망가뜨릴수 있지 않을까하는 생각에 검색하게 되었고 확인해보니 pure / view function은 internally call 해주게 되면 gas비가 든다고 한다. 즉 크립토좀비가 이번 세션에서 설명하는 것은 blockchain 외부(i.g web3.js)에서 호출하면 free gas cost라는 의미이다. Pure and view functions still cost gas if they are called internally from another function. They are only free if they are called externally, from outside of the blockchain. This View/Pure Gas usage - Cost gas if called internally by another function? goes into greater depth on this topic. 자세히 보니 크립토 좀비의 참고에도 아래와 같은 hint가 작성되어있네요. (데헷 😧) Tip 만약 view 함수가 동일 컨트랙트 내에 있는, view 함수가 아닌 다른 함수에서 내부적으로 호출될 경우, 여전히 가스를 소모할 것이네. 이것은 다른 함수가 이더리움에 트랜잭션을 생성하고, 이는 모든 개별 노드에서 검증되어야 하기 때문이네. 그러니 view 함수는 외부에서 호출됐을 때에만 무료라네. 이제 우리의 좀비 DApp에 사용자의 전체 좀비 군대를 볼 수 있는 메소드를 추가해보자. getZombiesByOwner()라는 네이밍에 external view function으로 만들어 보겠습니다. Declaring arrays in memory 솔리디티에서 storage에 write하는 것은 비싼 연산 중 하나입니다. 이더리움은 World computer이기 때문에 main-net기준으로 storage를 사용할 경우, 연결되어 있는 전세계 수많은 node들에 update를 시키게 되기 때문이죠. 이러다 보니 대부분의 프로그래밍 언어가 크기가 상당한 collection에 각각 접근( O(N) )하는 것을 지양하는 것과 달리, 솔리디티는 그 접근이 external view함수라면 storage를 쓰는 것보다 memoery를 써서 각각 element에 접근하는 것이 더 저렴한 방법입니다. (이는 gas비 때문인데, 훗날 이더리움 가격이 떨어진다면 달라질지도) Tip 생각해보니 실제로 storage에 write하는 것은 O(N) * per_gas_cost는 아닌것 같네요. 만약 1만명이 사용하는 contract라고 가정했을 떄 N=element갯수라면, gas_cost = (O(N) * 하나의_write_연산에_사용되는_gas_cost) * 10000이 되기 때문에 만약 1만명이 아닌 사용하고자 하는 사람의 숫자가 많아진다면, 즉 if 10000 \u003e= storage's element size라면 N의 정의가 달라지게 될 것 같습니다. Storage에 아무것도 쓰지 않고도 함수 안에서 새로운 배열을 만들기 위해서는 memory키워드를 사용하면 됩니다. 이는 storage배열을 직접 업데이트하는 것보다 gas_cost 측면에서 훨씬 (크립토 좀비에 따르면) 저렴하다고 합니다. 그러므로 collection을 storage로 관리하지 말고 memory로 전환하여 관리합시다. pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { ... 중략 ... function getZombiesByOwner(address _owner) external view returns(uint[]) { uint[] memory result = new uint[](ownerZombieCount[_owner]); return result; } } ","date":"2022-01-21","objectID":"/ch03/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-20","objectID":"/ch02/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Quote 좀비에게 먹이를 주어서 조합이 가능하게 해보자. ","date":"2022-01-20","objectID":"/ch02/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"[ch02] Zombies Attack Their Victims 이번 장을 마치면 다음과 같은 고양이를 먹은 좀비를 생성할 수 있다. ","date":"2022-01-20","objectID":"/ch02/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Mappings and Addresses 이더리움 블록체인은 은행계좌와 같은 account를 사용해서 유저를 식별합니다. 이때 각 account들은 이더리움 블록체인상의 coin인 ether를 단위로 balance를 가지게 됩니다. 이를 통화를 통해 각 계정은 송금/인출 등의 은행과 같은 기능들을 할 수 있습니다. 이를 위해 이더리움에서 각 계정은 은행 계좌 번호와 같은 address를 가지고 있으며, 여기서 말하는 address는 EOA(Extenally Owned Account)의 address입니다. 보통은 EOA간의 메세지는 이더를 보내지만, EOA는 컨트랙트 어카운트에 메세지를 보내 해당 코드를 실행 시킬 수 도 있습니다. Mapping은 기본적으로 python의 dict와 같은 key-value 저장소입니다. contract ZombieFactory { ... mapping (uint =\u003e address) public zombieToOwner; mapping (address =\u003e uint) ownerZombieCount; ... } ","date":"2022-01-20","objectID":"/ch02/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Msg.sender solidity에는 모든 함수에서 이용 가능한 특정 전역 변수들이 있는데, 그 중의 하나가 현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소를 가리키는 msg.sender이다. Tip solidity에서 함수 실행은 항상 external caller(외부 호출자)가 시작하며, 컨트랙트는 외부에서 함수를 호출 하기 전까지 블록체인 상에서 아무것도 하지 않는다. 즉 스마트 컨트랙트는 msg.sender(호출자)가 항상 존재합니다. mapping (address =\u003e uint) favoriteNumber; function setMyNumber(uint _myNumber) public { favoriteNumber[msg.sender] = _myNumber; } function getMyNumber() public view returns (uint) { return favoriteNumber[msg.sender]; } ","date":"2022-01-20","objectID":"/ch02/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Require 특정 조건이 True가 아닐 경우, 에러를 발생시키고 함수를 벗어나게 됩니다. function sayHiToLeoo(string _name) public returns (string) { // solidity는 고유의 스트링 비교 기능이 없다. 그러므로 keccak256 해시값을 // 비교해 스트링이 같은 값인지 판단하는 코드 require(keccak256(_name) == keccak256(\"Leoo.j\")); return \"Hi\"; } ","date":"2022-01-20","objectID":"/ch02/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Inheritance contract Animal { function cry() public returns (string) { return \"Default cry\"; } } contract Dog is Animal { function cry() public returns (string) { return \"Bark\"; } } ","date":"2022-01-20","objectID":"/ch02/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Import 파일들로 코드를 분리하고, 다른 파일에 있는 코드를 불러오고 싶을 때, 솔리디티는 import라는 keyword를 사용합니다. import \"./someothercontract.sol\"; // SomeOtherContract contract newContract is SomeOtherContract { } ","date":"2022-01-20","objectID":"/ch02/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Storage vs Memory solidity가 변수를 저장할 수 있는 공간에는 2가지 종류가 있습니다. storage memory Storage는 블록체인 상에 영구적으로 저장되는 변수들입니다. state variable(함수 외부에 선언된 변수)인 경우 초기 설정상 Storage로 관리되어 블록체인 상에 영구적으로 저장됩니다. 이와 반대로 함수 내부에 선언된 변수는 memory로 자동 선언되어 함수 호출 종료시 사라지게 됩니다. 단 명시적으로 storage, memory 키워드들을 사용해주어야 하는 상황이 존재하는데, 바로 함수 내에서 struct, 배열을 처리할 때 입니다. contract SandwichFactory { struct Sandwich { string name; string status; } Sandwich[] sandwiches; // state variable (storage) function eat(uint _idx) public { string defaultState = \"NOT EATEN\"; // implicit memory Sandwich storage mySandwich = sandwiches[_idx]; // arr should explict Sandwich memory anotherSandwich = sandwiches[_idx + 1]; sandwiches[_idx + 1] = anotherSandwich; } } pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract ZombieFeeding is ZombieFactory { function feedAndMultiply(uint _zombieId, uint _targetDna) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; } } ","date":"2022-01-20","objectID":"/ch02/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Extra Function Visibility solidity에는 public과 private 이외에도 internal과 external이라는 함수 접근 제어자가 있다. internal 상속하는 컨트랙트에서도 접근 가능 (java protected와 비슷해 보임?) 나머지는 private과 동의 external 컨트랙트 바깥에서만 호출 될 수 있음 컨트랙트 내의 다른 함수에 의해 호출될 수 없다. 나머지는 public과 동의 internal은 상속하는 컨트랙트에서도 접근 가능하다는 점을 제외하면 private과 같다. 느낌 상 java의 protected와 유사해 보이며, state variable은 default로 internal 접근자를 가진다. external은 함수가 컨트랙트 바깥에서만 호출 될 수 있고 컨트랙트 내의 다른 함수에 의해서 호출 될 수 없다는 부분만 제외하면 public과 같다. contract Sandwich { uint private sandwichesEaten = 0; function eat() internal { sandwichesEaten++; } } contract BLT is Sandwich { uint private baconSandwichesEaten = 0; function eatWithBacon() public returns (string) { baconSandwichesEaten++; // eat 함수가 internal로 선언되었기 때문에 여기서 호출이 가능하다 eat(); } } ","date":"2022-01-20","objectID":"/ch02/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"interface 블록체인 상에서, 다른 컨트랙트와 상호작용을 하고 싶다면 Interface를 정의해야 합니다. contract LuckyNumber { mapping(address =\u003e uint) numbers; function setNum(uint _num) public { numbers[msg.sender] = _num; } function getNum(address _myAddress) public view returns (uint) { return numbers[_myAddress]; } } 예를 들어 다음과 같은 외부 컨트랙트가 있다고 가정 할 때, 우리는 다음과 같은 interface를 만들 수 있습니다. // 예시에서는 contract NumberInterface {}를 사용한다. interface NumberInterface { function getNum(address _myAddress) public view returns (uint); } 크립토 좀비에 제공된 예시에서는 contract NumberInterface {}를 사용하고 있는데, interface키워드가 추가 된 것인지 아니면 contract보다 interface가 제약조건이 많기 때문에 간단하게 contract로 구현했는지 모르겠지만, 좀 더 명확한 표현이 좋아서 예제를 변경하였습니다. 실제 interface 사용은 다음과 같습니다. contract MyContract { address NumberInterfaceAddress = 0xab38... // ^ 이더리움상의 FavoriteNumber 컨트랙트 주소이다 NumberInterface numberContract = NumberInterface(NumberInterfaceAddress) // 이제 `numberContract`는 다른 컨트랙트를 가리키고 있다. function someFunction() public { // 이제 `numberContract`가 가리키고 있는 컨트랙트에서 `getNum` 함수를 호출할 수 있다: uint num = numberContract.getNum(msg.sender); // ...그리고 여기서 `num`으로 무언가를 할 수 있다 } } interface라는 키워드는 아래와 같은 제약조건이 있습니다. 다른 Contract로 부터 상속받을 수 없습니다, 하지만 다른 interface로부터는 상속받을 수 있습니다. 모든 function들은 public, external이어야 합니다. constructor를 선언할 수 없습니다. variable를 선언할 수 없습니다. struct를 선언할 수 없습니다. enum를 선언할 수 없습니다. 내부에는 추상함수, 즉 함수 시그니처만 존재합니다. Interfaces cannot have any functions implemented ","date":"2022-01-20","objectID":"/ch02/:1:8","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"summary 최종적으로 다음과 같은 코드가 만들어집니다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; // 끝에 2자리를 99로 변경한다. } _createZombie(\"NoName\", newDna); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 요구사항 고양이 좀비(kitty zombie)는 DNA 마지막 2자리로 99를 갖는다고 가정한다. 그러면 우리 코드에서는 만약(if) 좀비가 고양이에서 생성되면 좀비 DNA의 마지막 2자리를 99로 설정한다. 자바스크립트와 web3.js를 활용하여 우리의 컨트랙트와 상호작용하는 예시 var abi = /* abi generated by the compiler */ var ZombieFeedingContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFeeding = ZombieFeedingContract.at(contractAddress) // 우리 좀비의 ID와 타겟 고양이 ID를 가지고 있다고 가정하면 let zombieId = 1; let kittyId = 1; // 크립토키티의 이미지를 얻기 위해 웹 API에 쿼리를 할 필요가 있다. // 이 정보는 블록체인이 아닌 크립토키티 웹 서버에 저장되어 있다. // 모든 것이 블록체인에 저장되어 있으면 서버가 다운되거나 크립토키티 API가 바뀌는 것이나 // 크립토키티 회사가 크립토좀비를 싫어해서 고양이 이미지를 로딩하는 걸 막는 등을 걱정할 필요가 없다 ;) let apiUrl = \"https://api.cryptokitties.co/kitties/\" + kittyId $.get(apiUrl, function(data) { let imgUrl = data.image_url // 이미지를 제시하기 위해 무언가를 한다 }) // 유저가 고양이를 클릭할 때: $(\".kittyImage\").click(function(e) { // 우리 컨트랙트의 `feedOnKitty` 메소드를 호출한다 ZombieFeeding.feedOnKitty(zombieId, kittyId) }) // 우리의 컨트랙트에서 발생 가능한 NewZombie 이벤트에 귀를 기울여서 이벤트 발생 시 이벤트를 제시할 수 있도록 한다: ZombieFactory.NewZombie(function(error, result) { if (error) return // 이 함수는 레슨 1에서와 같이 좀비를 제시한다: generateZombie(result.zombieId, result.name, result.dna) }) ","date":"2022-01-20","objectID":"/ch02/:1:9","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["ros"],"content":"ros2 Foxy 실행에 필요한 개발 환경을 ubuntu, vm환경에 세팅해봅니다. ","date":"2022-01-18","objectID":"/ch02_setup/:0:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup zsh sudo apt-get install zsh chsh -s /usr/bin/zsh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" .zshrc update ZSH_THEME=\"Theme_Name\" 4. powerlevel10k install https://github.com/romkatv/powerlevel10k#meslo-nerd-font-patched-for-powerlevel10k install fonts wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf update fonts terminal vscode install powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k Set ZSH_THEME=“powerlevel10k/powerlevel10k” in ~/.zshrc. plugins git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\ ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting plugins=( # other plugins... zsh-autosuggestions ) 최종 ~/.basrc 파일 # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) [ -x /usr/bin/lesspipe ] \u0026\u0026 eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] \u0026\u0026 [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] \u0026\u0026 tput setaf 1 \u003e\u0026/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026\u0026 eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases alias ll='ls -alF' alias la=","date":"2022-01-18","objectID":"/ch02_setup/:1:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup workspace 먼저 ros를 실행하기 위해서는 workspace가 필요합니다. 필요한 작업공간을 만들어 보겠습니다. # ros2-sandbox on vmware $ colcon build $ echo 'source /home/leoo/shared/ros2-sandbox/install/setup.bash' \u003e\u003e ~/.bashrc sudo ros2를 하니 command not found가 나왔다. 만약 sudo를 써야 한다면, $ sudo echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e /root/.bashrc \u0026\u0026 sudo reboot host디렉토리를 mount 해버리니, .bashrc에서 commad가 permission denied되었다. 그러므로 매번 vmware에서는 sudo -i를 해주고, /root 디렉토리에 symlink를 생성해주자(편리함)s $ sudo -i # 생성하지 않았다면 $ ln -s /home/leoo/shared/ros2-sandbox ros2-sandbox $ cd ros2-sandbox ","date":"2022-01-18","objectID":"/ch02_setup/:2:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"ros2 Foxy를 mac pro 로컬 환경에 설치해봅니다. ","date":"2022-01-18","objectID":"/ch01_install/:0:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"1. tl;dr 실행환경: virtualbox(ubuntu 20.04) mount: 현재 디렉토리 코드작성 vm vs code에서 실행 host에서 코드 작성을 하려하였으나, lint와 링크 기능이 제대로 동작하지 않음 ","date":"2022-01-18","objectID":"/ch01_install/:1:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2. setup on virtual box (✅) setup mac like keyboard on virtual box 최종적으로 성공한 방식은 vm에 ubuntu를 설치해서 foxy를 실행하는 방식입니다. 아래 절차를 거쳐 세팅을 진행하였습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.1. ubuntu iso download 가장 먼저 ubuntu iso 이미지를 다운 받습니다. https://mirror.kakao.com/ubuntu-releases/focal/ 에서 ubuntu 20.04 lts download ","date":"2022-01-18","objectID":"/ch01_install/:2:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.2. vritualbox download 다음으로 virtualbox를 최신버전으로 다운 받습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.3. virtual box 셋업 가장 먼저 설치한 iso를 연결해줍니다. 2.3.1. iso 등록 다음으로 아래 스펙으로 virtualbox를 세팅해줍니다. mem: 8192MB HDD: 30 GB 키보드 / 드래그앤 드롭 Bidirectional 설정 2.3.2. 일반 \u003e 기본 2.3.3. 일반 \u003e 고급 2.3.4. 시스템 \u003e 마더보드 2.3.5. 시스템 \u003e 프로세서 2.3.6. 디스플레이 2.3.7. 공유폴더 설정 2.3.8. 전체 설정 여기까지 기본적인 ubuntu 설정이 완료되었습니다. 다음으로 ubuntu 자체 설정을 해주겠습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.4. ubuntu install ubuntu는 한글설정 / 맥북 키보드 shortcut 설정 / zsh 등, 처음 세팅하게 되면 설정해주어야 할 것들이 존재합니다. 가장 먼저는 apt 저장소를 카카오 미러로 변경해주세요. (이렇게 하면 더 빠르게 apt 설치가 가능합니다.) virtual box cmd right로 변경 [키보드 세팅(mac like)] $ sudo apt-get install keyboard-configuration $ sudo dpkg-reconfigure keyboard-configuration # select macbook pro(intel) # MacIntosh # English # English (Macintosh) # Both Alt keys # No compose key # Terminal preference에서 copy \u0026 paste 설정 mount host folder(소스코드) to ubuntu # 이건 임시이며, 항상 mount시키고 싶다면, vmware에 공유 폴더 설정해주어야 한다. $ sudo mount -t vboxsf ros2-sandbox /home/leoo/shared/ros2-sandbox/ ","date":"2022-01-18","objectID":"/ch01_install/:2:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.5. install ros dependencies $ sudo apt update $ sudo apt install build-essential gcc make perl dkms $ sudo apt update \u0026\u0026 sudo apt upgrade $ sudo apt install terminator $ sudo add-apt-repository universe $ sudo apt-get update $ sudo apt-get install python3-pip ","date":"2022-01-18","objectID":"/ch01_install/:2:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.6. install ros2 binary $ locale # check for UTF-8 $ sudo apt update \u0026\u0026 sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 $ export LANG=en_US.UTF-8 $ locale # verify settings $ sudo apt update \u0026\u0026 sudo apt install curl gnupg2 lsb-release $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg $ echo \"deb [arch=$(dpkg --print-architecture)signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs)main\" | sudo tee /etc/apt/sources.list.d/ros2.list \u003e /dev/null $ sudo apt update $ sudo apt install ros-foxy-desktop $ echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e ~/.bashrc $ sudo apt install python3-argcomplete 만약 이렇게 세팅하였을 때 자신의 vm이 너무 느리다고 판단 된다면 vm 설정방법을 참고해주세요. 지금까지 세팅을 완료하였으면 예쁘게 동작하는 vm을 보실 수 있습니다. :) 2.6.1. vm에서 동작하는 화면 ","date":"2022-01-18","objectID":"/ch01_install/:2:6","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"3. setup with Docker (🚫) docker 설치 refs Host로 설정하는 방식이 실패하여, 그 다음으로 선택한 방식입니다. 도커를 사용한 방식은 문제없이 동작하였지만, 추후 터미널을 여러개 띄워 네트워크 통신이 많아지는 걸 고려하면, 추가적으로 설정해야 할 부분들이 많아 보였습니다. 추가로 문서 또한 리눅스 문서들이 많으므로 vm ware 사용 $ docker pull osrf/ros:noetic-desktop-full-buster $ brew install socat # https://www.cyberciti.biz/faq/apple-osx-mountain-lion-mavericks-install-xquartz-server/ $ brew install --cask xquartz $ sudo reboot # xquartz 보안 설정 모두 열어주기 host 터미널에서 아래 명령어 실행 # ip 확인 후 xhost에 추가 $ ip=$(ifconfig en0 | grep inet | awk '$1==\"inet\" {print $2}') $ xhost + $ip # 컨테이너 생성 $ docker run -it -e DISPLAY=$ip:0 --name ros osrf/ros:noetic-desktop-full-buster ","date":"2022-01-18","objectID":"/ch01_install/:3:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4. setup on Host (🚫) This was failed 이 방식은 맥북에 바로 설치하는 방식으로 mac os에 ros에 필요한 dependencies들을 바로 추가해주었습니다. ","date":"2022-01-18","objectID":"/ch01_install/:4:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.1. Pre-Install ROS2 on mac $ brew doctor $ softwareupdate --all --install --force $ sudo rm -rf /Library/Developer/CommandLineTools $ sudo xcode-select --install $ brew link kubernetes-cli $ brew link python@3.9 $ echo 'export PATH=\"/usr/local/sbin:$PATH\"' \u003e\u003e ~/.zshrc ","date":"2022-01-18","objectID":"/ch01_install/:4:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.2. Install ROS2 on mac brew install python@3.8 brew unlink python \u0026\u0026 brew link --force python@3.8 echo 'export PATH=\"/usr/local/opt/python@3.8/bin:$PATH\"' \u003e\u003e ~/.zshrc export LDFLAGS=\"-L/usr/local/opt/python@3.8/lib\" export PKG_CONFIG_PATH=\"/usr/local/opt/python@3.8/lib/pkgconfig\" brew install asio tinyxml2 tinyxml eigen pcre poco brew install openssl \u0026\u0026 echo \"export OPENSSL_ROOT_DIR=$(brew --prefix openssl)\" \u003e\u003e ~/.zshrc brew install qt freetype assimp sip pyqt5 brew install console_bridge log4cxx spdlog cunit graphviz python3 -m pip install pygraphviz pydot catkin_pkg empy ifcfg lark-parser lxml netifaces numpy pyparsing pyyaml setuptools argcomplete pip3 install -U colcon-common-extensions # OpenCV는 필수는 아닙니다. 설치시 시간이 엄청 오래 걸리니 고민해보세요. brew install opencv ","date":"2022-01-18","objectID":"/ch01_install/:4:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.3. Download ROS Foxy Binary # https://github.com/ros2/ros2/releases mkdir -p ~/ros2_foxy cd ~/ros2_foxy tar xf ~/Downloads/ros2-foxy-20211013-macos-amd64.tar.bz2 ","date":"2022-01-18","objectID":"/ch01_install/:4:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.4. Check installed $ . ~/ros2_foxy/ros2-osx/local_setup.zsh ","date":"2022-01-18","objectID":"/ch01_install/:4:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.5. Error $ . ~/ros2_foxy/ros2-osx/local_setup.zsh [connext_cmake_module] Warning: The location at which Connext was found when the workspace was built [[/Applications/rti_connext_dds-5.3.1]] does not point to a valid directory, and the NDDSHOME environment variable has not been set. Support for Connext will not be available. csrutil disable로 시도해보았지만 실패 ros2 바이너리 버전을 낮춰서 시도해보았지만 역시 실패 big sur과 맞지 않는 source code에러가 있는 듯하다. 아래는 host에 설치하기 위해서 참조했던 문서들입니다. 공식 how-to-install-ros2-foxy-on-macos building-ros2-on-macos-big-sur-m1 ","date":"2022-01-18","objectID":"/ch01_install/:4:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["blockchain"],"content":"이번장에서는 Mastering Ethereum과 김혐남님의 세미나 내용을 기반으로 이더리움이란 무엇인가에 대해서 정리합니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"tl;dr Ethereum is a Blockchain Platform. 이더리움을 블록체인 생태계에서 포지션을 생각한다면 플랫폼으로 구분할 수 있습니다. Ethereum is “the world computer” 이더리움 진영에서 내새우는 정의는 (합의를 기반으로 동작하는) World Computer입니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:1","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"1. What is Ethereum Quote Ethereum is often described as “the world computer” 이더리움 진영에서 정의하는 이더리움이란 (탈 중앙화된) 월드 컴퓨터입니다. World와 Computer에 집중해본다면, World라는 단어처럼 이더리움은 “전세계를 하나로 묶어줄 수 있는 connection\"을 제공해주어야 할 것으로 보입니다. 묶어준 다는 점에서 p2p 네트워크가 필요해 보입니다. Computer라는 단어는 program, 그리고 이 프로그램을 개발할 수 있는 language가 필요해 보입니다. 또한 그 프로그램은 decentralized 성격을 가져야 하기 때문에, 일반 프로그램과 비교해 특별한 성질을 가질 것으로 보입니다. Ethereum is an open source with globally decentralized computing infrastructure that executes programs called smart contracts. It uses a blockchain to synchronize and store the system’s state changes. smart contract라는 특별한 program을 사용해 globally decentralized computing infrastructure 이면서도, 하나의 world computer 즉 state가 sync되는 시스템을 구현합니다. Tip Ethereum is a deterministic but practically unbounded state machine, Which means consisting of a globally accessible singleton state and a virtual machine. p2p로 퍼져있으면서도, 하나의 컴퓨터로 동작하기 위해서 스마트 컨트랙트는 globally accessible singleton state와 virtual machine 개념이 존재합니다. It uses a blockchain to synchronize and store the system’s state changes, along with a cryptocurrency called ether to meter and constrain execution resource costs. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"2. Compared to Bitcoin in common p2p network connecting participants. to synchronize PoW they uses Byzantine fault-tolerant consensus algorithm. uses cryptographic primitives hashes digital signatures digital currency Tip PoW(proof of work) is a form of adding new blocks of transactions to a cryptocurrency’s blockchain. in contrast Ethereum’s purpose is not primarily to be a digital currency payment network. ether is intended as a utility currency to pay for use of the Ethereum platform as the world computer. Bitcoin’s Script language is intentionally constrained to simple true/false evaluation of spending conditions, but ethereum’s language is Turing complete Tip A Turing complete system means a system in which a program can be written that will find an answer (although with no guarantees regarding runtime or memory). So, if somebody says “my new thing is Turing Complete” that means in principle (although often not in practice) it could be used to solve any computation problem. 프로그래밍 언어는 이와 비슷하게 Turing complete하다 왜냐하면 프로그램이 실행될 충분한 메모리와 시간이 주어진다면 특정 computational problem을 풀어낼 수 있기 때문이다. 김혐남님의 말을 빌리자면, 이더리움을 간단히 블록체인의 플랫폼이라 소개합니다. 블록체인 플랫폼이 되려다보니 이더리움은 블록체인 튜링 완전 프로그래밍이 가능해야 했고, Turing Complete해지니 application을 만들 수 있게 되었고, 이 앱은 block chain 위에서 실행되니 블록체인의 특성을 지닌 앱이 될 수 있었습니다. 이더리움은 이런 블록체인의 기능을 플랫폼처럼 추상화 시켜, 참여하는 개발자들이 쉽게 블록체인의 특성을 지닌 애플리케이션을 개발할 수 있도록 도와줍니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"3. Components of a Blockchain The components of an open, public blockchain are: A peer-to-peer (P2P) network connecting participants and propagating transactions and blocks of verified transactions, based on a standardized “gossip” protocol Messages, in the form of transactions, representing state transitions A set of consensus rules, governing what constitutes a transaction and what makes for a valid state transition A state machine that processes transactions according to the consensus rules A chain of cryptographically secured blocks that acts as a journal of all the verified and accepted state transitions A consensus algorithm that decentralizes control over the blockchain, by forcing participants to cooperate in the enforcement of the consensus rules A game-theoretically sound incentivization scheme (e.g., proof-of-work costs plus block rewards) to economically secure the state machine in an open environment One or more open source software implementations of the above (“clients”) ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"4. The Birth of Ethereum 이더리움 창립자들은 프로그래밍을 통해 다양한 애플리케이션을 지원할 수 있는 특정 목적에 국한되지 않는 블록체인에 대해 생각하고 있었다. 이 생각은 이더리움과 같은 범용 블록체인을 사용하여 개발자가 피어투피어 네트워크, 블록체인, 합의 알고리즘 등의 기본 메커니즘을 구현하지 않고도, 특정 애플리케이션을 프로그래밍할 수 있다는 것이다. 이더리움 플랫폼은 세부사항을 추상화하고 탈중앙화 블록체인 애플리케이션을 위한 결정적이고 안전한 프로그래밍 환경을 제공한다. 이더리움은 범용 블록체인(=블록체인 플랫폼)으로서 위치하고 있다는 것을 확인할 수 있습니다. 탈중앙화의 첫 번째 대상은 ‘가치의 이동’입니다. 디파이라 불리는 탈중앙 금융이 블록체인의 성공적인 킬러 앱이 될 수 있는 이유는 바로 가치의 이동에서 찾을 수 있습니다. 블록체인이 왜 탈중앙화할 수 밖에 없었는지를 고민해 보면 정보의 이동이 아닌 핵심은 가치의 이동이 필요했기 때문입니다. The original blockchain, namely Bitcoin’s blockchain, tracks the state of units of bitcoin and their ownership. You can think of Bitcoin as a distributed consensus state machine, where transactions cause a global state transition, altering the ownership of coins. The state transitions are constrained by the rules of consensus, allowing all participants to (eventually) converge on a common (consensus) state of the system, after several blocks are mined. Ethereum answers the question: “What if we could track any arbitrary state and program the state machine to create a world-wide computer operating under consensus?” ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-14","objectID":"/ch01/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Quote 크립토 좀비에서 Solidity를 학습해보자. ","date":"2022-01-14","objectID":"/ch01/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"[ch01] Making the Zombie Factory 챕터1을 통과하게 되면 나만의 좀비를 가질 수 있다. :) 솔리디티 코드는 Contract안에 싸여져 있다. 컨트랙트는 이더리움 app의 기본 구성 요소로, 모든 변수/함수는 하나의 컨트랙트안에 속해 있어야 한다. 즉 컨트랙트는 모든 프로젝트의 시작 지점이라고 할 수 있다. contract ZombieFactory { } 모든 솔리디티 코드는 솔리디티의 버전을 선언 해주어야 한다. 이를 통해 새로운 컴파일러 버전이 나오더라도 코드가 깨지지 않도록 한다. pragma solidity ^0.4.19; contract ZombieFactory { } 솔리디티에서 state variable는 컨트랙트 저장소에 영구적으로 저장된다. 즉 이더리움 블록체인에 기록이 된다. uint는 unsigned 즉 부호가 없는 정수로, 음이 아닌 정수이다. (\u003c-\u003e int) uint는 uint256를 의미하며, 256비트 정수를 표현한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } 솔리디티는 c++과 마찬가지롤 struct를 제공한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } array안에 크기를 주지 않으면 동적할당 가능하다. // 2개의 원소를 담을 수 있는 고정 길이의 배열: uint[2] fixedArray; // 또다른 고정 배열으로 5개의 스트링을 담을 수 있다: string[5] stringArray; // 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다: uint[] dynamicArray; public으로 배열을 선언할 수 있으며 솔리디티는 이런 배열을 위해 getter 메소드를 자동적으로 생성해준다. Person[] public people; 함수의 경우 param명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례이다. 마찬가지로 private 함수명 또한 _를 쓰는 것이 convention이다. function _createZombie(string _name, uint _dna) private { } function createRandomZombie(string _name) public { } 참고로 솔리디티에서 함수는 기본적으로 public이다. 누구나 또는 다른 컨트랙트가 나의 컨트랙트 함수를 호출하고 코드를 실행할 수 있다. 솔라디티는 함수가 데이터를 read만 하고 state change를 하지 않을 때 view 함수를 사용한다. function sayHello() public view returns (string) { } 또한 pure 함수도 가지고 있는데, 이는 함수가 앱에서 어떤 데이터도 접근하지 않는(read, write둘다 하지 x) 것을 의미한다. function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 이더리움은 SHA3의 버전 중 하나인 keccak256를 내장 해시 함수로 가지고 있다. 해시 함수는 기본적으로 입력 스트링을 랜덤 256bit 16진수로 매핑한다. Question 블록체인에서 안전한 의사 난수 발생기는 어려운 문제라고 한다고 하는데 hash collision과 관련해서 어렵다고 하는 걸까? 아니면 안전하다고 하는게 Oracle?과 관련이 있는 걸까? //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(\"aaaab\"); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(\"aaaac\"); event는 생성한 컨트랙트가 블록체인 상에서 앱에 접근하는 사용자 layer에서 액션이 발생했을 때, 통신하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는지 “listen\"하며, 그 이벤트가 발생하면 action을 취한다. // 이벤트를 선언한다 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다: IntegersAdded(_x, _y, result); return result; } ","date":"2022-01-14","objectID":"/ch01/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Summary 지금까지의 과정을 정리하면 아래와 같은 코드가 최종적으로 만들어진다. pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; // push returns length NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } // 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다: var abi = /* abi generated by the compiler */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다. // 일종의 이벤트 리스너가 텍스트 입력값을 취한다: $(\"#ourButton\").click(function(e) { var name = $(\"#nameInput\").val() // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다: ZombieFactory.createRandomZombie(name) }) // `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다 var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 좀비 DNA 값을 받아서 이미지를 업데이트한다 function generateZombie(id, name, dna) { let dnaStr = String(dna) // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다 while (dnaStr.length \u003c 16) dnaStr = \"0\" + dnaStr let zombieDetails = { // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여 // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. // 이를 기초로 \"head1.png\"에서 \"head7.png\" 중 하나의 이미지를 불러온다: headChoice: dnaStr.substring(0, 2) % 7 + 1, // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 셔츠 타입에는 6가지가 있다: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 \"filter: hue-rotate\"를 이용하여 아래와 같이 업데이트된다: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: \"A Level 1 CryptoZombie\", } return zombieDetails } ","date":"2022-01-14","objectID":"/ch01/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["algorithm"],"content":"Sorting algorithms","date":"2022-01-12","objectID":"/sorting/","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":" Let’s summary list of Sorting Algorithms ","date":"2022-01-12","objectID":"/sorting/:0:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"tl;dr index sorting name time space description 1 Bubble O(n^2) O(1) 루프당 max가 가장 뒤, swap O(n^2) 2 Selection O(n^2) O(1) 루프당 min 맨 앞, swap O(n) 3 Insertion O(n^2) O(1) I까지 sort 보장, 정렬이 어느정도 되어있다면 사용할 것 4 Merge O(nlogn) O(n) nlogn 알고리즘 중 유일한 stable 5 Heap O(nlogn) O(1) insert(O(logn) * n개 원소, space가 1이 포인트 6 Quick O(nlogn) O(n) piv기준 작으면 left 크거나 같으면 right,balanced partition을 위해 random piv를 해준다. ","date":"2022-01-12","objectID":"/sorting/:1:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Bubble Sort ","date":"2022-01-12","objectID":"/sorting/:2:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Selection Sort ","date":"2022-01-12","objectID":"/sorting/:3:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Insertion Sort 이미 정렬된 상태라면 O(n)의 빠른 속도를 보인다. 정렬된 상태에서 빠른 이유는 각 insert마다 1번의 비교만 하면 되기 때문이다. reversed를 사용하면 insert시 arr re-arrange를 방지 가능하다. 단점: 삽입을 하게 되면 데이터가 하나씩 뒤로 밀려야 되기 때문에 배열이 길어질수록 효율이 떨어진다. 개인적으로 input()받을 때 insertionSort를 사용하면 입력과 정렬을 동시에 할 수 있어서 더욱 효율적인 것 같다. def insertion_sort(arr): n = len(arr) for i in range(1, n): val = arr[i] j = i - 1 if arr[j] \u003c val: continue while j \u003e= 0 and val \u003c arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = val return arr ","date":"2022-01-12","objectID":"/sorting/:4:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Merge Sort def merge_sort(arr): def merge(left, right): l = r = 0 result = [] while l \u003c len(left) and r \u003c len(right): if left[l] \u003c right[r]: result.append(left[l]) l+=1 else: result.append(right[r]) r+=1 return result + left[l:] + right[r:] # 나머지 (left over) if len(arr) \u003c= 1: return arr mid = len(arr) // 2 return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:])) ","date":"2022-01-12","objectID":"/sorting/:5:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Heap Sort ","date":"2022-01-12","objectID":"/sorting/:6:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Quick Sort 성능을 생각하면 piv를 random으로 찾아야 한다. from __future__ import annotations def quick_sort(arr: list[int]) -\u003e list[int]: if len(arr) \u003c= 1: return arr piv = arr[0] others = arr[1:] left = [v for v in others if v \u003c= piv] right = [v for v in others if v \u003e piv] return quick_sort(left) + [piv] + quick_sort(right) ","date":"2022-01-12","objectID":"/sorting/:7:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"About Binary Search and BST","date":"2022-01-08","objectID":"/binary_search/","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":" Binary Search와 BST에 대해서 정리합니다. Binary Search는 divide conquer의 일종으로 검색 범위를 binary하게 줄여나가면서 원하는 데이터를 검색하는 알고리즘입니다. def binary_search(sorted_arr, target): n = len(sorted_arr) if n == 0: return -1 low, high = 0, n-1 while low \u003c=high: mid = (low + high) // 2 if sorted_arr[mid] == target: return mid if sorted_arr[mid] \u003e target: high = mid -1 else: low = mid + 1 return -1 # low == high + 1 == mid 눈여겨 봐야할 포인트는 다음 2가지이다. 검색 대상이 되는 arr가 sorted되어있다. while의 조건으로 low \u003c= high 등호가 들어있다. 검색의 범위 element가 2개로 좁혀졌을 때 // 2 연산에 의해서 왼쪽만 탐색이 될 텐데, 찾아야하는 값이 우측 값에 존재한다면 low와 high가 같아야만(low == high == mid) 검색이 가능하다. ","date":"2022-01-08","objectID":"/binary_search/:0:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search 특징 retrieve Time complexity: O(log N) retrieve Space complexity: O(1) 삽입 / 삭제 불가 ","date":"2022-01-08","objectID":"/binary_search/:1:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search Tree (BST) n= number of elements, h = tree height 들어가기 앞서, ratsgo를 참조하여 정리했음을 알려드립니다. 이진 탐색 트리란 Binary Search와 Linked list를 결합한 자료구조 입니다. 특히 Binary Search의 탐색 속도(O(log n)) 와 링크드리스트의 삽입/삭제 O(1)의 장점을 결합했다는 특징이 있습니다. 참고로 binary search는 삽입/삭제가 불가하며, 링크드리스트는 탐색 속도가 O(n)이라는 단점들이 있습니다. BST는 서로의 장점을 사용해 각각의 단점을 O(h)로 보완합니다. ","date":"2022-01-08","objectID":"/binary_search/:2:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"주요 특징 left.val \u003c root \u003c right.val inorder traverse(중위 순회)시 결과가 정렬된 리스트가 주어진다. left -\u003e node -\u003e right 구성하는 노드에서 중복된 노드가 없어야 한다. (unique 보장) 노드 끼리 우선순위 대소 비교가 가능해야 한다. retrieve, insert, delete의 계산복잡성은 모두 𝑂(ℎ) ","date":"2022-01-08","objectID":"/binary_search/:2:1","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"기본 데이터 형태 class Node: def __init__(self, val): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root: Optional[Node] = None def set_root(self, val): self.root = Node(val) ","date":"2022-01-08","objectID":"/binary_search/:2:2","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"retrieve / find Time Complexity: O(h) 탐색 대상과 root를 비교하여 left / right를 찾아나간다. 이 경우 Binary Search와 비슷하게 O(h) 시간 복잡도를 가진다. (아래와 같은 극단적 불균형 트리인 경우이면서, min/max값을 탐색한다면 O(n)) def find(self, val): node = self.find_node(self.root, val): return True if node else False def find_node(self, node, val) -\u003e Optional[Node]: if not node: return None elif val == node.val: return node elif val \u003c node.val: return self.find_node(node.left, val) else: return self.find_node(node.right, val) ","date":"2022-01-08","objectID":"/binary_search/:2:3","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"insert Time Complexity: O(h) O(logn)이 아닌 이유는 비대칭(Unbalanced Binary Tree)인 경우 tree의 높이가 n까지도 가능하기 때문이다. (sorted arr를 차례대로 insert 시킬경우) 이를 해결하기 위해서는 BF(balance factor)를 사용해 balance를 맞추는 AVL 또는 B-같은 트리를 사용해야 한다. def insert(self, val): if not self.root: self.set_root(val) else: self.insert_node(self.root, val) def insert_node(self, node, val): if val \u003c= node.val: if node.left: self.insert_node(node.left, val) else: node.left = Node(val) elif val \u003e node.val: if node.right: self.insert_node(node.right, val) else: node.right = Node(val) Tip AVL 트리는 rotation을 사용해 tree의 insert / delete 시 balance를 맞춘다. 그러므로 검색의 경우 항상 O(log n)을 보장한다. 특별한 점은 single rotation, double rotation을 통해서 tree의 balance를 맞추어 주는데 자세한 설명을 참조하세요 ","date":"2022-01-08","objectID":"/binary_search/:2:4","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"delete Time Complexity: O(h) 삭제는 총 3가지 경우가 존재합니다. leaf node (자식노드가 없는 경우) -\u003e 그냥 제거 자식노드가 하나 존재하는 경우 -\u003e 제거 후, 자식 노드를 삭제된 노드의 부모로 연결 자식노드가 둘 존재하는 경우 이 경우에는 predecessor 또는 successor를 삭제할 노드와 위치를 뒤 바꾼 다음, 1와 2의 삭제 방법을 사용하면 됩니다. (참고로 successor와 predecessor는 자식노드가 1개 또는 없는 경우 밖에 존재하지 않습니다.) predecessor로 제거, successor로 제거 둘다 가능 합니다. Tip predecessor: 삭제 대상 노드의 왼쪽 서브트리 가운데 최대값 successor: 삭제 대상 노드의 오른쪽 서브트리 가운데 최소값 그림 기준으로 16을 inorder traverse를 해보면 다음과 같습니다. 4, 10, 13, 16, 20, 22, 25, 28, 30, 42 이때, predecessor(13), successor(20)가 됩니다. # delete 방법 (d = 삭제 대상 노드의 레벨) 1. 삭제 대상 노드의 오른쪽 서브트리를 찾는다. 2. successor(1에서 찾은 서브트리의 최소값) 노드를 찾는다. 3. 2에서 찾은 successor의 값을 삭제 대상 노드에 복사한다. 4. successor 노드를 삭제한다. 가장 계산이 복잡한 자식 노드가 둘 모두 존재하는 경우의 시간 복잡도를 분서해보겠습니다. 1에서 d레벨(트리 높이) 만큼 이동을 해주어야 하며, 2에서 최대 h-d 레벨(트리높이)만큼 이동해주어야 합니다. 3과 4의 연산은 계산에서 제외한다면 O(d + h -d) =\u003e O(h)가 만들어집니다. e.g) 간단히 가장 복잡할 것 같은 root를 지운다 가정하였을 때, d = 1, h = h이므로 O(1 + h - 1)이 됩니다. ","date":"2022-01-08","objectID":"/binary_search/:2:5","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"traverse (inorder) Time Complexity: O(n) 위의 그림의 경우 1 -\u003e 3 -\u003e 5 -\u003e 7 -\u003e 8 -\u003e 10로 순회 가능하다. def traverse(self): return self.traverse_node(self.root) def traverse_node(self, node): result = [] if node.left: result.extend(self.traverse_node(node.left)) if node: result.extend([node.val]) if node.right: result.extend(self.traverse_node(node.right)) return result ","date":"2022-01-08","objectID":"/binary_search/:2:6","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Conclusion 이상으로 binary search와 bst에 대하여 알아 보았습니다. 관련해서 leetcode문제는 binary search 에 정리를 해두었습니다. - 끝 - ","date":"2022-01-08","objectID":"/binary_search/:3:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["dev"],"content":"All Basic Computer Science","date":"2022-01-06","objectID":"/interview/","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":" Let’s prepare basic computer science interview questions. ","date":"2022-01-06","objectID":"/interview/:0:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Operating System … ","date":"2022-01-06","objectID":"/interview/:1:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Network ","date":"2022-01-06","objectID":"/interview/:2:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일 키워드: dhcp, dns, nat, isp, 3-way / 4-way handshake, ssl (ssl handshake) 가장 먼저 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. OS는 DNS Lookup을 수행합니다. 룩업 과정은 etc/hosts \u003e DNS Cache \u003e Cache가 없을 경우 dns server로 ip를 얻어옵니다. DNS server로 ip request 이때 DNS server IP는 1차적으로 isp(internet service provider, ex kt, skt…)가 제공하는 정보들이 dhcp에 의해 컴퓨터에 세팅됩니다. dhcp는 wifi를 쓸 경우, 공유기에 연결되어있는 gateway ip와 router의 NAT을 통해 사설 ip(private ip)를 할당 받으며, 외부 통신을 할 경우 router의 Public ip을 사용합니다. ISP에 의해 세팅되어 있는 dns server로 아래 형식의 요청을 보내어, 도메인에 매핑된 ip를 받아옵니다. - from: router ip(nat ip) - to: 받아온 ip - 게이트웨이 ip : wifi이면 공유기 연결 게이트웨이 ip / 스마트폰이면 자체 ip 루트 도메인서버에서부터 서브도메인 서버순으로 dns query 이제 DNS Server로 DNS Query를 요청하게 되면 DNS 서버는 Root name server에 해당 도메인을 질의하고, .com name server의 ip를 받아오게 됩니다. 그 후 .com 네임 서버에 도메인 Query하게되면 google.com의 ip주소를 받고 최종적으로 www.google.com의 ip를 받아오게 됩니다. pc는 최종 서버 ip로 HTTP Request를 보낸다. 3-way handshake syn \u003e ack, syn \u003e ack 4-way handshake fin \u003e ack(close wait) \u003e fin(last_ack) \u003e ack tls/ssl 좀 더 자세한 과정 설명 # RSA 키 교환 알고리즘 1. client hello (protocol version, 암호 알고리즘, 압축 방식, 클라 난수) 2. server hello (세션 ID, ca 인증서, 서버난수) 3. verify ca and get public key 4. 클라는 난수(pre master secret) 생성 후 public key로 암호화 후 서버 전달 5. 클라 세션키 생성 및 서버는 난수를 private key로 복호화 하여 대칭키(세션 키) 생성 6. 클라는 세션키(대칭키)로 암호화한 fin message를 서버로 전달 7. 서버 또한 세션키로 암호화한 fin message를 전달 8. 이후 세션키를 통해 통신 계속 진행 ","date":"2022-01-06","objectID":"/interview/:2:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"TCP vs UDP TCP UDP 연결방식 연결형서비스 비 연결형 서비스 패킷 교환 방식 가상 회선 방식 데이터그램 방식 전송 순서 전송 순서 보장 전송 순서가 바뀔 수 있음 수신 여부 확인 수신 여부를 확인함 수신 여부를 확인하지 않음 통신 방식 1:1 통신만 가능 1:1 / 1:N / N:N 통신 모두 가능 신뢰성 높음 낮음 속도 느림 빠름 ","date":"2022-01-06","objectID":"/interview/:2:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Web Socket Handshake web socket mdn 클라와 서버가 서로 TCP/IP 4계층 레이어에서 통신한다. 즉 conneciton을 들고 있다. http 요청 이후, upgrade요청 한다. ping을 지속적으로 쏴서, health-check ","date":"2022-01-06","objectID":"/interview/:2:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"로드 밸런싱(Load Balancing) 로드 밸런싱이란 여러 서버에게 균등하게 트래픽을 분산 시켜주는 것이다. nginx의 경우 기본적으로 라운드 로빈 방식으로 동작합니다. scale-out scale-up ","date":"2022-01-06","objectID":"/interview/:2:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Nginx가 10k problem을 해결한 방식 기존 방식은 request당 하나의 process 또는 thread를 사용해서 요청들을 처리했습니다. 이에 반해 nginx는 worker pool을 두고 request가 들어올 때 마다, async하게 worker(default cpu 당 1)에게 task를 위임합니다. 이렇게 하게 될 경우 process/thread에 비해, pcb/tcb를 만드는데 들어가는 비용을 줄일 수 있으며 또한 사용자의 요청이 많아질 경우, 상대적으로 context switching에 사용되는 비용을 줄일 수 있습니다. 마지막으로 os가 스케쥴링에 들어가는 비용이 줄어듭니다. 즉 지정된 갯수의 미리생성된 process(thread) 워커를 사용함으로써, 기존의 request가 늘어날 때마다, os 리소스가 급격히 늘어나는 것을 방지하여, 이에 대한 side effect(스케쥴링, context-switching등에 대한 오버헤드를 막아줍니다.) 또한 워커에 필요한 리소스들을 미리 생성해두기 때문에 Process 생성에 들어가는 오버헤드를 줄여줍니다. ","date":"2022-01-06","objectID":"/interview/:2:5","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Database ","date":"2022-01-06","objectID":"/interview/:3:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB 트랜잭션이란? 트랜잭션은 데이터베이스의 데이터를 조작하는 논리적인 작업의 단위(unit of work)입니다. 트랜잭션은 ACID Atomicity all or nothing (rollback) db transaction, rollback으로 보장 Consistency transaction이 commit 되어도 DB의 여러 제약 조건에 맞는 상태를 보장하는 성질이다. 송금하는 사람의 계좌 잔고가 0보다 작아지면 안 된다. Isolation transaction이 진행되는 중간 상태의 데이터를 다른 transaction이 볼 수 없도록 보장하는 성질이다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 아직 들어가지 않은 DB 상황을 다른 transaction이 읽으면 안 된다. lock으로 구현 Durability transaction이 Commit했을 경우 해당 결과가 영구적으로 적용됨을 보장하는 성질이다 ","date":"2022-01-06","objectID":"/interview/:3:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"트랜잭션과 lock에 대해서 isolation과 연결 지어 설명해주세요 DB엔진은 ACID 원칙을 희생하여 동시성을 얻을 수 있는 방법을 제공합니다. Row level lock shared lock: read lock exclusive lock: write lock Record lock s lock: read index lock x lock: write index lock Gap lock: db index record의 gap에 걸리는 lock (gap = db에 실제 record가 없는 부분) lock은 모두 transaction이 commit 되거나 rollback 될 때 함께 unlock Consistent read Isolation https://s1107.tistory.com/45 http://labs.brandi.co.kr/2019/06/19/hansj.html https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/ index https://idea-sketch.tistory.com/43?category=547413 https://idea-sketch.tistory.com/45 ","date":"2022-01-06","objectID":"/interview/:3:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB index에 대해 설명해주세요 https://idea-sketch.tistory.com/43?category=547413 ","date":"2022-01-06","objectID":"/interview/:3:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"todo dirty read, Non-Repeatable Read, Phantom Read optimistic lock, pessimistic lock slow query Index ","date":"2022-01-06","objectID":"/interview/:3:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Software Engineering ","date":"2022-01-06","objectID":"/interview/:4:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Design Pattern ","date":"2022-01-06","objectID":"/interview/:5:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Language ","date":"2022-01-06","objectID":"/interview/:6:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Computer Architecture","date":"2022-01-06","objectID":"/interview/:7:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["algorithm"],"content":"About DFS and BFS","date":"2022-01-06","objectID":"/dfs_bfs/","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":" 간단하게 bfs와 dfs를 python으로 구현해보고, 상황별 장단점을 분석해본다. ","date":"2022-01-06","objectID":"/dfs_bfs/:0:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1. Graph Traverse ","date":"2022-01-06","objectID":"/dfs_bfs/:1:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.1. BFS from collections import deque graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } def bfs(start_node=\"5\"): queue = deque([start_node,]) visited = set() while queue: node = queue.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: queue.appendleft(neighbor) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:1","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.2. DFS graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } # 5 8 7 3 4 2 def dfs(start_node=\"5\"): stack = [start_node,] visited = set() while stack: node = stack.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: stack.append(neighbor) def recursive_dfs(node=\"5\", visited = set()): visited.add(node) for neighbor in graph[node]: if neighbor in visited: continue recursive_dfs(neighbor, visited) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:2","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.3. BFS vs DFS 문제 유형별로 어떤 알고리즘이 더 유리한지 서술합니다.  : impossible  : good and possible  : bad but possible index Problem BFS DFS 1 그래프의 모든 정점을 방문 하는 문제 2 각 경로 마다 특징을 저장해둬야 하는 문제 3 최단 거리 문제 4 문제의 그래프가 매우 클 경우 5 검색 시작 지점과 원하는 대상이 가까이 있을 경우 단순히 모든 node 방문이라면 둘 모두 사용가능합니다. a-\u003eb로 가는 경로를 구할 때, 경로 안에서 같은 숫자가 x번 이상 없어야 하는 경우, dfs는 함수의 인자에 local 변수들을 좀 더 손 쉽게 줄 수 있는 반면, queue를 활용하는 bfs는 상태를 기억하기 좀 더 까다롭다. 물론 queue에 node를 넣을 때, local state를 같이 넣어주면 되긴 하지만, 이는 명시적이지 못하므로 dfs가 더 유리하다 생각된다. bfs의 경우 level(e.g 이동 count, tree의 level, ) 단위로 확장되기 때문에 목적지에 도착하는 순간 return한 값이 최소 이동거리가 되지만, dfs의 경우에는 깊이 있게 하나씩 파니까 상대적으로 bfs보다 오래 걸린다. Python의 경우 하나의 리스트가 가질 수 있는 Py_ssize_t는 536870912인 반면, 함수에 대한 메모리 제한은 두지 않고 있다. 그러므로 queue를 이용해서 구현하는 bfs의 경우 그래프가 크다면, 제한이 있는 반면 recursive function으로 구현한 dfs한정(stack으로 구현한 경우 동일한 문제발생)해서 function call stack을 사용해서 메모리 관리를 하기 때문에 상대적으로 더 큰 그래프 탐색에 사용될 수 있다. 3.의 경우와 같은 원리이다. ","date":"2022-01-06","objectID":"/dfs_bfs/:1:3","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"Conclusion 필자는 왠만하면 bfs를 좀 더 선호하는 경향이 있는데, 과거의 경험을 떠올려 보면, (정확하게 기억은 나지 않지만) path가 연속적으로 이어져야하는 로직에서 bfs가 불편했던 것 같다. DFS의 경우에는 처음부터 끝까지 연속적으로 탐색하기 때문에 비교적 쉽게 구현이 되었는데, BFS는 spread 하면서 이동하기 때문에 해당 상황에서 불리 했던 것 같다. dfs, bfs를 언제 써야하는지 개인적으로 헷갈렸었는데 표로 정리하고 나니 나중에도 유용하게 볼 것 같다. - 끝 - ","date":"2022-01-06","objectID":"/dfs_bfs/:2:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"About Binary Tree","date":"2022-01-06","objectID":"/binary_tree/","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":" Binary Tree관련 알고리즘들을 학습하고 정리합니다. ","date":"2022-01-06","objectID":"/binary_tree/:0:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Binary Tree child \u003e 2면 안된다. parent \u003e 1이면 안된다. root(부모가 없는 노드)는 한개만 존재해야 한다. array로 구현하면 편의를 위해 0인덱스를 비워둔다. parent = child % 2 lchild = parent * 2 rchild = parent * 2 + 1 ","date":"2022-01-06","objectID":"/binary_tree/:1:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap max heap, min heap (등호도 고려된다.) 대소 관계는 부모-자녀 간에만 고려된다. left child 먼저 삽입된다. (즉 leaf 중에 left 없이 right가 있는 경우는 없다.) ","date":"2022-01-06","objectID":"/binary_tree/:2:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap insert 인덱스 마지막에 새로운 요소 append (if parent is exist) 부모와 대소 비교 하여 exchange. (아래 -\u003e 위 heapify) ","date":"2022-01-06","objectID":"/binary_tree/:2:1","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap pop root pop 힙의 마지막 element를 root로 이동 힙 재구성 (= 위 -\u003e 아래 heapify) (if child exist) l, r 비교하여 현재 노드가 작다면 exchange (max heap 기준) 재귀적으로 반복 ","date":"2022-01-06","objectID":"/binary_tree/:2:2","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap sort O(n + n*logn) =\u003e O(nlogn) Max heap 구성(O(n)) 루트와 말단 노드 교체 후 heapify (O(nlogn)) O(logn) = 트리 최대 높이 = heapify시 depth n = 모든 노드들에 대하여 검사 ","date":"2022-01-06","objectID":"/binary_tree/:2:3","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["dev"],"content":"홍정모의 따라하며 배우는 C++","date":"2022-01-03","objectID":"/hong_modern_cpp/","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":" Modern c++을 학습하고 기억할만한 요소들을 정리합니다. 1. Terminology ","date":"2022-01-03","objectID":"/hong_modern_cpp/:0:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"1. Terminology 1.0.1. Basic C++ prototype forward declaration header guards (=include guards) 중복될 경우 한번만 include해라 (#pragma once) #pragma once 기 정의된 preprocessor의 일종 macro conditional compilation macro의 #ifdef, #ifndef, #else, #endif fundamental data types (=primitivate data types) auto는 데이터 타입을 자동으로 컴파일 타임에 찾아준다. 1.0.2. Variable and Fundamental types initialization copy initialization int a = 3; direct initialization int a(3); uniform initialization int a{ 3 }; Fixed-width Integers scientific notation inf: infinite nan: not a number ind: indeterminate literal constants symbolic constants constexpr(c++ 11): 컴파일 타임에 값이 완전히 결정되는 상수 const: 컴파일 타임 / 런타임에 값이 결정되는 모든 상수. (constexpr 포함) 1.0.3. Variable Scope and Extra types Scoped Enumerations (Enum Class) type aliases typedef using struct member selection operator = . memory padding 최적화를 위해서 member들의 순서를 고려해야 한다. (e.g short type 2byte는 2바이트가 뒤에 padding된다.) 1.0.4. Matrix, String, Pointer, Reference nullptr(null pointer) void pointer == generic pointer reference variable ","date":"2022-01-03","objectID":"/hong_modern_cpp/:1:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"2. Function Parameter function parameter #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, bool (*validator)(const int \u0026)) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with using or typedef #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; // typedef bool (*validator_fnc)(const int \u0026); using validator_fnc = bool (*)(const int \u0026); bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with std::function and default parameter #include \u003ciostream\u003e#include \u003carray\u003e#include \u003cfunctional\u003e using namespace std; using validator_fnc = function\u003cbool(const int \u0026)\u003e; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator = isEven) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } 매우 파이썬스럽게, 가장 깔끔해 보인다. ","date":"2022-01-03","objectID":"/hong_modern_cpp/:2:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"3. Matrix double pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int **matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[r][c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int **matrix = new int *[row]; for (int r = 0; r \u003c row; ++r) matrix[r] = new int[col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[r][c] = values[r][c]; printMatrix(matrix, row, col); // delete for (int r = 0; r \u003c row; ++r) delete[] matrix[r]; delete[] matrix; return 0; } single pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int *matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[(col * r) + c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int *matrix = new int[row * col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[(col * r) + c] = values[r][c]; printMatrix(matrix, row, col); // delete delete[] matrix; return 0; } ","date":"2022-01-03","objectID":"/hong_modern_cpp/:3:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"4. Pointer ","date":"2022-01-03","objectID":"/hong_modern_cpp/:4:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"4.1. Pointer and Const { using namespace std; const int value = 6; const int new_value = 7; const int *ptr_1 = \u0026value; // 6 0x7ffeefb45158 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; // *ptr_1 = new_value; (x) ptr_1 = \u0026new_value; // 7 0x7ffeefb45154 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; } const int를 가리키고 있는 mutable한 포인터를 의미한다. 포인터가 가리키는 값이 const int이기 때문에 dereference해서 값을 바꿀 수 없다. 하지만 포인터 그 자체는 const하지 않기 때문에 새로운 주소값을 넣을 수 있다. { using namespace std; int value = 6; int new_value = 7; int *const ptr_value = \u0026value; // 6 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; *ptr_value = new_value; // ptr_value = \u0026new_value; (x) // 7 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } int를 가리키는 *const 포인터. 포인터는 const이기 때문에 assign이 불가하지만, 포인터가 가리키는 값은 const하지 않기 때문에 변경 가능하다. 즉 포인터를 dereference(*)해서 값 대입 가능하다. c.f) int \u0026ref(레퍼런스)와 int *const ptr는 기능이 같다. { using namespace std; int value = 6; int new_value = 7; const int *ptr_value = \u0026value; // 6 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; value = new_value; // 7 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; // *ptr_value = new_value; (x) ptr_value = \u0026new_value; // 7 0x7ffee6efb154 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } 가리키는 값이 const한 int인 포인터. value 자체는 const가 아니기 때문에 assign 가능하다. value가 const가 아니지만, 포인터는 값을 const하게 처리하기 때문에 dereference가 불가능하다. 포인터 자체는 const하지 않기 때문에 주소 할당이 가능하다. { using namespace std; const int value = 6; const int new_value = 7; const int *const ptr_value = \u0026value; // ptr_value = \u0026new_value; (x) // *ptr_value = new_value; (x) } const int를 가리키는 *const 포인터. pointer value assign과 dereference를 통한 assign 둘 모두 불가하다. ","date":"2022-01-03","objectID":"/hong_modern_cpp/:4:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5. Reference ","date":"2022-01-03","objectID":"/hong_modern_cpp/:5:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5.1. Reference and Const reference variable은 변수의 별명이다. (주소, 값 모두 같다.) 파라미터로 넘겨줄 경우, 다른 함수에서 변수를 변경가능하다. #include \u003ciostream\u003e void doSomething(const int value, const int \u0026ref) { using namespace std; cout \u003c\u003c value \u003c\u003c ' ' \u003c\u003c \u0026value \u003c\u003c ' ' \u003c\u003c ref \u003c\u003c ' ' \u003c\u003c \u0026ref \u003c\u003c endl; } int main() { int a = 5; // 5 0x7ffeeaf4e158 doSomething(a, a); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e158 doSomething(a, 5); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e154 return 0; } 파라미터에 변수로 받는 것과, reference로 받는 것은 무슨 차이가 있을까? 파라미터를 변수로 받으면 value copy가 일어난다. (비효율) 반면 reference를 사용한다면 실제 원래 변수와 같은 주소를 가지게 된다. 또한 const int \u0026ref처럼 const reference를 사용한다면 immutable하면서도 reference로 파라미터를 받아 효율을 추구할 수 있다. literal의 주소를 기억할 수 없기 때문에, reference variable 대입에는 lvalue가 들어가야 하지만, const reference타입은 literal을 받을 수 있다. (이 경우 literal을 위한 주소가 할당 된다.) ","date":"2022-01-03","objectID":"/hong_modern_cpp/:5:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["todo"],"content":" This article is a simple list of todos that I will write to blog in my future. ","date":"2022-01-02","objectID":"/todo/:0:0","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1. TODO LIST ","date":"2022-01-02","objectID":"/todo/:1:0","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.1. Plan 21년 회고 22년 목표 ","date":"2022-01-02","objectID":"/todo/:1:1","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.2. Diary 나는 누구이고, 지금 어디에 존재하는가? 오쇼 글귀 정리 과거 네이버 / 커스텀 블로그 / 일기 글 migration ","date":"2022-01-02","objectID":"/todo/:1:2","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.3. Server Dev hugo 블로그 구축기 kotlin 공부했던 글 정리 c++ 7장까지 들었던 글 정리 kotlin in action ","date":"2022-01-02","objectID":"/todo/:1:3","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.4. Block chain binance academy gall dcinside 이더리움 크립토 좀비 디파이 로드맵 book: Mastering bitcoin, Mastering etherium web3.0 coin: 폴리곤, 폴카닷, 루나 etc coin: 솔라나 ","date":"2022-01-02","objectID":"/todo/:1:4","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.5. Startup 온라인 전자담배 도매부터 판매까지 ","date":"2022-01-02","objectID":"/todo/:1:5","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.6. Phrase 내 어록 쓰기 ","date":"2022-01-02","objectID":"/todo/:1:6","tags":["todo","diary"],"title":"Todo List","uri":"/todo/"},{"categories":["hugo"],"content":"Hugo로 블로그 만들기","date":"2022-01-02","objectID":"/initial_hugo/","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":" This article describes a series of technical steps to building this serious blog using the hugo framework. 사실 Hugo는 20년도에 혼자 제주도 여행을 가면서, 생각을 정리하고 싶어서 눈여겨 봤던 프레임워크이다. 당시 go를 공부하고 있었기 때문에 go로 만들어진 프레임워크라는 점에서 호감 +99점을 받았고, 이름이 다른 프레임워크들에 비해서 짧다는 장점이 있다. 🤔 Gatsby는 무슨 왁스 이름같고, Jekyll는 스펠링도 어렵고 사실 어떻게 발음해야 될지도 잘 모를정도로 이름이 못생김 이 블로그는 hugo와 LoveIt을 사용해 만들었다. keywords Hugo LoveIt git submodule github workflows shell script ","date":"2022-01-02","objectID":"/initial_hugo/:0:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1. Pre-Init Blog MacBook Pro (16-inch, 2019) Big Sur ","date":"2022-01-02","objectID":"/initial_hugo/:1:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.1. Install hugo install hugo docs # Install brew $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # download hugo $ brew install hugo # check hugo is successfully downloaded $ hugo version ","date":"2022-01-02","objectID":"/initial_hugo/:1:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.2. Select hugo templaate github에서 hugo를 검색하고, star많은 순으로 정렬 겉보기 이쁘다고 무턱대고 템플릿 가져다 쓰면, 아마 빠른시일 안에 블로그를 포기할 것임.. 1k 넘는 레포 중에서 이쁜거 찾는다. 검색 카테고리 기능 dark/light mode 댓글 기능 추천하는 테마들은 다음과 같다. ✅ https://github.com/dillonzq/LoveIt 👍 https://github.com/zzossig/hugo-theme-zzo https://github.com/luizdepra/hugo-coder https://github.com/adityatelange/hugo-PaperMod ","date":"2022-01-02","objectID":"/initial_hugo/:1:2","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.3. Generate your profile image 프로필 이미지 생성한 곳 이말년 스타일 프로필 이미지 필자는 프로필 사진에 cartoonize를 써보고 싶어서 github에서 ML 모델 위주로 검색했는데 원하는 곳을 찾지 못해서 대안으로 여기를 사용 하게 되었다. 이말년 그림체로 프로필 만들고 싶은데 뭔가 해줘야 할게 많아서 포기… 누가 online 서버 만들어주면 좋겠다…🥺 기타 작품들 열정적인 스터디원들 ","date":"2022-01-02","objectID":"/initial_hugo/:1:3","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2. Init Blog 자 본격적으로 블로그 만들어보자. ","date":"2022-01-02","objectID":"/initial_hugo/:2:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2.1. Generate Blog 먼저 블로그용 폴더를 만들고 템플릿을 submodule로 추가해보자. # hugo new site \u003cYOUR FOLDER NAME\u003e $ hugo new site love $ cd love $ git init $ git branch -M main # git remote add origin \u003cYOUR ROOT REPOSITORY\u003e $ git remote add origin https://github.com/minkj1992/love.git # git submodule add \u003cTHEME REPOSITORY\u003e themes/\u003cTHEME_NAME\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # + 사내 계정이라 config 변경 $ git config user.email minkj1992@gmail.com $ git config user.name \"minkj1992\" 필자의 경우 github page를 사용해서 블로그를 운영할 것이기 때문에, 미리 생성했던 YOUR_ID.github.io레포지토리를 submodule로 등록한다. # git submodule add \u003cYOUR_ID.github.io\u003e public $ git submodule add https://github.com/minkj1992/minkj1992.github.io public Warning $ git submodule add \u003cYOUR_ID.github.io\u003e public 명령어를 칠 때, 꼭 public을 디렉토리로 넣어주어야 한다! hugo는 스태틱 파일들을 public/ 디렉토리로 빌드해주고, 우리의 *.github.io는 블로그의 스태틱 파일들을 가지고 있어야 하니까 :) LoveIt config.toml의 example config.toml을 참조해서, 본인의 블로그 루트 디렉토리에 config.toml을 생성하고 필요한 설정들을 추가해주자. $ cp ./themes/LoveIt/exampleSite/config.toml ./config.toml # if you want to add image to site home $ mkdir -p assets/images # after this command, paste your profile \u0026 log image to images and change config.toml # (OPTIONAL) If you want to change css font-famiully and size, customize scss file. $ touch assets/_override.scss 자 이제 첫 글을 작성해보자. 주의할점은 draft:false가 되어있어야 hugo를 github page 배포했을 때, 깨지지 않고 배포 된다. # *.md draft must be falsed! $ hugo new posts/initial_post.md 글을 작성했다면, 로컬에서 실행시켜보자 (hot-reload적용 됨) 참고로 commit이 안되서, 실행이 안된다고 하니 이쯤에서 우선 커밋 먼저 해준다. (fatal: your current branch 'main' does not have any commits yet) $ git add . \u0026\u0026 git commit -m\"Initial commit\" # hot reload debug run server $ hugo server -D 정상적으로 블로그가 동작하는걸 확인했다면 배포를 해보자. 배포는 아래 과정을 거쳐 진행된다. hugo build ($ hugo) ./public commit \u0026 push (submodule e.g minkj1992.github.io) root repository push 먼저 hugo를 빌드하면 public/ 디렉토리에 파일들이 추가 된다. 추가된 파이들을 public의 remote로 push해주고, root 레포지토리로 돌아가서 push 해주면 된다. 필자는 아래의 스크립트를 사용해서 해당 과정을 진행해주고 있다. 2.1.1. git-push.sh #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32m I Love Leoo.j \\033[0m\\n\" printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" printf \"\\033[0;32mBuild the project.\\033[0m\\n\" hugo -D # hugo -t timeline # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m Go To Public folder \\033[0m\\n\" cd public printf \"\\033[0;32m Setting for submodule commit \\033[0m\\n\" git config --local user.name \"minkj1992\" git config --local user.email \"minkj1992@gmail.com\" git submodule update --init --recursive printf \"\\033[0;32m Add changes to git. \\033[0m\\n\" git add . printf \"\\033[0;32m Commit changes.. \\033[0m\\n\" msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" printf \"\\033[0;32m Push blog(presentation) source and build repos. \\033[0m\\n\" git push origin main printf \"\\033[0;32m Come Back up to the Project Root \\033[0m\\n\" cd .. echo $pwd printf \"\\033[0;32m root repository Commit \u0026 Push. \\033[0m\\n\" git add . msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" git push origin main shell을 만들었다면, 이제 배포 해보자. $ sh git-push.sh \u003cCOMMIT_MSG\u003e Tip 만약 github action을 사용하고 싶다면, https://github.com/minkj1992/love/blob/main/.github/samples/gh-pages.sample 를 사용 해보라. (단 secrets.PERSONAL_TOKEN은 github setting에서 ENV등록해 주어야 함) git hook을 쓰면 커밋이 편하긴 하지만, 개인적으로는 hook을 쓰면 로컬의 public/ 디렉토리의 git 버저닝이 관리되지 않고 있는게 눈에 거슬려서 shell을 사용 중이다. ","date":"2022-01-02","objectID":"/initial_hugo/:2:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"3. Conclusion Nexters에서 2021년 회고글 작성하는 모임에 참석해서, 많은 개발자 분들이 notion으로 글을 정리하는 것에 자극 받아서, 바로 블로그를 만들게 되었는데 개인적으로 만족스럽다. 생각보다 에러 잡는데 시간을 많이 지체한 것 같고, github hook부분 기능을 잘 몰라 커스터마이징 하고 싶어 이것 저것 만져보다가 토요일 하루가 꼬박 걸렸는데 이 글을 읽는 여러분은 제가 했던 삽질을 경험하지 않길 바란다. - 끝 - ","date":"2022-01-02","objectID":"/initial_hugo/:3:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["Markdown"],"content":"This article shows the basic Markdown syntax and format.","date":"2022-01-01","objectID":"/first_post/","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":" This article offers a sample of basic Markdown syntax that can be used in Hugo content files. Note This article is a shameful copy of the great Grav original page. If you want to know about the extented Markdown syntax of LoveIt theme, please read extended Markdown syntax page. Let’s face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages. Markdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it. Some of the key benefits are: Markdown is simple to learn, with minimal extra characters, so it’s also quicker to write content. Less chance of errors when writing in Markdown. Produces valid XHTML output. Keeps the content and the visual display separate, so you cannot mess up the look of your site. Write in any text editor or Markdown application you like. Markdown is a joy to use! John Gruber, the author of Markdown, puts it like this: The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email. – John Gruber Without further delay, let us go over the main elements of Markdown and what the resulting HTML looks like! Tip  Bookmark this page for easy future reference! ","date":"2022-01-01","objectID":"/first_post/:0:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"1. Headings Headings from h2 through h6 are constructed with a # for each level: ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading The HTML looks like this: \u003ch2\u003eh2 Heading\u003c/h2\u003e \u003ch3\u003eh3 Heading\u003c/h3\u003e \u003ch4\u003eh4 Heading\u003c/h4\u003e \u003ch5\u003eh5 Heading\u003c/h5\u003e \u003ch6\u003eh6 Heading\u003c/h6\u003e Heading IDs To add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading: ### A Great Heading {#custom-id} The HTML looks like this: \u003ch3 id=\"custom-id\"\u003eA Great Heading\u003c/h3\u003e ","date":"2022-01-01","objectID":"/first_post/:1:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"2. Comments Comments should be HTML compatible. \u003c!-- This is a comment --\u003e Comment below should NOT be seen: ","date":"2022-01-01","objectID":"/first_post/:2:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"3. Horizontal Rules The HTML \u003chr\u003e element is for creating a “thematic break” between paragraph-level elements. In Markdown, you can create a \u003chr\u003e with any of the following: ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks The rendered output looks like this: ","date":"2022-01-01","objectID":"/first_post/:3:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"4. Body Copy Body copy written as normal, plain text will be wrapped with \u003cp\u003e\u003c/p\u003e tags in the rendered HTML. So this body copy: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. The HTML looks like this: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e A line break can be done with one blank line. ","date":"2022-01-01","objectID":"/first_post/:4:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"5. Inline HTML If you need a certain HTML tag (with a class) you can simply use HTML: Paragraph in Markdown. \u003cdiv class=\"class\"\u003e This is \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Paragraph in Markdown. ","date":"2022-01-01","objectID":"/first_post/:5:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6. Emphasis ","date":"2022-01-01","objectID":"/first_post/:6:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.1. Bold For emphasizing a snippet of text with a heavier font-weight. The following snippet of text is rendered as bold text. **rendered as bold text** __rendered as bold text__ The HTML looks like this: \u003cstrong\u003erendered as bold text\u003c/strong\u003e ","date":"2022-01-01","objectID":"/first_post/:6:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.2. Italics For emphasizing a snippet of text with italics. The following snippet of text is rendered as italicized text. *rendered as italicized text* _rendered as italicized text_ The HTML looks like this: \u003cem\u003erendered as italicized text\u003c/em\u003e ","date":"2022-01-01","objectID":"/first_post/:6:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.3. Strikethrough In GFMGitHub flavored Markdown you can do strikethroughs. ~~Strike through this text.~~ The rendered output looks like this: Strike through this text. The HTML looks like this: \u003cdel\u003eStrike through this text.\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.4. Combination Bold, italics, and strikethrough can be used in combination. ***bold and italics*** ~~**strikethrough and bold**~~ ~~*strikethrough and italics*~~ ~~***bold, italics and strikethrough***~~ The rendered output looks like this: bold and italics strikethrough and bold strikethrough and italics bold, italics and strikethrough The HTML looks like this: \u003cem\u003e\u003cstrong\u003ebold and italics\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003estrikethrough and bold\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003estrikethrough and italics\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003ebold, italics and strikethrough\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"7. Blockquotes For quoting blocks of content from another source within your document. Add \u003e before any text you want to quote: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The rendered output looks like this: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The HTML looks like this: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e Blockquotes can also be nested: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. The rendered output looks like this: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2022-01-01","objectID":"/first_post/:7:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8. Lists ","date":"2022-01-01","objectID":"/first_post/:8:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.1. Unordered A list of items in which the order of the items does not explicitly matter. You may use any of the following symbols to denote bullets for each list item: * valid bullet - valid bullet + valid bullet For example: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2022-01-01","objectID":"/first_post/:8:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.2. Ordered A list of items in which the order of items does explicitly matter. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e Tip If you just use 1. for each number, Markdown will automatically number each item. For example: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2022-01-01","objectID":"/first_post/:8:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.3. Task Lists Task lists allow you to create a list of items with checkboxes. To create a task list, add dashes (-) and brackets with a space ([ ]) before task list items. To select a checkbox, add an x in between the brackets ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media The rendered output looks like this: Write the press release Update the website Contact the media ","date":"2022-01-01","objectID":"/first_post/:8:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9. Code ","date":"2022-01-01","objectID":"/first_post/:9:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.1. Inline Code Wrap inline snippets of code with `. In this example, `\u003csection\u003e\u003c/section\u003e` should be wrapped as **code**. The rendered output looks like this: In this example, \u003csection\u003e\u003c/section\u003e should be wrapped as code. The HTML looks like this: \u003cp\u003e In this example, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e should be wrapped with \u003cstrong\u003ecode\u003c/strong\u003e. \u003c/p\u003e ","date":"2022-01-01","objectID":"/first_post/:9:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.2. Indented Code Or indent several lines of code by at least four spaces, as in: // Some comments line 1 of code line 2 of code line 3 of code The rendered output looks like this: // Some comments line 1 of code line 2 of code line 3 of code The HTML looks like this: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.3. Block Fenced Code Use “fences” ``` to block in multiple lines of code with a language attribute. ```markdown Sample text here... ``` The HTML looks like this: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.4. Syntax Highlighting GFMGitHub Flavored Markdown also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code “fence”, ```js, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` The rendered output looks like this: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Note Syntax highlighting page in Hugo Docs introduces more about syntax highlighting, including highlight shortcode. ","date":"2022-01-01","objectID":"/first_post/:9:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"10. Tables Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. The HTML looks like this: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Right or center aligned text Adding a colon on the right side of the dashes below any heading will right align text for that column. Adding colons on both sides of the dashes below any heading will center align text for that column. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2022-01-01","objectID":"/first_post/:10:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11. Links ","date":"2022-01-01","objectID":"/first_post/:11:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.1. Basic Link \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) The rendered output looks like this (hover over the link, there is no tooltip): https://assemble.io contact@revolunet.com Assemble The HTML looks like this: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.2. Add a Title [Upstage](https://github.com/upstage/ \"Visit Upstage!\") The rendered output looks like this (hover over the link, there should be a tooltip): Upstage The HTML looks like this: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.3. Named Anchors Named anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) will jump to these sections: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. Note The specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works. ","date":"2022-01-01","objectID":"/first_post/:11:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"12. Footnotes Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. This is a digital footnote[^1]. This is a footnote with \"label\"[^label] [^1]: This is a digital footnote [^label]: This is a footnote with \"label\" This is a digital footnote1. This is a footnote with “label”2 ","date":"2022-01-01","objectID":"/first_post/:12:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"13. Images Images have a similar syntax to links but include a preceding exclamation point. ![Minion](https://octodex.github.com/images/minion.png) or: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat Like links, images also have a footnote style syntax: ![Alt text][id] The DojocatAlt text \" The Dojocat With a reference later in the document defining the URL location: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" This is a digital footnote ↩︎ This is a footnote with “label” ↩︎ ","date":"2022-01-01","objectID":"/first_post/:13:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"}]