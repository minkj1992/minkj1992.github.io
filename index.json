[{"categories":["book","wisdom"],"content":"워렌 버핏이 바라보는 돈과 투자 그리고 기업에 대하여.","date":"2022-12-15","objectID":"/warren_buffett/","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"워렌 버핏이 바라보는 돈과 투자 그리고 기업에 대하여. ","date":"2022-12-15","objectID":"/warren_buffett/:0:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 워렌 버핏은 어떻게 부자가 되었을까? 남들이 비싼 물건들을 구입하기 바쁠 때, 꼭 필요한 물건이 무엇일지 비싸게 고민하고 남들이 싸게 물건들을 팔기 바쁠 때, 자신은 꼭 필요한 물건만 주시하다 싸게 구한 뒤, 몇 년이 지나 남들이 꼭 필요한 물건을 비싸게 탐내기 시작하면, 욕심 부리지 않는 선에서 만족스러운 금액을 받고 다시 주는 것. ","date":"2022-12-15","objectID":"/warren_buffett/:1:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 실제로 주식 투자로 부자가 되기 위해서는 평생 동안에 올바른 결정 몇 개만 내리면 된다. 위대한 투자 아이디어는 일년에 한 번도 도출되기 어려울 만큼 드물다. (112p) 그는 무언가를 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. (65p) 연상된 점: 올바른 결정, 원하는 것 깨달은 점: 부자가 되기 위한 몇번 안되는 결정을 내리기 전에, 올바른 것이 무엇인지 자신이 무엇을 원하고 있는지 명확하게 알고있어야 한다. 인생을 잘 살기 위해서는 올바른 것이 무엇인지, 내가 무엇을 구하고 있는지 명확하게 알아야 한다. 나는 내 무의식을 다스리지 못하고 있기 때문에 계속 ‘따뜻한 아이스아메리카노’를 주문하고 있었고, 몇몇 부자들은 독이든 아이스 아메리카노를 주문한 것 같다. ","date":"2022-12-15","objectID":"/warren_buffett/:2:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"3. 저자의 주장에 대한 나의 생각 “사업의 세계에서는 백미러가 전면 유리보다 더 선명하게 보이는 법이다.” 버핏은 기술 분야의 앞날을 예측할 수 없다며, 이는 자신의 절친한 친구이자 컴퓨터 업계를 속속들이 알고 있는 빌 게이츠 역시 마찬가지일 것이라고 말한다. 앞날을 예측하는 것이 어렵다는 사실은, 버핏이 오랜 세월을 두고 그 실효성이 입증된 제품에만 관심을 두는 원인이기도 하다. 실효성이 입증된 제품의 경우, 적어도 15년 정도는 앞을 내다볼 수 있다. +: 15년 미래를 예측한다는 것과 워렌 버핏이 기술 분야에 관심을 덜 가져주어서 감사하다. 워렌 버핏이 들어왔다면 기술관련 주식들을 더 비싸게 구매해야 되기 때문이다. -: 직접 소설가가 되어보기 전까진, 소설이 아닌 것을 써볼 수 없다. 버핏은 엔지니어가 아니었기 때문에 기술 분야의 앞날을 모르는 것은 당연한 일이다. 어찌보면 모르기 때문에 투자하지 않는 것은 당연한 일이지만, 이 판단은 소설이기 때문에 나와는 맞지 않다. 아빠가 되어보면 아빠를 이해할 수 있고, 기술자가 되어보면 기술을 이해할 수 있다. 이해할 수 있다면, 당연히 예측도 가능해야 한다. ","date":"2022-12-15","objectID":"/warren_buffett/:3:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"4. 질문 및 토의 사항 Q. 다들 주문할 좋은 기업들은 찾으셨나요? ","date":"2022-12-15","objectID":"/warren_buffett/:4:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"5. 작은 실천 계획 돈을 버는 것도 중요하지만, 그 만큼 번 돈을 함부로 쓰지 않는 것도 중요하다. (12p) 미국 여행 지출 기록 매달 말 토요일, 지출계획표 작성 루틴 추가. 경기침체 대비, 앞으로 1년간 현재 지출에서 40% 절감 목표. 주식을 산다는 것은 기업의 일부를 산다는 의미다. (38p) 투자할 기업들 비전 정리 및 CEO 기부 현황 분석표 작성. “회계는 업종을 불문하고 모든 사업의 언어다.” (51p) 재무재표 관련 도서구매 “나는 10년 혹은 15년 후의 그림이 그려지는 사업을 찾는다.” (68p) 투자 시나리오에 10년-15년 미래 시나리오 작성 기업의 연차 보고서도 읽으라. 그러나 문자 그대로 따라해서는 곤란하다. (72p) 투자 시나리오 양식에 기업별 연차 보고서 링크 추가 ","date":"2022-12-15","objectID":"/warren_buffett/:5:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"6. 자유 감상문 템플턴 동안 책추남님이 추천해주신 책들은 읽을 때 한번, 내 생각으로 반박해보면서 한번, 저자를 통해 무언갈 받아들일 때 또 한 번 읽게 된다. 그래서 그런지 쉽게 읽지 못하고, 대부분 한 달 정도를 고민하고 나에게 적용하려고 노력했다. 이 책과 ‘돈 공부는 처음이라’ 역시 한 달 정도를 고민했다. 지금 이 글을 쓰는 시점인 아침, 내일 있을 만남에서 공유할 숙제들을 하지 못했다는 생각에 무거운 마음으로 기상했다. 그렇게 마음에 여유가 없는 상태에서 아침에 글을 쓰는데 잘 써지지 않았다. 사실 글을 쓸 수 있는 시간은 많이 있었지만, ‘좀 더 완벽하게!’, ‘좀 더 내 가슴이 뛰는걸!’, ‘좀 더 내가 실천할 수 있는걸!‘들을 외치다 보니 어느새 시간이 다 지나있었다. 이러다 보니 시간에 쫒겨 여유로울 때보다, 더 인위적인 글이 작성되는 것을 느꼈다. “불완전하더라도, 일주일 전에 글을 완성하고 보완했으면 어땠을까?” 이렇게 마음의 여유가 없게 된것은 내가 시간을 잘 관리하지 못해서이고, 다른말로 내가 ‘시간’에 대해 부유하지 않다는 것이다. 그렇게 생각하니 문득 내가 원하는 부자들의 공통점을 하나 떠올리게 되었는데 그것은 “마음의 여유\"였다. “나는 내가 넘지 못할 2미터의 막대를 뛰어넘으려 하지 않는다. 충분히 넘을 수 있는 30센티미터의 막대를 넘으면 그만이다. by 워렌 버핏” 나는 마음의 여유를 가지고 싶다. 따뜻한 아침을 보내고 싶고, 평온한 저녁을 보내고 싶다. 내가 원하는 부자란 이렇게 마음의 여유가 있는 사람이고, 10년 뒤에도 지금처럼 마음의 여유를 가지기 위해서는 그저 10년 뒤인 나와 내 가정이 필요할 금액을 지금부터 구해두면 된다. 돈이 없으면 마음의 여유가 없고, 돈이 있지만 마음의 여유가 없으면 부자가 될 수 없다. 이 공식을 적용하면, 워렌 버핏은 중요한 게 무엇인지 알고 계신 분이었다. 그렇기 때문에 10-15년 동안 신경 쓰지 않아도 될 기업들에 투자하였던 것이다. 구하라, 그러면 얻을 것이다. 그러나 구하지 않는다면 절대 얻을 수 없다. (16p) 워렌은 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. (65p) 이 공식은 앞으로 나의 투자에서도 똑같이 적용할 것이다. 나는 내가 가장 좋은 퍼포먼스를 낼 수 있는 상태가 ‘마음의 여유’가 있는 상태라는 것을 알고. 마음의 여유가 있는 상태에서 행동했다면, 지금 내가 할 수 있는 최고의 행동을 한 것이다. “불완전하게 시험공부를 하고, 마음이 여유로운 상태로 보다 완벽을 구하자. 중요한 것은 마음의 여유이다.” 이 글을 다 쓴 시점, 문득 ‘버핏의 공식을 적용한 나’보다 더 부자가 되는 방법이 떠올랐는데, 그것은 머리로는 버핏의 20년이 아닌 30년 뒤의 미래를 준비하는 마음을 가지는 것이고, 가슴으로는 30년 뒤에 마음의 여유가 없을 사람들을 위해, 내가 할 수 있는게 뭐가 있을지를 고민하고 지금 준비하는 것이라고 생각했다. “오래전에 누군가가 나무를 심었기 때문에 오늘 당신이 나무 그늘에서 편히 쉴수 있는 것이다. by 워렌 버핏” ","date":"2022-12-15","objectID":"/warren_buffett/:6:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"Buffett’s Quotes ","date":"2022-12-15","objectID":"/warren_buffett/:7:0","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"1. Getting and Staying Rich (부자되기 그리고 부자로 살아남기) 12 돈을 버는 것도 중요하지만, 그만큼 번 돈을 함부로 쓰지 않는 것도 중요하다. 16 매도 호가는 높게, 매수 호가는 낮게 부르라. (중략) 구하라, 그러면 얻을 것이다. 그러나 구하지 않는 절대 얻을 수 없다. 20 미국에서 개인이 모은 가장 큰 재산은 50개 기업으로 구성된 포트폴리오로 형성된 것이 아니다. 오직 하나의 탁월한 사업을 알아본 사람에 의해 가장 큰 부가 완성되었다. 22 일단 서명하면 계약을 파기하는 것은 불가능하다. 24 곤란한 상황에서 빠져나오는 것보다 그런 상황에 빠지지 않도록 조심하는 것이 훨씬 쉽다. 26 투자 결정은 결혼을 결정하는 것처럼 신중하게 28 업종을 불문하고 사업 전망이라는 것은 언제나 지나치게 장미빛을 띠게 마련이다. 29 “돈을 잃어도 좋습니다. 아주 큰돈을 잃더라도 상관없습니다. 하지만 절대로 명성을 잃어서는 안 됩니다. 아무리 작은 명성이라도 말입니다. (중략) 결국 우리는 합당한 평가를 받게 될 것입니다.” 31 주식시장은 자신이 무엇을 하는지 아는 이에게는 부를 선사한다. 그러나 무엇을 하는지 모르는 이에게는 가차없이 가난을 안긴다. 그래서 무지한 사람이 탐욕스럽기까지 하면 심각한 금전적 타격을 입게 되는 것이다. 자신이 무엇을 하는지 모르는데 따르는 대가는 이처럼 엄청나다. 32 타석에 들어설 때마다 홈런을 치겠다고 욕심을 부리지도 않는다. 다만 자신만의 고유한 타격 자세를 잡은 뒤 자신이 좋아하는 공이 오기를 묵묵히 기다릴 뿐이다. 더 이상 개선할 필요가 없는 훌륭한 제품을 생산하는 회사, 20년 후에도 건재할 것이 확실한 사업, 전부 매수해도 좋을 가격에 주식이 매매되는 회사 등을 노리는 것이 버핏이 말하는 자신만의 고유한 타격 자세다. 34 습관이라는 사슬은 끊어지기 전까지는 너무 가벼워 그 무게를 전혀 느끼지 못한다. (중략) 사업이 공경에 처한 다음에야 비용을 절감하는 기업을 떠올려 보자. 37 뭔가 대단한 일을 해야만 위대한 결과를 얻을 수 있는 것은 아니다. 하루 아침에 벼락부자가 되는 것만이 부자가 되는 유일한 길은 아니다. 버핏은 연평균 수익률 200퍼센트가 아니라 20퍼센트를 목표로 한다. 연리 20퍼센트로 10만 달러를 투자하면 20년 후에는 총 380만 달러가 된다. 30년이면 2370만 달러다. 주식 투자는 마라톤과 같다. 38 주식을 산다는 것은 기업의 일부를 산다는 의미다. 39 투자의 세계에서 큰돈을 벌기 위해서는 우선 자기 스스로 생각하는 법을 배워야 한다. 그리고 자기 스스로 생각하기 위해서는 홀로 서는 것을 두려워하지 말아야 한다. 41 5조 달러 규모의 미국 주식 시장에서 돈을 벌지 못하면서 수천 마일 떨어진 해외에서 실력을 보여 준다는 것은 희망 사항에 불과하다. (원효대사 해골물이 생각남) 45 버핏은 자식들에게 큰 재산을 물려주면 그들이 자신만의 인생을 살 수 없다고 생각한다. 부모의 재산을 물려받은 사람들이 상류층을 형성하는 것이 사회적으로도 결코 좋지 않다고 생각한다. 일한 만큼 벌고 번 만큼 대우받으며 사는, 능력 위주의 사회가 국가 발전에 더 기여한다는 생각이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:1","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"2. Business (투자 기업 고르기) 48 모든 것에는 끝이 있다. 굴러가는 공만 살펴서는 안 된다. 공이 어디로 굴러가고 있는지도 미리 살펴야 한다. 50 회사 운영 능력이 탁월한 경영자도 기초 체력이 부실한 기업은 어쩔 수 없다. 위대한 기업은 현금이 풍부한 반면 부채는 거의 없다. 또한 어려운 상황을 돌파하거나 불황을 견디는 능력도 뛰어나다. 그러나 평범한 기업은 언제나 현금 확보에 전전긍긍하며, 부채는 넘쳐난다. 51 회계는 업종을 불문하고 모든 사업의 언어다. 52 변화는 쉽게 일어나지 않는다. 세상에는 부실한 기초 체력 때문에 저가에 거래되는 기업이 수두룩하다. 버핏은 이런 기업 보다 제대로 된 가격에 거래되는 우량 기업을 선호한다. 우량 기업임에도 저가에 매매되는 경우라면 더욱 선호한다. 그러나 이런 경우는 극히 드물다. 54 가격이 폭락한 종목을 살 때는 그 회사의 장기적인 기업 가치에 문제가 없는지 반드시 확인해야 한다. 장기적 기업 가치가 건재하다면 기업의 장기적인 실적도 우수할 것이고, 이것은 결국 주가에 반영될 것이다. 56 주식 투자는 자신이 다닐 회사를 선택하는 것과 비슷하다. 이는 어려운 문제라기보다 올바른 선택의 문제다. 확실한 기차에 올라타야 시간 낭비와 고통을 그만큼 줄일 수 있다. 오랫동안 노력하여 튼튼한 기초 체력을 갖춘 기업은 어떠할까? 이런 회사는 대개 현금이 여유로운 편이다. 따라서 월급도 많고, 실적에 따른 연봉 인상과 보너스도 잦다. 게다가 경영진은 항상 풍부한 현금을 유용하게 사용할 방법을 모색하기 때문에 회사가 발전할 여지도 많다. 58 부실 운영과 부실 경영은 부실 회계로 이어진다. (중략) 지금도 어떤 기업에서는 회계 부정을 저지르고 있다는 사실을 명심하라. 59 성장하기 위해 많은 자본이 필요한 사업과 많은 자본이 필요 없는 사업의 차이는 크다. 이런 업종은 경쟁에서 살아남기 위해 끊임 없이 자본을 투입해야 한다. 5년마다 제품을 재구성하는데 수십억 달러를 들여야 한다면 사업 규모 확대나 신사업 인수, 주식 환매 등에 지출할 돈은 그 만큼 적어지게 된다. 한편 사업을 성장시키는 데 가외 자본을 투입할 필요가 없는 경우에는 이 돈을 사업 규모 확대 등에 지출할 수 있다. 이렇게 되면 회사의 주당 순이익이 증가하고, 결국 주가도 상승하게 된다. 성장하는 데 막대한 자본이 필요한 업종을 선택하면 큰돈을 벌기 어렵다. 반면 성장에 큰 자본이 필요 없는 종목을 선택해서 손해를 보는 일은 거의 없다. 61 기초 체력이 부실한 기업은 한 가지 문제를 해결하고 나면 곧바로 또 다른 문제에 봉착한다. 부엌에 바퀴벌레가 한 마리만 있는 경우는 드물기 떄문이다. 62 싸구려 시장으로 진출해도 매출을 증가시킬 수는 있지만, 일단 싸구려로 전락하면 다시 고가 시장으로 올라가기 힘들다. 64 “인간의 모든 비극은 혼자 조용히 방에 있지 못하는데서 비롯된다.” by 파스칼. 64 CEO들은 대개 조용히 방에 있지 못하다. 그들은 동분서주하며 이 회사 저 회사와 계약을 맺고, 이를 통해 회사 몸집을 불리는 일만이 자신들이 받는 엄청난 연봉에 걸맞은 행동이라고 생각한다. 월스트리트가 이를 부추기는 면도 분명 있다. 거기에 기존의 문제를 해결하기 보다, 새로운 문제를 떠맡기가 종종 더 쉽다는 사실도 작용한다. 버핏은 지속적인 경쟁 우위를 지닌 기업만을 사들인다. 이런 기업은 높은 자기 자본 이익률과 지속적으로 높은 수익률이 증명하듯 경제적 기초 체력이 튼튼하다. “무차별 상품형(commodity-type) 이런 유형의 사업은 소비자가 구매를 결정하는 중요한 요인이 가격밖에 없는 제품과 서비스를 제공하기 때문에 자본 이익률도 낮고, 수익률도 일정하지 않다. 전 세계에 있는 회사 대부분이 이러한 무차별 상품형 기업에 속한다. 65 그러나 한 가지 확실한 것이 있다. 버핏은 지속적인 경쟁 우위를 보이는 기업을 발견하면 지체하지 않고 사들인다는 사실이다. 그는 무언가를 원하기 이전에 이미 자신이 무엇을 원하는지 분명히 알고 있다. 66 투자 리스크는 사업의 질이 높을수록, 그리고 사업의 질에 비해 주가가 낮을수록 리스크는 낮아진다.(투자 리스크=주가/사업의 질) 주식시장에서 반드싯 피해야 하는 것은 질 낮은 기업을 높은 가격에 사는 일이다. 질이 높은 기업과 질에 비해 저가인 종목은 취하고, 질이 낮은 기업과 질에 비해 고가인 종목은 피해야 한다. 67 주식 투자는 종목 하나하나가 완전히 새로운 게임이라는 사실을 명심하라. 충분한 안전 마진(margin of safety)이 확보될 정도로 승률이 자신에게 유리하게 전개될 때를 기다려 크게 투자하는 것이 돈을 버는 비결이다. 재미있는 사실은, 주식 시장은 종종 아주 성공이 확실한 종목들을 선보인다는 사실이다. 버핏이 추구하는 것은 오직 이처럼 확실한 성공을 보장하는 종목들뿐이다. 68 나는 10년 혹은 15년 후의 그림이 그려지는 사업을 찾는다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:2","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"3. Mentors (거인의 어깨 위에 올라타기) 70 오래전에 누군가가 나무를 심었기 때문에 오늘 당신이 나무 그늘에서 편히 쉴수 있는 것이다. 거인의 어깨 위에 올라타면 당신이 일하는 분야에서 더 큰 성공을 거둘 수 있다. 중요한 것은 자신에게 맞는 거인을 선택하는 일이다. 71 유용하다 싶은 내부 정보를 들었다면 다른 사람은 이미 그것을 이용하고 있다는 사실을 명심하라. 더구나 내부 정보를 이용한 거래는 불법이다. 72 벤저민 그레이엄과 필 피셔의 책을 읽으라. 기업의 연차 보고서도 읽으라. 그러나 문자 그대로 따라해서는 곤란하다. 74 나는 사업가이기 때문에 더 좋은 투자가가 될 수 있고, 또 투자가이기 떄문에 더 좋은 사업가가 될 수 있다. 뛰어난 사업가는 좋은 사업과 그렇지 못한 사업을 구별할 줄 안다. 뛰어난 투자가는 사업체가 싸게 거래되고 있는 때와 비싸게 거래되고 있는 떄를 구별할 줄 안다. (commodity-type \u003c-\u003e consumer-monopoly, 소비자 독점형) 75 버핏은 경쟁 우위가 있는 소비자 독점형 기업만 사들였다. 제값만 주고 살 수만 있다면 장기간 보유했을 떄 반드시 큰돈을 벌어 줄 것이라고 버핏은 확신했다. 78 모두가 노리는 종목에 투자하려면 아주 비싼 대가를 치러야 한다. 이런 종목은 향후 주가가 오를 일은 별로 없는 반면 떨어질 일은 아주 많다. 가격이 떨어질 일만 남은 종목을 고가로 매수하는 것보다는 가격이 오를 일만 남은 종목을 저가로 매수하는 것에 더 관심이 있다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:3","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"4. Education (스스로 익히는 투자 전략) 83 자신의 경험을 통해 배우는 것도 좋지만, 가능하면 다른 사람의 경험을 통해 배우는 것이 현명하다. (중략) 무엇을 해야 하는지 알아야 하는 것과 마찬가지로 무엇을 하면 안 될지도 알아야 한다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:4","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"5. Management Philosophy (버핏의 경영 철학) 87 누군가를 고용하려 할 때는 정직, 지능, 열정 이 세가지를 살펴야 한다. 그중에서도 가장 중요한 것이 정직이다. 정직하지 않다면 지능과 열정도 그 빛을 잃는다. 89 물고기에게 땅에서 걷는 일이 어떤 것인지 설명할 수 있을까? 수백 번 이야기하는 것보다 단 하루라도 직접 걸어 보게 하는 것이 낫다. 사업을 운영하는 것도 이와 마찬가지다. 90 수영장의 물이 다 빠지고 나서야 누군가 알몸으로 헤엄치고 있었다는 사실을 알게 된다. 실제로 돈이 보이지 않으면 환상에 가까웠던 열렬한 호들갑은 한순간에 사라지고 만다. 남는 것은 텅 빈 통장과 파산 선고뿐이다. 문제는 물이 빠지기 전까지는 누가 알몸으로 헤엄치고 있는지 모른다는 것이다. 91 아이디어가 부실하면 말이 화려해진다. 주주들의 비난을 피하려고 하는 것은 결국 자신의 결정에 책임을 지지 않겠다는 의미다. 책임지지 않는 CEO를 기업의 리더라고 할 수 있을까? 주주인 내가 바로 그 회사의 소유주가 아닌가? 92 “오늘부터 비용을 점감하겠다\"고 말하는 관리자는 그다지 훌륭하다고 볼 수 없다. 93 사랑은 100만 달러를 줘도 살 수 없다. 사랑을 받는 유일한 방법은 스스로 사랑받을 만한 사람이 되는 것이다. 사랑받는 사람은 먼저 남에게 자신이 가진 것을 준다. 그리고 결과적으로 준 것보다 더 많이 받는다. 그는 먼저 남에게 주지 않으면 아무것도 얻지 못한다는 사실을 안다. 이렇게 사랑을 받는 사람 중 자신이 성공하지 못했다고 느끼는 사람은 없다. 또한 사랑을 받지 못하면서도 성공했다고 느끼는 사람도 없다. 94 사랑과 존경은 더 큰 사랑과 존경을 낳는다. 95 나를 움직이는 것은 결과보다는 과정에서 맛보는 일에 대한 재미와 열정이다. 버핏은 투자자로서 자신의 일에 열정이 있다. 그는 심지어 돈을 내고서라도 투자라는 일을 할 사람이다. 그러나 실제로는 돈을 지불하기는커녕 좋아하는 일을 하면서도 엄청난 부자가 되었으니 이보다 더 좋은 일이 있을 리 없다. 96 매 홀마다 홀인원을 한다면 골프를 오래 즐기기 어렵다. 도전이 없는 일은 지루하며, 자부심도 느끼기 어렵다. 당연히 동기 부여가 되지 않은 사람들만 꾀게 마련이다. 도전과 함께하는 일이라야 재미도 있고, 자부심도 높아진다. 도전과 함께하는 일이라야 창의력을 발휘할 수도 있고, 최고의 인재를 끌어 모을 수도 있다. 그러나 도전에는 항상 위험이 따른다. 실수하라 어느새 성공이 가까이에 와 있음을 알게 될 것이다. 97 언젠가 하고 싶은 일을 할 수 있는 때가 오면 자신이 정말 사랑하는 일을 하라. 아침에 저절로 눈이 떠질 것이다. 98 신나게 할 수 있는 일을 하라. 돈은 따라올 것이다. 일을 위해 열심히 일하면 나중에는 그 일이 당신을 위햏 일해 줄 것이다. 단지 멋진 경력을 하나 보태겠다는 생각에 좋아하지도 않는 일을 선택하는 것은 어리석은 짓이다. 99 “완벽한 이상형을 찾아 헤맨 친구가 있었다. 마침내 그 여자를 찾았을 때는 안타깝게도 그녀 역시 자신만의 이상형을 찾고 있었다.” ","date":"2022-12-15","objectID":"/warren_buffett/:7:5","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"6. Analysts, Advisers, Brokers (투자자가 반드시 피해야 할 사람들) 102 이발사에게 머리카락을 잘라야 하냐고 묻는 것만큼 어리석은 행동은 없다. 문제를 고쳐 주는 대가로 돈을 받는 사람들은 문제가 없으면 돈을 벌 일도 없기 때문에 없는 문제라도 만들어 내는 경향이 있다. 103 예측하는 사람에게 있어 앞날을 묻는 사람이란 그저 자신에게 돈을 주는 사람, 그 이상도 이하도 아니다. 전문적인 예측가라 하더라도 미래가 훤히 내다보이는 수정 구슬을 가지고 있는 것은 아니다. 이들에게도 그저 매달 갚아야 하는 주택 융자금과 학비를 대야 하는 대학생 자녀들이 있을 뿐이다. 104 이처럼 월스트리트는 투자자들로 하여금 이 종목에서 저 종목으로 최대한 자주 갈아타게 만들고, 이로부터 수익을 얻는다. 증권분석가라고 불리는 예측가들의 주 업무는 투자자들이 투자 종목을 이리저리 바꾸도록 종용하는 일이다. 문제는 이런 행동이 반복되는 가운데 돈을 버는 것은 투자자가 아니라 월스트리트의 예측가들이라는 사실이다. 105 다수의 의견이 나의 판단을 대신하도록 내버려 두어서는 안 된다. 107 “가장 단순한 설명이 가장 훌륭한 설명 by 윌리엄 오컴”, 인간에게는 쉬운 것을 어렵게 만드는 묘한 성향이 있는 것 같다. 무엇이든 이해하기 어렵게 만들어야 사람들이 전문가를 찾게 되고, 자신은 전문가로서 문제를 해결해 준 대가로 높은 수수료를 받을 수 있다는 것이다. 주식 중개인의 논리는 아주 간단하다. 자신이 받는 보수는 주식 투자자를 부자로 만들어 주는 데 대한 대가라는 것이다. 그리고 복잡하고 어려운 투자 게임을 투자자 혼자 하기는 어렵기 때문에 주식 중개인인 자신에게 자문을 구해야 한다고 한다. 그러나 주식 중개인들이 그렇게 똑똑하다면 자신이 부자가 되기 위해 굳이 다른 사람, 즉 투자자의 돈이 필요할까라는 의문을 던져 보아야 한다. 109 증권회사는 30년 동안 주식을 보유하라고 권할 수 없다. 그것은 힘든 자기희생을 기꺼이 감내하는 수도승이나 할 수 있는 일이다. 109 시장 상황의 변화를 구실로 불과 한 달 전에 매수한 종목을 다시 매도하라고 권하는 주식 중개인이 있다면, 그는 망상에 빠진것이 아니라 단지 거짓말을 하고 있는 것이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:6","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"7. Why Not to Diversify (투자 결정을 내릴 때) 112 어떤 종목에 투자하려면 그 종목의 사업 경쟁력을 모두 검토해야 한다. 이를 생각하면 50개의 서로 다른 종목에 투자하는 것이 소수 종목에 집중 투자하는 것에 비해 집중도나 시간적인 면에서 효율적이지 못하다는 것을 알 수 있다. 112 실제로 주식 투자로 부자가 되기 위해서는 평생 동안에 올바른 결정 몇 개만 내리면 된다. 위대한 투자 아이디어는 일년에 한 번도 도출되기 어려울 만큼 드물다. 113 분산 투자는 자신의 무지를 감추는 수단에 불과하다. 버핏은 자신이 무엇을 하고 있는지 알고 있기 때문에 굳이 달걀을 나눠 담지 않는다. 그보다는 제대로 고른 달걀 몇 개에 자신의 투자를 집중한 다음 엄중히 관리하는 것을 선호한다. 114 월스트리트는 거래가 있어야 돈을 번다. 그러나 투자자는 움직이지 않고 가만히 있을 때 돈을 번다. 119 옳은 선택 몇 개만으로도 충분히 성공할 수 있다. 버핏의 재산 가운데 90퍼센트는 이렇게 선별한 10개 종목으로부터 형성되었다. 하지 않는 것이 하는 것 만큼 중요할 떄도 있다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:7","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"8. Discipline, Prudence, and Patience (투자자의 태도) 122 “사소한 일에서 원칙을 지키지 못하면 큰일을 할 때도 원칙을 지키기 어렵다.” 123 글로 써보는 것만큼 스스로 생각하게 만들고 또 자신의 사고를 바로잡는 방법도 없다. 어떤 것을 글로 표현할 수 없다면 그것에 관해 제대로 생각해 보았다고 할 수 없다. 당신의 돈을 어디에 투자해야 하는지 머릿속으로만으로 생각하는 것도 좋지만, 직접 글로 써 보는 것이 더 좋은 이유는 바로 여기에 있다. 124 다른 사람들이 덜 신중하게 행동할수록 더 신중하게 행동하라. 이는 특히 주가가 하늘 높은 줄 모르고 치솟는 강세장일 때 더욱 빛을 발하는 말이다. 125 “투수가 공을 던지기 전에 방망이를 휘두르지 말라” 기다릴 줄 아는 버핏은 미래의 사업 실적을 가늠하기 어려운 회사는 절대 매입하지 않는다. 지금 수익을 올리고 있더라도 과거에 실적이 전혀 없는 회사를 멀리하는 것도 같은 이유 때문이다. 과거에 단 한푼의 수익도 올린 적이 없는 회사를 사들이는 것은 그 회사가 앞으로 돈을 벌 것이라는 막연한 바람을 사는 것과 다름없다. 결국 있지도 않을 미래의 수익 흐름(income stream)을 위해 투자하는 것이다. 존재하지 않을 미래의 수익 흐름은 그 가치를 측정할 수 없다. 만약 당신의 투자 전략이 회사의 막연한 미래 수익에 근거하고 있다면 당신은 미래의 불확실성에 필연적으로 뒤따르는 난관을 자초하고 있는 것이다. 127 “개인의 가장 중요한 자산은 바로 자기 자신이다. 그러므로 스스로를 관리하고 향상시키기 위해 부단히 노력해야 한다.” 128 “나 역시 고급 양복을 구입한다. 그러나 미래 가치를 생각했을 때 그다지 수지맞는 구매라고는 할 수 없다.” 129 “배우자를 고르는 것처럼 매수할 기업을 고르라. 즉 적극적인 관심과 특정 상대를 배제하지 않는 열린 마음으르 가져야 한다. 그러나 절대 서둘러서는 안 된다.” 129 적절한 때란 언제인가? 바로 일반적인 약세장이나 업종 불황, 기업의 기초 체력에 영향을 주지 않는 일회성 사건, 광적인 투매 현상 등이 이에 해당한다. 초유량 기업의 주식이 엄청나게 싼 가격에 거래되는 떄가 바로 투자할 타이밍이다. 버핏은 그저 인내심을 갖고 이런 상황이 나타나기를 느긋이 기다릴 뿐이다. 물론 이런 상황이 매일, 매달 일어나는 것은 아니다. 심지어 수년 동안 전혀 일어나지 않을 떄도 있다. 그러나 이런 투자 상황은 적어도 버핏을 세계 2위의 부자로 만들어 주기에 충분할 정도로는 주기적으로 발생했다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:8","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"9. Beware the Folly of Greed (일류 투자자의 기질) 132 다른 투자자들이 머뭇머뭇할 때 위대한 기업을 매입하라. 그러나 다른 투자자들이 모두 욕심을 내고 있다면 아무리 위대한 기업이라도 신중하라. 이런 기질을 갖춘 투자자라면 언제 어느 곳을 겨냥하여 방아쇠를 당겨야 할지 스스로 알 것이다. 즉, 다른 모든 투자자들이 겁을 먹고 주식을 헐값에 처분할 떄 방아쇠를 당기고, 다른 투자자들이 너나없이 달려들어 주가가 턱없이 치솟을 떄 총알을 아껴야 한다는 것을 안다. 132 버핏은 지금까지 과도한 주가 상승을 이유로 주식 매수를 완전히 멈춘 적이 두 번 있었다. 첫 번째는 1960년대 후반의 강세장, 두 번째는 1990년대 후반의 강세장이었다. 이를 통해 상당량의 현금을 확보, 시장 붕괴의 철퇴를 맞아 헐값이 된 종목들을 손쉽게 사들일 수 있었다. 134 버핏은 이따금 투자자들이 특정 종목에 과도하게 몰려들어 주가를 높인다는 사실을 잘 알고 있다. 또 어떤 떄는 특정 종목을 과도하게 기피하여 주가를 터무니없이 낮춘다는 사실도 알고 있다. 이런 일이 발생하면 버핏은 투자자들의 두려움과 어리석음에서 비롯된 저평가 종목을 놓치지 않고 이용한다. 탐욕을 조심하라. 그리고 투자자들의 두려움과 어리석음이 투자 기회를 만들도록 내버려 두라. 이것이 바로 현명한 투자자의 방식이다. 138 욕심을 주인으로 섬기는 대신 하인으로 부릴 수 있다면, 욕심은 투자를 할 때 멋지니 동기 부여가 된다. 욕심이 지나치면 행복할 수 없지만, 욕심이 전혀 없어도 부자가 될 수 없기 때문이다. 138 투자의 본질은 이렇게 타인의 주머니를 바라보며 시기와 질투심에 사로잡히는 것이 아니다. 투자는 돈을 벌기 위한 자기만의 열정이 더 중요한 게임이다. 세상에서 가장 행복한 부자는 자신이 하고 싶은 일을 통해 돈을 버는 동시에 다른 이들의 부에는 큰 관심이 없는 사람이다. 부자가 된다는 것이 타인에 대한 시기심으로 괴로워하는 것이라면 무슨 재미가 있을까? 140 다른 사람들이 욕심을 부릴 떄 신중하라. 다른 사람들이 두려워할 때 욕심 부리라. 대부분의 투자자들이 두려워하는 상황은 매수하려는 투자자가 없는 약세장이다. 이들은 약세장에서 기업의 내재 가치에 근거한 장기 경쟁력을 전혀 고려하지 않은 채 보유 주식을 매도한다. 이때가 바로 버핏이 욕심을 부리는 때다. 쏟아지는 우량 종목 중 자신이 오래전부터 사고 싶었던 종목을 모조리 사들이는 것이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:9","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"10. When to Sell, When to Leave(팔아야 할 때, 떠나야 할 때) 142 자신이 구멍에 빠진 것을 알았을 때는 더 이상 땅을 파지 않는 것이 가장 중요하다. 143 일단 우량 종목을 제대로 골랐다면 더 이상 다른 종목에 기웃대지 말라. 우량 종목에 충분한 금액을 투자한 다음에는, 약간의 이익을 위해 서둘러 팔고 다른 종목을 찾기보다, 처음의 결정을 믿고 기다리는 편이 낫다. 이것이 위대한 기업을 알아보는 안목과 적절한 매수 시점의 포착이 중요한 이유다. 만약 훌륭한 장기 경쟁력을 갖추지 못한 기업에 투자했다면 버나드 바루크의 조언을 따르라 사람들이 어마어마한 돈을 번 비결에 대해 묻자 바루크는 장난기 섞인 미소를 떠올리며 이렇게 말했다. “나는 언제나 남들보다 너무 빨리 팔았다.” 144 “다른 투자자들이 주식을 내다 팔 때 나는 사들인다.” 버핏은 다른 투자자들이 주식을 살 때가 아닌 팔 때가 바로 매수의 적기라고 생각한다. 버핏이 매수했던 우량종목들은 모두 좋지 않은 뉴스가 들려올 때 사들인 것이다. 145 “대부분의 투자자들은 다른 투자자들이 관심을 보일 때 따라서 관심을 보인다. 그러나 정작 관심을 가져야 할 때는 아무도 관심을 두지 않을 때다. 한창 인기 있을 때 사들이면 큰돈을 벌기 어렵다.” 현명한 투자자는 인기 있는 종목과 그에 따른 집단 광기를 경계한다. 사람들이 인기 있는 종목에만 달려들어 주가를 터무니없이 치솟게 한다는 사실을 알기 떄문이다. 어떤 기업의 주식을 사고 싶다면 인기가 떨어졌을 때를 노리라. 그때가 가장 유리한 가격에 매수할 수 있고, 또 향후 주가 상승의 폭도 가장 크다. 146 “변화에 좌우되거나 변화에 목숨을 걸어야 하는 기업에는 관심이 없다. 결혼 생활과 마찬가지로 투자 역시 변화보다는 지속성이 더 중요하다.” 147 “리스크는 자신이 하는 일을 제대로 이해하지 못하는 데서 발생한다.” 비인기 종목에 투자할 때 그 기업의 장기적인 경쟁력을 확인할 수 없다면 투자 위험이 높아질 수밖에 없다. 투자 리스크를 줄이는 유일한 길은 자신이 투자하는 기업에 관해 더 잘 아는 것이다. “나는 기업을 매수하는 이유에 대해 종이 한 장을 가득 채우기 전까지는 절대로 매수하지 않는다.” 어떤 기업에 투자하고자 하는 자신만의 이유를 말할 수 없다면 그 기업의 주식은 사면 안 된다. 매수 이유에 대한 자기만의 답변이 가능하다면, 그것을 수차례 시도한다면 당신은 큰돈을 벌 수 있을 것이다. 148 질문은 투자자로 하여금 생각하게 만들고, 질문에 대한 자기만의 답은 생각을 행동으로 옮기게 만든다. 여기서 중요한 것은 올바른 투자 종목을 찾는 것이라기보다 올바른 질문에 대한 올바른 답을 갖고 있느냐 하는 것이다. 149 신규 상장 시 투자 은행은 발행 주식과 채권 가격을 이미 최고 한도로 설정해 놓았기 떄문에 일반 투자자로서는 할인된 가격에 매수할 여지가 전혀 없다. 대신 버핏은 주식이나 채권이 일정 기간 거래된 다음 주식 시장의 근시안적 비관론 떄문에 이들 유가증권의 가격이 본래 가치 이하로 떨어질 때를 기다린다. 투자 은행은 투자자에게 할인 가격을 허용하지 않지만, 주식시장은 투자자에게 할인 가격을 제시할 수 있다. 150 경영자가 갖춰야 할 가장 중요한 덕목은 정직이다. 사람들을 잘못 이끄는 CEO는 자신 역시 잘못된 방향으로 이끌고 말 것이다. 자신의 실수를 솔직하게 인정하는 CEO는 실수를 통해 더 많은 것을 배울 수 있다. 자신의 잘못임에도 다른 사람과 사건을 탓하는 CEO는 향후 다른 중요한 사안에 있어서도 자신에게 거짓말을 할 가능성이 크다. “항상 목표 달성을 외치는 경영자는 언젠가 숫자를 조작하고 싶은 유혹에 빠지기 쉽다.” 151 할 가치가 전혀 없는 일은 잘할 가치 역시 전혀 없다. 본질적인 가치가 낮은 기업은 결국 앞으로 돈을 벌 가망성도 희박하다. 그렇다면 왜 자신에게 전혀 이롭지 않은 기업에 아까운 시간과 열정을 낭비하는가? 153 “기업 실적이 좋고 나쁜 것은 얼마나 노를 잘 젓느냐의 문제라기보다 얼마나 좋은 배를 선택했느냐의 문제다. 물이 샌다는 사실을 알았다면 배를 갈아타는 것이 훨씬 생산적이다.” ","date":"2022-12-15","objectID":"/warren_buffett/:7:10","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"11. Mistakes to Beware Of (치명적 실수) 156 “나는 과거를 돌아보지 않는다. 과거에 매달린다고 달라지는 것은 아무것도 없다. 우리는 과거가 아닌 미래를 향해 나아갈 수 있을 뿐이다.” 156 백 가지 결정 가운데 열 가지 잘못된 결정을 내린 경우, 당신은 열 가지 실수에 집착하는 바람에 새롭게 내려야 할 결정에 충분한 주의를 기울이지 못한다. 157 앞으로도 주식 투자라는 게임을 할 때 당신은 해야 할 일을 빠트리는 실수를 무수히 하게 될 것이다. 그러나 이런 유형의 실수는 그렇게 치명적이지 않다. 치명적인 실수란 하지 말아야 할 행동을 하는 것을 의미하는 말이다. 158 “나는 내 실수에 대해 설명하고 싶다. 이 말은 내가 실수를 완벽하게 이해했다는 의미다.” 158 자신이 하고 있는 일의 의미를 제대로 이해하지 못한다면 왜 그 일을 하려고 하는가? 직관을 따르는 것은 올바른 투자법이 아니다. (머리, 가슴, 배) 159 “실수를 하지 않고는 어떠한 결정도 내릴 수 없다.” 어떤 사람은 결정을 잘 내리고, 또 어떤 사람은 그렇지 못하다. 전자는 사람들을 이끄는 사람이 되고, 후자는 리더가 이끄는 대로 따라가는 사람이 된다. 159 의사 결정을 할 때 중요한 것은 현재의 실수에 발목 잡히지 않고 다음번 의사 결정으로 무리 없이 넘어갈 수 있느냐 하는 점이다. 결정을 내리지 못하고 미적대는 것은 아무런 결정을 내리지 않기로 결정한 것과 다름없다. 이런 일이 반복되다 보면 미결 사항이 산처럼 쌓이고, 아무 일도 진행되지 않는다. 당연히 회사는 더 이상 수익을 내지 못한다. “다른 엔지니어와 다른 점이 무엇이냐는 질문에 자신의 실수를, 실험에서 빠지지 않는 당연한 일부로 인정하고 받아들인 점이라고 대답했다. Cray Supercomputer를 설계한 세계적인 컴퓨터 설계자 Seymour Cray ","date":"2022-12-15","objectID":"/warren_buffett/:7:11","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"12. Your Circle of Competence (투자 대상 범위) 162 “합리적 이성을 바탕으로 투자 결정을 내려야 한다. 잘 모른다면 투자하지 말라.” 164 “어떤 투자 아이디어를 이해했다면 그것을 다른 사람들이 이해하도록 설명할 수 있어야 한다.” 다른 사람에게 설명할 수 없다면 제대로 이해하지 못한 것이다. 버핏은 투자 대상에 관해 잘 알지 못하면 투자하지 않았다. 설명할 수 없다면 함부로 덤비지 말라. 167 “나의 투자 방법은 아주 간단하다. 기본적인 경쟁력을 갖춘 기업, 그리고 정직하고 유능한 경영자가 운영하는 우량 기업을 골라 적정 가격에 매수하는 것이다. 이외에 내가 달리 할 일은 없다.” 167 기업의 기초 체력이 튼실한지 아닌지 알려면 해당 사업 분야에 관해 잘 알고 있어야 한다. 정직하고 유능한 경영자가 운영하는 기업인지 알고 싶을 때에도 역시 그 사업 분야에 대한 지식이 있어야 한다. 적정 가격인지 아닌지를 판단할 때 역시 해당 사업 분야에 관해 알아야 한다. 기업이나 사업에 관한 이러한 기본 지식과 정보야 말로 버핏을 성공으로 이끈 비결이라 할 수 있다. 168 “나의 능력 범위를 벗어난 곳에 그럴 듯환 먹잇감이 있다고 해서 무리하게 접근하지는 않는다. 그저 나의 능력의 범위 안에 먹잇감이 나타나기를 기다릴 뿐이다. 버핏은 자신의 능력 범위 밖에 있는 기업이라고 판단되면 아예 눈길조차 주지 않는다. 버핏은 아무도 주목하지 않는 기업을 선택해 인수하는 방식을 취한다고 했다. 이런 선택이 가능하려면 해당 기업의 내재적인 경제 가치를 잘 알아야 했다. 그래야만 그 기업의 미래를 예측할 수 있기 때문이다. 그 기업이나 사업 분야에 관해 잘 알지 못하면 이러한 예측과 선택이 불가능하다. 171 앞날을 예측하는 것이 어렵다는 사실은, 버핏이 오랜 세월을 두고 그 실효성이 입증된 제품에만 관심을 두는 원인이기도 하다. 실효성이 입증된 제품의 경우, 적어도 15년 정도는 앞을 내다볼 수 있다. (면도기, 껌 기타 등등) 버핏은 앞길을 분명하게 예측할 수 있는 제품만 선호한다. 이러한 제품이라면 단기적 관점이 주를 이루는 주식 시장이 그 가치를 얼마로 측정하든 관계없이 사업의 장기적 경제 가치를 가늠할 수 있다. 175 “투자자를 녹초로 만드는 것은 경제 상황이 아니라 투자자 자신이다.” 다른 사람들이 ‘파티장’을 떠나면 안절부절못하다가 헐값에 주식을 처분하고 그 사람들을 다시 따라가다. 이성적인 판단은 간데없고, 감정에만 치우친 결정을 내리는 것이다. 일확천금을 꿈꾸며 근시안적으로 접근하기 때문에 기업의 장기적인 경제 가치 따위는 아예 안중에도 없다. (💡 10년뒤의 위험, 10년뒤의 가능성을 투자한다. ) ","date":"2022-12-15","objectID":"/warren_buffett/:7:12","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"13. The Price You Pay (가격 결정) 178 “가치가 아닌 가격에서 투자 판단의 실마리를 구하는 것도 나름대로의 일리가 있다. 가격은 당신이 지불하는 액수이고, 가치는 거래를 통해 얻는 무엇이다.” 지불 규모가 너무 크면 당연히 가치는 줄어든다. 반면 지불 규모가 작을수록 가치는 늘어난다. 요컨대 투자의 비결은 항상 낮은 가격을 지불하고 높은 가치를 얻는 것이다. 179 “한 번 오르면 반드시 떨어지는 때가 있다고 하지만, 예외도 있는 법이다.” (버크셔 해서웨이) 대단하긴 하다. 22년 기준으로 모든 기업이 떨어질 때, 신재생 에너지 흐름을 타서 또 올랐다. 한편으로는 버핏의 벌어들인 자산에 대한 신뢰감과 버핏의 원활한 현금 덕분 일수도 있다고 보지만 수영장 물이 다 빠져나가봐야 알 것 같다. 180 “주식 시장은 주식의 가격을 결정할 뿐이다. 주식 시장은 당신에게 봉사하기 위해 있는 것이지, 당신을 가르치기 위해 있는 것이 아니다.” 180 버핏에게 주식 시장은 단기적 경제 전망에 따른 주가 형성을 참고하는 장일 뿐이다. 단기적 접근법을 따르게 되면 짧은 주기로 주가 변동이 이루어지고, 장기적인 경제 가치와는 무관하게 주가가 형성된다. 이러한 단기적 변동으로 인해 장기적 경제 가치 이하로 혹은 이상으로 주가가 형성되기도 한다. 대체로 주식 시장은 종목의 가치를 과대평가하는 경향이 있다. 180 버핏은 주가가 기업의 장기적 가치 이하로 형성될 때 주식을 매수하고, 가치가 과대 평가됐던 수준으로 주가가 오르기를 기다린다. 우량 기업의 주식을 낮은 가격에 매수한 경우에는 사내 유보 이익이 장기적인 기업의 내재 가치를 증가시킬 것이다. 그리고 이는 결국 주가 상승으로 이어질 것이다. 투자자는 그때까지 주식을 보유해야 한다. 우량 기업이라면, 언젠가는 주식 시장에서 제대로 평가받지 못했던 장기적 가치가 드러나게 마련이다. 그러므로 근시안적인 주식 시장의 의견에 상관하지 말라. 기업의 장기적 경제 가치를 기준으로 매수 대상과 시점을 결정하라. 무엇을 언제 살지는 주식 시장이 아닌 바로 투자자 자신이 결정해야 함을 잊지 말라. 182 “처음에는 기업의 기초 경제 지표에 따라 주가가 결정된다. 그러나 일정 시점이 되면 투기가 가격을 결정한다.” 현명한 투자자는 기업의 기초 경제 지표가 자신에게 유리하게 나타날 때를 기준으로 매수를 결정한다. 그래야 주가가 하락하더라도 안전 마진을 확보할 수 있다. 시간 역시 기초 경제 지표의 친구다. 즉 시간이 경과하면 결국에는 장기적인 경제 가치에 따라 가격 조정이 일어난다. 그러다 투기가 개입되면 기초 경제 지표는 안중에 없어지고, 가격이 급등하면서 매수를 촉진하는 단계로 접어든다. 멍청한 사람은 현명한 사람이 하던 일을 뒤늦게 따라한다. 즉 현명한 투자자는 투기가 개입되는 시점이 언제인지 알고, 적절한 시기에 빠져 나올 줄도 안다. 그러나 미련한 투자자는 장기적 기초 경제가치가 반영된 가격에 투기적 수요가 더해져 주가가 한껏 치솟았을 때 매수에 들어간다. 186 “모든 거품에는 그것을 터뜨릴 핀이 항상 도사리고 있다. 결국 핀은 거품을 터뜨리고, 초보 투자자들은 새로운 교훈을 얻게 된다. 그러나 그 교훈은 아주 오래된 것이다.” 너도나도 주식에 달려들면 투기 열풍이 조성된다. 특정 종목의 주가가 오른다 싶으면 재빨리 이 주식을 매수하여 쉽게 돈을 벌려고 한다. 이런 투기 열풍은 약 30년에 한번씩 찾아온다. 보통은 새로운 기술이 개발됐을 때 이런 현상이 나타나기 쉽다. 지난 100여년을 돌아보면 라디오, 항공사, 자동차, 컴퓨터, 생명 공학, 인터넷 등이 등장했을 떄가 그랬다. 투기적 강세장의 주가에는 기업의 기초 경제 가치가 아니라 도박장의 광기가 반영된다. 버핏은 초창기 부터 투기적 강세장은 애써 외면했다. 그가 보기에 투기적 강세장에서 형성된 높은 주가는, 결코 발생할 것 같지 않은 미래 수익이 반영된 결과다. 미래 수익이 실현되지 않고, 주가가 오르리라는 기대도 사라지면 중력의 법칙에 따라 주가는 무서운 속도로 급전직하한다. 187 “나는 주식 시장을 통해 돈을 벌어 보겠다고 생각한 적이 없다. 내일 당장 시장이 문을 닫아 향후 5년 동안 개장하지 않는다는 가정 하에 투자한다.” 버핏은 주식 자체가 아니라 기업을 인수한다는 생각으로 투자를 한다. 187 버핏은 기본적으로 주식 시장을, 일확천금을 획득하여 ‘올해의 뮤추얼 펀드 상’ 이라는 타이틀을 거머쥐겠다는 욕망에 사로잡혀 기업의 장기적 경제 가치는 무시한 채 근시안적으로 접근하는 조직으로 본다. 그래서 주식 시장을 자신의 주 활동 무대로 삼지 않는다. 적절한 기업의 주식을 적정 가격에 매수하기만 하면 그것으로 족하다. 이제 이 우량 기업의 가치가 오르기만 기다리면 된다. 주가에 기업의 내재 가치가 반영됨에 따라 투자자의 주머니는 두둑해진다. 여기서 중요한 점은 주식 시장이 향후 5년 동안 폐쇄되더라도 기업의 내재 가치는 지속적으로 상승한다는 점이다. 주식 시장은 단기간의 기업 가치를 바탕으로 형성된 가격표를 제공하는 장소에 불과하다. 매수한 주식을 5년 동안 보유한다면 그 이전, 즉 1년에서 5년 사이에 주식 시장에서 주가가 어떻게 형성되는지를 신경 쓸 이유가 없다. 주식 시장의 주가가 의미 있는 떄는 보유 주식을 매도하는 시점뿐이다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:13","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"14. Long-Term Economic Value is the Secret( 버핏이 욕심 부릴 때 ) 190 “주식 시장은 스트라이크 선언이 없는 야구 경기장과 같아서 날아오는 공마다 방망이를 휘두를 필요는 없다. 자신이 가장 좋아하는 공만 노리라.” 이렇게 하다 보니 단기적인 주가 변동에만 관심이 몰려 기업의 장기적 경제 가치와 무관하게 주가가 형성되어 버린다. 191 그러므로 주식투자로 큰돈을 벌고 싶다면 전문 펀드 매니저를 멀리하라. 그리고 그들이 장기적인 가격을 예측할 때 저지르는 실수를 이용하라. 그렇게 하기 위해서는 이들 펀드 매니저들의 근시안적인 시각을 십분 활용할 수 있어야 한다. 192 “역사를 통해 배울 수 있는 사실은 아이러니하게도 사람들은 역사를 통해 아무것도 배우지 않는다는 사실이다.” 단기적 주가 변동을 통해 큰돈을 벌겠다는 생각으로 높은 가격에 주식을 매수하는 일을 끊임없이 반복하는 것, 투자자들은 주식 시장에서 똑같은 실수를 계속 반복한다. 투자자라면 누구나 행하는 이 공통된 실수가, 사실은 주식 시장을 움직이는 동력으로 작용하고 있다. 192 장기적 경제 가치에 비해 과도하게 높이 형성된 주가는 (주로 강세장에서 많이 발생하는 현상이다) 다양한 기대 심리가 사라지고 투자 상황의 변화가 일어나면 폭락할 가능성이 농후하다는 사실이다. 강세장에서 과도하게 높이 형성된 가격에 매수한 투자자들은 갑작스런 주가 폭락을 견디지 못하고 빈털터리가 되고 만다. 192 그래서 버핏은 주가가 지나치게 높게 형성됐다 싶으면 시장에서 멀찌감치 떨어져 있다가, 주가가 하락하기 시작하면 그제야 매수에 관심을 보이고, 가격이 충분히 떨어졌다 싶을 때 그리고 그 기업이 올바른 기업일 때 비로소 행동에 나선다. 194 “시세 변동을 적이 아닌 친구로 생각하라. 변동의 물결에 휩쓸리기 보다 그 어리석음에서 이익을 창출하라.” 194 주식 시장은 기업의 장기적 경제 가치는 무시하고 단기적 전망에만 의거해 거래하는 무지한 야수와 같다. 단기적 전망이 좋지 않다는 것은 곧 주가가 급락할 수 있음을 의미한다. 그 과정에서 기업의 장기적인 잠재력은 철저히 무시된다. 바보들이 달려들어 주가를 올리고 있을 때는 관망세를 취하다가 바보들이 모두 물러나고 주가가 하락하기 시작할 때를 노리라. (1973, 1987년) 198 “기업의 장기적 가치를 보고 주식을 구매하는 투자자에게 시장의 불확실성은 오히려 좋은 친구다.” 결국 실제 가치에 맞게 주가를 끌어올려 줄 것은 장기적 경제 가치이기 때문이다. 199 “월스트리트의 전문가들에게 기업과 주식은 단지 거래를 위한 재료일 뿐이다.” 자산 관리 전문가들은 사업적 관점에서 기업과 주식을 바라보지 않는다. 단지 자신이 베팅하는 화면상의 숫자로 볼 뿐이다. 199 이런 카지노와 같은 성격은 주식 시장이 처음 생겼을 때부터 있었던 특성이다. 사람들은 기본적으로 내기를 즐긴다. 별다른 이유가 있어서가 아니다. 단지 내기가 재미있기 때문이다. 전문가들은 주식이라는 미끼로 투자자들에게서 엄청난 돈을 받은 다음, 이를 걸고 내기를 한다. 주가가 심하게 요동치는 것은 바로 전문가들의 도박성향 때문이다. 201 “아무리 재능이 뛰어나고 많이 노력한다 해도 결과를 얻기까지는 어느 정도 시간이 걸린다. 아홉 명의 여자를 임신시켰다고 해서 한달 만에 아이를 얻을 수는 없는 노릇이다.” 201 기업의 가치가 형성되는 데는 시간이 걸린다. 아이가 자라 어른이 되는 데 일정한 시간이 필요하듯 한 기업의 가치가 신장되는 데에도 시간이 필요하다. 하지만 처음부터 경제 가치가 높은 우량 기업을 매수한다면 투자자가 얻을 수 있는 가치는 놀랄 정도로 높아질 것이다. 206 “오늘의 투자자는 어제의 성장 실적에서 수익을 내는 것이 아니다.” 206 지금 투자자가 거두는 수익의 근원은 과거의 성장 실적이 아니라 미래의 성장 실적이다. 오늘 내가 어느 기업을 사들여 이익을 보았다면, 그것은 오로지 그 회사의 성장 가능성에서 나온 것임을 알아야 한다. 과거는 결코 주식 시장의 수익 원천이 될 수 없다. 206 이제 남은 문제는 해당 기업이 성장 가능성이 있는가, 있다면 나는 그에 대해 얼마를 지불할 의사가 있는가 하는 점이다. 지속적 경쟁 우위를 지닌 제품을 생산하며 성장 가능성도 있는 기업이지만 매수 가격이 너무 높다면 향후 당신의 투자 수익은 줄어들 수 밖에 없다. 이는 당신의 연간 수익률 또한 줄어들게 만드는 결과로 이어진다. 당신이라면 연간 100만 달러의 수익밖에 내지 못하는 기업을 1억 달러를 주고 사들일 것인가? 아마 그렇지는 않을 것이다. 하지만 연간 2000만 달러의 수익을 내는 기업이라면 기꺼이 1억 달러를 투자할 것이다. 문제는 양극단의 중간에 위치한 경우다. 그러나 만약 당신이 버핏처럼 되고자 한다면 판단이 쉽지 않은 어정쩡한 중간 조건도 거부하라. 오로지 더 쉬운 조건, 즉 싼 경우에만 거래하라. 208 “주식 시장이 효율적이었다면 나는 아마 거리에서 구걸하는 신세를 면치 못했을 것이다.” (효율적 시장 가설, 모든 정보가 대중들에게 똑같이 유통되어, 그날의 주식 가치가 정확하게 주가에 반영된다는 가설이다.) 208 단기적 시각에서 보면 주식 시장은 매우 효율적이다. 이런 단기적 효율성은 장기적 관점으로 볼 때 주식의 가격을 잘못 매기는 비효율을 만들어 낸다. 결국 장기적 관점에서 볼 때 주식 시장은 비효율적이라는 의미다. (1973년) 여기서 놓치지 말아야 할 사실은 주식 시장의 단기적 효율성이 종종 장기적인 비효율을 낳는다는 점이다. 당신은 이런 주식 시장의 장기적 비효율을 이용하여 큰돈을 벌 수 있다. 210 “주식 시장은 다른 사람들이 어떤 어리석은 행동을 하는지 알려 주는 참고 자료일 뿐이다.” 버핏은 주식 시장의 향방에는 조금도 관심이 없다. 그는 다만 대형 뮤추얼 펀드를 운용하는 근시안적 시각의 주식 투기꾼들이 장기적 관점에서 볼 때 어리석은 행동을 하고 있는지 아닌지 확인하는 데만 관심이 있다. 211 모멘텀 투자 전략 (Momentum investing) 주가가 급등하면 주식을 사고, 주가가 급락하면 주식을 판다. 회사 수익이 조금만 떨어져도 주식을 팔고, 수익이 조금만 올라도 주식을 산다. 전쟁이 일어날 기미만 보이면 주식을 팔고, 종전의 서광이 약간이라도 비치면 주식을 산다. 212 “투자란 주식 조각을 사는 것이 아니라 기업의 일부를 사서 그 기업이 성장하는 과정을 지켜보는 행위다. 반면, 투기란 단기적 주가 향방에 목을 매고 주사위를 던치는 행위다. 투자는 투자자를 부자로 만들어 주지만, 투기는 주사위를 굴리는 펀드 매니저를 부자로 만들어준다. (죄송하지만, 나는 선한 가치관을 가지지 못한 지적 끌림을 느끼는 기업은 단기적으로 투자할 것이다. 디즈니, 텐센트 등의 기업이 그렇다. IP) 213 “우리는 주식 시장과 금리, 기업 활동 등이 향후 어떻게 전개될지 조금도 알 수 없다. 과거에도 그랬고 지금도 그러하며 미래에도 마찬가지다. 213 다른 투자자들이 모두 주식 시장의 시세 동향과 내년의 금리 변동에만 관심을 가졌기 때문이다. 시세 동향과 금리 변동 추이에만 관심을 두는 투자자는 결국 미국 연방 준비은행에서 발표하는 약간의 금리 인상 뉴스에도 장기적인 경제 가치가 탁월한 우량 기업의 주식을 내다 파는 어리석은 행동을 하고 만다. 이처럼 민감한 투자자들이 어리석은 이유 때문에 (나같이 예민한 사람들) 우량 기업의 주식을 대량으로 내다 팔 때를 기다린다. 때가 오면 버핏은 그 주식들을 가만히 주워 담는다. 213 역발상 투자 전략(selective contrarian investment strategy): 부자가 되고 싶다면 주식 시장이 어떻게 될 것이라든가, 연방 준비 은행이 금리를 얼마나 올릴 것인가 등에 관한 갖가지 예측이나 장담에 귀를 닫으라. 대신 지속적 경쟁 우위를 지닌 기업의 장기적 경제 가치를 판단하는 데만 집중하라. 그런 다음 얼마에 주식이 거래되고 있는지 살피라. 장기적 기업 가치에 비해 주가가 낮게 형성됐다고 판단되면 주식을 사라. 주가가 가치보다 높게 형성되었다면 기다리라. 215 “부자가 된다고 해서 그 사람의 본질까지 바뀌는 것은 아니다. 돈을 벌기 전에 바보였다면 돈","date":"2022-12-15","objectID":"/warren_buffett/:7:14","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["book","wisdom"],"content":"Cross my mind 문득 든 생각. 워렌 버핏은 보수적이다. 내가 욕심에 눈이 멀었을 때, 정신을 차릴 수 있게 해주는 할아버지다. 그럼에도 나와 워렌은 다르다. 젊었을 때는 젊은 사람의 방식이 있고, 늙었을 때는 늙은 사람들의 방식이 있다. 이 세상은 젊은이와 늙은이가 함께 살며, 그때와 지금이 다르고 지금이 미래와 다르다. 다만 원칙은 같다. 왜냐하면 늙은 사람들로 부터 젊은 사람들이 태어나고, 이전 세대로 부터 다음 세대가 태어나기 때문이다. 말은 행동보다 가볍다. 행동했던 노인들의 지혜가 젊은이의 지혜보다 대부분 더 옳다. 예수님, 석가모니가 조금 특이했던 것이다. 그럼에도 나는 코카콜라를 좋아하지 않는다. 나는 워렌이 아니다. 나를 지켜야 한다. 늙은 사람들의 신념은 흔들리지 않지만, 고정관념 또한 그 만큼 흔들리지 않는다. 젊은 사람들의 신념은 흔들리기 쉽지만 고정관념 또한 쉽게 흔들릴 수 있다. 균형을 맞춰야 옳다. 고정관념으로 세상을 바라보면 젊어질 수 없고 즉 미래를 미워하고, 반대로 내 신념만 고집한다면 늙어진다 즉 과거를 미워한다. 과거를 미워하면, 어른들이 경험한 시간 만큼을 다시 내가 시간을 주고 실수해야 하며, 미래를 미워하게 되면, 실수를 하지 못해 노인들보다 더 지혜롭게 살 수 없다. 둘 모두 균형을 맞춰야 옳다. 나는 어린이들을 사랑하며 노인들을 공경하고 싶다. 어린이와 노인들은 모두 똑같은 스승이다. 어린이에게는 행동을 배우고, 노인들에게는 실수를 배운다. ","date":"2022-12-15","objectID":"/warren_buffett/:7:15","tags":["book","money"],"title":"Warren buffett's word of wisdom","uri":"/warren_buffett/"},{"categories":["HowTo"],"content":"Set up a Cold wallet especially nano s plus","date":"2022-12-05","objectID":"/ledger/","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"How to setup my cold wallet (nano s plus). 거래소를 잘 신뢰하지 못하던 차에, 2022년 FTX 사태가 터져서 겸사겸사 Cold wallet을 구매하였습니다. 미국에 지내는 동안 tax포함 약 $85.00에 Nano S plus를 구입하여 세팅하는 과정을 정리합니다. 또한 앞으로 거래 시 DeX(Decentralized exchange, P2P방식의 분산형 암호화폐 거래소)의 특성을 가진 거래소에서 거래를 할 생각이며, 편의를 위할 때는 Ledger 인프라를 사용할 것 같다. ","date":"2022-12-05","objectID":"/ledger/:0:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"TL;DR PIN CODE Recovery letters (24 words) Install Ledger Live (opt) Update firmware. Install coin apps to nano device. Add your accounts Water proof 현재 까지 나온 Ledger사의 Cold wallet들은 방수를 지원하지 않는다. 물론 악세사리로, 방수케이스를 판매하지만 cold wallet 자체는 방수가 되지 않기 때문에 변기에 빠뜨리거나 커피를 쏟는다면 기기가 고장날 수 있다. 다만 Seed phrase(24개의 words, recovery letters)만 기억하고 있다면, 이를 통해 새로운 nano 하드웨어를 구매하여 지갑을 다시 복구할 수 있다. seed phrase ","date":"2022-12-05","objectID":"/ledger/:1:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"1. Cold Wallet Background What you should basically know about. My crypto assets are stored on the blockchain (p2p, network). I need a private key to access and manage them. My private key is stored within my Nano Your Nano works as a “cold storage” wallet. This means that it never exposes my private key online even when using the app. Validate transactions: Ledger live allows you to buy, sell, manage, exchange and earn crypto while remaining protected. You will validate every crypto transaction with your Nano. ","date":"2022-12-05","objectID":"/ledger/:2:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"2. How to set Nano S plus in Desktop? With Ledger live desktop app. ","date":"2022-12-05","objectID":"/ledger/:3:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"1. PIN CODE Nano S plus에서 4-8자리의 숫자 PIN코드를 설정합니다. PIN code를 세번 틀리게 될 경우, nano device는 reset됩니다. PIN code Your PIN code is the first layer of security. It physically secures access to your private key and your Nano. Your PIN code must be 4 to 8 digits long. Don’t share it. You can change your PIN code if needed. Three wrong PIN code entries in a row will reset the device. Never store your PIN code on a computer or phone. ","date":"2022-12-05","objectID":"/ledger/:3:1","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"2. Recovery letters (24 words) 준비물: 안전하게 24 영어단어들을 적어둘 공간. Nano S plus에서 보여주는 24개의 단어 리스트 (recovery letters)를 확인하며, 이를 안전한 곳에 적어둡니다. Recovery phrase Your recovery phrase is a secret list of 24 words that backs up your private keys. Your Nano generate a unique recovery phrase. Ledger does not keep a copy of it. If you lose this recovery phrase, You will not be able to access your crypto in case You lose access to your Nano. How does recovery phrase work? Recovery phrase works like a unique master key. Your ledger device uses it to calculate private keys for every crypto asset you own. To restore access to your crypto, any wallet can calculate the same private keys from your recovery phrase. What Happens if I lose Access To My Nano? To restore access to your crypto, any wallet can calculate the same private keys from your recovery phrase. 1. Get a new hardware wallet. 2. Select “Restore recovery phrase on a new device” in the Ledger app. 3. Enter your recovery phrase on your new device to restore access to your crypto. 가장 중요하게 기억할 것 When I connect my Nano to the ledger app, my private key is STILL OFFLINE! ","date":"2022-12-05","objectID":"/ledger/:3:2","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"3. Install Ledger Live Ledger Live desktop앱을 다운로드합니다. Download ledger live link ","date":"2022-12-05","objectID":"/ledger/:3:3","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"4. (opt) Update firmware. Nano S plus의 firmware를 업데이트 합니다. firmware? 하드웨어 장치에 들어가는 소프트웨어의 일종. Ledger의 경우 버그 픽스 그리고 UI변경 때문에 하드웨어 펌웨어를 진행할 것으로 보인다. ","date":"2022-12-05","objectID":"/ledger/:3:4","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"5. Install coin apps to nano device. 사용하고 싶은 종류의 코인들의 sw 어플리케이션을 다운로드합니다. ","date":"2022-12-05","objectID":"/ledger/:3:5","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"6. Add your accounts This section will be continued with my 2023 investment scenario. ","date":"2022-12-05","objectID":"/ledger/:3:6","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["HowTo"],"content":"3. How to setup Nano S plus in Phone? my phone: Galaxy (Android) Install Ledger Live app from google playstore link . Physically connect Nano Device and Phone with C type usb cable. Type Pin code. Done ","date":"2022-12-05","objectID":"/ledger/:4:0","tags":["money","crypto"],"title":"Cold Wallet with Ledger","uri":"/ledger/"},{"categories":["plan"],"content":"2023년부터 진행할 투자 시나리오와 투자 원칙들을 정리 합니다. ","date":"2022-12-04","objectID":"/2023_investments/:0:0","tags":["plan"],"title":"(WIP) 2023 투자계획","uri":"/2023_investments/"},{"categories":["plan"],"content":"1. scenario ","date":"2022-12-04","objectID":"/2023_investments/:1:0","tags":["plan"],"title":"(WIP) 2023 투자계획","uri":"/2023_investments/"},{"categories":["plan"],"content":"2. principles ","date":"2022-12-04","objectID":"/2023_investments/:2:0","tags":["plan"],"title":"(WIP) 2023 투자계획","uri":"/2023_investments/"},{"categories":["plan"],"content":"3. mind ","date":"2022-12-04","objectID":"/2023_investments/:3:0","tags":["plan"],"title":"(WIP) 2023 투자계획","uri":"/2023_investments/"},{"categories":["wisdom"],"content":"After reading the Book of Proverbs, I write down some phrases that touched my heart.","date":"2022-11-30","objectID":"/proverbs/","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"After reading the Book of Proverbs, write down some phrases that touched my heart. ","date":"2022-11-30","objectID":"/proverbs/:0:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Book of Proverbs The Book of Proverbs (Hebrew: מִשְלֵי, Mīšlē, “Proverbs of Solomon”) is a book in the third section (called Ketuvim) of the Hebrew Bible. Tanakh, Hebrew Bible Book of Proverbs는 타나크(히브리어 성경)안에 들어 있으며, 기원전 1500~400년대 바빌로니아, 팔레스티나, 이집트 등의 지역에서 전해지던 이야기들이 기록된 경전들이 오랜 세월을 거쳐 한권의 책으로 만들어져 전해져 왔다. 또한 타나크는 아래의 4종교의 경전으로도 인정되어 유대교 카톨릭 기독교 이슬람교 학계에서는 중립적으로 히브리 성경이라는 단어를 사용하기도 한다. Proverbs is not merely an anthology but a “collection of collections” relating to a pattern of life which lasted for more than a millennium. Although most of this book identifies Solomon as its author, not all of it is attributed to him. This book itself also emphasizes that this book is a collection of proverbs of many people. 31장으로 구성된 이유 Book of Proverbs는 의도적으로 31장으로 구성되어있다라고 보는 학자들도 있는데, 이유는 매일 1장씩 읽기 편하도록 히스기야 시대에 신하들이 편찬했다는 주장이다. 이 주장을 굳이 믿지 않더라도, 실제로 일자별로 읽어보니 아침을 좀 더 고요하게 마음으로 맞이할 수 있었던 것 같다. ","date":"2022-11-30","objectID":"/proverbs/:1:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Phrases Phrases that touched my heart, with NIV version. ","date":"2022-11-30","objectID":"/proverbs/:2:0","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 1 Purpose and Theme (7) The fear of the LORD is the beginning of knowledge, but fools despise wisdom and instruction. Warning Against the Invitation of Sinful Men (10) My son, if sinful men entice you, do not give in to them. Wisdom’s Rebuke (31-33) they will eat the fruit of their ways and be filled with the fruit of their schemes. For the waywardness of the simple will kill them, and the complacency of fools will destroy them; but whoever listens to me will live in safety and be at ease, without fear of harm. ","date":"2022-11-30","objectID":"/proverbs/:2:1","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 2 Moral Benefits of Wisdom (1-5) My son, if you accept my words and store up my commands within you turning your ear to wisdom and applying your heart to understanding indeed, if you call out for insight and cry aloud for understanding, and if you look for it as for silver and search for it as for hidden treasure, then you will understand the fear of the Lord and find the knowledge of God. (7-9) He holds success in store for the upright, he is a shield to those whose walk is blameless, for he guards the course of the just and protects the way of his faithful ones. Then you will understand what is right and just and fair–every good path. ","date":"2022-11-30","objectID":"/proverbs/:2:2","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 3 Wisdom Bestows Well-Being (9) Honor the Lord with your wealth, with the firstfruits of all your crops; (12) because the Lord disciplines those he loves, as a father the son he delights in. (21) My son, do not let wisdom and understanding out of your sight, preserve sound judgment and discretion; (25-26) Have no fear of sudden disaster or of the ruin that overtakes the wicked, for the Lord will be at your side and will keep your foot from being snared. ","date":"2022-11-30","objectID":"/proverbs/:2:3","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 4 Get Wisdom at Any Cost (7) The beginning of wisdom is this: Get wisdom. Though it cost all you have, get understanding. (12-13) When you walk, your steps will not be hampered; when you run, you will not stumble. Hold on to instruction, do not let it go; guard it well, for it is your life. (16-17) For they cannot rest until they do evil; they are robbed of sleep till they make someone stumble. They eat the bread of wickedness and drink the wine of violence. (23) Above all else, guard your heart, for everything you do flows from it. (26) Give careful thought to the paths for your feet and be steadfast in all your ways. ","date":"2022-11-30","objectID":"/proverbs/:2:4","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 5 Warning Against Adultery (6) She gives no thought to the way of life; her paths wander aimlessly, but she does not know it. (7) Now then, my sons, listen to me; do not turn aside from what I say. (8) Keep to a path far from her, do not go near the door of her house, (18-19) May your fountain be blessed, and may you rejoice in the wife of your youth. A loving doe, a graceful deer may her breasts satisfy you always, may you ever be intoxicated with her love. ","date":"2022-11-30","objectID":"/proverbs/:2:5","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 6 Warnings Against Folly (8) yet it stores its provisions in summer and gathers its food at harvest. (16-19) There are six things the Lord hates, seven that are detestable to him: haughty eyes, a lying tongue, hands that shed innocent blood, a heart that devises wicked schemes, feet that are quick to rush into evil, a false witness who pours out lies and a person who stirs up conflict in the community. (26) For a prostitute can be had for a loaf of bread, but another man’s wife preys on your very life. (29) So is he who sleeps with another man’s wife; no one who touches her will go unpunished. ","date":"2022-11-30","objectID":"/proverbs/:2:6","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 7 Warning Against the Adulterous Woman (4) Say to wisdom, “You are my sister,” and to insight, “You are my relative.” ","date":"2022-11-30","objectID":"/proverbs/:2:7","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 8 Wisdom’s Call (6-7) Listen, for I have trustworthy things to say; I open my lips to speak what is right. My mouth speaks what is true, for my lips detest wickedness. (12-13) “I, wisdom, dwell together with prudence; I possess knowledge and discretion. To fear the Lord is to hate evil; I hate pride and arrogance, evil behavior and perverse speech. (17-18) I love those who love me, and those who seek me find me. With me are riches and honor, enduring wealth and prosperity. (22-23) “The Lord brought me forth as the first of his works, before his deeds of old; I was formed long ages ago, at the very beginning, when the world came to be. (30-31) Then I was constantly at his side. I was filled with delight day after day, rejoicing always in his presence, rejoicing in his whole world and delighting in mankind. (34-36) Blessed are those who listen to me, watching daily at my doors, waiting at my doorway. For those who find me find life and receive favor from the Lord. But those who fail to find me harm themselves; all who hate me love death.” ","date":"2022-11-30","objectID":"/proverbs/:2:8","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 9 Invitations of Wisdom and Folly (7-8) Whoever corrects a mocker invites insults; whoever rebukes the wicked incurs abuse. Do not rebuke mockers or they will hate you; rebuke the wise and they will love you. (12) If you are wise, your wisdom will reward you; if you are a mocker, you alone will suffer. ","date":"2022-11-30","objectID":"/proverbs/:2:9","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 10 Proverbs of Solomon (3) The Lord does not let the righteous go hungry, but he thwarts the craving of the wicked. (8) The wise in heart accept commands, but a chattering fool comes to ruin. (12-13) Hatred stirs up conflict, but love covers over all wrongs. Wisdom is found on the lips of the discerning, but a rod is for the back of one who has no sense. (16-19) The wages of the righteous is life, but the earnings of the wicked are sin and death. Whoever heeds discipline shows the way to life, but whoever ignores correction leads others astray. Whoever conceals hatred with lying lips and spreads slander is a fool. Sin is not ended by multiplying words, but the prudent hold their tongues. (22) The blessing of the Lord brings wealth, without painful toil for it. (32) The lips of the righteous know what finds favor, but the mouth of the wicked only what is perverse. ","date":"2022-11-30","objectID":"/proverbs/:2:10","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 11 (2) When pride comes, then comes disgrace, but with humility comes wisdom. (10) When the righteous prosper, the city rejoices; when the wicked perish, there are shouts of joy. (13) A gossip betrays a confidence, but a trustworthy person keeps a secret. (16) A kindhearted woman gains honor, but ruthless men gain only wealth. (19) Truly the righteous attain life, but whoever pursues evil finds death. (21) Be sure of this: The wicked will not go unpunished, but those who are righteous will go free. (24-26) One person gives freely, yet gains even more; another withholds unduly, but comes to poverty. A generous person will prosper; whoever refreshes others will be refreshed. People curse the one who hoards grain, but they pray God’s blessing on the one who is willing to sell. (28) Those who trust in their riches will fall, but the righteous will thrive like a green leaf. (30) The fruit of the righteous is a tree of life, and the one who is wise saves lives. ","date":"2022-11-30","objectID":"/proverbs/:2:11","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 12 (9) Better to be a nobody and yet have a servant than pretend to be somebody and have no food. (12-14) he wicked desire the stronghold of evildoers, but the root of the righteous endures. Evildoers are trapped by their sinful talk, and so the innocent escape trouble. From the fruit of their lips people are filled with good things, and the work of their hands brings them reward. (16) Fools show their annoyance at once, but the prudent overlook an insult. (24-25) Diligent hands will rule, but laziness ends in forced labor. Anxiety weighs down the heart, but a kind word cheers it up. (28) In the way of righteousness there is life; along that path is immortality. ","date":"2022-11-30","objectID":"/proverbs/:2:12","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 13 (8) A person’s riches may ransom their life, but the poor cannot respond to threatening rebukes. (16) All who are prudent act with knowledge, but fools expose their folly. (25) The righteous eat to their hearts’ content, but the stomach of the wicked goes hungry. ","date":"2022-11-30","objectID":"/proverbs/:2:13","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 14 (3-4) A fool’s mouth lashes out with pride, but the lips of the wise protect them. Where there are no oxen, the manger is empty, but from the strength of an ox come abundant harvests. (7-10) Stay away from a fool, for you will not find knowledge on their lips. The wisdom of the prudent is to give thought to their ways, but the folly of fools is deception. Fools mock at making amends for sin, but goodwill is found among the upright. Each heart knows its own bitterness, and no one else can share its joy. (13) Even in laughter the heart may ache, and rejoicing may end in grief. (15-16) The simple believe anything, but the prudent give thought to their steps. The wise fear the Lord and shun evil, but a fool is hotheaded and yet feels secure. (21-24) It is a sin to despise one’s neighbor, but blessed is the one who is kind to the needy. Do not those who plot evil go astray? But those who plan what is good find love and faithfulness. All hard work brings a profit, but mere talk leads only to poverty. The wealth of the wise is their crown, but the folly of fools yields folly. (26-27) Whoever fears the Lord has a secure fortress, and for their children it will be a refuge. The fear of the Lord is a fountain of life, turning a person from the snares of death. (29-33) Whoever is patient has great understanding, but one who is quick-tempered displays folly. A heart at peace gives life to the body, but envy rots the bones. Whoever oppresses the poor shows contempt for their Maker, but whoever is kind to the needy honors God. When calamity comes, the wicked are brought down, but even in death the righteous seek refuge in God. Wisdom reposes in the heart of the discerning and even among fools she lets herself be known. ","date":"2022-11-30","objectID":"/proverbs/:2:14","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 15 (3) The eyes of the Lord are everywhere, keeping watch on the wicked and the good. (9) The Lord detests the way of the wicked, but he loves those who pursue righteousness. (11) Death and Destruction lie open before the Lord, how much more do human hearts! (15-16) All the days of the oppressed are wretched, but the cheerful heart has a continual feast. Better a little with the fear of the Lord than great wealth with turmoil. (18) A hot-tempered person stirs up conflict, but the one who is patient calms a quarrel. (20) A wise son brings joy to his father, but a foolish man despises his mother. (22-23) Plans fail for lack of counsel, but with many advisers they succeed. A person finds joy in giving an apt reply and how good is a timely word! (27-29) The greedy bring ruin to their households, but the one who hates bribes will live. The heart of the righteous weighs its answers, but the mouth of the wicked gushes evil. The Lord is far from the wicked, but he hears the prayer of the righteous. (31-33) Whoever heeds life-giving correction will be at home among the wise. Those who disregard discipline despise themselves, but the one who heeds correction gains understanding. Wisdom’s instruction is to fear the Lord, and humility comes before honor. ","date":"2022-11-30","objectID":"/proverbs/:2:15","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 16 (2) All a person’s ways seem pure to them, but motives are weighed by the Lord. (3) Commit to the Lord whatever you do, and he will establish your plans. (4) The Lord works out everything to its proper end even the wicked for a day of disaster. (5) The Lord detests all the proud of heart. Be sure of this: They will not go unpunished. (6) Through love and faithfulness sin is atoned for; through the fear of the Lord evil is avoided. (7) When the Lord takes pleasure in anyone’s way, he causes their enemies to make peace with them. (9-14) In their hearts humans plan their course, but the Lord establishes their steps. The lips of a king speak as an oracle, and his mouth does not betray justice. Honest scales and balances belong to the Lord; all the weights in the bag are of his making. Kings detest wrongdoing, for a throne is established through righteousness. Kings take pleasure in honest lips; they value the one who speaks what is right. A king’s wrath is a messenger of death, but the wise will appease it. (16) How much better to get wisdom than gold, to get insight rather than silver! (19) Better to be lowly in spirit along with the oppressed than to share plunder with the proud. (21-24) The wise in heart are called discerning, and gracious words promote instruction. Prudence is a fountain of life to the prudent, but folly brings punishment to fools. The hearts of the wise make their mouths prudent, and their lips promote instruction. Gracious words are a honeycomb, sweet to the soul and healing to the bones. (28) A perverse person stirs up conflict, and a gossip separates close friends. (32-33) Better a patient person than a warrior, one with self-control than one who takes a city. The lot is cast into the lap, but its every decision is from the Lord. ","date":"2022-11-30","objectID":"/proverbs/:2:16","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 17 (2-3) A prudent servant will rule over a disgraceful son and will share the inheritance as one of the family. The crucible for silver and the furnace for gold, but the Lord tests the heart. (5-7) Whoever mocks the poor shows contempt for their Maker; whoever gloats over disaster will not go unpunished. Children’s children are a crown to the aged, and parents are the pride of their children. Eloquent lips are unsuited to a godless fool how much worse lying lips to a ruler! (9-10) Whoever would foster love covers over an offense, but whoever repeats the matter separates close friends. A rebuke impresses a discerning person more than a hundred lashes a fool. (13) Evil will never leave the house of one who pays back evil for good. (15) Acquitting the guilty and condemning the innocent the Lord detests them both. (17) A friend loves at all times, and a brother is born for a time of adversity. (19) Whoever loves a quarrel loves sin; whoever builds a high gate invites destruction. (23-24) The wicked accept bribes in secret to pervert the course of justice. A discerning person keeps wisdom in view, but a fool’s eyes wander to the ends of the earth. (27-28) The one who has knowledge uses words with restraint, and whoever has understanding is even-tempered. Even fools are thought wise if they keep silent, and discerning if they hold their tongues. ","date":"2022-11-30","objectID":"/proverbs/:2:17","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 18 (2) Fools find no pleasure in understanding but delight in airing their own opinions. (12-13) Before a downfall the heart is haughty, but humility comes before honor. To answer before listening that is folly and shame. (17) In a lawsuit the first to speak seems right, until someone comes forward and cross-examines. ","date":"2022-11-30","objectID":"/proverbs/:2:18","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 19 (4) Wealth attracts many friends, but even the closest friend of the poor person deserts them. (15) Laziness brings on deep sleep, and the shiftless go hungry. (20-21) Listen to advice and accept discipline, and at the end you will be counted among the wise. Many are the plans in a person’s heart, but it is the Lord’s purpose that prevails. ","date":"2022-11-30","objectID":"/proverbs/:2:19","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 20 (21) An inheritance claimed too soon will not be blessed at the end. (23) The Lord detests differing weights, and dishonest scales do not please him. (28) Love and faithfulness keep a king safe; through love his throne is made secure. ","date":"2022-11-30","objectID":"/proverbs/:2:20","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 21 (2-3) A person may think their own ways are right, but the Lord weighs the heart. To do what is right and just is more acceptable to the Lord than sacrifice. (6) A fortune made by a lying tongue is a fleeting vapor and a deadly snare. (8) The way of the guilty is devious, but the conduct of the innocent is upright. (11) When a mocker is punished, the simple gain wisdom; by paying attention to the wise they get knowledge. (13) Whoever shuts their ears to the cry of the poor will also cry out and not be answered. (21) Whoever pursues righteousness and love finds life, prosperity and honor. (27) The sacrifice of the wicked is detestable how much more so when brought with evil intent! ","date":"2022-11-30","objectID":"/proverbs/:2:21","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 22 (3-4) The prudent see danger and take refuge, but the simple keep going and pay the penalty. Humility is the fear of the Lord; its wages are riches and honor and life. (11-12) One who loves a pure heart and who speaks with grace will have the king for a friend. The eyes of the Lord keep watch over knowledge, but he frustrates the words of the unfaithful. Thirty Sayings of the Wise (24-25) Saying3 Do not make friends with a hot-tempered person, do not associate with one easily angered, or you may learn their ways and get yourself ensnared. ","date":"2022-11-30","objectID":"/proverbs/:2:22","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 23 (4-5) Saying8 Do not wear yourself out to get rich; do not trust your own cleverness. Cast but a glance at riches, and they are gone, for they will surely sprout wings and fly off to the sky like an eagle. ","date":"2022-11-30","objectID":"/proverbs/:2:23","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 24 (14) Know also that wisdom is like honey for you: If you find it, there is a future hope for you, and your hope will not be cut off. (16) for though the righteous fall seven times, they rise again, but the wicked stumble when calamity strikes. (17) Do not gloat when your enemy falls; when they stumble, do not let your heart rejoice, ","date":"2022-11-30","objectID":"/proverbs/:2:24","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 25 More Proverbs of Solomon (6-7) Do not exalt yourself in the king’s presence, and do not claim a place among his great men; it is better for him to say to you, “Come up here,” than for him to humiliate you before his nobles. (13) Like a snow-cooled drink at harvest time is a trustworthy messenger to the one who sends him; he refreshes the spirit of his master. (15-17) Through patience a ruler can be persuaded, and a gentle tongue can break a bone. If you find honey, eat just enough too much of it, and you will vomit. Seldom set foot in your neighbor’s house too much of you, and they will hate you. (20-22) Like one who takes away a garment on a cold day, or like vinegar poured on a wound, is one who sings songs to a heavy heart. If your enemy is hungry, give him food to eat; if he is thirsty, give him water to drink. In doing this, you will heap burning coals on his head, and the Lord will reward you. (26-28) Like a muddied spring or a polluted well are the righteous who give way to the wicked. It is not good to eat too much honey, nor is it honorable to search out matters that are too deep. Like a city whose walls are broken through is a person who lacks self-control. ","date":"2022-11-30","objectID":"/proverbs/:2:25","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 26 (2) Like a fluttering sparrow or a darting swallow, an undeserved curse does not come to rest. (5) Answer a fool according to his folly, or he will be wise in his own eyes. (16-20) A sluggard is wiser in his own eyes than seven people who answer discreetly. Like one who grabs a stray dog by the ears is someone who rushes into a quarrel not their own. Like a maniac shooting flaming arrows of death is one who deceives their neighbor and says, “I was only joking!” Without wood a fire goes out; without a gossip a quarrel dies down. (26-27) Their malice may be concealed by deception, but their wickedness will be exposed in the assembly. Whoever digs a pit will fall into it; if someone rolls a stone, it will roll back on them. ","date":"2022-11-30","objectID":"/proverbs/:2:26","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 27 (1-2) Do not boast about tomorrow, for you do not know what a day may bring. Let someone else praise you, and not your own mouth; an outsider, and not your own lips. (6) Wounds from a friend can be trusted, but an enemy multiplies kisses. (9-11) Perfume and incense bring joy to the heart, and the pleasantness of a friend springs from their heartfelt advice. Do not forsake your friend or a friend of your family, and do not go to your relative’s house when disaster strikes you better a neighbor nearby than a relative far away. Be wise, my son, and bring joy to my heart; then I can answer anyone who treats me with contempt. (20) Death and Destruction are never satisfied, and neither are human eyes. ","date":"2022-11-30","objectID":"/proverbs/:2:27","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 28 (1) The wicked flee though no one pursues, but the righteous are as bold as a lion. (4-6) Those who forsake instruction praise the wicked, but those who heed it resist them. Evildoers do not understand what is right, but those who seek the Lord understand it fully. Better the poor whose walk is blameless than the rich whose ways are perverse. (8) Whoever increases wealth by taking interest or profit from the poor amasses it for another, who will be kind to the poor. (20) A faithful person will be richly blessed, but one eager to get rich will not go unpunished. (21) To show partiality is not good yet a person will do wrong for a piece of bread. (23) Whoever rebukes a person will in the end gain favor rather than one who has a flattering tongue. ","date":"2022-11-30","objectID":"/proverbs/:2:28","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 29 (5) Those who flatter their neighbors are spreading nets for their feet. (15) A rod and a reprimand impart wisdom, but a child left undisciplined disgraces its mother. (19-20) Servants cannot be corrected by mere words; though they understand, they will not respond. Do you see someone who speaks in haste? There is more hope for a fool than for them. (23) Pride brings a person low, but the lowly in spirit gain honor. (25) Fear of man will prove to be a snare, but whoever trusts in the Lord is kept safe. ","date":"2022-11-30","objectID":"/proverbs/:2:29","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 30 Agur, son of Jakeh Saying of Agur (8-9) Keep falsehood and lies far from me; give me neither poverty nor riches, but give me only my daily bread. Otherwise, I may have too much and disown you and say, ‘Who is the Lord?’ Or I may become poor and steal, and so dishonor the name of my God. (15-16) “The leech has two daughters. ‘Give! Give!’ they cry. “There are three things that are never satisfied, four that never say, ‘Enough!’: the grave, the barren womb, land, which is never satisfied with water, and fire, which never says, ‘Enough!’ ","date":"2022-11-30","objectID":"/proverbs/:2:30","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":"Chpater 31 Sayings of King Lemuel, utterance his mother taught him. (8) Speak up for those who cannot speak for themselves, for the rights of all who are destitute. (15) She gets up while it is still night; she provides food for her family and portions for her female servants. (30) Charm is deceptive, and beauty is fleeting; but a woman who fears the Lord is to be praised. ","date":"2022-11-30","objectID":"/proverbs/:2:31","tags":["book"],"title":"Book of Proverbs","uri":"/proverbs/"},{"categories":["wisdom"],"content":" You can train your brain to remember better, to learn faster and to achieve mastery in anything you want in your life. (Nishant Kasibhatla) 문득 소중한 사람들과의 감사했던 순간들을 잊어버리기 때문에, 사람이 교만하고 잔인해 질 수 있다고 생각했다. 소중한 시간들을 잊지 않기 위해, 나는 기억을 다스려야한다. 이를 위해 기억력을 높여 줄 3가지 방법 | 한영자막 을 보았고 앞으로의 공부에도 실용적으로 도움이 될 것 같아, 나만의 방법으로 이해하고 정리해보고자 한다. ","date":"2022-11-23","objectID":"/what_is_memory/:0:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"tl;dr Quote For true mastery, you need to focus more on the output rahter than the input. Learn, Do one thing at one time, especially when it comes to learning. Reflect, How can I use this information in my life? Implement, Share it. Nishant Kasibhatla FYI, 영상에 나오는 Nishant Kasibhatla(니샨트 카십하틀라) 는 찾아보니 Grand Master of Memory (= International Association of Memory) 보유자. 기억력 기네스 보유자. 20년간 관련 분야에 대해 코카콜라, Oracle, American express, 필립스 등 수많은 기업 강연함. 등등의 경력을 가지고 있다. ","date":"2022-11-23","objectID":"/what_is_memory/:1:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"1. As Below (3) 3 steps to improve your memory and ability to learn. 1-1. Learn: focus, single task You must ensure that the quality of input is really, really high, Which means avoid multi-tasking. Multi-tasking kills your learning momentum. Quality of input determines the quality of retention. It also affects the quality of recall. Do one thing at one time, especially when it comes to learning 1-2. Reflect: solidifies How to learn solidifies. After you learn something, pause for a while and ask yourself. “Hey, What’s the takeaway from this thing?” “How can I use this information in my life?” “How can I use this information in my work, in my family?” 1-3. Implement: share, express This is where the magic happens, but unfortunately many people miss out on this. What they do, is go on learning new things, and get excited and they feel good and they feel inspired and they go on to learn something new. You just mess up. Illusion of competence If you get into the habit of just learning without implementation, you know what you get. You get the illusion of competence. You feel you’ve learned it. You feel you’re competent. But it’s not competence at all, because you haven’t implemented. Suggestion After learn, Stop and write down what are the few things I can take action on. Schedule it in the calendar and take some action. Share: the best way to learn something is to teach it. When you learn something. Just output it, Just share it with other people. What you’re doing is you’re helping your brain to pay more attention. I(Nishant) have not seen anyone who became a master at something just by doing the input. They all became masters by doing the input and more of the output. If you’re spending X amount of time on input. My suggestion is at least spend 2X amount of time on output. And when you do that, you are well on your way to be a master at achieving anything you want. ","date":"2022-11-23","objectID":"/what_is_memory/:2:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2. As Above 나만의 원칙으로 재해석 해보자. ","date":"2022-11-23","objectID":"/what_is_memory/:3:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2-1. What is Like Me? 나는 “나 답게 살고 싶고, 그렇게 죽고 싶다.”. 현 시점의 나 또한 여전히 성공한 인생이란, 죽기 전까지 나답게 살아서, 후회없이 사는 것이라고 생각한다. 지금까지 나는 “나답게\"에서 나라는 개념을 찾아왔고 이해했고 살아왔다. 10대 “세상이 가지지 못한 복음\"을 믿고 있는, 나는 특별하다. “청소년기에는 죽음을 고민하다 선교사를 꿈꾸며(중2)” 지식: 성경의 예수님을 통해 사랑을, 다니엘을 보며 지혜를, 요한과 바울을 보며 신비를 꿈꾸었으며, 이해: 내 주변의 폭력과 경쟁 속에서 이를 구현하도록 기도했고, 행동: 수능과 재수, 선교(요르단, 티베트, 베이징)를 통해 더 큰 세상을 느꼈다. 20대 “내가 모든 것을 맛보고 나서야 판단하겠다”(만류귀종)는 신념이 있는, 나는 특별하다. “20대에는 내 인생의 전부인 교회를 지우기로 결심하고, 나아가서는 해석을 강요하는, 즉 기존에 시스템으로 존재하는 모든 종류의 믿음을 거부하여 지식: 모든 종류의 배우고 느낄 수 있는 웃긴, 즐거운, 특별한, 대단한, 두근거리는, 신비한, 강한, 쿨한, 부유한, 흥분되는, 지식-조각들을 모아왔고, 이해: 그 동안 교회와 관련된 내 모든 친구와 동생들, 형과 누나들의 모든 연락을 끊고, 술과 담배, Hermetics, Kabbalah, astrology 성공학(네빌고다드, 드마코, 디팩초프라, 조-디스펜자), 조던 피터슨, 사이토 히토리, osho 복싱, 5번의 주전공 수업 그리고 프로그래밍을 이해하기 위해 노력했고, 행동: 알바, 군대, 인턴, 취업 투자, 2번의 이직, 3년의 사회생활 대외활동들(미소국가대표, 멋쟁이사자처럼6-7기, 넥스터즈18-21기) 여행(베트남, 오키나와, 싱가포르, 삿포로, 라오스, 제주도 🏝️)을 통해 더 큰 세상을 느꼈다. 30대 만으로 30세가 되었다. “사랑과 정의를 양심으로 균형 맞추고 싶다”. “30대의 나는 믿음이 아닌, 행동을 통해 알고 싶고, 그 모든 과정이 선했으면 좋겠다. (Albert Einstein) Innovation is not the product of logical thought, even though the final product is tied to a logical structure. 지식: 내가 생각하는 균형이란 선과 악, 양과 음, 사랑과 정의, 자유와 책임, 안과 밖. 나와 너, 천국과 지옥, 인생과 죽음, 말과 행동, 생각과 감정. 하찮은 것과 대단한 것, 양심과 욕심. 내가 생각하는 사랑이란. 선한 것을 좋아하는 마음. 나와 너가 사랑 안에서 둘이 아니라는 것. 나와 세상이 사랑 안에서 둘이 아니라는 것. 들이 쉬는 것, 자유로운 것, 확장하는 것, 아는 것. 내가 생각하는 정의란. 악한 것을 싫어하는 마음. 신념을 행동으로 책임지는 것. 구분하고 있는 나를 아는 것. 뱉어내는 것, 무거운 것. 내가 생각하는 양심이란. 중심을 맞추는 것 (도) 내가 나에게 떳떳한 것. (팔은 안으로 굽으니) 남을 미워한 만큼, 나를 조금 더 미워할 줄 아는 것. (내가 신이 아니니) 남을 사랑한 만큼, 나를 조금 더 사랑할 줄 아는 것. (내가 신을 닮고 싶으니) 받은 만큼, 조금 더 줄 줄 아는 것. (내가 신을 닮고 싶으니) 들이 쉰 만큼, 조금 더 뱉는 것. 이해: 고전/경전 들을 읽고 있고 더 읽을 예정이다. 철학자들의 생각을 읽고 있으며 더 읽을 예정이다. 명상과 단학을 해보고 있고, 더 해볼 예정이다. 돈에 대해 읽고, 정의 내려보고 있으며, 돈의 시나리오를 작성해 다시 투자해볼 예정이다. 영어를 공부하며, 미국 문화를 이해하고 있으며, 기회가 된다면 살아볼 예정이다. 직업에 대해서 고민하고 있으며, 더 정의해 볼 예정이다. 인간관계에 대해서 고민하고 있으며, 가까운 사람들을 통해 행동해보고 있으며, 다시 사회로 나가 시험해 볼 예정이다. 행동: 퇴사 mma 미국 여행 책추남 템플턴 아카데미 홍익학당 신사과정 준비 ","date":"2022-11-23","objectID":"/what_is_memory/:3:1","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"2-2. Back to the point 학습과 기억에 대한 원칙을 나만의 것으로 재해석 해보자. Spirit investments Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton 존 템플턴의 멋진말에 공감한다. 모든 행동의 원칙은 내가 사는 이유, 선/악의 기준 즉 나의 양심에 기반해서 도출하고 싶다. 이는 투자에서도, 프로그래밍에서도, 앞으로 공부할 모든 분야에 대해서도 마찬가지라 생각한다. 그리고 사실 분리된 것 같아 보이는 모든 분야에서, 나는 공통의 결을 볼 수 있으리라 생각한다. 나라는 개념 또한 그렇게 생각하기 때문에 앞서 Like Me에 대해서 정리를 해보았다. Einstein and the Poet The truly religious man has no fear of life and no fear of death and certainly no blind faith; his faith must be in his conscience. I am therefore against all organized religion. by Albert Einstein 뉴턴, 라이프니츠 등 과거에는 철학자이자 신학자이자 과학자이자 수학자이고 음악가등 한 인물이 다양한 분야에서 관심을 가지고 공부하고 발견했듯이, 벤포드 법칙과 같은 법칙이 우연으로 보이는 데이터 세상에서 내적 법칙으로 동작하듯이, 나는 내가 할 수 있는 모든 학습을 통해 그 결을 보고 느끼고 싶다. (Albert Einstein) I want to know God’s thoughts; the rest are details. 1. Seek (learn) 신을 찾듯이, 기도 하듯이, 사랑을 읽고 찾는다. 💡: You, love, free-will, study, expand, light, focus, pray, know, search (Matt.22.37) Love the Lord your God with all your heart and with all your soul and with all your mind. (Matt.7.7-12) Ask and it will be given to you; seek and you will find; knock and the door will be opened to you. For everyone who asks receives; the one who seeks finds; and to the one who knocks, the door will be opened. “Which of you, if your son asks for bread, will give him a stone? Or if he asks for a fish, will give him a snake? 2. Establish (reflect) 기존의 나의 존재와 발견한 사랑을 다시 합친다. 💡: Ego, justice, responsibility, connect, spider-web, plan, dark, don’t know, 無極, microcosm, Monad, feel, find (Prov.16.3) Commit to the LORD whatever you do, and he will establish your plans. “어떻게 하면 현실에서 적용할 수 있을까?” “어떻게 하면 강하면서도 선할 수 있을까?” “어떻게 하면 원수도 사랑 할 수 있을까?” 3. Subdue (implement) 나의 법칙으로 다스려본다. 잘 된다면 말과 행동이 일치하는 인생을 살고 있는 것이다. 💡: I, being, As above so below, oneness, 道, 中庸, 良心, macrocosm, 太極, sympathy-empathy, golden rule, Ouroboros (Matt 22.39) And the second is like it: ‘Love your neighbor as yourself.' (Gen 1.28) God blessed them and said to them, “Be fruitful and increase in number; fill the earth and subdue it. Rule over the fish in the sea and the birds in the sky and over every living creature that moves on the ground.” by Rabbi Daniel Lapin 말보다 행동이 더 무겁다. 글을 읽는 것보다 이해하는게 더 어렵고, 이해한 것 보다 그것을 전달하는게 더 어렵고, 말한 것 보다 그렇게 사는게 더 어렵기 때문이다. 말과 행동이 다른 사람이 역한 것은, 자신이 빌려온 지식을 가지고 이해한척, 선생님인척 굴기 때문이다. 이렇게 1 -\u003e 2 -\u003e 3을 하고 나면 다시 반대로 2 -\u003e 1을 하여, 배움을 이어간다. ","date":"2022-11-23","objectID":"/what_is_memory/:3:2","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["wisdom"],"content":"3. Conclusion 계자서(戒子書) 끝으로 제갈량(諸葛亮,181-234)이 54세의 나이에 8살 아들인 제갈첨(諸葛瞻)에게 보내는 편지를 통해 배움에 대한 생각을 마무리해보려 합니다. 계자서 비석 탁본 글씨 戒子書, 제갈량 夫君子之行(부군자지행) 무릇 군자의 조행(操行-행동을 조심함)이란 靜以修身(정이수신) 고요한 마음으로 몸을 닦고 儉以養德(검이양덕) 검소함으로써 덕을 기르는 것이다. 非澹泊無以明志(비담박무이명지) 마음에 욕심이 없어 담박하지 않으면 뜻을 밝힐 수 없고, 非寧靜無以致遠(비녕정무이치원) 마음이 안정되어 있지 않으면 원대한 이상을 이룰 수 없다. 夫學須靜也(부학수정야) 무릇 배울 때는 반드시 마음이 안정되어 있어야 하며, 才須學也(재수학야) 재능은 반드시 배움을 필요로 한다. 非學無以廣才(비학무이광재) 배우지 않으면 재능을 발전시킬 수 없고 非靜無以成學(비정무이성학) 마음이 고요하지 않으면 학문을 성취할 수 없다. 慆慢則不能硏精(도만칙불능연정) 마음이 방자하고 오만하면 정밀하고 미묘한 이치를 깊이 연구할 수 없고, 險躁則不能理性(험조칙불능이성) 조급하고 경망하면 자신의 본성을 제대로 다스릴 수 없다. 年與時馳(년여시치) 이치를 제대로 밝히지 못하고 본성을 제대로 다스리지 못하는 사이에 志與歲去(지여세거) 나이는 시간과 함께 달려가고 의지는 세월과 함께 사라지면서 遂成枯落(수성고락) 마침내 가을날 초목처럼 시들어 갈 것이다. 悲嘆(守)窮廬(비탄궁려) 그때 가서 곤궁한 오두막집에서 슬퍼하고, 將復何及也(장부하급야) 탄식해본들 어찌 할 것인가? 대만의 남회근 선생님(중국문화 만담)의 풀의 중 참고할 만한 내용입니다. “무릇 군자는 고요함으로 몸을 닦고 검소함으로 덕을 기른다. 담박하지 않으면 뜻을 밝게 할 수 없고, 고요하지 않으면 멀리 이를 수 없다” [夫君子之行, 靜以修身, 儉以養德. 非淡泊無以明志, 非寧靜無以致遠] 먼저 심경이 고요할 수 있어야 합니다. 중국의 신흥 기업가들, 특히 여러분들은 주의해야 합니다! 담박할 수 있겠습니까? 비단 삶이 담박해야 할 뿐 아니라 생각 또한 담박해야 합니다. “무릇 배움은 모름지기 고요해야 하며[夫學須靜也]” 진정으로 학문을 말하려면 고요한 환경, 고요한 시간을 가져야 합니다. 하루 스물네 시간 중 예닐곱 시간은 혼자서 고요히 돌이켜 생각하고 반성하며 독서해야 합니다. “재능은 모름지기 배워야 얻는다[才須學也]” 지식의 축적, 재능의 신장은 학문을 통해서 나옵니다. “배우지 않으면 재능을 넓힐 수 없고[非學無以廣才]” 광범한 지식을 구하지 않으면 재능이 국한됩니다. “고요하지 않으면 학문을 이룰 수 없다[非靜無以成學]” 고요한 심경이 없다면, 고요한 생각이 없다면 여러분의 학문은 깊어질 수 없습니다. 어떤 판본에서는, “뜻이 없으면 학문을 이룰 수 없다[非志無以成學]”고도 했는데, ‘지(志)’란 입지(立志)로서 뜻을 세우는 것입니다. 강렬한 바람이나 의지가 없다면 학문 역시 깊어질 수 없습니다. “오만하면 세밀히 연구할 수 없고, 험하고 조급하면 본성을 다스릴 수 없다[慢則不能硏精, 險躁則不能理性]” 스스로 자신을 용납하고 게으르며 정진하지 않는 것이 ‘도’이고 ‘만’은 자만으로서 스스로 자기 만족에 빠져 뛰어나다고 생각하는 것입니다. 누구든 쉽게 이런 잘못을 범할 수 있습니다. 예를 들어 봅시다. 여러분은 보통의 젊은 사람들이 독서할 때와 마찬가지로 한 번 보고는 모두 이해했다고 생각하지만 사실은 그림자도 잡지 못했습니다. 이것이 바로 도만입니다. 도만하면 정치하게 연구할 수 없습니다. 내면의 생각과 정서가 요동치면 마음이 안정되지 못해 조급하게 성질을 부리는데, 그렇게 되면 본성을 다스릴 수 없습니다. 자신을 관리할 수 없게 되지요. - 끝 -","date":"2022-11-23","objectID":"/what_is_memory/:4:0","tags":["memory","study"],"title":"What is memory?","uri":"/what_is_memory/"},{"categories":["book","money","wisdom"],"content":"What is money? and How to subdue it? ","date":"2022-11-16","objectID":"/spiritual_investments/:0:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"tl;dr Intro Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton ","date":"2022-11-16","objectID":"/spiritual_investments/:1:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"17 Principles Invest for maximum total real return. Invest–don’t trade or speculate. Remain flexible and open-minded about types of investments. Buy low–at the point of maximum pessimism. Search for quality when buying. Buy value, not market trends or economic outlook. Diversify. Do your homework or hire reliable experts to help you. Monitor your investments. Don’t panic. Learn from your mistakes. Use prayer to gain perspective and quiet your mind. Recognize the difficulty of outperforming the market. An investor who has all the answers doesn’t even understand the questions. There is no free lunch. Do not be overly fearful or negative. Those who do good do well. ","date":"2022-11-16","objectID":"/spiritual_investments/:1:1","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"17가지 원칙 최종 수익률로 평가하라. 투기적 매매가 아닌 투자를 하라. 유연한 자세로 투자 대상을 고르라. 쌀 때 사라, 비관적 분위기가 최고조에 달했을 때. 매수하기 전에 먼저 좋은 주식인지 살펴보라. 시장의 유행이나 전망이 아니라 가치를 사라. 위험을 분산하라. 스스로 공부하라, 아니면 전문가의 도움을 받으라. 투자에 주의를 게을리 하지 말라. 패닉에 빠지지 말라. 실수로부터 배우라. 기도를 통해 평정심과 통찰력을 얻으라. 평균 이상의 수익률을 거두기가 얼마나 어려운지 알라. 자만을 버리고 겸손하라. 세상에 공짜는 없다. 너무 두려워하지도 말고 부정적으로 보지도 말라. 선을 행하면 다 잘 된다. ","date":"2022-11-16","objectID":"/spiritual_investments/:1:2","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 돈이란 무엇인가? 그리고 어떻게 다스릴 것인가? A. 하나님을 찾듯 돈을 찾고, 받은 사랑을 대하듯 돈을 대하며, 저지른 실수에 대해서는 책임을 배워 더 사람으로 살자. Book Intro Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. by Sir John Templeton ","date":"2022-11-16","objectID":"/spiritual_investments/:2:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 ","date":"2022-11-16","objectID":"/spiritual_investments/:3:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2-1. 받은 영감: 이 책의 저자는 템플턴이 아닌 Gary Moore이다. 연상된 점: 항룡유회 깨달은 점: 템플턴 경은 Gary Moore같이 속 시원하게 이야기할 친구가 있어서 신이났을 것 같다. 나도 속시원하게 내 이야기를 할 수 있는 친구가 있어서 감사하다. ","date":"2022-11-16","objectID":"/spiritual_investments/:3:1","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"2-2. 받은 영감: 형이하적인 17가지 투자 원칙 마다, 저자의 영혼의 원칙이 존재하고 그것을 삶으로 완성시켰다. 연상된 점: As above, so below 깨달은 점: 말은 가볍고 행동은 무겁다. 내 안에 알아차리는 자, 신성, 태극이 존재함과 남/세상과 내가 사랑 안에서 둘이 아니라는 신념은 내가 얼마나 그에 맞게 세상에서 행동을 하는지에 따라서만 내가 이해할 수 있다. ","date":"2022-11-16","objectID":"/spiritual_investments/:3:2","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"3. 저자의 주장에 대한 나의 생각 Gary Moore in spiritual investments “죄악주(Sin stock)라고 부르는 주류회사와 담배회사, 도박회사에는 처음부터 투자하지 않는다는 원칙을 세웠고, 이 원칙은 오늘까지도 지켜지고 있다.” +: Sin stock이라는 개념을 실제로 주식시장에 적용해서 행동함. -: (템플턴을 존경해서, 감히 판단하자면) Sin stock의 종류가 너무 1차원적으로 굳어있다. 과연 술, 담배는 악할까? 돈이 사람에 따라 선하기도 악하기도 하듯, 술/담배 또한 그러한 것 같다. 현재 상황에서 나와 세상에 대체로 악하게 작동된다 판단되는 모든 것이 Sin stock이 되야 된다고 생각하며 그 종류는 계속해서 변경되야 된다고 생각한다. ","date":"2022-11-16","objectID":"/spiritual_investments/:4:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"4. 질문 및 토의 사항 Q. 주식투자와 선행을 분리해서 생각해야 할까? 기업의 주식을 사는 것이 기업의 ‘시가총액’은 높여줄 수 있지만, 실제로 기업의 재산에는 어떤 영향도 주지 않는다고 이해했습니다. 그렇다면 템플턴 경이 말했던 “적어도 자산의 일부는 저개발 국가에 투자해야 한다고 강조한다”(19p) 라는 문맥에서 투자는 주식을 사는 행위가 아닌 걸까요? 그렇다면 투자하기 좋은 기업이란 그저 Sin Stock이 아니면서, 내 자본을 크게 부풀려줄 수 있는 기업일까요? ","date":"2022-11-16","objectID":"/spiritual_investments/:5:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"5. 작은 실천 계획 존 템플턴의 행복론, 존 템플턴의 성공론 읽기. 테크닉적인 주식 공부하며, 나의 좋은 주식 원칙 기록하기. ","date":"2022-11-16","objectID":"/spiritual_investments/:6:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"6. 자유 감상문 이 책을 일주일전 뉴욕 맨하튼 호텔 로비에서 완독하였다. 그 동안 부유한 월스트리트와 화려한 타임스퀘어를 돌아 보았고 그리고 건강하게 센트럴파크도 뛰어 보았다. 그러면서도 찌든 대마 냄새와 추위에 떨면서 술에 취해 자는 많은 노숙자들을 보았다. 그리고 다시 호텔로 돌아와 책을 읽으며 뉴욕의 경험과 함께 돈과 관련된 나의 생각을 정리해 나갔다. Prov 16:3 Commit your works to the Lord, And your thoughts will be established. 현재 나는 “돈을 왜 벌어야 할까?” 라는 질문으로 좋은 페이와 기회를 주는 회사를 그만두었고, 사실 그 질문의 이면에는 너무나도 초라한 마음 상태를 가진 내가 불쌍하기 때문이었다. 회사를 그만둔 뒤, 마음껏 재밌는 것들을 하고, 스케줄의 압박 없이 편하게 지내며, 좋은 고전들을 듣고 읽고 땀을 흘려 운동을 하였다. 시간과 여유가 있으니 자연스레 할머니, 부모님 그리고 친구들을 돌아보며 내가 많은 것들을 놓쳤다는 것을 알았고, 이를 표현하며 더 성숙해졌다. 그러다 미국에 혼자 있는 형이 보고 싶어 달러강세에도(1,410원/$) 돈을 환전해 미국으로 갔고, 그 안에서 생활하면서 다양한 경험을 하고 있다. 그리고 퇴사후 했던 이 모든 과정에서 사실 모두 돈이 필요했다는 것을 알고, 내가 쓴돈 이외에도 형과 부모님의 금전적 희생이 토대가 된다는 것을 알며, 앞으로의 계획을 위해서는 더 많은 돈이 필요하다는 것을 알았다. 그럼 다시 \"나는 왜 돈을 벌어야하고 어떻게 벌어야 할까?\" Sir John Ethics and spiritual principles should be the basis of everything we do in life. All that we say. All that we think. Every activity should be based on that including the selection of investments. 나는 안과 밖에서 모두 신을 찾고 느껴 확장하며 살고싶다. 지금의 백수 생활처럼 지혜를 경험하고 고민할 수 있는 시간과 공간이 필요하다. 즉 자유의 돈이 필요하다. 고민한 만큼 더 많은 위험과 악한것들이 보이니, 사랑하는 모든 것들을 지켜내기 위한 정의의 돈이 필요하다. 지금 사랑하는 사람들과 앞으로 나타날 제2의 제민욱들에게 부끄럽지 않을 증명과 권력으로써의 돈, 즉 책임의 돈이 필요하다. 내가 보기에 아름다워 보이는 향기를 내는 모든 종류의 스승들과 친구들에게 감사를 전하고 싶다, 즉 사랑의 돈이 필요하다. 템플턴 경(그리고 게리 무어)이 전달해준 지식과 그걸 증명해내는 행동 덕분에 많이 배웠습니다. 이 깨달음을 돈에 대한 나의 다짐으로 마무리 하겠습니다. ","date":"2022-11-16","objectID":"/spiritual_investments/:7:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["book","money","wisdom"],"content":"My Resolution What do I think about money? 나는 돈을 다스릴 것이다. Gen.1.28 God blessed them and said to them, “Be fruitful and increase in number; fill the earth and subdue it.” … 나에게 돈이란 사랑과 정의, 자유와 책임이며. 돈을 다스린다는 것은, 욕심과 양심 사이를 저울질하면서. Prov.21.2 A person may think their own ways are right, but the LORD weighs the heart. 돈을 스승으로 삼아. 사랑과 정의, 자유와 책임을 위해 사용하는 것입니다. Matt.22.37 “Love the Lord your God with all your heart and with all your soul and with all your mind” … And the second is like it: “Love your neighbor as yourself” 먼저는 나에게. 둘째는 가족이며. 셋째는 스승과 친구이며. 이 모든것은 신께 드리는 내 행동의 기도입니다. Prov.15.9 The LORD detests the way of the wicked, but he loves those who pursue righteousness. 그러므로 돈을 통해 내 욕심의 소리와 양심의 소리를 같이 듣겠습니다. Prov.15.31 Whoever heeds life giving correction, will be at home among the wise. 내 행동의 기도가 양심이라면, 내 그릇이 커질 것이고 Prov.19.21 Many are the plans in a person’s heart, but it is the LORD’s purpose that prevails. 내 행동의 기도가 욕심이라면, 내 그릇이 부끄러워 질 것입니다. Prov.15.33 Wisdom’s instruction is to fear the LORD, and humility comes before honor. ","date":"2022-11-16","objectID":"/spiritual_investments/:8:0","tags":["book"],"title":"Spiritual Investments","uri":"/spiritual_investments/"},{"categories":["life","philosophy"],"content":"한달 전 일도 인생도 제대로 안살고 있는 내가 꼴보기 싫어 직장을 그만두었다. 그리고 사실은 그렇게 못살고 있던 내가 불쌍해서 앞으로는 소중한 것을 놓치지 말라는 마음을 기록해 봅니다. ","date":"2022-10-22","objectID":"/what-i-know/:0:0","tags":["poetry"],"title":"세번째 직장을 그만두고서","uri":"/what-i-know/"},{"categories":["life","philosophy"],"content":"What I know 제목: 나는 내가 나를 모른다는 것을 안다. 나는 숨을 쉰다. 내가 숨을 참는다. 나는 내가 숨을 참지 못할 것을 안다. 숨 보다 숨을 참지 못하는 몸을 더 모른다는 것을 안다. 몸 보다 잊혀진 생각, 감정, 느낌 그리고 기억들을 더 모른다는 것을 안다. 나는 나를 모른다는 것을 안다. 나는 나보다 내 부모를 더 모른다는 것을 안다. 가족보다 친구를 더 모른다는 것을 나는 안다. 친구보다 남을 더 모른다는 것을 나는 안다. 남보다 원수를 더 모른다는 것을 나는 안다. 원수보다 그 원수를 사랑하라는 예수를 더 모른다는 것을 나는 안다. 나는 내가 하나님을 모른다는 것을 안다. 나는 내가 신이 아니라는 것을 안다. 그런데 계속 안다고, 말하는 너가 누군지 모르겠다. 지금 모르겠다고, 말하는 내가 누군지도 모르겠다. 나는 나를 모른다. 나는 내가 나를 모른다는 것을 안다. 그런데 사람들이 나를 알아봐준다. 그래서 더 불편하다. 그래서 더 답답하다. 그래서 더 섭섭하다. 그래서 더 거슬린다. 그래서 더 짜증난다. 그래서 더 부끄럽다. 그래서 더 까먹는다. 그래서 악하다. 그래도 사람들이 나를 알아봐준다. 그래서 더 편하다. 그래서 더 끌린다. 그래서 더 공감한다. 그래서 더 감사하다. 그래서 더 기대한다. 그래서 더 신뢰한다. 그래서 더 사랑한다. 그래서 선하다. 그래서 더 모르겠다. 그래도 더 궁금하다. 그러니 더 재밌다. 그래서 숨을 조금 더 뱉어본다. ","date":"2022-10-22","objectID":"/what-i-know/:1:0","tags":["poetry"],"title":"세번째 직장을 그만두고서","uri":"/what-i-know/"},{"categories":["life"],"content":"나를 포함한 내 주변이 나를 온전히 봐주길 원한다. 나한테 그게 양심이다. ","date":"2022-10-20","objectID":"/behavior/:0:0","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["life"],"content":"원칙 딱 들이쉰 만큼만 뱉어내라. 모든 곳에 신이있다. 시시하다면 지금 내 마음이 급한거다. 내가 높아졌으면 누가 깔아준거다. 망하는거 생각보다 초라하지 않다. 주고 싶으면, 엄마 아빠부터 돌아봐라. 입꼬리 살짝 올리고 있으면, 기분 좋다. 지금 불안하면, 그 장소의 냄새와 맛들을 찾아봐라. 오늘의 원칙이 없으면, 내일의 성장이 없다. 말 만하고 행동하지 않으면, 부끄럽다. 말 없이 행동으로 증명하는게 더 설득력있다. 말보다 감정의 맛이 더 깊다. 모르겠으면 그냥 더 불편한걸 해라. 그래도 법은 지켜라. 안다는건 시각 미각 후각 청각 촉각으로 아는것. 가르치려 들지 마라. 기분 나쁘다. 온전히 봐주고 이해해주길 원한다, 하지만 커밍아웃을 당하면 수치심이 들거다. 기억나지 않는건 내 수치심을 건드렸을 확률이 높다. 까먹기 싫다면, 내일의 나에게 수치심을 줘라. 기록을 한다면, 짧을 수록 좋다. 상대가 못생겼다면, 내 감정이 못생긴거다. 집에가서 그 감정을 품어줘라. 나도 귀한집 자식이다. 유전자 타고 가면 상대방도 내 형제다. 형이랑 싸우고 있으면 엄마 가슴이 찢어진다. ","date":"2022-10-20","objectID":"/behavior/:0:1","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["life"],"content":"폭력 누가 내 왼뺨을 때리려 하면, 왼쪽 가드 -\u003e 투 -\u003e 훅 -\u003e 원투를 정확히 오른쪽 뺨에 때리자. 성인 군자인척 하지 말자. 이건 내가 아빠한테 할아버지처럼 행동하는 것 만큼 어색하다. 꼭 싸워야만 한다면, 말 없이 때리자. 내가 맞아 준다면, 아빠, 엄마, 할머니를 내가 때리고 있다는걸 기억하자. ","date":"2022-10-20","objectID":"/behavior/:0:2","tags":["life"],"title":"Consciousness","uri":"/behavior/"},{"categories":["book","money","mind"],"content":"나에게 권위에 대한 자발적 순종을 알려준, 적당히 욕심 많은 아버지가 딸들에게 보내는 헌신적인 사랑 ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:0:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q. 아버지가 딸에게 바라는 것은? A. 자발적 순종 ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:1:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 짐 로저스는 딸을 소유하고 싶어하면서도 할렘 같은 곳으로 가라는 믿음을 준다. 아버지가 딸을 믿어주니 딸이 자유를 가질 수 있다. 그럼 아버지는 딸로 부터 무엇을 가장 원할까? 순종을 알려준 적당히 욕심 많은 아버지. 먼저 내가 받았으니 오버하지 말고 나도 적당히만 순종하자. ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:2:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"3. 저자의 주장에 대한 나의 생각 (207p) “너희도 사람들이 곤경에 처했을 때 모른 체하면 안 된다. 그런 때일수록 힘이 돼주는 일이 중요하다. 외면하지 않고 곁에 있어주는 데 큰돈이 드는 것도 아닌데 당사자는 그 일을 항상 기억하면서 매우 고마워한다.” 부정: 딸들/돈을 사랑하는 마음은 이해되지만 그럼에도 불구하고 힘든 이웃을 도우는 일에 이렇게 까지 값으로 계산하는 의도가 밉다. 딸들이 만약 자신을 그렇게 계산적으로 생각한다고 느낀다면, 본인도 상처입지 않을 수 있을까? 긍정: 짐로저스가 생각하는 “돈\"을 내가 좋아하는 “사랑\"이라는 단어로 대입하여 생각 해본다면. 힘든 이웃을 잊지 말고 도와줄 수 있도록 동기부여를 주는 자상한 아버지이지 않을까, 어쩌면 흔들리는 건 깃발이 아니라 판단하는 내 마음 아닐까? ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:3:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"4. 질문 및 토의 사항 부모는 자식의 어떤 모습에서, 가장 감사함을 느낄까? ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:4:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"5. 작은 실천 계획 내 양심에 선한 기업에 투자하자. 만약 벌었으면 들이 쉰 만큼, 양심에 맞게 뱉자. ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:5:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["book","money","mind"],"content":"6. 자유 감상문 이 책이 불편해서 띄엄띄엄 세번 읽었습니다. 아마 제 안에 권위에 반발하려는 마음과 관련되어 있어 보입니다. 처음읽었을 때: 소유욕에 눈빛이 번들번들한 노인 처음 읽었을 때는 욕심 가득한 할아버지의 모습을 한 짐 로저스를 보며, 잔뜩 화가나 내가 빌려온 지식들로 할 수 있는 최대한의 멋지고 원색적인 비판을 적었습니다. 그래서 지금 “내 아이들에게 주는 선물\"에는 마치 청소년 시절 제가 부모님을 평가했듯 온갖 분노와 욕설이 가득합니다. 스크루지 영감을 떠올리며, 딸들도 돈도 계속 소유하려하는 욕심 많은 노인으로 보며 분노의 감정을 쏟아낸 글들 이하 생략. (첫번째 성찰 일부) 두번째 성찰: 아버지로 보여주는 신의 조각 그렇게 책을 잊은채로 짬짬이 홍익학당의 윤홍식 선생님의 영상을 보며 양심을 들었습니다. 그리고 다시 책을 보니 또 잔뜩 오바해서 빌려온 성인들의 멋진말로 로저스를 평가해놨고, 그 감정에 취해 많이 울었습니다. 그러다 아빠와 엄마에게 고맙다는 마음을 전하고 싶어, 자발적으로 교회를 나가 멋진말들 중 일부를 빌려주신 예수님에게 감사를 전했습니다. 사실 이 글을 쓰는 지금 최대한 담담하게 적고 있지만 두번째 시점에서의 평가글을 보면 또 오버 했습니다. 나는 짐로저스 만큼 행동했는가? 할렘 가봤는가? 못 가보았다. 자식을 사랑하는 마음으로 위험에 대한 자유를 그리고 사랑의 마음으로 221p에 달하는 경험을 명상하고 성찰한 자신의 자명함으로 줄 수 있는가? 당장 나는 주식만해도 내가 사랑으로 투자한 회사를 믿어주지도 못하면서, 즉 행동하지도 못하면서 바리세인마냥 떠들고 있다. 위선자. (두번째 성찰 일부) 자명할 때만 투자하라. 즉 빌려온 지식들로 선한 것 마냥 유세 떨지말자. 나는 분리하지 않고 더 사랑하고 행할 것이다. 욕심 많은 할아버지로 보이던 짐 로저스는 나에게 부모님, 권위, 신, 돈에 대한 순종과 절제를 알려주는 참 스승이다. 탐욕과 욕심으로 번들번들하는 눈을 가진 내가 알아차리지 못했을 뿐. 이 말을 쓰면서도 이 정도면 멋있는 글이 나오겠지? 칭찬 받겠지? 라고 생각하는 내가 참 안쓰럽다. 그럼에도 판단할 수 있는 사랑을 주심에 감사합니다. (두번째 성찰 일부) 세번째: 순종을 알려준 적당히 욕심 많은 아버지 지금 독후감을 쓰기 위해 다시 돌아보니 이제 짐 로저스는 적당히 욕심 많은 아버지로 보입니다. 저는 제가 딱 경험한 만큼만 알 수 있는 것 같습니다. 저는 짐 로저스로 부터 권위에 대한 순종을 배웠으며, 이를 통해 부모님에게 감사한 마음을 느꼈습니다. 그 안에서 발견한 적당한 아름다움에 맞게 돈을 바라보겠습니다. 아버지가 성실함으로 어린 나를 지켜주셨고, 어머니가 젊음을 바쳐 나를 안아주셨습니다. 그 분들이 내가 태어났을 때 따뜻하게 바라봐주셨으니, 그걸 내가 이해한 만큼만 세상을 향해 따뜻하게 웃을 수 있습니다. 부모님 또한 할아버지/할머니의 불완전한 아들/딸로서 미숙한 부모님으로 헌신 하였으니, 저도 주변 사람들의 미숙한 아버지가 되어 딱 적당히 조화로울 수 있도록 따뜻하겠습니다. 내가 들이쉰 만큼만, 뱉어 내겠습니다. by (세번째 기도) ","date":"2022-10-16","objectID":"/a-gift-to-my-children-in-2009/:6:0","tags":["book"],"title":"A Gift to My Children","uri":"/a-gift-to-my-children-in-2009/"},{"categories":["dev"],"content":"홍정모의 따라하며 배우는 C++","date":"2022-10-01","objectID":"/hong_modern_cpp/","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":" Modern c++을 학습하고 기억할만한 요소들을 정리합니다. 1. Terminology ","date":"2022-10-01","objectID":"/hong_modern_cpp/:0:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"0. Terminology 1.0.1. Basic C++ prototype forward declaration header guards (=include guards) 중복될 경우 한번만 include해라 (#pragma once) #pragma once 기 정의된 preprocessor의 일종 macro conditional compilation macro의 #ifdef, #ifndef, #else, #endif fundamental data types (=primitivate data types) auto는 데이터 타입을 자동으로 컴파일 타임에 찾아준다. 1.0.2. Variable and Fundamental types initialization copy initialization int a = 3; direct initialization int a(3); uniform initialization int a{ 3 }; c.f) Most vexing parse: syntax가 일관성이 없어서, uniform initialization이 도입됨. (C++ 11) Fixed-width Integers scientific notation inf: infinite nan: not a number ind: indeterminate literal constants symbolic constants constexpr(c++ 11): 컴파일 타임에 값이 완전히 결정되는 상수 const: 컴파일 타임 / 런타임에 값이 결정되는 모든 상수. (constexpr 포함) 1.0.3. Variable Scope and Extra types Scoped Enumerations (Enum Class) type aliases typedef using struct member selection operator = . memory padding 최적화를 위해서 member들의 순서를 고려해야 한다. (e.g short type 2byte는 2바이트가 뒤에 padding된다.) 1.0.4. Matrix, String, Pointer, Reference nullptr(null pointer) void pointer == generic pointer reference variable :: : scope resolution operator ","date":"2022-10-01","objectID":"/hong_modern_cpp/:1:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"1. Basic C++ namespace using namespace namespace끼리 nested하게 사용가능하다. Macro (preprocessor) Build 타임전, 즉 컴파일 타임에 처리된다. (preprocessor) #ifdef, #ifndef 다음과 같은 경우는 multi platform 즉 여러 os 타입에 따라서 build를 다르게 해주고 싶을 떄, 사용한다. 혹은 gpu 버전에 따라서 버저닝 하고 싶을 때 사용한다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:2:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"2. Basic types Void type void 자체는 메모리가 할당되지 않기 때문에 선언이 불가하다. void my_void; // (x) 하지만 void의 포인터 타입은 메모리 address가 있기 때문에 선언이 가능하다. void *my_void; // (o) int i = 123; float f = 123.456f; my_void = (void*)\u0026i; my_void = (void*)\u0026f; 또한 모든 포인터 address의 사이즈는 같기 때문에 int, float, void 타입 상관없이 동일한 변수에 assign이 가능하다. (void*) void pointer type \u0026i, \u0026f: int와 float 변수의 address 값 Char type casting style // c-style casting cout \u003c\u003c (char)65 \u003c\u003c endl; cout \u003c\u003c (int)'A' \u003c\u003c endl; // c++ style casting cout \u003c\u003c char(65) \u003c\u003c endl; cout \u003c\u003c int('A') \u003c\u003c endl; static cast cout \u003c\u003c static_cast\u003cchar\u003e(65) \u003c\u003c endl; cout \u003c\u003c static_cast\u003cint\u003e('A') \u003c\u003c endl; static_cast의 경우, 명시적으로 type을 변경해주고 싶을 때, compile 타임에 형변환에 대한 타입 오류를 잡아주고 싶을 때 사용합니다. string buffer string operator는 buffer에 임시로 저장되기 떄문에, cin으로 받아들인 값의 경우 cout을 하지 않더라도 buffer에 임시로 보관되어집니다. char c1; cin \u003e\u003e c1; cout \u003c\u003c static_cast\u003cint\u003e(c1) \u003c\u003c endl; cin \u003e\u003e c1; cout \u003c\u003c static_cast\u003cint\u003e(c1) \u003c\u003c endl; $ abc 97 98 \\n vs endl vs std::flush \\n: new line하라. endl: buffer에 있는 모든 것들을 출력한 뒤, new line하라. std::flush: 줄바꿈 없이 buffer에 있는 것들을 모두 쏟아내라. Literal constants 리터럴 상수 unsigned int n = 5u; long n2 = 5L; double d = 6.0e-10; decimal, ocatal, hexa int x = 012; // 8진수 cout \u003c\u003c x \u003c\u003c endl; // 10 int y = 0xF; // 16진수 cout \u003c\u003c y\u003c\u003c endl; // 15 c++14 이후 부터 binary literal이 가능해졌다. 또한 literal 사이에 quota(')를 넣어주게 되면 '를 무시해주기 떄문에, 편하게 구분이 가능하게 되었다. int x = 0b1010; cout \u003c\u003c x \u003c\u003c endl; // 10 int x = 0b1010'1111'1010; // with quota cout \u003c\u003c x \u003c\u003c endl; // 10 Symbolic Constants C++ 11 constexpr // Both is allowed const double gravity { 9.8 }; double const gravity2 { 9.8 }; cout \u003c\u003c gravity \u003c\u003c endl; const는 보통은 앞에 붙인다. pointer ref를 배우게 되면 const의 순서에 따라서 의미상 차이를 가지게 된다. runtime constants (\u003c-\u003e compile time constants) const int compile_time_const(123); // compile time int num; cin \u003e\u003e num; const int runtime_const(num); // runtime c++ 11 부터는 runtime const와 compile-time const를 구분해주기 위해서 constexpr이 도입되었다. constexpr: 컴파일 타임에 initialize되는 상수를 뜻함 constexpr int compile_time_const(123); // compile time int num; cin \u003e\u003e num; const int runtime_const(num); // runtime 또한 constatns들은 일반적으로 하나의 파일에 몰아서 사용한다. MY_CONSTANTS.h #pragma once namespace constants { constexpr double pi(3.141592); constexpr double avogadro(6.22123e23); constexpr double gravity(9.8); } #include \u003ciostream\u003e#include \"MY_CONSTANTS.h\" using namespace std; int main() { cout \u003c\u003c int(constants::pi) \u003c\u003c endl; return 0; } ","date":"2022-10-01","objectID":"/hong_modern_cpp/:3:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"4. Variable variable scope using namespace std; int main() { const int apple = 5; { cout \u003c\u003c apple \u003c\u003c endl; // 5 int apple = 1; cout \u003c\u003c apple \u003c\u003c endl; // 1 } cout \u003c\u003c apple \u003c\u003c endl; // 5 return 0; } const를 사용하더라도 중괄호 안에서 변수는 새롭게 할당되기 때문에 할당이 가능하다. Global variable cout \u003c\u003c ::value \u003c\u003c endl; Static variable Internal Linkage: static int g_x; External Linkage int g_x; extern int g_x; extern const int g_x; Static variable in a Function os로 부터 메모리를 빌려와서, program lifetime 동안 재사용된다. 선언된 scope 블록 안에 제한된다. 즉 scope를 벗어난 공간에서, 해당 variable을 참조할 수 없다.( Global과의 차이) It gets allocated for the lifetime of the program. Even if the function is called multiple times, space for the static variable is allocated only once and the value of variable in the previous call gets carried through the next function call. #include \u003ciostream\u003e using namespace std; void doSomething() { static int a = 1; // It is called only once. ++a; cout \u003c\u003c a \u003c\u003c endl; } int main() { doSomething(); // 2 doSomething(); // 3 doSomething(); // 4 doSomething(); // 5 return 0; } 디버깅할 때, 함수가 몇번 호출되는지 확인하고 싶을 때 유용하게 사용가능하다. 전역변수 vs Static variable static은 접근 scope안에서만 할당이 가능한데 반하여, 전역변수는 실수로 다른 scope에서 할당을 하게 되면 원치 않은 결과를 만들어낼 수 있다. Linkage local variable은 해당 소스코드(모듈)에서만 사용되므로, linkage 시켜주지 않는다. Extern global // forward declaration extern void doSomething(); extern int a; int main() { ... } 참고로 extern은 생략 가능하다. 상수 메모리 낭비 header 파일에 const를 선언 및 할당까지 한 뒤, 외부 .cpp 파일들에서 이를 include 시키게 되면, 신기하게 모듈별로 const의 주소가 다르게 나온다. 즉, 메모리 낭비가 생긴다. 이를 방지하기 위해서는 header에는 signature를 넣어주고, extern const의 할당은 .cpp파일에서 하게되면 된다. MyConstants.h #pragma once namespace constants { extern const double pi; extern const double avogadro; extern const double gravity; } MyConstants.cpp #include \u003ciostream\u003e namespace constants { extern const double pi(3.141592); extern const double avogadro(6.22123e23); extern const double gravity(9.8); } helloworld.cpp #include \u003ciostream\u003e#include \"CONSTS.h\" using namespace std; void doSomething(); int main() { cout \u003c\u003c int(constants::pi) \u003c\u003c \" \" \u003c\u003c \u0026constants::pi \u003c\u003c endl; // 3 0x104037d70 doSomething(); // 3 0x104037d70 return 0; } helloworld2.cpp #include \u003ciostream\u003e#include \"CONSTS.h\" using namespace std; void doSomething() { cout \u003c\u003c int(constants::pi) \u003c\u003c \" \" \u003c\u003c \u0026constants::pi \u003c\u003c endl; } Using scope를 최대한 작게 가져가는게 좋다. 가능하면 .cpp에서 사용하는 것이 좋다. 전역 사용만큼은 무조건 피해라. namespace a { int dup_int(10); } namespace b { int dup_int(20); } int main() { using namespace std; { using namespace a; cout \u003c\u003c dup_int \u003c\u003c endl; // 10 } { using namespace b; cout \u003c\u003c dup_int \u003c\u003c endl; // 20 } } Auto Type inference 함수의 return type에 대해서도 auto를 사용할 수 있다. auto add(int x, int y) { return x + y; } trailing return type: 친절하게 설명을 위해서 사용 auto add(int x, int y) -\u003e int; auto add(double x, double y) -\u003e double; auto add(int x, int y) -\u003e int { return x + y; } Scoped Enumerations (Enum Class) C++ 11 Enum을 사용할 때, 주의해야할 점은 아래와 같이 index로 비교하게되면 엉뚱한 결과를 만들 수 있게 된다. #include \u003ciostream\u003e int main() { using namespace std; enum Color { RED, BLUE, }; enum Fruit { BANANA, APPLE, }; Color c = RED; Fruit f = BANANA; if (c == f) { cout \u003c\u003c \"True\" \u003c\u003c endl; } return 0; } 이를 방지하기 위해서 c++11 부터는 enum class가 도입되었다. #include \u003ciostream\u003e int main() { using namespace std; enum class Color { RED, BLUE, }; enum class Fruit { BANANA, APPLE, }; Color c = Color::RED; Fruit f = Fruit::BANANA; /* * 다른 타입끼리 비교하기 때문에 * 여기에서 에러가 발생한다. if (c == f) { cout \u003c\u003c \"True\" \u003c\u003c endl; } */ return 0; } Type aliases Type에 편의상 별명을 붙여주는 것 int main() { typedef double distance_t; double my_distance; distance_t home2work; distance_t home2school; return 0; } pair example // before #include \u003ciostream\u003e#include \u003cvector\u003e int main() { using namespace std; vector\u003cpair\u003cstring, int\u003e\u003e pairlist; return 0; } // after #include \u003ciostream\u003e#include \u003cvector\u003e int main() { using namespace std; typedef vector\u003cpair\u003cstring, int\u003e\u003e pairlist_t; // 위의 typedef 대신에 using을 사용할 수도 있다. using pairlist_t = vector\u003cpair\u003cstring, int\u003e\u003e; pairlist_t pairlist1; pairlist_t pairlist2; return 0; } #include \u003ciostream\u003e#include \u003cvector","date":"2022-10-01","objectID":"/hong_modern_cpp/:4:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Function Parameter function parameter #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, bool (*validator)(const int \u0026)) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with using or typedef #include \u003ciostream\u003e#include \u003carray\u003e using namespace std; // typedef bool (*validator_fnc)(const int \u0026); using validator_fnc = bool (*)(const int \u0026); bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr, isEven); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } function parameter with std::function and default parameter #include \u003ciostream\u003e#include \u003carray\u003e#include \u003cfunctional\u003e using namespace std; using validator_fnc = function\u003cbool(const int \u0026)\u003e; bool isEven(const int \u0026number) { return (number % 2 == 0) ? true : false; } bool isOdd(const int \u0026number) { return !isEven(number); } void printNumbers(array\u003cint, 10\u003e \u0026arr, validator_fnc validator = isEven) { for (int v : arr) if (validator(v)) cout \u003c\u003c v \u003c\u003c ' '; cout \u003c\u003c endl; } int main() { array\u003cint, 10\u003e my_arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; printNumbers(my_arr); // 0 2 4 6 8 printNumbers(my_arr, isOdd); // 1 3 5 7 9 return 0; } 매우 파이썬스럽게, 가장 깔끔해 보인다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:5:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"3. Matrix double pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int **matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[r][c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int **matrix = new int *[row]; for (int r = 0; r \u003c row; ++r) matrix[r] = new int[col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[r][c] = values[r][c]; printMatrix(matrix, row, col); // delete for (int r = 0; r \u003c row; ++r) delete[] matrix[r]; delete[] matrix; return 0; } single pointer #include \u003ciostream\u003eusing namespace std; void printMatrix(int *matrix, const int row, const int col) { for (int r = 0; r \u003c row; ++r) { for (int c = 0; c \u003c col; ++c) cout \u003c\u003c matrix[(col * r) + c] \u003c\u003c \" \"; cout \u003c\u003c endl; } } int main() { const int row = 3; const int col = 5; const int values[row][col] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}, }; // init int *matrix = new int[row * col]; // assign for (int r = 0; r \u003c row; ++r) for (int c = 0; c \u003c col; ++c) matrix[(col * r) + c] = values[r][c]; printMatrix(matrix, row, col); // delete delete[] matrix; return 0; } ","date":"2022-10-01","objectID":"/hong_modern_cpp/:6:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Pointer ","date":"2022-10-01","objectID":"/hong_modern_cpp/:7:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"Pointer and Const { using namespace std; const int value = 6; const int new_value = 7; const int *ptr_1 = \u0026value; // 6 0x7ffeefb45158 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; // *ptr_1 = new_value; (x) ptr_1 = \u0026new_value; // 7 0x7ffeefb45154 0x7ffeefb45148 cout \u003c\u003c *ptr_1 \u003c\u003c ' ' \u003c\u003c ptr_1 \u003c\u003c ' ' \u003c\u003c \u0026ptr_1 \u003c\u003c endl; } const int를 가리키고 있는 mutable한 포인터를 의미한다. 포인터가 가리키는 값이 const int이기 때문에 dereference해서 값을 바꿀 수 없다. 하지만 포인터 그 자체는 const하지 않기 때문에 새로운 주소값을 넣을 수 있다. { using namespace std; int value = 6; int new_value = 7; int *const ptr_value = \u0026value; // 6 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; *ptr_value = new_value; // ptr_value = \u0026new_value; (x) // 7 0x7ffee173e158 0x7ffee173e148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } int를 가리키는 *const 포인터. 포인터는 const이기 때문에 assign이 불가하지만, 포인터가 가리키는 값은 const하지 않기 때문에 변경 가능하다. 즉 포인터를 dereference(*)해서 값 대입 가능하다. c.f) int \u0026ref(레퍼런스)와 int *const ptr는 기능이 같다. { using namespace std; int value = 6; int new_value = 7; const int *ptr_value = \u0026value; // 6 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; value = new_value; // 7 0x7ffee6efb158 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; // *ptr_value = new_value; (x) ptr_value = \u0026new_value; // 7 0x7ffee6efb154 0x7ffee6efb148 cout \u003c\u003c *ptr_value \u003c\u003c ' ' \u003c\u003c ptr_value \u003c\u003c ' ' \u003c\u003c \u0026ptr_value \u003c\u003c endl; } 가리키는 값이 const한 int인 포인터. value 자체는 const가 아니기 때문에 assign 가능하다. value가 const가 아니지만, 포인터는 값을 const하게 처리하기 때문에 dereference가 불가능하다. 포인터 자체는 const하지 않기 때문에 주소 할당이 가능하다. { using namespace std; const int value = 6; const int new_value = 7; const int *const ptr_value = \u0026value; // ptr_value = \u0026new_value; (x) // *ptr_value = new_value; (x) } const int를 가리키는 *const 포인터. pointer value assign과 dereference를 통한 assign 둘 모두 불가하다. ","date":"2022-10-01","objectID":"/hong_modern_cpp/:7:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5. Reference ","date":"2022-10-01","objectID":"/hong_modern_cpp/:8:0","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev"],"content":"5.1. Reference and Const reference variable은 변수의 별명이다. (주소, 값 모두 같다.) 파라미터로 넘겨줄 경우, 다른 함수에서 변수를 변경가능하다. #include \u003ciostream\u003e void doSomething(const int value, const int \u0026ref) { using namespace std; cout \u003c\u003c value \u003c\u003c ' ' \u003c\u003c \u0026value \u003c\u003c ' ' \u003c\u003c ref \u003c\u003c ' ' \u003c\u003c \u0026ref \u003c\u003c endl; } int main() { int a = 5; // 5 0x7ffeeaf4e158 doSomething(a, a); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e158 doSomething(a, 5); // 5 0x7ffeeaf4e13c 5 0x7ffeeaf4e154 return 0; } 파라미터에 변수로 받는 것과, reference로 받는 것은 무슨 차이가 있을까? 파라미터를 변수로 받으면 value copy가 일어난다. (비효율) 반면 reference를 사용한다면 실제 원래 변수와 같은 주소를 가지게 된다. 또한 const int \u0026ref처럼 const reference를 사용한다면 immutable하면서도 reference로 파라미터를 받아 효율을 추구할 수 있다. literal의 주소를 기억할 수 없기 때문에, reference variable 대입에는 lvalue가 들어가야 하지만, const reference타입은 literal을 받을 수 있다. (이 경우 literal을 위한 주소가 할당 된다.) ","date":"2022-10-01","objectID":"/hong_modern_cpp/:8:1","tags":["c++"],"title":"홍정모의 따라하며 배우는 C++","uri":"/hong_modern_cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"Compare cpp and carbon with each language's base principles.","date":"2022-09-28","objectID":"/cpp/","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"Let’s deep dive into c++ and Carbon ","date":"2022-09-28","objectID":"/cpp/:0:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"tl;dr About main refs C++ Core Guideline C++ reference C++ FAQ ","date":"2022-09-28","objectID":"/cpp/:1:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"1. Principles ","date":"2022-09-28","objectID":"/cpp/:2:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"2. Compile and Linker https://en.cppreference.com/w/cpp/language/translation_phases https://en.cppreference.com/w/cpp/preprocessor ","date":"2022-09-28","objectID":"/cpp/:3:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["dev","cpp","modern cpp"],"content":"3. Why not C++? References Carbon README.md Difficulties improving C++ Carbon vs C++ Generics Memory Safety Carbon’s Principles Errors are values: recoverable Information accumulation: with forward declarations used to introduce names beforethey are first referenced when necessary. Low context sensitivity: 코드를 읽고 이해하는 데 필요한 컨텍스트의 양을 충분히 효과적으로 줄이기 위해쓰기뿐만 아니라 읽기에도 이점이 있는 간결함을 기꺼이 희생하겠다. Prefer providing only one way to do a given thing Safety strategy Memory safety Type safety Data race safety One static open extennsion mechanism Success criteria Difficulties improving C++ Carbon team failed to meaningfully change C++’s direction and priorities towards improvements rather than backwards compatibility, and demonstrates how the process can fail to make directional decisions. C++’s process is oriented around standardization rather than design ","date":"2022-09-28","objectID":"/cpp/:4:0","tags":["dev","principle"],"title":"Design principle of C++ and Carbon","uri":"/cpp/"},{"categories":["book","money","mind"],"content":"거래의 신 혼마, 주식시장의 캔들차트와 사께다 전법의 창시자를 읽고 ","date":"2022-09-14","objectID":"/honma-munehisa/:0:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"tl;dr 도서명: 거래의 신 혼마 읽은 기간: 3d (2022.09.13 - 2022.09.15) ","date":"2022-09-14","objectID":"/honma-munehisa/:1:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"1. 주제 질문과 주제 책의 주요 질문은 무엇이고 그에 대한 답은? Q: “혼마는 어떤 철학을 가지고 투자하였는가?” A: 원칙을 가지고 인내하고 용감해지며, 지혜로 원칙을 세운다. ","date":"2022-09-14","objectID":"/honma-munehisa/:2:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"2. 받은 영감 받은 영감, 연상된 점, 깨달은 점 혼마는 쌀(상업)을 사랑했고 이를 통해 자연과 자신을 보았다. 나는 만류귀종이라는 말을 참 좋아하는데, 자신의 전문분야를 통해서 세상을 해석하는 모습을 보면서, 나도 개발에 대한 철학을 자연에 빗대어 표현할 수 있는 수준까지 올리고 싶다고 생각했다. ","date":"2022-09-14","objectID":"/honma-munehisa/:3:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"3. 저자의 주장에 대한 나의 생각 “심오한 것은 천정 바닥의 순서를 심득하고, 매일의 시세에 주의하는 것이 원칙이다.” 혼마와 달리 나는 전업 투자자가 아니다. 매일 시세에 주의를 기울일 수 없을 뿐더러 재미없기 때문에 그렇게 하고 싶지도 않다. 그저 내가 관심있는 기술과 비전을 가진 기업에 투자하고 맘 편하게 있으면 안되는 걸까? ","date":"2022-09-14","objectID":"/honma-munehisa/:4:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"4. 질문 및 토의 사항 4-1. 원칙은 불변해야 하는가? 어느 주기로 원칙을 업데이트 해야할까? 나는 투자에 대해서 지식이 혼마, 워렌버핏 같은 인물들에 비해 훨씬 떨어진다. 그러니 내 원칙은 그들의 원칙에 비해 지혜롭지 못할 수 있다. 앞으로도 내 분석은 계속 더 지혜로워 질 것인데, 이미 투자를 하고 있다면 언젠가 과거가 될 내가 만든 원칙과 분석을 “인내\"라는 이름으로 계속 가지고 있어야 할까? 아니면 “용기\"있게 변경해야 할까? 만약 변경해야 한다면 그 주기를 어느 주기로 수정해야 할까? “한번 매입하면 원칙을 가지고 인내하면서 주변에 흔들리지 말고 매수하지 말아야 한다\"라는데, 누구나 그렇듯 그 원칙이라는 것은 죽을 때까지 완성되지 않을 것 같기 때문이다. 4-2. 혼마의 쌀 투자에 대한 디테일들은 오늘날 투자에서 어떻게 적용해야 할까? “쌀 가격이 점점 하락하여 상승 시세로 바뀜없이 각처 모두 최상의 가격물이 수없이 나와 있다는 풍문이며, 분위기도 모두 약하고, 얼마나 하락할지 모르며, 자신이 생각해도 약세장이라 생각할 때 마음을 돌려 매입할 것이다. 이렇게 함은 바닷속에 뛰어드는 심정으로 좀처럼 성공할 수 없을 것 같지만 그때 의심하지 않고 매입해야 하며, 반드시 이운이 된다. 하락한다고 전망될 때 생각한 대로 하락한다면 마음 편할지 모르지만 분위기가 하락한다고 방치할 때 오히려 상승하므로 생각이 따라가지 못하게 된다. 상승도 마찬가지로 즉 바닷속에 뛰어드는 심정이 비결이다. -혼마-” 쌀은 필수재이다. 그러므로 주식과는 성격이 조금 다르다. 일례로 쌀 가격은 상장폐지 할 수 없다. 그러므로 혼마의 투자법은 어쩌면 확실한 BM이 있어서 언론의 주목을 받을 수 있는 기업 또는 이미 주목 받고 있는 대기업에 통하는 투자법인 것 같다. ","date":"2022-09-14","objectID":"/honma-munehisa/:5:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"5. 작은 실천 계획 중요한 결정은 3일간 고민해보고, 매도/매수 타이밍 또한 삼법을 기억해보자! ","date":"2022-09-14","objectID":"/honma-munehisa/:6:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":["book","money","mind"],"content":"6. 자유 감상문 500자 이상 혼마는 3을 좋아하는 것 같기 때문에, 내가 느낀 것을 3가지로 정리해보았다. 사랑 혼마는 쌀을 통해 세상을 보았다. 이럴 수 있었던 것은 그가 쌀(상업)을 사랑했기 때문이라 생각한다. 어쩌면 이 덕분에 기다릴 줄아는 인내와 자연의 지혜를 얻은 것이 아닐까? 지금까지 나는 투자를 돈 벌이 수단으로 보았다. 사랑이 빠져있다. 물론 지금껏 내가 관심있는 기술을 다루는 회사들에 투자를 했지만, 여전히 근본은 투자를 사랑없이 돈 벌이 수단으로 보아왔다. 투자 또한 가슴 뛰게 해야겠다, 그렇게 되면 혼마 같이 인내할 수 있지 않을까. 하지만 사실 여전히 데이터나 수치들은 사랑스럽지 않게 느껴진다. 그래도 공부를 해야겠지.. 낭만 혼마의 상업 지혜는 부지런함이 근본으로 들어있다. 책의 느낌만 보면 혼마라는 인물에서 술을 마신다거나, 넷플릭스를 본다던가 하는 여유가 느껴지지 않는다. 그러다 보니 내가 느끼기에는 예수, 오쇼나 사이토 히토리에 비해 사랑이 덜하다는 느낌이 있다. 어쩌면 인내와 부지런함을 강조하는 느낌을 주는 사람들을 내가 싫어해서 일지도 모른다, 사랑과 열정이 먼저이고 인내와 부지런함은 수단일뿐 자연스럽게 따라오는 것인데, 혼마의 투자 원칙들에는 감정이 빠져 있어서 그런가? 그렇다면 투자에는 낭만과 인간적인 감정이 무조건 빠져야 하는걸까? 다시 생각해보니 이렇게 느껴지는 근본적인 이유는 어쩌면 혼마가 왜 쌀(상업)을 사랑하고 그 어마어마한 이윤을 얻었는지에 대한 동기가 책에 빠져 있어서 그런 것 같다. 문득 궁금해진다, 혼마는 그 많은 돈을 왜 벌었는지 왜 그렇게 까지 열심히 상업을 했는지에 대한 근본적인 이유가 말이다. 고집 나는 지금까지 직감에 의존해서 투자를 했으며, 투자에 대한 지식이 거의 없을 정도로 잘 모른다. 나는 직감을 사랑하지만, 투자에 있어서 혼마의 지혜는 나와 비할바가 아닌, 선생님임에도 불구하고 약간 비판적으로 읽고 있는 내 모습을 보면서 에고(고집)를 느꼈다는 점이 반성된다. ","date":"2022-09-14","objectID":"/honma-munehisa/:7:0","tags":["book"],"title":"Honma Munehisa","uri":"/honma-munehisa/"},{"categories":[""],"content":"The warm words of the wise rich old-man Saito Hitori ","date":"2022-09-10","objectID":"/hitori-saito/:0:0","tags":["dev"],"title":"Hitori Saito","uri":"/hitori-saito/"},{"categories":[""],"content":"나는 분명 성공한다. 부자의 행동습관 82p 지금 일을 찾고 있는 사람, 어떤 일을 시작하려는 사람이라면 잘 들어보세요. 그 일이 사업이든, 취업이든, 시험이든 상관없습니다. 지금부터 돈 이야기를 할 텐데, 뭔가 다른 얘길 기대했다면 미안합니다. 그래도 돈에 관한 예시가 알기 쉬우니까요. 예컨대 ‘저금통장에 1억이 있으면 좋겠다.‘고 가정해 봅시다. 그러면 우선 해야 할 일은 ‘나는 1억을 반드시 모을 수 있어.‘라고 확신하는 것입니다. 스스로에게 확신이 없으면 목표를 이룰 수 없습니다. 이는 10억의 경우도 마찬가지입니다. 확신을 가졌다면 자문해 보세요. ‘저금 통장에 모인 1억을 정말 상상할 수 있어?‘라고요. 상상할 수 있다면 다음으로는 1억을 모을 수 있는 행동을 취해야 합니다. 행동하지 않고서 돈을 버는 건 불가능하니까요. 가령 1억을 모으기 위해 메밀국수 가게를 열기로 했다면, 우선은 남의 밑에서 일을 배우러 가야겠지요? 1억을 10층짜리 건물이라고 치면, 가장 먼저 해야 할 일은 ‘1층 만들기’라고 생각하는 사람도 있습니다. 그러나 사실은 1층이 아닌 기초부터 만들어 나가야 합니다. 즉, 건물을 세우려면 우선은 땅에 구덩이를 파야 한다는 말이지요. 메밀국수 가게 하나를 열 때라도, 우선은 남의 밑에서 일을 배우는 기초공사에 해당하는 행동이 필요합니다. 만약 모으려 하는 돈이 10억이고, 이를 100층짜리 건물이라고 가정하면 지하 깊숙이 까마득한 곳까지 파야합니다. 다시 말해, 세우고자 하는 건물이 높으면 높을수록 깊은 구덩이를 파야 합니다. 그러니 일단은 행동하지 않으면 안됩니다. 1억을 모으고 싶은데 방법을 모르겠다면, 당장 저금통을 사 와서 하루에 1,000원씩이라도 저금하세요. 월급 중 10만원씩이라도 저금하는 등 생각을 행동으로 바로 옮기다 보면, 점점 좋은 아이디어가 떠오르게 됩니다. 즉 꿈은 목적지를 향해 가는 여정을 즐기며 행동하면 이뤄지기 마련입니다. 어떤 사람이 제게 일본 납세액 1위에 오른 이유는 불로소득 덕분이 아니냐고 묻습니다. 하지만 저는 불로소득을 얻는 방법 같은 건 궁리하지도 않습니다. 게다가 일본 납세액 1위도 불로소득을 통해 달성하지 않았습니다. 저는 열심히 일을 해서 납세액 1위에 올랐기 때문에 일을 해서 돈을 버는 방법밖에 모르며, 또 그 방법밖에 가르쳐 줄 수 없습니다. 불로소득을 얻는 방법은 재산을 그렇게 모은 사람한테 물어봐 주세요. 분명 그 사람에게도 나름대로의 방법이 있을 테니까요. 그러나 저는 사업가이므로 사업으로 돈을 버는 방법밖에 알려줄 수 없습니다. 따라서 제 방법으로 행동하면 분명히 성공합니다. 스파게티 가게든 뭐든 확실히 성공합니다. 성공한다고 믿으니 행동할 수 있습니다. 아무리 쉬운 일도 단번에 성공할 수는 없겠지요? 하지만 연습을 되풀이하면 결국은 성공하게 됩니다. 이처럼 몇 번이고 실패하더라도 ‘나는 분명 성공한다!’ 라는 확신이 있다면, 잘못된 점을 거듭 개선해 가며 성공을 향해 한 걸음씩 나아갈 수 있습니다. 개선하고, 개선하고 또 개선할 수 있는 이유는 나는 틀림없이 성공하리라는 확신이 있기 때문입니다. 운도 마찬가지입니다. 스스로를 운이 좋은 사람이라고 생각하면 행동할 수 있습니다. 그러니 확신을 가지고 미래에 성공한 자신의 모습을 상상해 보세요. 그리고 행동하세요. 행동하는 도중에 산이 있어서 방해된다면, 생각만 하지 말고 삽을 가져와서 조금씩이라도 산을 파내세요. 전력을 다해 파다 보면 여러 가지 아이디어와 지혜가 떠오릅니다. 행동이 뒤따르지 않는 소원은 진짜 소원이 아닙니다. 자기도 모르게 행동을 하고 싶어지고, 실제로 행동하게 되어야 합니다. 이 이야기는 100번 반복해서 읽어주세요. 100번 읽으면 제 뜻을 분명 아실 테니까요. 이상입니다. by Hitori Saito- ","date":"2022-09-10","objectID":"/hitori-saito/:1:0","tags":["dev"],"title":"Hitori Saito","uri":"/hitori-saito/"},{"categories":["dev","go","computer science"],"content":"Learn about Multithreading, Concurrency \u0026 Parallel programming with practical and fun examples in Google’s Go Lang. ","date":"2022-09-04","objectID":"/multithreading_with_go/:0:0","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"1. Introduction Concurrency의 세계에서는 thread 수를 아무리 높이더라도, 일정 수준이 지나면 병목현상이 생긴다. ","date":"2022-09-04","objectID":"/multithreading_with_go/:1:0","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"Amdal’s law Focus on latency (speed up) 암달의 법칙은 컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는 데 사용된다. 1 / ((1-p) + (p/s)) 작업의 portion이 낮은 작업을 아무리 개선시키더라도, 시스템 전체에 미치는 영향은 미미하다. 즉 전체 작업의 효율을 최대한 증가시키고 싶다면 그 중에 가장 비중이 큰 작업부터 초점을 맞추는 것이 좋다. (도표와 같이) 아무리 병렬작업이 늘어나더라도, 병렬화가 불가능한 작업들에 의해 병목현상이 발생하여 speedup의 한계가 정해지게 된다. from pprint import pprint def amdahl(p,s): \"\"\" Amdahl's law p is the proportion of execution time that the part benefiting from improved resources originally occupied. s is the speedup of the part of the task that benefits from improved system resources. \"\"\" return 1 / ((1-p) + (p/s)) def simulate(): # represents p in amdahl's law portion = [95/100, 90/100, 75/100, 50/100] # represents s in amdahl's law number_of_processors = [1,2,4,8,16,32,64,128,256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536] for s in number_of_processors: print(f'##################number_of_processors:{s}#############') for p in portion: pprint(f'parallel portion:{p}, speedup: {amdahl(p,s)}') simulate() \"\"\" ##################number_of_processors:1############# 'parallel portion:0.95, speedup: 1.0' 'parallel portion:0.9, speedup: 1.0' 'parallel portion:0.75, speedup: 1.0' 'parallel portion:0.5, speedup: 1.0' ##################number_of_processors:2############# 'parallel portion:0.95, speedup: 1.9047619047619047' 'parallel portion:0.9, speedup: 1.8181818181818181' 'parallel portion:0.75, speedup: 1.6' 'parallel portion:0.5, speedup: 1.3333333333333333' ##################number_of_processors:4############# 'parallel portion:0.95, speedup: 3.478260869565217' 'parallel portion:0.9, speedup: 3.0769230769230775' 'parallel portion:0.75, speedup: 2.2857142857142856' 'parallel portion:0.5, speedup: 1.6' ##################number_of_processors:8############# 'parallel portion:0.95, speedup: 5.925925925925925' 'parallel portion:0.9, speedup: 4.7058823529411775' 'parallel portion:0.75, speedup: 2.909090909090909' 'parallel portion:0.5, speedup: 1.7777777777777777' ##################number_of_processors:16############# 'parallel portion:0.95, speedup: 9.142857142857139' 'parallel portion:0.9, speedup: 6.400000000000001' 'parallel portion:0.75, speedup: 3.3684210526315788' 'parallel portion:0.5, speedup: 1.8823529411764706' ##################number_of_processors:32############# 'parallel portion:0.95, speedup: 12.54901960784313' 'parallel portion:0.9, speedup: 7.8048780487804885' 'parallel portion:0.75, speedup: 3.657142857142857' 'parallel portion:0.5, speedup: 1.9393939393939394' ##################number_of_processors:64############# 'parallel portion:0.95, speedup: 15.421686746987941' 'parallel portion:0.9, speedup: 8.767123287671234' 'parallel portion:0.75, speedup: 3.8208955223880596' 'parallel portion:0.5, speedup: 1.9692307692307693' ##################number_of_processors:128############# 'parallel portion:0.95, speedup: 17.414965986394545' 'parallel portion:0.9, speedup: 9.343065693430658' 'parallel portion:0.75, speedup: 3.9083969465648853' 'parallel portion:0.5, speedup: 1.9844961240310077' ##################number_of_processors:256############# 'parallel portion:0.95, speedup: 18.618181818181803' 'parallel portion:0.9, speedup: 9.66037735849057' 'parallel portion:0.75, speedup: 3.9536679536679538' 'parallel portion:0.5, speedup: 1.9922178988326849' ##################number_of_processors:512############# 'parallel portion:0.95, speedup: 19.284369114877574' 'parallel portion:0.9, speedup: 9.827255278310943' 'parallel portion:0.75, speedup: 3.9766990291262134' 'parallel portion:0.5, speedup: 1.996101364522417' ##################number_of_processors:1024############# 'parallel portion:0.95, speedup: 19.635666347075723' 'parallel portion:0.9, speedup: 9.912875121006778' 'parallel portion:0.75, speedup: 3.988315481986368' 'parallel portion:0.5, speedup: 1.9980487804878049' ##################number_of_processors:2048############# 'parallel portion:0.95, speedup: 19.816158684083195' 'parallel portion:0.9, speedup: 9.956246961594557' 'parallel porti","date":"2022-09-04","objectID":"/multithreading_with_go/:1:1","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"Gustafson’s law Focus on Throughput S(P)=P−a(P−1) P: 프로세서의 갯수 a: 병렬화되지 않는 부분의 비율 S(P): 이론상 성능 향상 비율 성능 향상은 같은 시간 동안 처리하는 데이터량의 비율을 의미한다. Useful refs ","date":"2022-09-04","objectID":"/multithreading_with_go/:1:2","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"2. Creating and using thread ","date":"2022-09-04","objectID":"/multithreading_with_go/:2:0","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"process vs thread vs green thread 먼저 process는 memory space를 isolate하게 관리하며, fork()를 통해서 복사된다. thread는 memory space를 공유하기 때문에 isolate하지 않으며, thread간 context switch에 따른 overhead가 발생한다. 아래는 single processor에서 multi thread를 표현한 그림이다. context switch의 오버헤드는 스레드 수가 많지 않다면 큰 비중을 차지 하지 않지만, 스레드 수가 커짐에 따라 문제가 발생한다. 이에 대한 대안으로 green thread가 사용되는데, green thread는 쉽게 말해 user level thread로 kernel level thread(흔히 우리가 말하는 thread)과 1:n관계를 가진다. 하나의 kernel thread안에서 여러 green thread가 존재하기 때문에, 연산중이 kernel thread안에 존재하는 특정 green thread에서 IO 연산이 필요하여 Interrupt가 발생할 경우, io 연산이 불필요한 green thread들 까지 불필요하게 cpu연산을 하지 못하게 된다. kernel thread의 green thread중 일부에서 io interrupt이 발생하면 나머지 kernel thread에 존재하는 다른 green thread들도 cpu연산이 block되어서 java나 python계열에서 g-thread를 사용하려면 asnyc로 io를 처리해야 한다. “When a green thread executes a blocking system call, not only is that thread blocked, but all of the threads within the process are blocked. To avoid that problem, green threads must use asynchronous I/O operations, although the increased complexity on the user side can be reduced if the virtual machine implementing the green threads spawns specific I/O processes (hidden to the user) for each I/O operation.” Wikipedia 이를 해결하기 위해 golang에서는 hybrid 방식의 green thread를 사용한다. 즉 io가 필요한 green trhead가 발생할 경우, 동일한 방식으로 io interrupt를 시키면서 새로운 kernel level thread를 만들어주어, io연산이 불필요한 green thread들을 새로운 스레드로 넣어주어 효과적으로 동작하도록 한다. ","date":"2022-09-04","objectID":"/multithreading_with_go/:2:1","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["dev","go","computer science"],"content":"Boids algorithm https://en.wikipedia.org/wiki/Boids Boids is an ai program, developed by Craig Reynolds in 1986, which simulates the flocking behavior of birds. The rules applied in the simplest Boids world are as follows separation: 무리가 붐비지 않도록 반대 방향으로 이동(steer to avoid crowding local flockmates) alignment: 무리의 평균 방향으로 이동 (steer towards the average heading of local flockmates) cohesion: 무리의 평균 위치를 향해 이동 (steer to move towards the average position, which is center of mass of local flockmates) ","date":"2022-09-04","objectID":"/multithreading_with_go/:2:2","tags":["dev"],"title":"Mastering Multithreading Programming with golang","uri":"/multithreading_with_go/"},{"categories":["life","book","heart"],"content":" Whatever thy hand finds to do, do it with all thy heart by Jesus ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:0:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH00 이 챕터에서는 저자가 유망한 로스쿨 입학하여, 공부하다 갑자기 학교를 그만두고 전세계로 유명 인사들을 만나서 이야기 나눈 여정과 그 도전을 하기까지의 동기부여를 말하고 있다. I had begun thinking: What did I really want from life? What was my goal? I felt I’d lost my way and I was worried about my future. It’s fine to ask yourself what you want from life, but a far more important question is, What does life want from you? … it’s important to allow moments of silence into your life, because silence can let you escape the mental noise that we call “thinking.” I also didn’t want to disappoint my parents, who had been proud of my academic success and career choice. ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:1:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH01 The way is not in the sky. The way is in the heart by Buddha Whatever thy hand finds to do, do it with all thy heart by Jesus Abide at the center of your being, for the more you leave it, the less you learn. Search your heart-the way to do is to be. by Laozi The higher order of logic and understanding originates in your heart. It is experienced in your heart. It is lived in your heart. by Gary zukav We think of the heart in the poetic sense, the seat of love and compassion and it’s this heart that is so terribly important. by Jane goodall ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:2:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":["life","book","heart"],"content":"CH02 파울로 코엘료가 어린시절 내향적이고 고집스러운 아이로 보여서 부모님에 의해 정신병원에 보내졌고, 20대에는 저자와 마찬가지로 law school에 입학했지만 drop out한 스토리가 나온다. From the moment that I realized that I wanted to be a writter, I said, “It may take ten days, ten years, or twenty years, but I am going to write.” I started by writing songs; I started writing articles for newspapers. I had no choice but to follow the thing that I wanted to do. by Paulo cohelho When you lose touch with your heart, you lose touch with your true self. You may feel unmoored and aimless; the world around you seems colorless, dull, and bleak. You cannot remember where you are going with your life. But as soon as you reconnect with your heart, eveything begins to improve. You are never truly lost when you know your heart. ","date":"2022-08-22","objectID":"/the-power-of-the-heart/:3:0","tags":["dev"],"title":"[Book] The Power of the Heart by Baptist De Pape","uri":"/the-power-of-the-heart/"},{"categories":[""],"content":"In this article, I’ll describe the cheapest way to deploy server with GCP in a side project ","date":"2022-07-09","objectID":"/gcp_build/:0:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"tl;dr Deploy API server with Cloud run Deploy DB server with Cloud SQL Build CI/CD pipeline with github action and Cloub build ","date":"2022-07-09","objectID":"/gcp_build/:1:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Deploy MySQL Database server with Cloud SQL in Google cloud platform Cloud SQL meta At first fill in your database meta data. Set instance id Set databse password MySQL version Region (taiwan) Set single zone The myply mainly serves to korean users, but I selected Taiwan(asia-east1) because of pricing issue. detail price description Cloud SQL Status Select db-f1-micro I set a machine type to Shared core with 1vCPU, 0.614. This spec is called db-f1-micro. It costs $7.665 per month, which is the cheapest spec in cloud sql. If I calculated it in ₩, the currency of the south korea. $7.665 * 1300 = ₩9,964 per month db-f1-micro Based on Official cloud sql docs The db-f1-micro and db-g1-small machine types aren’t included in the Cloud SQL SLA. These machine types are configured to use a shared-core CPU, and are designed to provide low-cost test and development instances only. Don’t use them for production instances. Note: The db-f1-micro and db-g1-small machine types are not included in the Cloud SQL SLA. These machine types are designed to provide low-cost test and development instances only. Do not use them for production instances. Select HDD storage 10GB is the lowest storage size. $0.09 per GB/month * 10GB(min) = ₩1,170 per month Cloud SQL misc.1 Cloud SQL misc.2 Cloud SQL misc.3 So total GCP cloud SQL database server will cost ₩ 11,134($8.56) per month. ","date":"2022-07-09","objectID":"/gcp_build/:2:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Buil CI/CD pipeline with github action and Cloud Build Before deploy cloud run, you should set cloud build to apply continuous integration and continuous deployment(CICD). Link with github repository Enable Cloud Build API (almost free) Enable Container analysis API (free) Install GCP Build plugin to your repository Set your repository to cloud build Select branch to be triggered and Dockerfile locaiton Select branch to be triggered Enter Dockerfile loaction If you have multi phase (e.g. local, sandbox, beta ,prod) it would be useful to set dockerfile name as dockerfile.prod. FROMgolang:1.18-alpine AS builderLABEL maintainer=\"leoo.j \u003cminkj1992@gmail.com\u003e (https://minkj1992.github.io)\"# Move to working directory (/build).WORKDIR/build# Copy and download dependency using go mod.COPY go.mod go.sum ./RUN go mod download# Copy the code into the container.COPY . .# Set necessary environment variables needed for our image and build the API server.ENV CGO_ENABLED=0 GOOS=linux GOARCH=amd64 RUN go build -ldflags=\"-s -w\" -o apiserver ./application/cmd/main.goFROMscratch# Copy binary and config files from /build to root folder of scratch container.COPY --from=builder [\"/build/apiserver\", \"/build/.env\", \"/\"]# Command to run when starting the container.ENTRYPOINT [\"/apiserver\"] ","date":"2022-07-09","objectID":"/gcp_build/:3:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Deploy API server with Cloud run in Google cloud platform Select Continuously deploy new revisions from a source repository. Select region as Taiwan(asia-east1) Select Cpu is only allocated during request processing Set number of instance (Autoscaling) (0 ~ 4) Set Container status Set application server’s port number Set memory 128Mib(lowest) Set Number of vCPUs less than 1. Set Execution environment to First generation (slower than 2nd generation) Connect Cloud SQL instance Click Connections tab \u003e Cloud SQL connections \u003e +Add Connection button Connect Cloud SQL instance 2 ","date":"2022-07-09","objectID":"/gcp_build/:4:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":[""],"content":"Conclusion Through the steps so far, I have covered the cheapest way to deploy a gcp service for a side project topic. Now if you have followed all the steps so far, go to your github repository and merge it into the main branch. Then the service will deployed according to the Dockerfile you set. ","date":"2022-07-09","objectID":"/gcp_build/:5:0","tags":["dev"],"title":"The cheapest way to build GCP","uri":"/gcp_build/"},{"categories":["gcp"],"content":"사이드 프로젝트를 하면서 GCP로 배포할 때, 서버 비용이 걱정되었다면! ","date":"2022-07-07","objectID":"/gcp_pricing/:0:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"tl;dr 사이드 프로젝트 성격인 서비스에, 대부분의 사용자가 한국인이라고 가정하면 아래와 같이 설정하면 됩니다. Just use Taiwan region for every instance Check cloud run minimum instance number(set 0) Set cloud sql vCPU 1 ","date":"2022-07-07","objectID":"/gcp_pricing/:1:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Intro 2022년 6/25일(현재 날짜 7/7일) GDG 해커톤을 통해 정말 간단한 golang 서버를 배포했었다. 갑자기 문득 궁금한 생각이 들어, cloud console에 가서 금액을 확인해보니,, ₩268,826,, 말이되나? 트래픽 없는 해커톤 서비스가, 약 12일 정도 사용했는데 26만원 찍혔다는건 말도 안된다. 이에 대한 이유를 분석해보고 다음 myply 사이드 프로젝트를 할 떄, 적용해보기 위해서 정리를 해봅니다. 대부분 cloud sql이 잡아먹고 있었다. (원인: vCPU 4인 default instance가 살아있어서) cloud run은 100만건까지는 공짜인줄 알았는데, 500원씩 사용되었다. (원인: min instance count 1로 되어있었다.) ","date":"2022-07-07","objectID":"/gcp_pricing/:2:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"GCP network https://cloud.google.com/vpc/network-pricing Ingress ( users -\u003e instance ) is free egress ( kr -\u003e taiwan $0.05 ) ","date":"2022-07-07","objectID":"/gcp_pricing/:3:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Cloud run https://cloud.google.com/run/pricing Set cpu less than 1, memory 128MiB Check CPU is only allocated during request processing Execution env to set First generation Set autoscaling min number of instances field to 0. (max: 4~5?) cloud run pricing by region, FYI, seoul is 2nd grade. ","date":"2022-07-07","objectID":"/gcp_pricing/:4:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Cloud SQL https://cloud.google.com/sql/pricing Set number of vCPU 1 (4로 설정하면 대략 하루 18,000원) Seoul이 vCPU가격이 다른 region에 비해서 훨씬 높다. -\u003e Select Taiwan Taiwan의 경우 us-central들과 가격 정책이 같다. lowa seoul Data Egress(outboud) pricing Set cloud run region same as cloud sql ","date":"2022-07-07","objectID":"/gcp_pricing/:5:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["gcp"],"content":"Conclusion 저와 비슷한 환경에서 사이드 프로젝트를 한다면 cloud run과 cloud sql을 지금까지 분석했던 방식으로 설정하면 될 것 같습니다. 단, 트래픽이 늘어나서 taiwan \u003c-\u003e korea에 대한 이그래스 가격이 합리적이지 못하다고 느낀다면, region을 seoul로 바꾸는 것도 좋아보입니다. 간단하게 계산해보면 18GB(9/0.5)이상의 트래픽이 한달 간 발생한다면, region을 다시 seoul로 바꿔서 서비스해야 할 것 같습니다. 단 트래픽이 늘어나면 sql vCPU도 늘어나야 하기 때문에 다시 계산해야 될 수도 있습니다. (여기서 $9는 cloud sql single vCPU 한달 사용 차액 $9(taiwan - seoul, per vCPU)) 정리하면, youtube의 홈화면(최적화가 잘되어있다는 것도 감안 필요, 또한 스트리밍 시청하게 되면 영상 사이즈로 고려해야 함)은 약 613kb 네트워크 리소스를 사용하며, 이를 18GB만큼 사용하려면 29363.7846656으로 해당 서비스가 약 한달에 3만번 이상 hit를 받는 서비스라고 생각한다면, 네트워크 이그레스를 고려해야 한다. ","date":"2022-07-07","objectID":"/gcp_pricing/:6:0","tags":["dev","money"],"title":"Google Cloud Computing 가격 정책 비교","uri":"/gcp_pricing/"},{"categories":["life"],"content":" Life as travel 🛫 ","date":"2022-07-04","objectID":"/2022_first_half/:0:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"🗒 TL;DR Goal of 2022 2022 visionboard 해외 기업 취업 (영어) 커리어 전환 (robotics or Dao freelance) Hawaii or california 오픈소스 기여 Ros2 or Cosmos or NASA open source or Rust Based project co-project with GF Communicate Youtube Lecture Blog Earn 5억 IoT 프로젝트 제품 판매 Study Refactoring Rust Go Gin Framework grpc / Protobuf Monorepo(Bazel) Arduino IoT core Solidity Web3.0 아침 마다 명상 킥복싱 운전면허 따기 영어 free talking ","date":"2022-07-04","objectID":"/2022_first_half/:1:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"1. 🚸 카카오 퇴사 Step out of my comfort zone 21년 8월 즈음 같이 일하던 블록체인팀이 krust로 분사를 하면서 이직 제안을 받았었고(나를 제외하고 제안받은 모든 사람들은 이직을 하였고 엄청난 레거시들과 함께 혼자 남았다), 이때 부터 진지하게 이직해야지 라는 생각을 가지고 있었지만 번아웃이라는 핑계로 결정을 미루고 있었다. 그러다 보니 열심히는 살았지만 실질적으로 이직에 도움이 되는 어떤 행동들을 취하지 못했었다. 21년 12월 일기 21년 12월 어느날, 문득 회사를 다니다가 퇴사를 하고 싶다는 생각을 하게되었다. 사실 대단하게 생각한 것은 아니고, 평소에 내가 회사 업무에 대해서 얼마나 열정을 가지고 시간을 쓰고 있는지를 생각해보니, 처음 취업을 준비했던 때 만큼 열정적으로 살고 있지 않다고 생각했기 때문이다. 신기하게도 막상 퇴사를 해야겠다고 마음속으로 결정하니, 그 다음 부터는 가슴이 뛰며 새롭게 공부하고 싶은 분야들과 강의들이 눈에 들어왔다. 그렇게 한동안 카카오에서 하고 있는 일정을 바쁘게 진행하면서, 퇴근 후 복싱 그 후 해외 개발 유튜버들이 보여주는 관심있는 기술 스택들을 2배속으로 들으면서 지냈다. 퇴사를 결심하며 그렇게 약 한달 정도 시간을 보내고 부모님과 형에게 내 퇴사에 대한 내 생각을 말했다. 이렇게 1달의 시간이 필요했던 이유는 2가지 인데 그 동안 카카오라는 브랜드 뒤에 숨어서, 나는 잘하는 개발자야 라는 우월의식을 가지고 있었다. 같이 정말 바쁘게 일하고 있는 joel, scott에게 나중에 퇴사하겠다고 말할 걸 생각하니 숨이 턱 막혔다. 생각보다 1번의 마음이 있어서 인지, 카카오를 버린다고 생각하니, 내 실력에 대한 믿음이 흔들렸고 “과연 내가 이직 시장에서 통할까?” “이력서/면접 너무 귀찮다.. 나는 번아웃 상태인걸?” 같은 무섭다는 생각과 귀찮은 마음이 공존했었다. 하지만 이런 생각들 보다, 로보틱스나 web3같은 새 도전을 해보고 싶다는 생각이 더 컸기 때문에 내 의사를 가까운 지인들에게 알리기 시작했다. with father 사실 내 인생은 내 책임이라는 생각이 있기 때문에, 주변 사람들의 지지를 받을 필요는 없다고 생각하지만, 여러 사람들에게 내 의사를 전달하면서, 내가 어떤 것을 원하는지, 이직을 한다면 어떤 이유 때문에 하는 건지가 명확하게 정리가 되었다. Digital card team 그렇게 여러 면담들을 거쳐, 3월3일 카카오에 마지막 출근을 하였다. Bye Kakao ","date":"2022-07-04","objectID":"/2022_first_half/:2:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"2. ✍️ 이직 준비 그리고 합격 Hello My name is … 21년 12월 즘 퇴사 마음이 생겼을 때, 블록체인 TF때 같이 일했던 지인이 로보틱스 회사로 이직했다는 게 기억이 나 오랜만에 연락을 해 근황과 이직한 회사에 대해 알아보았다. 결과적으로 회사가 로보틱스와 영어 경험 둘 모두를 경험할 수 있는 좋은 기회라 생각 되어 그날(강릉 가족여행 중) 바로 이력서를 작성해 지원하였다. 하지만 이 때 당시 심적으로 많이 지쳐있어서, 사실 이직을 하고 싶은지 잘 판단이 서질 않았지만 그래도 퇴사 \u0026 이직준비는 자연스럽게 같이 진행하는 절차인 것 같아, 어느정도 될 건 된다는 마인드로 이력서를 준비했다. (비록 P이지만 plan c까지 준비하긴 했다.) A. Robotics B. Gitcoin freelance C. Canada Master's Degree 그렇게 서류는 통과되었고, 21년 12월 중순에 과제 전형을 시험봤다. ATM 을 만드는 과제 전형이었는데, 준비하면서 command pattern, strategy pattern, transaction 등을 구현해보면서 정말 재미있게 과제를 진행했었다. 그래서인지 면접까지 자연스럽게 진행되었다. 면접은 1/14일에 오전 7시 - 12시까지 총 5명의 면접관들과 면접을 진행하는 방식이었으나, 마지막 영어로 진행되는 CTO와의 면담은 일정 문제로 취소가 되었다. 그래서 총 4시간 면접이 진행되었는데, 온라인으로 진행되었다. 4시간이라는 압박도 있었고, 실리콘 밸리 스타트업이다 보니 기존에 경험한 면접과 다소 다른 방식으로 진행될 것 같아 면접 전까지는 개인적으로 꽤 긴장을 하였지만, 막상 면접관님들을 보니 그렇게 까지 긴장되지는 않았다. 1/14일 일기장 中 어제 너무 가슴이 뛰어서 3시까지 잠을 자지 못했다. 7시에 기상해서 면접을 보았다. 면접관 중 한 분이 과제에서 transaction을 만든 것에 칭찬을 해주셨다. 이후 긍정적인 답변을 얻어, 연봉협상과 이직 날짜를 정하였다. ","date":"2022-07-04","objectID":"/2022_first_half/:3:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"3. 🏠 성수/뚝섬 이사 Be Alone 새로운 회사가 성수에 있기 때문에, 본가(광교)에서 약 1시간 반정도 출퇴근 시간이 필요했다. 이때는 새로운 회사가 재택근무를 허용하지 않는줄 알고, 당연히 자취해야지 생각하고 방을 구했다. First day 부모님과 성수에 5곳정도 방을 보고, 그날 바로 방을 구했다. 창문이 크고, 근처에 카페가 많아서 여기로 정했다. 약 8평 정도 되어서 혼자 살기에도 적당했고, 채광이 좋았다. ","date":"2022-07-04","objectID":"/2022_first_half/:4:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"4. ⚽ 차였다 T can cry 1~2월 즈음 퇴사와 이직을 준비하는 사이, 좋아하는 사람이 생겨서 고백했는데 차였다. 친구로 접근해서 꽤 오랜기간 친해졌는데, 얄짤없었다. 그래도 차이면서 멋있고 싶어서 마지막 톡일 것 같다고 잘지내라고 하며 비운의 영화배우에 빙의되어 멋지게 돌아섰다. 그날 저녁 AJR-100 Bad days를 계속 들으며, 지하 주차장에서 울었다. 형이 미국 떠날 때 이후로 2년 만에 처음 울어본 것 같다. 그렇게 눈물을 흘리고 정확히 3일 뒤에 다시 연락해서 절교하자고 한거 무르기 가능?라고 연락했고 ㅗ라고 답변을 받았다. 그래도 다시 서로 웃으면서 친구하기로 했다. Quote 역시 멜로보단 로멘스 코미디 👍 ","date":"2022-07-04","objectID":"/2022_first_half/:5:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"5. 🐈 ExchangeDiary project Take heart github repo: Exchange Diary 카카오를 퇴사한 뒤, 가장 먼저 계획한 건 7일안에 golang공부 끝내기와 golang을 활용한 프로젝트 만들기 였다. 그렇게 go 공부를 빠르게 한 뒤, 프로젝트에 뛰어들었다. Exchange Diary Flow 생각보다 곳곳에 까다로운 로직들이 있어서 힘들었지만 재밌는 경험이었다. 그리고 무엇보다 업무가 아닌 내 자유의지로 학습하며 프로젝트를 만들면서 자신감도 많이 얻었던 것 같다. What I learned Golang Gin framework Hexagonal architecture pros/cons GCP Goodle Cloud run Cloud Build Cloud Storage Firebase notification Cloud Task Hexagonal 비록 일정이 조금씩 미뤄지고, 나 또한 회사 출근이 다가오게 되어 중간에 하차하였다. 이 프로젝트를 통해 개인적인 깨달음은 다음과 같다. Wisdom 우선순위: 프로젝트의 핵심 BM이 있어야 한다. (잡다하게 많은 feature는 필요없다.) 동기부여: 팀 멤버들이 명확하게 BM과 목표를 공유해야 한다. (1달 지나면 왜 개발해야하는지 목적성을 잃어 버림) 3개월 노력 물거품 방지: 아무리 못해도 운영될 서버 비용 정도는 수익으로 얻는 서비스가 만들어져야 한다. 여러모로 많은 것은 얻은 프로젝트여서 미안한 마음과 고마운 마음이 있다. 🙏 ","date":"2022-07-04","objectID":"/2022_first_half/:6:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"6. 🤖 Bear robotics Hello, New Bear! 실리콘밸리 로보틱스를 스타트업에 이직했다. 구글 출신 개발자분들께서 창업해주셔서 그런지 정말 좋은 개발문화를 가지고 있다고 생각했다. 그 중 크게 2가지를 꼽아보자면 Ownership: FANG처럼 회사에 기획자가 없다. 프론트/백 구분 또한 없다. 이를 통해서 본인이 서비스에서 기여하고 싶은 부분을 찾고, proposal 및 디자인 발표를 한 뒤 성과를 보여주면 된다. 결국은 개인이 회사 뒤에 숨지말고 맞든 틀리든 목소리를 내야한다는 걸 배웠다. 흘러가는데로 사는게 아니라 자기가 주도해야된다는 점에서 인생이랑 비슷하다고 생각했다. English: slack도 영어, code review도 영어, Merge request도 영어, 심지어 회의도 영어.. 나는 정말 운이 좋게 CTO 면접(영어 면접) 없이 회사에 합격했었다. 개인적으로 나는 스피킹이 정말 많이 부족한데, 그래서 해외 팀과 일을 할 때 많이 스트레스를 현재도 받고 있다. 회의에서 개발새발 영어로 말할 때면 개인적으로 많이 쪽팔리고 자존심이 상한다. 보란듯이 이겨내야지 회사에서 링글을 지원해줘서, 이 기회에 영어 스피킹을 만족스럽게 가져갈 예정이다. ","date":"2022-07-04","objectID":"/2022_first_half/:7:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"7. 🇺🇸 친형의 미국 Jika ada pertemuan, juga ada perpisahan Bro 극한직업: 동생 우애 미국에 살고 있는 형은 원래 1년에 한번씩은 한국에 왔었다. 그러다 코로나 때문에 2년 넘도록 만나질 못했는데, 이번년에는 다행히 한국에 올 수 있었다. 약 2달간 형은 한국에 있었는데 그러면서 가족끼리 제주도, 강릉여행을 다녀오며 좋은 시간을 보낼 수 있었다. 형은 중학교 때 약 1~2년 미국에서 살았고, 이후에 한국에 살다가 다시 대학교를 미국으로 다니게 되면서, 성인이 되고 난 뒤 부터는 약 1~2년에 한번씩 만나고 있다. 즉 1~2년에 한번씩 형과 이별을 해야한다. 그럼에도 불구하고 이별을 할때의 기분은 아직도 적응이 되지 않는데, 매번 형을 인천공항에서 떠나보낼 때마다, 이루 말할 수 없는 먹먹함이 몰려와서 개인적으로 많이 슬프다. 이번에도 형과 함께 여행을 다니면서도, 자기전에 문득 “몇일 지나면 형은 다시 없겠네?” 같은 슬픈 생각이 들었다. 형이 미국에 돌아갈 시간이 다가오면 올 수록, 가족원들 모두 말은 하지 않았지만 아련한 기운이 조금씩 느껴졌다. 그렇게 형이 미국가기 약 일주일전? 마냥 수동적으로 다가올 이별을 맞이하는게 아니라, 능동적으로 이별에 대처하고 싶어 가족 톡방에 제안을 했다. Proposal 제목: 민욱이의 제안 Know also that wisdom is sweet to your soul; if you find it, there is a future hope for you, and your hope will not be cut off. (Proverbs 24:14) 시간은 목표가 없으면 정말 빠르게 지나간다고 생각합니다. 제가 돌아 봤을 때 그렇게 지나간 시간들은 그것에 비례해서 정말 크게 후회를 만든다고 생각합니다. 그 만큼 저에게는 목표를 말하고 그걸 공유할 수 있는 자리가 굉장히 중요한데요. 제 나이 31살, 지금 껏 다양한 사람들을 만나봤지만 목표를 말할 수 있었던 관계는 손에 꼽을 정도라고 생각됩니다. 그러다보니 오히려 가까운 관계일 수록, 그게 가족이라면 더욱, 이런 이야기를 하는게 값진 시간일 것이라 생각해요. 그래서 한 가지 제안을 드리고 싶은 것은, 형이 미국으로 가는 시간을 수동적으로 안타까워 하면서 기다리기 보다, 능동적으로 다시 형을 만났을 때 개인적으로 가장 중요하다고 생각되는 비전과 그걸 성취했다고 남들이 말할 수 있는 객관적인 수치 이 2가지를 가족 끼리 공유했으면 좋겠어요. 제가 생각하는 공유 날짜는 6/10일 금요 예배 이후 시간입니다. 가나안 땅에 입성 시 갈렙의 추정나이는 78세(한국나이 80세) 였다고 해요. 개인적인 욕심으로는 갈렙이 “이 산지\"라는 명확한 목표가 있었 듯이, 가족들 모두 평가 받을 수 있는 뚜렷한 목표가 있었으면 좋겠습니다 🙃. 이런 글이 저의 처음이자 마지막 글일 것 같은데요? 아빠, 엄마, 형 모두 동의 한다면 진지하게 비전을 나눠서 진지하게 공유했으면 좋겠습니다. 단, 제가 생각할 때는 “개인(제발 개인)이 도전 할 수 있어야 비전이라고 생각해요, 타인에 대한 비전은 삼가 줬으면 좋겠습니다”. 기도를 하며 감동 오는 부분들을 특히 개인적인 도전들에 대해서 공유할 수 있는 자리 였으면 좋겠습니다. Family vision 나 자유롭게 살고 싶다. 경제적으로 재미있고 새로운 일을 계속 도전하고 경험하여 전문가가 되고 싶다. 사랑하고 싶고 높아지기 위해 사람을 이용하고 싶지 않다. 하고 싶은 일 강의 찍기 로봇틱스 프로젝트: 22.7월부터 별도로 시작 (5억) 매력적인 사람이 되자 금연프로그램 신청 킥복싱대회 출전 샐러드 신청 형 … 엄마 … 아빠 … 분명 가족끼리 꿈을 공유하는 건 어색한 상황이지만, 이번 기회로 가족끼리 목표를 나누고 나니 형을 떠나 보내면서 도리어 열정을 가지고 다음 만남을 기다릴 수 있어서 좋았다. (물론 인천공항에서 이별은 아직도 적응이 되지 않는다. 😢) 아 참고로 나를 제외하고 우리 가족 모두는 크리스찬이다. 그리고 나 또한 기독교인은 아니지만, 성경에서 많은 영감을 받는다. Family TMI 형과 이별을 준비하면서 느낀 감정들을 기념하고 싶어 목걸이를 구매했다. 터키석 목걸이를 찾고 있었는데 구찌 모델중에서 디자인이 과하지 않으면서 눈에 쏙들어오는 모델이 있어, 그날 바로 구매했다. Life as travel ","date":"2022-07-04","objectID":"/2022_first_half/:8:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"8. 🔓 3개월 수습 끝 Self evaluation “I am not satisfied with the MQTT task. But I love my team and bear. I think I am the right person for my position.” by minwook. 나는 MQTT 작업 때문에 매우 낮게 나를 평가했지만, TL이 좋게 나를 평가 해주었다. 감사하다. 추가로 비전에 대해서도 이야기를 나누게 되었는데 개인적으로 도전이 되었다. 과연 나의 비전은 뭘까? 버킷리스트 같은 꿈말고 크리스찬 용어를 빌려오자면, 선한 영향력을 주변에 주는 비전을 가지고 싶다. 참고로 퍼블릭 사운드 의 이 분도 우리팀이다. 많이 도전이 된다. 수습 기간 동안 주로 작업했던 방역로봇 ","date":"2022-07-04","objectID":"/2022_first_half/:9:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"9. 🤔 친한형이 회사를 차렸다. 아는 개발자 형이 1년간 준비를 거쳐, 창업하게 되었다. 현재 퇴사 절차를 진행중인데, 준비 과정을 옆에서 보면서 많은 도전을 받고 있다. 나랑 한살 밖에 차이가 나지 않는데, 개발 실력은 두말할 것 없고 바쁘게 회사를 다니면서도 창업에 필요한 프로토타입들 하나 하나 개발하는게 정말 멋지다고 생각이든다. 그러면서도 야나두?라는 생각이 문득 문득 든다. 만약 내가 열정 없이 시간을 매너리즘에 빠져서 회사를 다니고 있다라고 느끼는 순간이 생긴다면 시간 낭비 말고 창업을 해야겠다고 다짐했다. The greatest developer 고양이 Lumi ","date":"2022-07-04","objectID":"/2022_first_half/:10:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"10. 🌖 Hackaton GDG 2022 summer hackaton Github repo: pitch-backend(부제: dobby’s) GDG에서 주관하는 무박2일 오프라인 해커톤에 참여했다. 해커톤은 마켓컬리 18층 오피스에서 진행되는데, 이상하게 그 전날 잠이 오지 않아서 새벽 3시에 잠에 들어 피곤한 상태로 참가했다. 저녁을 먹고 7~8시가 정말 고비였는데, 팀원들이 아무도 이탈하지 않아서 개인적으로 정말 괴로워하면서 버텼다. 이쁘게 찍어달라고 부탁한 컷 우리팀은 해커톤에서 작업 효율을 주제로 선택했고, 이를 위해서 만든 아이디어는 Task 스퍼트 서비스이다. 한줄 설명으로는 팀원들이 약 1~2시간동안 작업할 task goal을 공유하고, 이때 들을 유튜브 노동요 플레이리스트를 공유하는 서비스이다. Instagram post Service design 다음에는 만약 참가한다면 무박2일이 아니라, 3박4일 해커톤 같은 곳에 나가보고 싶다. (새벽이 되니까, 솔직히 작업 효율이 너무 떨어지는 것 같아서) 그래도 평소에 느끼지 못했던 순수한 열정을 여기에서 많이 느낄 수 있어서 값진 시간이었다. ","date":"2022-07-04","objectID":"/2022_first_half/:11:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"11. 💾 etc 카카오 퇴사하고 붕 뜨는 기간에 전자담배 액상 도매 사업을 친구와 했다. 사이트 디자인 부터, 사업자 등록, 해외 도매처 컨택 및 판매할 상품 선정 등등… 친구와 각각 100씩 투자해서 작게작게 해보자 했는데, 나중 되니까 서로 시간이 너무 없어서 포기했다. 아직도 도매로 구매했던 상품들과 포장 박스들이 친구 자취방에 있다. github: scrapper 타 사이트들의 상품정보 스크래퍼도 개발했었다. 자동 사이트 홍보 cronjob 도 만들었었다. 사이트 로고 5년간 했던 복싱을 그만두고 킥복싱을 시작했다. GYM 88 향수에 재미들렸다. 예전에 찍어둔 사진 빅션 영상 을 봤다. Focus on 👍 ","date":"2022-07-04","objectID":"/2022_first_half/:12:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["life"],"content":"🍀 Conclusion: Next step 넥스터즈 youtube api server (recommend songs) Develop more dobby's service IoT 프로젝트 (Arduino) 강의 찍기 Ros2 Open source 기여 Rust 배우기 또는 Golang 더 깊게 공부 “대의”, “선한 영향력”, 베품 같은 나의 소중한 비전을 찾는다. ","date":"2022-07-04","objectID":"/2022_first_half/:13:0","tags":["dev","retrospect"],"title":"2022년 상반기를 돌아보며","uri":"/2022_first_half/"},{"categories":["iot"],"content":"MQTT stands for MQ Telemetry Transport but previously was known as Message Queuing Telemetry Transport. ","date":"2022-06-11","objectID":"/mqtt/:0:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["iot"],"content":"tl;dr Lightweight and Efficient Bi-directional Communications This makes for easy broadcasting msgs to groups of things Scale to Millions of Things Reliable Message Delivery(QoS) 0, 1, 2 Support for Unreliable Networks MQTT’s support for persistent sessions reduces the time to reconnect the client with the broker. Security Enabled easy to encrypt msg using TLS also support OAuth ","date":"2022-06-11","objectID":"/mqtt/:1:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["iot"],"content":"MQTT Essentials https://www.hivemq.com/mqtt-essentials/ MQTT stands for MQ Telemetry Transport. The protocol is a set of rules that defines how IoT devices can publish and subscribe to data over the Internet. ","date":"2022-06-11","objectID":"/mqtt/:2:0","tags":["dev","mqtt","iot"],"title":"MQTT","uri":"/mqtt/"},{"categories":["dev"],"content":"Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. ","date":"2022-06-01","objectID":"/proto_buf/:0:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"tl;dr What are protocol buffers Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. How do I start? Download and install the protocol buffer compiler. Read the overview . Try the tutorial for your chosen language. (python ) ","date":"2022-06-01","objectID":"/proto_buf/:1:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"overview https://developers.google.com/protocol-buffers/docs/overview protobuf It’s like JSON, except it’s smaller and faster, and it generates native language bindings. Protocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data that is written to a file (or sent across a network connection). These are protobuf’s main components (2) Protoc (compiler) It is for data format compile It compiles .proto files SDK each language support The proto compiler is invoked at build time on .proto files to generate code in various programming languages Each generated class contains simple accessors for each field and methods to serialize and parse the whole structure to and from raw bytes. ","date":"2022-06-01","objectID":"/proto_buf/:2:0","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"languages The following languages are supported directly in the protocol buffers compiler, protoc: C++ C# Java Kotlin Objective-C PHP Python Ruby The following languages are supported by Google, but the projects’ source code resides in GitHub repositories. The protoc compiler uses plugins for these languages Dart Go for other languages ","date":"2022-06-01","objectID":"/proto_buf/:2:1","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Pros language/platform-neutral (low coupling, microsevice) Compact data storage Fast Parsing (compared to json?) Availability in many programming languages Optimized functionality through automatically-generated classes You can update Proto Definitions without updating code. which refers you can control code(especially data schema) version compatibility. ","date":"2022-06-01","objectID":"/proto_buf/:2:2","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Cons Protocol buffers tend to assume that entire messages can be loaded into memory at once and are not larger than an object graph. For data that exceeds a few megabytes, consider a different solution; when working with larger data, you may effectively end up with several copies of the data due to serialized copies, which can cause surprising spikes in memory usage. When protocol buffers are serialized, the same data can have many different binary serializations. You cannot compare two messages for equality without fully parsing them. Messages are not compressed. While messages can be zipped or gzipped like any other file, special-purpose compression algorithms like the ones used by JPEG and PNG will produce much smaller files for data of the appropriate type. Protocol buffer messages are less than maximally efficient in both size and speed for many scientific and engineering uses that involve large, multi-dimensional arrays of floating point numbers. For these applications, FITS and similar formats have less overhead. Protocol buffers are not well supported in non-object-oriented languages popular in scientific computing, such as Fortran and IDL. Protocol buffer messages don’t inherently self-describe their data, but they have a fully reflective schema that you can use to implement self-description. That is, you cannot fully interpret one without access to its corresponding .proto file. Protocol buffers are not a formal standard of any organization. This makes them unsuitable for use in environments with legal or other requirements to build on top of standards. ","date":"2022-06-01","objectID":"/proto_buf/:2:3","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Flow ","date":"2022-06-01","objectID":"/proto_buf/:2:4","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":".proto definition syntax (3) optionality(field rules) optional repeated Repeated fields are represented as an object that acts like a Python sequence singular(proto3, default, 단수형) required(deprecated) reversed field type message you can nest parts of the definition, such as for repeating sets of data. enum set of values to choose from. oneof which you can use when a message has many optional fields and at most one field will be set at the same time. map field number basic scalar type additional scalar type field number Field numbers cannot be repurposed or reused. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number. from microsoft description 필드 번호는 Protobuf의 중요한 부분입니다. 이진 인코딩된 데이터의 필드를 식별하는 데 사용됩니다. 즉, 서비스 버전에서 버전으로 변경할 수 없습니다. 장점은 이전 버전과의 호환성 및 앞으로 호환성이 가능하다는 것입니다. 클라이언트 및 서비스는 누락된 값의 가능성이 처리되는 한 모르는 필드 번호를 무시합니다. 이진 형식에서 필드 번호는 형식 식별자와 결합됩니다. 1에서 15까지의 필드 번호는 해당 형식으로 단일 바이트로 인코딩할 수 있습니다. 16에서 2,047까지의 숫자는 2바이트를 사용합니다. 어떤 이유로든 메시지에 2,047개 이상의 필드가 필요한 경우 더 높아질 수 있습니다. 필드 번호 1에서 15까지의 싱글 바이트 식별자는 더 나은 성능을 제공하므로 가장 기본적으로 자주 사용되는 필드에 사용해야 합니다. ","date":"2022-06-01","objectID":"/proto_buf/:2:5","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"Example This is the status.proto file used by Google. (refs ) // Copyright 2020 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. syntax = \"proto3\";package google.rpc;import \"google/protobuf/any.proto\";option cc_enable_arenas = true;option go_package = \"google.golang.org/genproto/googleapis/rpc/status;status\";option java_multiple_files = true;option java_outer_classname = \"StatusProto\";option java_package = \"com.google.rpc\";option objc_class_prefix = \"RPC\";// The `Status` type defines a logical error model that is suitable for // different programming environments, including REST APIs and RPC APIs. It is // used by [gRPC](https://github.com/grpc). Each `Status` message contains // three pieces of data: error code, error message, and error details. // // You can find out more about this error model and how to work with it in the // [API Design Guide](https://cloud.google.com/apis/design/errors). message Status { // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]. int32 code = 1; // A developer-facing error message, which should be in English. Any // user-facing error message should be localized and sent in the // [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client. string message = 2; // A list of messages that carry the error details. There is a common set of // message types for APIs to use. repeated google.protobuf.Any details = 3;} ","date":"2022-06-01","objectID":"/proto_buf/:2:6","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"protobuf: python https://developers.google.com/protocol-buffers/docs/reference/python-generated#invocation ","date":"2022-06-01","objectID":"/proto_buf/:2:7","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"protobuf vs … protobuf(grpc) vs thrift grpc vs thrift protobuf(grpc) vs graphql https://github.com/google/rejoiner 구글에서 graphql과 호환 lib 오픈소스화 시킴. https://medium.com/@lvdbrink/graphql-meets-protocol-buffers-in-go-cdbf11090934 ","date":"2022-06-01","objectID":"/proto_buf/:2:8","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["dev"],"content":"refs protobuf github ","date":"2022-06-01","objectID":"/proto_buf/:2:9","tags":["dev","protobuf","iot"],"title":"Protocol Buffers","uri":"/proto_buf/"},{"categories":["arduino"],"content":"Learn arduino with Arduino Step by Step: Getting Started by Dr. Peter Dalmaris lecture. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:0:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"tl;dr Build simple circuits around the Arduino Uno, that implement simple functions. Understand what is the Arduino. Understand analog and digital inputs and outputs Use the multimeter to measure voltage, current, resistance and continuity be productive with the Arduino IDE, write, compile and upload sketches, install libraries Detect and measure visible light, color, and ultraviolet light Measure the distance between the sensor and an object in front of it Detect a noise Display text on a liquid crystal display Write simple Arduino sketches that can get sensor reading, make LEDs blink, write text on an LCD screen, read the position of a potentiometer, and much more. Understand what is prototyping. Understand the ways by which the Arduino can communicate with other devices Use protoboards to make projects permanent Understand what is Arduino programming, it’s basic concepts, structures, and keywords Measure temperature, humidity and acceleration Detect a person entering a room Make noise and play music ","date":"2022-05-27","objectID":"/arduino_step_by_step/:1:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Section 2: Know your Arduino ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Getting to know the Arduino Uno Arduino Uno The Arduino UNO is the best board to get started with electronics and coding. If this is your first experience tinkering with the platform, the UNO is the most robust board you can start playing with. The UNO is the most used and documented board of the whole Arduino family. Arduino Uno is a microcontroller board based on the ATmega328P Atmega328P The ATmega328 is a single-chip microcontroller(=mcu) created by Atmel in the megaAVR family Shields add-on, plugin Shields are modular circuit boards that piggyback(하나의 운송 단위를 다른 운송 수단에 싣고 운반하는 상품 운송, 어부바) onto your Arduino to instill it with extra functionality. In general, these are called “daughter boards.” USB Pins power clock ATmega16U2 (https://mosesnah.tistory.com/5 ) USB-to-Serial Converter ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"GPIO Digital Pins output input Analog pins output Note PWM(Pulse Width Modulation) PWM is not true analog output, however. PWM “fakes” an analog-like result by applying power in pulses, or short bursts of regulated voltage. 0과 1로만 이뤄진 디지털 신호를 아날로그 신호처럼 흉내낸다. 즉 중간 값들을 만들어 낼 수 있다. input Potentiometer(가변저항) Ohm's law: V(전압) = I(전류) * R(저항) 저항이 커지면 전압이 강해진다. 직관적으로 이해하기에는 일정한 부피에 사람들 잔뜩 집어넣으면 밀도가 올라가서 압력이 쎄진다고 생각함. 흐르는(일정한 전류) 호수관 입구 손으로 막으면(저항) 압력 더 쎄져서 물 파워(전압) 쎄짐 pot는 시계방향으로 이동시키면 저항길이가 길어져서 더 큰 저항을 줄 수 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:2:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Section 3: Introduction to communications ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"UART Universal asynchronous receiver/transmitter 병렬(parallel) 데이터의 형태를 직렬(async serial) 방식으로 전환하여 데이터를 전송하는 컴퓨터 하드웨어의 일종이다. 두 장치 간에 직렬 데이터를 교환하기 위한 프로토콜 또는 규정을 정의합니다. UART는 매우 간단하며 양방향으로 데이터를 송신 및 수신하기 위해 송신기와 수신기 사이에 두 개의 와이어만 사용합니다. It is old fashion compare to I2C and SPI. simple, cheap, easy to make USART USART(Universal Synchronous serial Receiver and Transmitter)를 처리하기 위해서는 동기적으로 송수신 타이밍이 동기화 되어야 한다. 이런 동기화를 위해서 Clock 신호 라인이 필요하다. 클럭신호로 HIGH, LOW를 한번 반복해 보내는 동안 데이터 핀으로 한 비트의 데이터를 보내게된다. 다음은 100(2진수로 01100100)이라는 값을 보내는 방식이다. 아래를 보면 CLOCK 라인이 존재하는 것을 확인할 수 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"I²C(TWI, I2C) Inter-Integrated circuit Two Wire(sda, sck) Interface 아이 스퀘어 C I²C는 데이터를 주고 받는 선 하나와 송수신 타이밍 동기화를 위한 CLOCK 선하나로 이루어진다. Master-Slave 구조 line(2) SDA(data): 데이터 송수신 SCK(clock): Clock 시작 신호와 정지 신호를 가지고 있으며, 슬레이브마다 지정된 주소 값을 가지고 데이터를 주고 받는다. 데이터를 주고 받을 때 반드시 주소 값을 붙여서 보내야 하므로 긴 데이터를 보내기에는 적합하지 않지만, 통신 타이밍에 구애 받지 않으며 두 개의 선만으로 여러 기기와 통신할 수 있다는 장점 있다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"SPI Serial Peripheral(주변의) Interface line(4) MOSI: Master Out, Slave In MISO: Master In, Slave Out SCK: Clock Line SS(CS): Slave Select or Chip Select 즉 데이터를 수신할 기기 선택 신호 Full Duplex Master-Slave 구조 SPI 통신은 데이터의 송신과 수신이 동시에 이루어지기 때문에 다른 데이터 통신에 비해 속도가 빠르다는 장점이 있어서 이더넷 통신 등에 주로 사용된다. 하나의 마스터에는 여러 개의 슬레이브가 연결 될 수 있지만, 슬레이브마다 각각 하나의 SS 선을 필요로 하기 때문에 슬레이브의 개수가 많아질 경우에는 물리적으로 효율적이지 않다. ","date":"2022-05-27","objectID":"/arduino_step_by_step/:3:3","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"Prototyping basics ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:0","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"tl;dr breadboard jumper wire power supplies multimeter soldering(납땜) protoboard ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:1","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["arduino"],"content":"with images breadboard breadboard back breadboard front jumper wire male female aligator clips (=spring clips) jumper wire(female) jumper wire(aligator clips) power supplies multimeter measuring voltage measuring current measuring resistance measuring voltage measuring current measuring resistance soldering(납땜) protoboard ","date":"2022-05-27","objectID":"/arduino_step_by_step/:4:2","tags":["dev","iot"],"title":"Arduino step by step","uri":"/arduino_step_by_step/"},{"categories":["iot"],"content":"Let’s get familiar with basic features of Google pubsub service by practicing. ","date":"2022-05-21","objectID":"/pubsub/:0:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"tl;dr Google Cloud Pub/Sub: Qwik Start - Console Google Cloud Pub/Sub: Qwik Start - Command Line Google Cloud Pub/Sub: Qwik Start - Python ","date":"2022-05-21","objectID":"/pubsub/:1:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Quick start pub/sub Configure gcloud console Welcome to Cloud Shell! Type \"help\" to get started. Your Cloud Platform project in this session is set to qwiklabs-gcp-03-5549c96ad433. Use “gcloud config set project [PROJECT_ID]” to change to a different project. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud auth list Credentialed Accounts ACTIVE: * ACCOUNT: student-03-731a0523b9da@qwiklabs.net To set the active account, run: $ gcloud config set account `ACCOUNT` student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud config list project [core] project = qwiklabs-gcp-03-5549c96ad433 Your active configuration is: [cloudshell-4687] student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ Create topic Add a subscription Go to detailed topic page Publish a message to the topic View the message gcloud pubsub subscriptions pull --auto-ack MySub student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription DATA: Hello World MESSAGE_ID: 4704893166371310 ORDERING_KEY: ATTRIBUTES: DELIVERY_ATTEMPT: student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack mySubscription Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack myTopic-sub DATA: Hello World MESSAGE_ID: 4704893166371310 ORDERING_KEY: ATTRIBUTES: DELIVERY_ATTEMPT: student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ gcloud pubsub subscriptions pull --auto-ack myTopic-sub Listed 0 items. student_03_731a0523b9da@cloudshell:~ (qwiklabs-gcp-03-5549c96ad433)$ ","date":"2022-05-21","objectID":"/pubsub/:2:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Google Cloud Pub/Sub: Qwik Start - Command Line ","date":"2022-05-21","objectID":"/pubsub/:3:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"The Pub basics (CRD) A producer publishes messages to a topic and a consumer creates a subscription to a topic to receive messages from it. Create topics $ gcloud pubsub topics create myTopic Created topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic]. $ gcloud pubsub topics create myTopic2 $ gcloud pubsub topics create myTopic3 When duplicates topcic name, gcp returns error $ gcloud pubsub topics create myTopic2 $ gcloud pubsub topics create myTopic2 ERROR: Failed to create topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2]: Resource already exists in the project (resource=myTopic2). ERROR: (gcloud.pubsub.topics.create) Failed to create the following: [myTopic2]. List topics $ gcloud pubsub topics list --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic3 --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2 Delete topics student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics delete myTopic3 Deleted topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic3]. student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics delete myTopic2 Deleted topic [projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic2]. student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub topics list --- name: projects/qwiklabs-gcp-04-82b04dcaac56/topics/myTopic ","date":"2022-05-21","objectID":"/pubsub/:3:1","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"The Sub basics (CRD) create student_03_89bc281f2314@cloudshell:~ (qwiklabs-gcp-04-82b04dcaac56)$ gcloud pubsub subscriptions create --topic myTopic mySubsciption Created subscription [projects/qwiklabs-gcp-04-82b04dcaac56/subscriptions/mySubsciption]. delete $ gcloud pubsub subscriptions delete Test1 list $ gcloud pubsub topics list-subscriptions myTopic ","date":"2022-05-21","objectID":"/pubsub/:3:2","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Pub/Sub Publishing and Pulling a Single Message $ gcloud pubsub topics publish myTopic --message \"Hello\" $ gcloud pubsub topics publish myTopic --message \"Publisher's name is minwook\" $ gcloud pubsub topics publish myTopic --message \"Publisher likes to eat love\" $ gcloud pubsub topics publish myTopic --message \"Publisher thinks Pub/Sub is awesome\" # pull subscription $ gcloud pubsub subscriptions pull mySubscription --auto-ack What’s going on here? You published 4 messages to your topic, but only 1 was outputted. Now there are important features of the pull command that often trip developers up Using the pull command without any flags will output only one message, even if you are subscribed to a topic that has more held in it. Once an individual message has been outputted from a particular subscription based pull command, you cannot access that message again with the pull command (maybe this happens ack) Run the last command three more times. You will see that it will output the other messages you published before. Now run the command a 4th time. $ gcloud pubsub subscriptions pull mySubscription --auto-ack ","date":"2022-05-21","objectID":"/pubsub/:3:3","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Pub/Sub pulling all messages from subscriptions with flag $ gcloud pubsub subscriptions pull mySubscription --auto-ack --limit=3 Here, notice that gcp pubsub important features. about --auto-ack (BETA) Acknowledges one or more messages as having been successfully received. If a delivered message is not acknowledged within the Subscription’s ack deadline, Cloud Pub/Sub will attempt to deliver it again. To automatically acknowledge messages when pulling from a Subscription, you can use the –auto-ack flag on gcloud pubsub subscriptions pull. ","date":"2022-05-21","objectID":"/pubsub/:3:4","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Google Cloud Pub/Sub: Qwik Start - Python https://www.cloudskillsboost.google/focuses/2775?catalog_rank=%7B%22rank%22%3A3%2C%22num_filters%22%3A0%2C%22has_search%22%3Atrue%7D\u0026parent=catalog\u0026qlcampaign=yt18-gsp095-11078 Project setup \u003e git clone https://github.com/googleapis/python-pubsub.git \u003e cd python-pubsub/samples/snippets \u003e ls README.rst noxfile.py requirements-test.txt subscriber.py README.rst.in noxfile_config.py requirements.txt subscriber_test.py iam.py publisher.py resources utilities iam_test.py publisher_test.py schema.py mypy.ini quickstart schema_test.py \u003e python3 -m venv venv \u003e source venv/bin/activate \u003e pip list Package Version ---------- ------- pip 22.0.4 setuptools 47.1.0 WARNING: You are using pip version 22.0.4; however, version 22.1 is available. You should consider upgrading via the '/Users/minwook/code/python-pubsub/samples/snippets/venv/bin/python3 -m pip install --upgrade pip' command. \u003e cat requirements.txt google-cloud-pubsub==2.12.1 avro==1.11.0 \u003e pip install --upgrade pip \u003e pip install -r requirements.txt Create a topic # you must authorize google cloud auth before create a topic $ echo $GOOGLE_CLOUD_PROJECT $ python publisher.py $GOOGLE_CLOUD_PROJECT create MyTopic $ python publisher.py $GOOGLE_CLOUD_PROJECT list Create a subscription $ python subscriber.py $GOOGLE_CLOUD_PROJECT create MyTopic MySub list subscription $ python subscriber.py $GOOGLE_CLOUD_PROJECT list-in-project Subscribe messages $ python subscriber.py $GOOGLE_CLOUD_PROJECT receive MySub Listening for messages on projects/qwiklabs-gcp-7877af129f04d8b3/subscriptions/MySub Received message: Message { data: 'Publisher thinks Pub/Sub is awesome' attributes: {} } Received message: Message { data: 'Hello' attributes: {} } Received message: Message { data: \"Publisher's name is Harry\" attributes: {} } Received message: Message { data: 'Publisher likes to eat cheese' attributes: {} } pub.py #!/usr/bin/env python # Copyright 2019 Google LLC # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import argparse from google.cloud import pubsub_v1 def pub(project_id: str, topic_id: str) -\u003e None: \"\"\"Publishes a message to a Pub/Sub topic.\"\"\" # Initialize a Publisher client. client = pubsub_v1.PublisherClient() # Create a fully qualified identifier of form `projects/{project_id}/topics/{topic_id}` topic_path = client.topic_path(project_id, topic_id) # Data sent to Cloud Pub/Sub must be a bytestring. data = b\"Hello, World!\" # When you publish a message, the client returns a future. api_future = client.publish(topic_path, data) message_id = api_future.result() print(f\"Published {data.decode()}to {topic_path}: {message_id}\") if __name__ == \"__main__\": parser = argparse.ArgumentParser( description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter, ) parser.add_argument(\"project_id\", help=\"Google Cloud project ID\") parser.add_argument(\"topic_id\", help=\"Pub/Sub topic ID\") args = parser.parse_args() pub(args.project_id, args.topic_id) Wow.. it looks simple, I think the variable naming api_future is a key to this script. api_future is returned value of google.cloud.pubsub_v1.PublisherClient.publish() and a variable message_id is type of api_future.result() Let’s deep dive into below logics. google.cloud.pubsub_v1.PublisherClient.publish() google.cloud.pubsub_v1.PublisherClient.publish.result() class PublisherClient(metaclass=PublisherClientMeta): \"\"\"The service that an application uses to manipulate topics, and to send messages to a topic. \"\"\" ... def publish( sel","date":"2022-05-21","objectID":"/pubsub/:4:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"Conclusion This is so impressive that pubsub_v1’s client generates Future object which needs client should supports async features. Eventually gcp pubsub_v1’s clients inherit official python concurrent Future object, so I’m wondering that can pubsub_v1 handle python2.x? because python future object is not supported on python2.x version. If it does not support python2.x version than, how do I mock Future based async flow to gevent logic. Through this journey, I would like to study Python’s concurrent-related features to an advanced level. https://docs.python.org/ko/3/library/concurrent.futures.html ","date":"2022-05-21","objectID":"/pubsub/:5:0","tags":["dev","gcp","pubsub"],"title":"Google Cloud Pub/Sub","uri":"/pubsub/"},{"categories":["iot"],"content":"This post is a summary of lectures taken in coursera on the topic of Google IoT core. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:0:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day 1 ~ 2 ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"What is IoT? Internet of Things is a sprawling set of technologies and use that has no clear, single definition. But one workable view frames IoT as the use of network-connected devices, embedded in the physical env, to improve some existing process or to enable a new scenario not previously possible. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"IoT cloud The general structure of an IoT cloud Devices gathering data performing an action interact with users Gateway A gateway ensures that devices are securely connected to the cloud. It can be a cell phone. It controls messaging between the device and the cloud Cloud u na mean ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Challenges in IoT When designing an IoT network, below topics should be considered. connectivity At present IoT relies on a server/client model to authenticate, authorize and connect devices to nodes in the network It will become unworkable as numbers grow to the millions and billions per network. In the future, off-loading tasks to the edge will become important. This means that IoT networks will need devices capable of handling data analysis, ML, and data gathering. brownfield deployment(legacy infra) Companies will need to confront the task of integrating new devices and technologies into existing networks. security and compilance non-standard communication protocol Dealing with non-standard communication protocol will increase in importance as networks need to handle ever-increasing amounts of data from sensors. Data handling, processing, and storing will increase as data input loads increase, while at the same time, the value of data increases with the size, depth, and frequency of data available to data analytics. IT/OT convergence IT has traditionally been data-centric OT has been used to monitor events. get actionable intelligence from data. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"IoT Architecture IoT architecturesmust be capable of scaling connectivity of devices, data ingestion, data processing, and data storage. They must be able to do this quickly while still producing real-time data insights. To migrate this demand, distributed computing known as fog or edge computing is gaining popularity. The edge refers to the geographic distribution of computing nodes in the network as sIoT devices, which are at the “edge” of a network. This in turn increases the demand for devices that are capable of cleaning, processing and analyzing data locally. The result is that only cleaned metadata is sent to the cloud. An asynchronous, scalable communication stack is crucial in bidirectional communication with devices. https://k21academy.com/google-cloud/cloud-sql-vs-cloud-spanner/ ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:1:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day 3 ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Types of sensors ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Devices A “Thing” in the “Internet of Things” is a processing unit that is capable of connecting to the internet and exchanging data with the cloud. Devices are often called “smart devices” or “connected devices.” They communicate two types of data: telemetry and state. Device information is mainly composed of three types as follows. Device metadata: Most metadata rarely, if ever, changes. Identifier (ID) -An identifier that uniquely identifies a device. Class or type Model Revision Date manufactured Hardware serial numbe Telemetry: Data collected by the device is called telemetry Telemetry is read-only data about the environment usually collected through sensors e.g. Temperature(35.4oC) State information Describes the current status of the device, not of the environment can be read/write. It is updated, but usually not frequently. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Device commands Commands are actions performed by a device. So tye should include a time-to-live(TTL) or other expiration value Operational information is data that’s most relevant to the operation of the device as opposed to the business application. This might include things such as CPU operating temperature and battery state. it has short-term value to help maintain the os It can be transmitted as telemetry or state data ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Defining devices For example, consider a project for monitoring the temperature in hotel rooms. Each room has three sensors: one near the floor, one near the bed, and one near the ceiling. option1 {deviceID: \"dh28dslkja\", \"location\": \"floor\", \"room\": 128, \"temp\": 22 } {deviceID: \"8d3kiuhs8a\", \"location\": \"bedside\", \"room\": 128, \"temp\": 24 } {deviceID: \"kd8s8hh3o\", \"location\": \"ceiling\", \"room\": 128, \"temp\": 20 } option2 {deviceID: \"dh28dslkja\", \"room\": 128, \"temp_floor\": 22, \"temp_bedside\": 24, \"temp_ceiling\": 20, \"average_temp\": 22 } ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Google IoT developer prototyping kits Google works with partners to build device starter kits that make connecting to Google Cloud IoT Platform easy for developers. At this time, Google has partnered with fourteen companies to offer a wide variety of IoT developer prototyping kits . ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:5","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"MQTT protocol https://cloud.google.com/iot/docs/concepts/protocols MQTT is an industry-standard IoT protocol (Message Queue Telelmetry Transport). Messages include the topic in the message, which is used for routing information by the broker. This means that subscribers do not need to know the publisher, because all communication is done through messages Messages are pushed to subscribers, so there must be an open TCP connection to the broker (subscriber \u003c-\u003e broker) If the connection is broken, the broker can hold messages for later transmission. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:6","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"HTTP protocl HTTP is a “connectionless” protocol: with the HTTP bridge, devices do not maintain a connection to the cloud. In connectionless communication, client requests are sent without having to first check that the recipient is available. Therefore devices have no way of knowing whether they are in a conversation with the server, and vice versa. This means some of the features that Cloud IoT Core provides, for example, last Heartbeat detected, will not be available with an HTTP connection. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:7","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Comparison of MQTT and HTTP general features MQTT is considered to be data focused, while HTTP is document focused. Which means MQTT is better suited to the rigors of IoT. In addition, MQTT has three levels of service(QoS) At most once. Guarantees at least one attempt at delivery, (no guarantee of delivery). At least once. Guarantees the message will be delivered at least once. Exactly once. Guarantees the message is delivered only once. MQTT also has Last will and testament(유언, LWT). If a client (ie device) is disconnected unexpectedly, the subscribers will be notified by the MQTT broker. Retained(보관) messages. New subscribers will get an immediate status update. LWT 통신에서 중요하지만 구현이 까다로운 문제로 “상대방이 예상치 못한 상황으로 인하여 접속이 끊어졌을때\"의 처리가 있다. 그래서 전통적 방식으로는 자신의 생존 여부를 계속 ping을 통해 서버가 물어보고 timeout 시간안에 pong이 안올 경우 서버에서 접속 종료를 인식하는 번거로운 방식을 취하는데, MQTT의 경우 subscribe 시점에서 자신이 접속 종료가 되었을 때 특정 topic으로 지정한 메시지를 보내도록 미리 설정할 수 있다. 이를 LWT(Last will and testament) 라고 한다. 선언을 먼저하고 브로커가 처리하게 하는 방식인 것이다. $ mqtt help subscribe Usage: mqtt subscribe [opts] [topic] Available options: ... 중략 ... --will-topic TOPIC the will topic --will-message BODY the will message --will-qos 0/1/2 the will qos --will-retain send a will retained message Both MQTT and HTTP use pub key(asymmetric) device authentication, and JWT. In more detail ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:2:8","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Day4: Google Cloud’s IoT Platform This section covers the ingest and process stages of IoT architecture. Learning Objectives Create Cloud IoT registries and devices Create Pub/Sub topics and sobscriptions Create and manage Cloud Storage buckets Manage device credentials and access control Create a Dataflow pipeline ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:0","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Pub/Sub The Subscriber sends the acknowledgement to the Subscription Use Cases Balancing workloads in network clusters Implementing async workflows Distirbuting event notifications Refreshing distributed caches Logging to multiple systems Data streaming from various processes or devices Reliabiltiy(신뢰할 수 있음) improvement FYI use case Balancing workloads in network clusters, for example, a large queue of tasks can be efficiently distributed among multiple workers such as Google Compute Engine instances. Implementing asynchronous workflows, for example, an order processing application can place an order on a topic from which it can be processed by one or more workers. Distributing event notifications, for example, a service that accepts user sign-ups can send notifications whenever a new user registers and a downstream services can subscribe to receive notifications of the event. Refreshing distributed caches, for example, an application can publish invalidation(캐시 무효화) events to update the IDs of objects that have changed. Logging into multiple systems, for example, a Google Compute Engine instance can write logs to the monitoring system, to a database for later querying and so on. Data streaming from various processes or devices, for example, a residential(주거, 숙박) sensor can stream data to backend services hosted in the Cloud. Also, reliability improvement, for example, a single-zone Compute Engine service can operate in additional zones by subscribing to a common topic to recover from failures in a zone or region. gcp pubsub labs in practice https://minkj1992.github.io/pubsub/ ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:1","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Cloud IoT Core Full Ingest and Process and Analyze process Cloud IoT combines both protocol bridge and device manager. Protocol Bridge MQTT protocol with single Global endpoint(mqtt.googleapis.com) Automatic load balancing Global data access with Pub/Sub Device Manager Configure individual devices Update and control devices Role level access control (authrization) Console and APIs for device deployment and monitoring Cloud IoT Core fully integrates your devices make decision Device telemetry data is forwarded to a Pub/Sub topic, which can then be used to trigger Cloud Functions. You can also perform streaming analysis with Dataflow or custom analysis with your own subscribers. secure Cloud IoT uses automatic load balancing and horizontal scaling to ensure smooth data ingestion under any condition. Cloud IoT Core follows industry-standard security protocols. Registration connects devices to Google IoT Cloud tl;dr Device registry: belong to cloud project so single region Device: belong to device registry so single region (registry : device = 1 : n) topic: global single endpoint (belong to pubsub) In order for a device to connect, it must first be registered in the device manager. The device manager lets you create and configure device registries and the devices within them. A device registry is a container of devices. When you create a device registry, you select which protocols to enable: MQTT, HTTP, or both. Each device registry is created in a specific cloud region and belongs to a cloud project. A registry is identified in the cloudiot.googleapis.com service by its full name. as projects/{project-id}/locations/{cloud-region}/registries/{registry-id} The device registry is configured with one or more Pub/Sub topics to which telemetry events are published for all devices in that registry. A single topic can be used to collect data across all regions. Cloud monitoring is automatically enabled for each registry. For details, seeDeviceRegistry resource reference Protocol bridges Devices communicate with Cloud IoT Core across a “bridge” — either the MQTT bridge or the HTTP bridge. Note that GCP Cloud IoT Core supports HTTP 1.1 only. ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:2","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Cloud Storage ","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:3","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["iot"],"content":"Dataflow","date":"2022-05-13","objectID":"/coursera-gcp-iot/:3:4","tags":["dev","gcp","iot","coursera"],"title":"Coursera Google IoT","uri":"/coursera-gcp-iot/"},{"categories":["python"],"content":"Let's deep dive into gevent based python programming","date":"2022-04-24","objectID":"/gevent/","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Let’s deep dive into gevent based python programming ","date":"2022-04-24","objectID":"/gevent/:0:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"tl;dr from gevent import ( event, joinall, queue, sleep, threadpool, Timeout, wait, kill, get_hub, signal, ) ","date":"2022-04-24","objectID":"/gevent/:1:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"gevent gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop. deterministic ","date":"2022-04-24","objectID":"/gevent/:2:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Intro ","date":"2022-04-24","objectID":"/gevent/:3:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"gevent vs eventlet gevent is inspired by eventlet has some diff gevent is built on top of libevent event loop epoll on Linux Signal handling is integrated with the event loop. Other libevent-based libraries can integrate with your app through single event loop. DNS requests are resolved asynchronously rather than via a threadpool of blocking calls. WSGI server is based on the libevent’s built-in HTTP server gevent’s interface follows the conventions set by the standard library ","date":"2022-04-24","objectID":"/gevent/:3:1","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"backgrounds greenlet Greenlet은 C 확장 모듈 형태로 제공되는 경량 코루틴 입니다. Greenlet들은 메인 프로그램을 실행하는 OS process 안에서 모두 실행되지만 상호작용하며 스케줄링됩니다. 운영체제에 의해 스케줄링되는 process들과 POSIX 쓰레드들을 사용하여 실제로 병렬로 실행되는 multiprocessing 나 threading을 이용한 병렬처리들과는 달리 한 번에 오직 하나의 greenlet만이 실행됩니다. greenlet은 deterministic 합니다. 같은 greenlet 세팅과 같은 입력이 주어졌을때, 언제나 같은 결과를 출력합니다. import time def echo(i): time.sleep(0.001) return i # Non Deterministic Process Pool from multiprocessing.pool import Pool p = Pool(10) run1 = [a for a in p.imap_unordered(echo, range(10))] run2 = [a for a in p.imap_unordered(echo, range(10))] run3 = [a for a in p.imap_unordered(echo, range(10))] run4 = [a for a in p.imap_unordered(echo, range(10))] print(run1 == run2 == run3 == run4) # Deterministic Gevent Pool from gevent.pool import Pool p = Pool(10) run1 = [a for a in p.imap_unordered(echo, range(10))] run2 = [a for a in p.imap_unordered(echo, range(10))] run3 = [a for a in p.imap_unordered(echo, range(10))] run4 = [a for a in p.imap_unordered(echo, range(10))] print(run1 == run2 == run3 == run4) False True libev vs libuv vs libevent The three network libraries Libevent , libev , and libuv are all asynchronous event libraries implemented in C language. ( Asynchronousevent library ). Libevent: the most famous, most widely used and long-standing cross-platform event library; libev: Compared with libevent , the design is more concise and the performance is better, but the support for Windows is not good enough; libuv: A cross-platform event library is needed in the process of developing node . They preferred libev , but they also need to support Windows , so they repackaged a set, implemented with libev under Linux , and IOCP under Windows ","date":"2022-04-24","objectID":"/gevent/:3:2","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"key features refs ","date":"2022-04-24","objectID":"/gevent/:4:0","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Synchronous \u0026 Asynchronous Execution on gevent 동시성 처리의 핵심 개념은 큰 단위의 task를 한번에 동기로 처리하는 대신, 작은 단위의 subtask들로 쪼개서 동시에 비동기로 실행시키는 것입니다. 두 subtask간의 스위칭을 컨텍스트 스위칭이라고 합니다. gevent에서는 컨텍스트 스위칭을 yielding을 이용해서 합니다. gevent의 진짜 힘은 상호작용 하며 스케쥴링 될 수 있는 네트워크와 IO bound 함수들을 작성할때 발휘됩니다. gevent는 네트워크 라이브러리들이 암시적으로 greenlet 컨텍스트들이 가능한 시점에 암시적으로 yield 하도록 보장합니다. import time import gevent from gevent import select start = time.time() tic = lambda: 'at %1.1fseconds' % (time.time() - start) def gr1(): # Busy waits for a second, but we don't want to stick around... print('Started Polling: %s' % tic()) select.select([], [], [], 2) print('Ended Polling: %s' % tic()) def gr2(): # Busy waits for a second, but we don't want to stick around... print('Started Polling: %s' % tic()) select.select([], [], [], 2) print('Ended Polling: %s' % tic()) def gr3(): print(\"Hey lets do some stuff while the greenlets poll, %s\" % tic()) gevent.sleep(1) print('gr3 fin') gevent.joinall([ gevent.spawn(gr1), gevent.spawn(gr2), gevent.spawn(gr3), ]) Started Polling: at 0.0 seconds Started Polling: at 0.0 seconds Hey lets do some stuff while the greenlets poll, at 0.0 seconds Ended Polling: at 2.0 seconds Ended Polling: at 2.0 seconds ","date":"2022-04-24","objectID":"/gevent/:4:1","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Determinism greenlet은 deterministic 합니다. 같은 greenlet 세팅과 같은 입력이 주어졌을때, 언제나 같은 결과를 출력합니다. gevent가 일반적으로 deterministic 하다고 해도, 소켓과 파일과 같은 외부 서비스와 연동할 때 non-deterministic한 입력들이 들어올 수 있습니다. 그러므로 green 쓰레드가 “deterministic concurrency” 형태라고 해도, POSIX 쓰레드들과 프로세스들을 다룰 때 만나는 문제들을 경험할 수 있습니다. 동시성을 다룰 때 만날 수 있는 문제로 race condition이 있습니다. 간단히 요약하자면, race condition은 두 개의 동시에 실행되는 쓰레드나 프로세스들이 같은 공유 자원을 수정하려고 할 때 발생합니다. 이때 해당 공유자원의 결과 값은 실행 순서에 따라 달라지게 됩니다. 이런 결과는 non-deterministic한 프로그램 동작을 야기하기 때문에 발생시키지 않기 위해 노력해야 합니다. Best practice는 공유자원을 사용하지 않도록 하는 것입니다. ","date":"2022-04-24","objectID":"/gevent/:4:2","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Spawning Greenlets gevent는 greenlet 초기화를 위한 몇 가지 wrapper들을 제공합니다. import gevent from gevent import Greenlet def foo(message, n): gevent.sleep(n) print(message) c1 = Greenlet.spawn(foo, \"Hello\", 1) c2 = gevent.spawn(foo, \"Hello2\", 2) c3 = gevent.spawn(lambda x: (x+1), 5) coroutines = [c1,c2, c3] gevent.joinall(coroutines) 6 Hello Hello2 Greenlet 클래스를 상속하고 _run 함수를 override 하는 방법도 있습니다. import gevent from gevent import Greenlet class MyGreenlet(Greenlet): def __init__(self, message, n): Greenlet.__init__(self) self.message = message self.n = n def _run(self): print(self.message) gevent.sleep(self.n) g = MyGreenlet(\"Hi there!\", 3) g.start() g.join() Hi there! ","date":"2022-04-24","objectID":"/gevent/:4:3","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Greenlet State 다른 코드 예시들처럼, greenlet도 다양한 경우에 실패할 수 있습니다. greenlet은 예외를 발생시키는것이 실패하거나, 정지에 실패할 수도 있고, 시스템 자원을 과도하게 사용할 수도 있습니다. greenlet의 내부 상태는 대체로 time-dependent합니다. greenlet에는 쓰레드의 상태를 모니터링 할 수 있는 다양한 flag들이 있습니다. started: bool Greenlet이 실행되었는지 여부를 나타냅니다 ready(): bool Greenlet이 정지되었는지 여부를 나타냅니다 successful(): bool Greenlet이 예외를 발생시키지 않고 정지되었는지 여부를 나타냅니다. value: Any Greenlet에 의해서 리턴된 값입니다. exception: Exception Greenlet안에서 발생한 예외입니다. import gevent def win(): return 'You win!' def fail(): raise Exception('You fail at failing.') winner = gevent.spawn(win) loser = gevent.spawn(fail) print(winner.started) # True print(loser.started) # True try: gevent.joinall([winner, loser]) except Exception as e: print('This will never be reached') print(winner.value) # 'You win!' print(loser.value) # None print(winner.ready()) # True print(loser.ready()) # True print(winner.successful()) # True print(loser.successful()) # False # It is possible though to raise the exception again outside # raise loser.exception # or with # loser.get() print(loser.exception) # You fail at failing. ","date":"2022-04-24","objectID":"/gevent/:4:4","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Program Shutdown 메인 프로그램이 SIGQUIT 시그널을 받은 시점에 yield를 실패한 Greenlet은 예상보다 오래 실행이 정지되어 있을 수 있습니다. 이런 프로세스는 “좀비 프로세스\"라고 불리고, 파이썬 인터프리터 외부에서 kill되어야 합니다. 일반적인 패턴은 메인 프로그램에서 SIGQUIT 시그널에 대기하고 있다가 프로그램이 종료되기 전에 gevent.shutdown 호출하는 것입니다. import gevent import signal def run_forever(): gevent.sleep(1000) if __name__ == '__main__': # gevent.signal(signal.SIGQUIT, gevent.shutdown) gevent.signal(signal.SIGQUIT, gevent.kill) thread = gevent.spawn(run_forever) thread.join() 아래는 realworld example입니다. def main(): parser = ArgumentParser() parser.add_argument(\"--start\", action=\"something start\", help=\"Launch the processes\") args = parser.parse_args() threading.currentThread().setName('something') launcher = Launcher() launcher.setup_procmanager() if args.start: launcher.start_proc_manager() try: gevent.signal.signal(gevent.signal.SIGTERM, sig_handler) gevent.signal.signal(gevent.signal.SIGINT, sig_handler) gevent.wait() except KeyboardInterrupt: print('Shutdown requested. Exiting...') launcher.shutdown() if __name__ == '__main__': main() ","date":"2022-04-24","objectID":"/gevent/:4:5","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Timeouts import gevent from gevent import Timeout seconds = 10 timeout = Timeout(seconds) timeout.start() def wait(): gevent.sleep(10) try: gevent.spawn(wait).join() except Timeout: print('Could not complete') with statement import gevent from gevent import Timeout time_to_wait = 5 # seconds class TooLong(Exception): pass with Timeout(time_to_wait, TooLong): gevent.sleep(10) ","date":"2022-04-24","objectID":"/gevent/:4:6","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Events Event는 Greenlet 간의 비동기 통신에 사용됩니다. import gevent from gevent.event import Event ''' Illustrates the use of events ''' evt = Event() def setter(): '''After 3 seconds, wake all threads waiting on the value of evt''' print('A: Hey wait for me, I have to do something') gevent.sleep(3) print(\"Ok, I'm done\") evt.set() def waiter(): '''After 3 seconds the get call will unblock''' print(\"I'll wait for you\") evt.wait() # blocking print(\"It's about time\") def main(): gevent.joinall([ gevent.spawn(setter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter), gevent.spawn(waiter) ]) if __name__ == '__main__': main() A: Hey wait for me, I have to do something I'll wait for you I'll wait for you I'll wait for you I'll wait for you I'll wait for you Ok, I'm done It's about time It's about time It's about time It's about time It's about time Event 객체의 확장은 wakeup call과 함께 값을 전송할 수 있는 AsyncResult입니다. AsyncResult는 임의의 시간에 할당될 미래 값에 대한 레퍼런스를 갖고 있기 때문에, 때때로 future나 deferred로 불리기도 합니다. import gevent from gevent.event import AsyncResult a = AsyncResult() def setter(): a.set('leoo is cool') gevent.sleep(0.5) a.set('minwook is cool') def waiter(): print(a.get()) gevent.sleep(1) print(a.get()) gevent.joinall([ gevent.spawn(setter), gevent.spawn(waiter), ]) leoo is cool minwook is cool ","date":"2022-04-24","objectID":"/gevent/:4:7","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["python"],"content":"Queues Queue는 일반적인 put 과 get 연산을 지원하지만 Greenlet 사이에서 안전하게 조작되는 것이 보장되는 순서를 가진 데이터들의 집합입니다. import gevent from gevent.queue import Queue tasks = Queue() def worker(n): while not tasks.empty(): task = tasks.get() print('Worker %sgot task %s' % (n, task)) gevent.sleep(0) print('Quitting time!') def boss(): for i in xrange(1,25): tasks.put_nowait(i) gevent.spawn(boss).join() gevent.joinall([ gevent.spawn(worker, 'steve'), gevent.spawn(worker, 'john'), gevent.spawn(worker, 'nancy'), ]) Worker steve got task 1 Worker john got task 2 Worker nancy got task 3 Worker steve got task 4 Worker john got task 5 Worker nancy got task 6 Worker steve got task 7 Worker john got task 8 Worker nancy got task 9 Worker steve got task 10 Worker john got task 11 Worker nancy got task 12 Worker steve got task 13 Worker john got task 14 Worker nancy got task 15 Worker steve got task 16 Worker john got task 17 Worker nancy got task 18 Worker steve got task 19 Worker john got task 20 Worker nancy got task 21 Worker steve got task 22 Worker john got task 23 Worker nancy got task 24 Quitting time! Quitting time! Quitting time! 즉 Queue는 put이나 get 연산 시 block 됩니다. 만약 non-blocking 연산이 필요할 때는 block이 되지 않는 put_nowait과 get_nowait을 사용할 수 있습니다. 대신 연산이 불가능할 때는 gevent.queue.Empty 나 gevent.queue.Full 예외를 발생시킵니다. 아래 코드는 상사가 3명의 작업자(steve, john, nancy)에게 동시에 일을 시키는데 Queue가 3개 이상의 요소를 담지 않도록 제한하는 예시입니다. 이 제한은 put연산이 Queue에 남은 공간이 있을 때 까지 block 되어야 함을 의미합니다. 반대로 get 연산은 Queue에 요소가 없으면 block 되는데, 일정 시간이 지날 때 까지 요소가 들어오지 않으면 gevent.queue.Empty 예외를 발생시키면서 종료될 수 있도록 타임아웃 파라미터를 설정할 수 있습니다. import gevent from gevent.queue import Queue, Empty tasks = Queue(maxsize=3) def worker(name): try: while True: task = tasks.get(timeout=1) # decrements queue size by 1 print('Worker %sgot task %s' % (name, task)) gevent.sleep(0) except Empty: print('Quitting time!') def boss(): \"\"\" Boss will wait to hand out work until a individual worker is free since the maxsize of the task queue is 3. \"\"\" for i in xrange(1,10): tasks.put(i) print('Assigned all work in iteration 1') for i in xrange(10,20): tasks.put(i) print('Assigned all work in iteration 2') gevent.joinall([ gevent.spawn(boss), gevent.spawn(worker, 'steve'), gevent.spawn(worker, 'john'), gevent.spawn(worker, 'bob'), ]) Worker steve got task 1 Worker john got task 2 Worker bob got task 3 Worker steve got task 4 Worker john got task 5 Worker bob got task 6 Assigned all work in iteration 1 Worker steve got task 7 Worker john got task 8 Worker bob got task 9 Worker steve got task 10 Worker john got task 11 Worker bob got task 12 Worker steve got task 13 Worker john got task 14 Worker bob got task 15 Worker steve got task 16 Worker john got task 17 Worker bob got task 18 Assigned all work in iteration 2 Worker steve got task 19 Quitting time! Quitting time! Quitting time! ","date":"2022-04-24","objectID":"/gevent/:4:8","tags":["dev","robotics"],"title":"Gevent","uri":"/gevent/"},{"categories":["dao","ohso"],"content":"Daoist 도의 사람은 장애물이 없이 행한다. 그는 자신의 행동으로 남을 상처 주지 않는다. 그럼에도 그는 자신의 부드러움과 따뜻함을 알지 못한다. 그는 재물을 모으고자 애쓰지 않으며 그렇다고 청빈의 덕을 내세우지도 않는다. 그는 남에게 의존함 없이 자신의 길을 걸어가며 또한 홀로 걸어감을 자랑하지도 않는다. 도의 사람은 알려짐 없이 머물러 있다. 완전한 덕은 아무것도 만들어 내지 않는다. 자아가 사라진 것이 진정한 자아. 가장 위대한 자는 아무도 아닌 자다. 도의 사람 by Zhuang Zhou 마음의 본성은 한 극에서 반대편 극으로 움직여 가는 것이다. 누군가를 사랑할 때 그대는 곧 그를 미워하기 위한 반동력을 모으고 있는 것이다. 그래서 오직 친구만이 적이 될 수 잇다. 먼저 친구가 되지 않으면 갑자기 적으로 될 수가 없다. 사랑하는 이들만이 말다툼을 할 수 있고 싸울 수 있다. 삶 속에서는 온갖 반대되는것들이 하나로 합쳐진다. 그것들은 함께 존재한다. 마음은 늘 거리를 갈망한다. 결코 가까워지기를 바라지 않는다. 가까워지면 권태로워지고 싫증을 느낀다. 거리를 가지면 꿈과 희망들을, 즐거움의 가능성들을 품을 수 있다. 매력적이고 아름다워 보이는 것은 언제나 거리가 있다. 모든 관계는 사랑과 미움의 관계다. 순수한 사랑의 관계는 없다. 순수한 미움의 관계도 없다. 사랑과 미움 둘 다이다. 그대가 정직하다면 곤란에 빠질 것이다. 살아오면서 너무나 긴장해 있었기 때문에 이제 명상을 하고 있는 것이다. 그러나 그것은 긴장의 반대편이지 진정한 명상이 아니다. 그대는 가까이 오기 위해 멀리 가야만 한다. 명상하기 위해 긴장해야만 한다. 그것은 명상이 아니다. 반대편으로 옮겨가지 말라. 중간에 멈춰 서서. 이것이 줄곧 속임수였음을 지켜보라 그것들이 서로 연결되어 있음을, 한 과정의 양면으로 이어져 있음을 자각하라. ","date":"2022-04-24","objectID":"/daoist/:0:0","tags":["love","삶의 길 흰구름의 길"],"title":"Daoist","uri":"/daoist/"},{"categories":["script","shell"],"content":"List up some useful shell scripts","date":"2022-04-23","objectID":"/shell_script/","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"Useful shell script commands :) ","date":"2022-04-23","objectID":"/shell_script/:0:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"Shebang #!: Shebang #!/usr/bin/\u003cbash|python|perl|php...\u003e 스크립트를 실행시켜줄 인터프리터의 절대경로를 지정하는 역할 #!/usr/bin/env \u003clanguate\u003e env는 환경 변수에서 지정한 언어의 위치를 찾아서 실행됩니다. 다양한 환경에서 실행되는 스크립트라면 “env\"를 사용하는 것이 좋습니다. e.g. #!/usr/bin/env bash ","date":"2022-04-23","objectID":"/shell_script/:1:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"set commands refs #!/usr/bin/env bash set -o nounset -o errexit -o errtrace -o pipefail 만일, 미리 선언되지 않은 변수를 사용했을 때 스크립트를 종료시키고 싶은 경우 $ set -o nounset or $ set -u exit if a command yields a non-zero exit status. (exit when the command fails.) $ set -o errexit or $ set -e prints commands arguments during execution. Useful for debugging $ set -o xtrace or $ set -x 파이프 사용시, 이전 단계의 오류(non-zero exit code)를 승계하도록 하는 설정 파이프 사용시 오류 코드(non-zero exit code)를 이어받는다. e.g. $ mysqldump | gzip commands fails, than gzip commands returns non-zero -e option과 함께 사용된다. $ set -o pipefail When errtrace is enabled, the ERR trap is also triggered when the error (a command returning a nonzero code) occurs inside a function or a subshell. $ set -o errtrace # or $ set -E e.g. #!/bin/bash set -o errtrace function x { echo \"X begins.\" false echo \"X ends.\" } function y { echo \"Y begins.\" false echo \"Y ends.\" } trap 'echo \"ERR trap called in ${FUNCNAME-main context}.\"' ERR x y false true if set -o errtrace enabled X begins. ERR trap called in x. X ends. Y begins. ERR trap called in y. Y ends. ERR trap called in main context. disabled X begins. X ends. Y begins. Y ends. ERR trap called in main context. ","date":"2022-04-23","objectID":"/shell_script/:2:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"trap trap defines and activates handlers to run when the shell receives signals or other special conditions. # trap [action] [signal] trap 'echo \"Fatal: Exits abnormally at line #$(caller 0 || echo ${LINENO})\" \u003e\u00262' ERR ERR A SIGNAL_SPEC of ERR means to execute [action] each time a command’s failure would cause the shell to exit when the -e option is enabled. #$(caller 0 || echo ${LINENO}) ","date":"2022-04-23","objectID":"/shell_script/:3:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["script","shell"],"content":"redirection (\u003e) # \u003e1은 커맨드의 표준 출력을 다음에 나오는 파일 디스크립터에 전달한다. $ \u003e 1 # 쉘 스크립트의 표준 에러를 다음에 나오는 파일 디스크립터에 전달한다. $ \u003e2 # \u003e\u00262는 모든 출력을 강제로 쉘 스크립트의 표준 에러로 출력한다. $ \u003e\u00262 ","date":"2022-04-23","objectID":"/shell_script/:4:0","tags":["dev","shell"],"title":"Depp dive into shell script line by line","uri":"/shell_script/"},{"categories":["robotics"],"content":"tl;dr ","date":"2022-04-23","objectID":"/iot_core/:1:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"Terminology referenced Technical overview of Internet of Things article. top-level components(3) device: hardware itself and sw gateway: connect to cloud services without internet cloud: google cloud type of message state information(data) current status of the device read/write telemetry device metric (i.g sensor data, gps …) read only Each source of telemetry results in a channel Telemetry data might be preserved as a stateful variable on the device or in the cloud. commnads actions performed by a device. commands are often not idempotent which means each duplicate message usually results in a different outcome operational information i.g. CPU operating temperature and battery state can be transmitted as telemetry or state data. serial interface process of sending data one bit at a time, sequentially, over a communication channel or computer bus contrast to parallel communication GPIO General-purpose input/output pin can be designed to carry digital or analog signals, and digital pins have only two states: HIGH or LOW. PWM pulse width modulation The effect in the device can be a lower or higher power level ADC analog to digital conversion analog -\u003e binary I2C Inter Integrated Circuit Inter-Integrated Circuit serial bus uses a protocol that enables multiple modules to be assigned a discrete address on the bus pronounced “I two C”, “I-I-C”, or “I squared C”. OTA update over the air updates ","date":"2022-04-23","objectID":"/iot_core/:2:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"GCP IoT Core conecpts Devices, Configuration and State ","date":"2022-04-23","objectID":"/iot_core/:3:0","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"1. Device metadata metadata serves primarily as a label or identifier for devices. (or classifies devices) more secure than device state or device configuration because device metadata is never sent to or from a device shouldn’t change often (best: update it no more often than once per day) 500 key-value pairs (each key must be unique) Cloud IoT Core does not interpret or index device metadata e.g. hardware thumbprint, serial number, manufacturer information ","date":"2022-04-23","objectID":"/iot_core/:3:1","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"2. Device configuration IoT Core → device Sends desired state to robot with pre-defined commands like e.g. Device configuration is an arbitrary, user-defined blob of data sent from Cloud IoT Core to a device Device configuration is persisted in storage by Cloud IoT Core (64KB) After a configuration has been applied to a device, the device can report its state to Cloud IoT Core. A device configuration should focus on desired values or results, rather than on a sequence of commands Updates a device’s state by sending the expected state as a configuration Note that a device is not guaranteed to receive every configuration update If a configuration is being updated rapidly, devices may not receive intermediate versions. Configuration versions A device receives configurations only in increasing order of version numbers; in other words, it will never be sent a configuration older than its current version If the device reconnects to the MQTT bridge, it may receive an older configuration than it did during the earlier connection (rare case) ","date":"2022-04-23","objectID":"/iot_core/:3:2","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["robotics"],"content":"3. Device state device → IoT Core Captures the current status of the device, not the environment Devices can describe their state with an arbitrary user-defined blob of data sent from the device to the cloud Device state information is not updated frequently. Configuration and state data can have the same schema and encoding, or they can be different e.g. health of the device or its firmware version ","date":"2022-04-23","objectID":"/iot_core/:3:3","tags":["iot","gcp","robotics"],"title":"[GCP] Iot core","uri":"/iot_core/"},{"categories":["python"],"content":"Describes python google style editor settings on vscode ","date":"2022-04-17","objectID":"/python_formatter/:0:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"tl;dr full settings.json settings.json { \"security.workspace.trust.banner\": \"always\", \"security.workspace.trust.untrustedFiles\": \"open\", \"python.formatting.yapfPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/yapf\", \"python.sortImports.path\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/isort\", \"python.linting.pylintPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/pylint\", \"editor.tokenColorCustomizations\": { \"textMateRules\": [ { \"scope\": \"text.html.markdown.journal.task.open.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.task.open.marker\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.task.open.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.task.open.text\", \"settings\": {} }, { \"scope\": \"text.html.markdown.journal.task.completed.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.marker\", \"settings\": { \"foreground\": \"#AAAAAA\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.text\", \"settings\": { \"foreground\": \"#AAAAAA\" } }, { \"scope\": \"text.html.markdown.journal.task.completed.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.memo.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.memo.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.scope\", \"settings\": { \"foreground\": \"#FFFF00\" } }, { \"scope\": \"text.html.markdown.journal.link.keyword\", \"settings\": { \"fontStyle\": \"italic\" } }, { \"scope\": \"text.html.markdown.journal.link.bullet\", \"settings\": { \"foreground\": \"#FFFF00\" } } ] }, \"editor.fontSize\": 13, \"terminal.integrated.fontFamily\": \"'MesloLGS NF'\", \"editor.fontFamily\": \"Menlo, Monaco, 'Courier New', monospace\", \"editor.tabCompletion\": \"on\", \"editor.suggestSelection\": \"first\", \"vsintellicode.modify.editor.suggestSelection\": \"automaticallyOverrodeDefaultValue\", \"[markdown]\": { \"editor.tabCompletion\": \"onlySnippets\", \"editor.quickSuggestions\": { \"other\": \"on\", \"comments\": \"on\", \"strings\": \"on\" } }, \"[python]\": { \"editor.defaultFormatter\": \"ms-python.python\", \"editor.formatOnSave\": true, \"editor.codeActionsOnSave\": { \"source.organizeImports\": true, }, \"editor.rulers\": [ { \"column\": 80, \"color\": \"#5a5a5a80\" }, ] }, \"python.formatting.provider\": \"yapf\", // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/yapf\", \"python.formatting.yapfArgs\": [ \"--style\", \"google\", ], // or \"python.sortImports.path\": \"${workspaceFolder}/.venv/bin/isort\", \"python.sortImports.args\": [ \"--settings-file=${workspaceFolder}/.isort.cfg\", ], \"python.linting.enabled\": true, \"python.linting.lintOnSave\": true, \"python.linting.pylintEnabled\": true, // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/pylint\", \"python.linting.pylintArgs\": [ \"--load-plugins\", \"pylint_django\", \"pylint_quotes\", // related string quotes ], \"workbench.colorTheme\": \"Community Material Theme Palenight High Contrast\", \"[jsonc]\": { \"editor.defaultFormatter\": \"vscode.json-language-features\" }, } ","date":"2022-04-17","objectID":"/python_formatter/:1:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Yapf { ... \"python.formatting.provider\": \"yapf\", // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/yapf\", \"python.formatting.yapfPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/yapf\", ... \"python.formatting.yapfArgs\": [ \"--style\", \"google\", ], } ","date":"2022-04-17","objectID":"/python_formatter/:2:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Isort It helps to sort automatically whenever file is saved google import formatting guide vscode’s settings.json { ... \"python.sortImports.path\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/isort\", // or // \"python.sortImports.path\": \"${workspaceFolder}/.venv/bin/isort\", \"python.sortImports.args\": [ \"--settings-file=${workspaceFolder}/.isort.cfg\", ], ... } ${workspaceFolder}/.isort.cfg [settings] py_version=37 profile=google src_paths=api,common,core,infra,logs,tests,universe_z # 3 - Vertical Hanging Indent multi_line_output=3 include_trailing_comma=True force_single_line=False # profile google default # force_single_line: True # force_sort_within_sections: True # lexicographical: True # single_line_exclusions: ('typing',) # order_by_type: False # group_by_package: True readable references below isort options isort configs ","date":"2022-04-17","objectID":"/python_formatter/:3:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"Pylint TODO: force to avoid string double quotes { ... \"python.linting.enabled\": true, \"python.linting.lintOnSave\": true, \"python.linting.pylintEnabled\": true, // or \"python.linting.pylintPath\": \"${workspaceFolder}/.venv/bin/pylint\", \"python.linting.pylintPath\": \"/Library/Frameworks/Python.framework/Versions/3.7/bin/pylint\", \"python.linting.pylintArgs\": [ \"--load-plugins\", \"pylint_django\", \"pylint_quotes\", // related string quotes ], ... } ","date":"2022-04-17","objectID":"/python_formatter/:4:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["python"],"content":"IntelliSense general term for various code editing features including: code completion, parameter info, quick info, and member lists ","date":"2022-04-17","objectID":"/python_formatter/:5:0","tags":["dev","vscode","yapf","isort","pylint"],"title":"Google like python on vscode","uri":"/python_formatter/"},{"categories":["go"],"content":"gin framework로 crud 서버를 만들며 배운 내용들을 기록해보겠습니다. ","date":"2022-02-12","objectID":"/ch03_real_world/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"TIL go에서는 모든 type을 나타내고자 할 때 비어진 interface를 사용합니다.(dynamic typing) gin-gonic/context.go // MustBindWith binds the passed struct pointer using the specified binding engine. // It will abort the request with HTTP 400 if any error occurs. // See the binding package. func (c *Context) MustBindWith(obj interface{}, b binding.Binding) error { if err := c.ShouldBindWith(obj, b); err != nil { c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck return err } return nil } ","date":"2022-02-12","objectID":"/ch03_real_world/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Update crud를 만들면 update 부분을 깔끔하게 짜는것이 신경쓰입니다. 아래는 todo에서 짜본 update 코드입니다. func UpdateTodo(c *gin.Context) { var todo models.Todo id := c.Params.ByName(\"id\") err := models.GetTodoById(\u0026todo, id) if err != nil { c.JSON(http.StatusNotFound, todo) } c.BindJSON(\u0026todo) err = models.UpdateTodo(\u0026todo, id) if err != nil { c.AbortWithStatus(http.StatusNotFound) } else { c.JSON(http.StatusOK, todo) } } c.BindJSON(\u0026todo)를 ","date":"2022-02-12","objectID":"/ch03_real_world/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"conclustion 프로젝트 일정이 다가와서, gin 공식문서는 대충보고 프로젝트를 1달동안 만들어보았습니다. https://github.com/ExchangeDiary/exchange-diary . 만들면서 배우는게 가장 재밌게 배울 수 있는 거 같아서 만족스럽습니다. - 끝 -","date":"2022-02-12","objectID":"/ch03_real_world/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.3 Real World Go","uri":"/ch03_real_world/"},{"categories":["go"],"content":"Effective go 를 통해 go 핵심 문법을 빠르게 배워보겠습니다. 또한 나중에 레퍼런스 개념으로 개발할 때 찾아보기 위해서 필요해 보이는 정보들을 모으는 개념으로 글을 작성합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Formatting gofmt 패키지 아래 코드는 소스 파일이 아닌 패키지 레벨에서 실행됩니다. $ go fmt 들여쓰기 들여쓰기를 위해 탭(tabs)을 사용하며, gofmt는 기본값으로 탭을 사용한다. 만약 꼭 써야하는 경우에만 스페이스(spaces)를 사용하라. 한 줄 길이 Go는 한 줄 길이에 제한이 없다. 길이가 길어지는것에 대해 걱정하지 마라. 만약 라인 길이가 너무 길게 느껴진다면, 별도의 탭을 가지고 들여쓰기를하여 감싸라 괄호 Go는 C와 Java에 비해 적은 수의 괄호가 필요하다. 제어 구조들(if, for, switch)의 문법엔 괄호가 없다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Comment godoc package 주석 패키지에서 최상위 선언의 바로 앞에있는 주석이 그 선언의 문서주석으로 처리된다. 패키지 내부에서 최상위 선언 바로 이전의 주석은 그 선언을 위한 문서주석이다. 프로그램에서 모든 외부로 노출되는 (대문자로 시작되는) 이름은 문서주석이 필요하다. 첫 문장은 선언된 이름으로 시작하는 한 줄짜리 문장으로 요약되어야 한다. // Compile parses a regular expression and returns, if successful, // a Regexp that can be used to match against text. func Compile(str string) (*Regexp, error) { 패키지는 각각의 문서 주석을 패키지명과 함께 시작하기 때문에 만약 아래와 같은 명령을 터미널에 활용하면 효율적이다. $ godoc regexp | grep parse Compile parses a regular expression and returns, if successful, a Regexp parsed. It simplifies safe initialization of global variables holding cannot be parsed. It simplifies safe initialization of global variables ","date":"2022-02-07","objectID":"/ch02_go_basic/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Names ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Package Name Go에서는 이름의 첫 문자가 대문자인지 아닌지에 따라서 이름의 패키지 밖에서의 노출여부가 결정된다. package name 패키지가 임포트되면, 패키지명은 패키지 내용들에 대한 접근자가 된다. import \"bytes\" bytes.Buffer // usage 관례적으로, 패키지명은 소문자, 한 단어로만 부여하며 언더바(_)나 대소문자 혼용에 대한 필요가 없어야한다. 또 다른 규칙은 패키지명은 소스 디렉토리 이름 기반이라는 것이다. src/encoding/base64에 있는 패키지는 encoding/base64로 임포트가 된다. base64라는 이름을 가지고 있지만, encoding_base64나 encodingBase64를 쓰지 않는다. import .표현을 사용하지 말라. Package Naming Convention bufio 패키지에 있는 버퍼 리더는 BufReader가 아닌 Reader로 불린다. 왜냐하면 사용자는 이를 bufio.Reader로 보게되며, 이것이 더 명확하고 간결하기 때문이다. 게다가 임포트된 객체들은 항상 패키지명과 함께 불려지기 때문에 bufio.Reader는 io.Reader와 충돌하지 않는다. … 중략 … Go에 존재하는 ring.Ring이라는 구조체의 인스턴스를 만드는 함수는 보통은 NewRing으로 불릴테지만, Ring은 패키지 밖으로 노출된 유일한 타입이며, 패키지가 ring으로 불리기 때문에, 이 함수는 그냥 New라고 부르고 ring.New와 같이 사용한다. Comment is better than long naming 또 다른 간단한 예시는 once.Do이다. once.Do(setup)는 읽기가 쉬우며 once.DoOrWaitUntilDone(setup)으로 개선될게 없다. 긴 이름은 좀 더 쉽게 읽는것을 방해한다. 문서에 주석을 다는것이 긴 이름을 사용하는 것보다 더 좋을 것이다. 클린코드에서는 네이밍을 길게 가져가고 주석을 없애는, 즉 코드로 설명이 가능하도록 하자는 적략을 취하는데 Effective go를 쓴 저자는 무조건 짧은게 최고다는 느낌을 준다. 이러다 보니 history 차원이 아닌 설명을 위한 주석을 달때는 죄의식을 느꼈는데, 개인적으로 미니멀리즘을 좋아하니 go 방식이 더 끌리는 것 같다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Getter and Setter Go는 getters와 setters를 자체적으로 제공하지 않는다. getter and setter naming getter의 이름에 Get을 넣는건 Go언어 답지도, 필수적이지도 않다. 만약 owner(첫 문자가 소문자이며 패키지 밖으로 노출되지 않는다.)라는 필드를 가지고 있다면 getter 메서드는 GetOwner가 아닌 Owner(첫 문자가 대문자이며, 패키지 밖으로 노출됨)라고 불러야한다. … 중략 … 만약 필요하다면, setter 함수는 SetOwner라고 불릴 것이다 owner := obj.Owner() if owner != user { obj.SetOwner(user) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface 관례적으로, 하나의 메서드를 갖는 인터페이스는 메서드 이름에 -er 접미사를 붙이거나 에이전트 명사를 구성하는 방식을 사용한다. Reader Writer Formatter CloseNotifier … ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"MixedCaps go는 camelCase를 사용한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:3:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Semicolons C언어 처럼, Go의 정식문법은 구문을 종료하기 위하여 세미콜론을 사용한다. 하지만 C언어와는 달리 세미콜론은 소스상에 나타나지 않는다. 대신 구문분석기(lexer)는 간단한 규칙을 써서 스캔을 하는 과정에 자동으로 세미콜론을 삽입한다. 그래서 소스작성시 대부분 세미콜론을 사용하지 않는다. 세미콜론과 중괄호 세미콜론 입력규칙의 중요한 한가지는 제어문(if, for, switch, 혹은 select)의 여는 중괄호({)를 다음 라인에 사용하지 말아야 한다. // This is good if i \u003c f() { g() } // This sucks if i \u003c f() // wrong! { // wrong! g() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Control structures Go언어에서는 do 나 while 반복문이 존재하지 않으며, for, switch select가 존재한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"if 중괄호를 의무적으로 사용해야 하기 때문에, 다중 라인에서 if 구문들이 간단하게 작성된다. if x \u003e 0 { return y } if와 switch가 초기화 구문을 허용하므로 지역변수를 설정하기 위해 사용된 초기화 구문을 흔히 볼 수 있다. if err := file.Chmod(0664); err != nil { log.Print(err) return err } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Redeclaration and reassignment 먼저 아래의 코드를 보자 f, err := os.Open(name) d, err := f.Stat() 이런 경우처럼 err가 위/아래 곳 모두에서 사용되는데, 이런 선언 중복은 허용된다. Function variable Go언어에서 함수 파라미터와 리턴 값들은, 함수를 감싸고 있는 브래이스들(braces)밖에 위치해 있음에도, 그 스코프는 함수 body의 스코프와 동일하다는 점을 주목할 가치가 있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"for // C언어와 같은 경우 for init; condition; post { } // C언어의 while 처럼 사용 for condition { } // C언어의 for(;;) 처럼 사용 for { } 아래는 go-style for문들입니다. sum := 0 for i := 0; i \u003c 10; i++ { sum += i } 만약 배열, slice, string, map, 채널로 부터 읽어 들이는 반복문을 작성한다면, range 구문이 이 반복문을 관리가능합니다. for key, value := range oldMap { newMap[key] = value } 이렇게 index를 날릴수도 있습니다. for key := range m { if key.expired() { delete(m, key) } } UTF-8 파싱이 덜된 string의 경우 rune으로 변환된다. for pos, char := range \"日本\\x80語\" { // \\x80 은 합법적인 UTF-8 인코딩이다 fmt.Printf(\"character %#U starts at byte position %d\\n\", char, pos) } /* character U+65E5 '日' starts at byte position 0 character U+672C '本' starts at byte position 3 character U+FFFD '�' starts at byte position 6 character U+8A9E '語' starts at byte position 7 */ 다음은 parallel assignment를 사용한 for문이다. for i, j := 0, len(a) -1; i\u003cj; i,j = i+1, j-1 { a[i], a[j] = a[j], a[i] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Switch func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } go에서는 switch에 Label(예시에서는 Label)을 넣어서 escape하는 방식도 가끔이지만 쓰인다. Loop: for n := 0; n \u003c len(src); n += size { switch { case src[n] \u003c sizeOne: if validateOnly { break } size = 1 update(src[n]) case src[n] \u003c sizeTwo: if n+1 \u003e= len(src) { err = errShortInput break Loop } if validateOnly { break } size = 2 update(src[n] + src[n+1]\u003c\u003cshift) } } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Type switch 스위치 구문은 인터페이스 변수의 동적 타입을 확인하는데 사용될 수도 있다. var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } ","date":"2022-02-07","objectID":"/ch02_go_basic/:5:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Functions ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Multiple return values 값과 에러를 같이 내리는 signature func (file \\*File) Write(b []byte) (n int, err error) index와 value를 return func nextInt(b []byte, i int) (int, int) { for ; i \u003c len(b) \u0026\u0026 !isDigit(b[i]); i++ { } x := 0 for ; i \u003c len(b) \u0026\u0026 isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Named result parameters Go 함수에서는 반환 “인자\"나 결과 “인자\"에 이름을 부여하고 인자로 들어온 매개변수처럼 일반 변수로 사용할 수 있다. 이름을 부여하면, 해당 변수는 함수가 시작될 때 해당 타입의 제로 값으로 초기화 된다. func nextInt(b []byte, pos int) (value, nextPos int) { } return parameter는 선언되기 때문에 다음과 같이 사용될 수도 있다. func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) \u003e 0 \u0026\u0026 err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } return } ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Defer Go 의 defer 문은 defer 를 실행하는 함수가 반환되기 전에 즉각 함수 호출(연기된 함수)을 실행하도록 예약한다. 이를 통해 기존의 언어가 자원 해제를 context를 사용했던 것과 달리 defer라는 키워드를 통해서 자원 해지가 가능해진다. (python에서는 with을 사용해서 context가 끝날때 exit 호출을 처리해 주었다.) 다음은 mutex에 lock을 풀거나 잠그는 코드입니다. func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(resut, buf[0:n]...) if err != nil { if err == io.EOF { break } return \"\", err } } return string(result), nil } close를 delay 시킴으로써 크게 2가지 장점을 얻게된다. 파일을 닫는 것을 잊어버리는 실수를 하지 않도록 보장해 준다. open 근처에 close 가 위치하면 함수 맨 끝에 위치하는 것 보다 훨씬 명확한 코드가 되는것을 의미한다. defer는 함수가 종료될 때 실행되기 때문에 하나의 defer 호출 위치에서 여러개의 함수 호출을 delay 시킬 수 있다. for i:=0; i \u003c 5; i++ { defer fmt.Println(i) } 지연된 함수는 LIFO 순서로 실행된다. (4 3 2 1 0) (와우 궁금했던 부분인데) 추가로 defer안에 인자들에 대한 평가는 기존 함수 실행 순서에 따라 진행된다. 다음은 조금 더 복잡한 defer 예시이다. func trace(s string) string { fmt.Println(\"entering:\", s) return s } func un(s string) { fmt.Println(\"leaving:\", s) } func a() { defer un(trace(\"a\")) fmt.Println(\"in a\") } func b() { defer un(trace(\"b\")) fmt.Println(\"in b\") a() } func main() { b() } 위 함수들에 대한 결과는 아래와 같다. entering: b in b entering: a in a leaving: a leaving: b 나중에 나올 panic 과 recover를 사용하면 더욱 멋진 것들을 만들 수 있다고 한다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:6:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Data ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with new Go에는 메모리를 할당하는 두가지 기본 방식이 있는데, 내장(built-in) 함수인 new와 make이다. new: 새로 제로값으로 할당된 타입 T를 가리키는 포인터를 반환 new(File) == \u0026File{} make: 내부 데이터 구조를 초기화하고 사용될 값을 준비한다. 먼저 new부터 살펴보면, 내장 함수로 메모리를 할당하지만 다른 언어에 존재하는 같은 이름의 기능과는 다르게 메모리를 초기화하지 않고, 단지 값을 제로화(zero) 한다. 다시 말하면, new(T)는 타입 T의 새로운 객체에 제로값이 저장된 공간(zeroed storage)을 할당하고 그 객체의 주소인, *T값을 반환한다. 제로값의 유용함은 전이적인(transitive) 특성이 있다. type SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer } p := new(SyncedBuffer) // type *SyncedBuffer var v SyncedBuffer // type SyncedBuffer ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constructors and composite literals(합성 리터럴) 때로 제로값만으로는 충분치 않고 생성자(constructor)로 초기화해야 할 필요가 생긴다. 먼저 불필요한 boiler plate 코드 부터 확인해보자. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f } 아래는 constructor를 활용한 방식이다. func NewFile(fd int, name string) *File { if fd \u003c 0 { return nil } f := File{fd, name, nil, 0} return \u0026f } C와는 달리, 로컬 변수의 주소를 반환해도 아무 문제가 없음을 주목하라; 변수에 연결된 저장공간은 함수가 반환해도 살아 남는다. 실제로, 합성 리터럴의 주소를 취하는 표현은 매번 실행될 때마다 새로운 인스턴스에 연결된다. 그러므로 마지막 두 줄을 묶어 버릴 수 있다. return \u0026File{fd, name, nil, 0} 합성 리터럴의 필드들은 순서대로 배열되고 반드시 입력해야 한다. 하지만, 요소들에 레이블을 붙여 필드:값 식으로 명시적으로 짝을 만들면, 초기화는 순서에 관계 없이 나타날 수 있다. 입력되지 않은 요소들은 각자에 맞는 제로값을 갖는다. 그러므로 아래와 같이 쓸 수 있다. return \u0026File{fd: fd, name: name} Composite literals(합성 리터럴)이란? Composite literals are used to construct the values for arrays, structs, slices, and maps a := [...]string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // array s := []string {Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // slice m := map[int]string{Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"} // map ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Allocation with make new와 달리 make는 slices, maps, 그리고 channels에만 사용하고 (*T가 아닌) 타입 T의 (제로값이 아닌) 초기화된 값을 반환한다. 아래는 new와 make의 차이점을 보여준다. var p *[]int = new([]int) // slice 구조체를 할당한다; *p == nil; 거의 유용하지 않다 var v []int = make([]int, 100) // slice v는 이제 100개의 int를 갖는 배열을 참조한다 // 불필요하게 복잡한 경우: var p *[]int = new([]int) *p = make([]int, 100, 100) // Go 언어다운 경우: v := make([]int, 100) make는 maps, slices 그리고 channels에만 적용되며 포인터를 반환하지 않음을 기억해야 합니다. 포인터를 얻고 싶으면 new를 사용해서 메모리를 할당하거나 변수의 주소를 명시적으로 취해야 합니다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Arrays Go와 C에서는 배열의 작동원리에 큰 차이가 있다. Go에서는, 배열은 값이다. 한 배열을 다른 배열에 assign할 때 모든 값이 복사된다. 함수의 argument로 배열을 패스하면, 포인터가 아닌 copy된 array를 받는다. 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다. 개인적으로 배열의 크기는 타입의 한 부분이다. 타입 [10]int과 [20]int는 서로 다르다.가 무슨 말인지 잘 모르겠다. 배열을 값(value)으로 사용하는 것이 유용할 수도 있지만 또한 비용이 큰 연산이 될 수도 있다; 만약 C와 같은 실행이나 효율성을 원한다면, 아래와 같이 배열 포인터를 보낼 수도 있다. func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } array := [...]float64{7.0, 8.5, 9.1} x := Sum(\u0026array) // 명시적인 주소 연산자(\u0026)를 주목하라. 하지만 이런 스타일조차 Go언어 답지는 않다. 대신 slice를 사용하라. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:4","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Slices Go에서는 변환 메스릭스와 같이 뚜렷한 차원(dimension)을 갖고 있는 항목들을 제외하고는, 거의 모든 배열 프로그래밍은 단순한 배열보다는 slice를 사용한다. Slice는 내부의 배열을 가리키는 레퍼런스를 쥐고 있어, 만약에 다른 slice에 할당(assign)되어도, 둘 다 같은 배열을 가리킨다. 함수가 slice를 받아 그 요소에 변화를 주면 호출자도 볼 수 있는데, 이것은 내부의 배열를 가리키는 포인터를 함수에 보내는 것과 유사하다. slice의 용량은, 내장함수 cap을 통해 얻을 수 있는데, slice가 가질 수 있는 최대 크기를 보고한다. 아래를 보면 slice에 데이터를 부착(append)할 수 있는 함수가 있다. 만약 데이터가 용량을 초과하면, slice의 메모리는 재할당된다. 결과물인 slice는 반환된다. func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } slice는 꼭 처리후 반환되어야 한다. Append가 slice의 요소들을 변경할 수 있지만, slice 자체(포인터, 크기, 용량을 갖고 있는 런타임 데이터 구조)는 값으로 패스되었기 때문이다. 참고로 slice에는 append가 구현되어있다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:5","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Two-dimensional slices 다음은 go에서 이차원 slices 또는 배열을 정의하고 init하는 방법입니다. type Transform [3][3]float64 type LinesOfText [][]byte text := LinesOfText{ []byte(\"Leoo is awesome\"), []byte(\"Life is fun\"), []byte(\"Life is full of love\"), []byte(\"Let's give our love and fire to the world\") } 예를 들어 사진을 스캔하는 상황이 온다면 2가지 방식으로 이를 해결할 수 있다. 일반적으로 2차원 배열을 만들어 사용하는 방식 height := 300 width := 300 picture := make([][]uint8, height) for i:= range picture { picture[i] = make([]uint8, width) } 하나의 긴 slice에 width만큼 자르면서 이차원 배열에 포인터를 전달하는 방식 picture := make([][]uint8, height) pixels := make([]uint8, width * height) for i := range picture { picture[i], pixels = pixels[:width], pixels[width:] } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:6","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Maps {key: value} key는 equality연산이 정의되어 있는 어떤 타입이라도 가능하다. int float string pointer interface(equality 구현된) structs array slice의 경우에는 map의 key로 사용이 될 수 없는데, 이유는 equality가 정의되어 있지 않기 때문이다. 왜 slice에는 equality가 없을까? go에 제시되었던 issue 에 레퍼런스된 slice equality에 대한 golang discussion 링크 를 보면서 일부분을 정리하면, slice가 value로 비교해야할지, pointer타입으로 비교해야할지 혼돈을 줄 수 있기 때문이라고 합니다. This would probably introduce unnecessary confusion. People are used to the equality operator comparing values in go, as opposed to references. It’s much better if the slices finally support the equality operator, even though the comparison speed will depend on the number of items in the slices. Slice와 마찬가지로 map 역시 내부 데이터 구조를 가진다. 함수에 map을 입력하고 map의 내용물을 변경하면, 그 변화는 호출자에게도 보인다. Map 또한 콜론으로 분리된 key-value 짝을 이용한 합성 리터럴로 생성될 수 있으며, 초기화중에 쉽게 만들 수 있다. var timeZone = map[string]int{ \"UTC\": 0*60*60, \"EST\": -5*60*60, \"CST\": -6*60*60, \"MST\": -7*60*60, \"PST\": -8*60*60, } offset := timeZone[\"EST\"] go는 keyError를 내지 않고 타입별로 0을 의미하는 값을 리턴한다. 그러므로 아래와 같은 경우가 가능하다. attended := map[string]bool{ \"Ann\": true, \"Joe\": true, ... } if attended[person] { // 만약 person이 맵에 없다면 false일 것이다. fmt.Println(person, \"was at the meeting\") } 만약 value가 bool인 경우같이 keyError와 value(false)를 구분하고 싶다면 아래와 같이한다. 이것을 “comma ok” 관용구라고 부른다. 이 예제에서, 만약 tz가 있다면, seconds는 적절히 세팅될 것이고 ok는 true가 된다 var seconds int var ok bool seconds, ok = timeZone[tz] 다음은 에러헨들링 하는 방식이다. func offset(tz string) int { if seconds, ok := timeZone[tz]; ok { return seconds } log.Println(\"unknown time zone:\", tz) return 0 } 값이 필요없다면 이렇게 한다. _, present := timeZone[tz] Map의 엔트리를 제거하기 위해서는, 내장 함수 delete을 쓰는데, map과 제거할 key를 인수로 쓴다. map에 key가 이미 부재하는 경우에도 안전하게 사용할 수 있다. delete(timeZone, \"PDT\") // Now on Standard Time ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:7","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Printing 정수(integer)를 소수로 바꾸는 예와 같은 기본적인 변환을 원할 경우는, 다목적 용도 포맷인 %v(value라는 의미로)를 사용할 수 있다 fmt.Printf(\"%v\\n\", timeZone) // or just fmt.Println(timeZone) // map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200] 물론, map의 경우 key들은 무작위로 출력될 수 있다. struct를 출력할 때는, 수정된 포맷인 %+v를 통해 구조체의 필드에 주석으로 이름을 달며, 대안 포맷인 %#v를 사용하면 어떤 값이든 완전한 Go 문법을 출력한다. type T struct { a int b float64 c string } t := \u0026T{ 7, -2.35, \"abc\\tdef\" } fmt.Printf(\"%v\\n\", t) fmt.Printf(\"%+v\\n\", t) fmt.Printf(\"%#v\\n\", t) fmt.Printf(\"%#v\\n\", timeZone) \u0026{7 -2.35 abc def} \u0026{a:7 b:-2.35 c:abc def} \u0026main.T{a:7, b:-2.35, c:\"abc\\tdef\"} map[string] int{\"CST\":-21600, \"PST\":-28800, \"EST\":-18000, \"UTC\":0, \"MST\":-25200} 또 다른 유용한 포맷은 %T로, 값의 타입을 출력한다. fmt.Printf(\"%T\\n\", timeZone) // map[string] int 커스텀 타입 print 포맷 지정하는 방법 커스텀 타입의 기본 포맷을 조종하기 위해 해야할 것은 단지 String() string의 시그너처를 갖는 메서드를 정의해 주는 것이다. (위에 정의된) 단순한 타입 T는 아래와 같은 포맷을 가질 수 있다. func (t *T) String() string { return fmt.Sprintf(\"%d/%g/%q\", t.a, t.b, t.c) } fmt.Printf(\"%v\\n\", t) // 7/-2.35/\"abc\\tdef\" 위에 예제에서 struct 타입에 포인터를 사용한 이유는 더 효율적이고 Go 언어다운 선택이기 때문이다. String 메서드가 Sprintf를 호출할 수 있는 이유는 print 루틴들의 재진입(reentrant)이 충분히 가능하고 예제와 같이 감싸도 되기 때문이다. 하지만 이 방식에 대해 한가지 이해하고 넘어가야 하는 매우 중요한 디테일이 있는데: String 매서드를 만들면서 Sprintf를 호출할 때 다시 String 매서드로 영구히 재귀하는 방식은 안 된다는 것이다. Sprintf가 리시버를 string처럼 직접 출력하는 경우에 이런 일이 발생할 수 있는데, 그렇게 되면 다시 같은 메서드를 호출하게 되고 말 것이다. 흔하고 쉽게 하는 실수로, 다음의 예제에서 살펴보자. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", m) // 에러: 영원히 재귀할 것임. } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 해결책은 string() 시켜주면 된다. 인수를 기본적인 문자열 타입으로 변환하면, 같은 메서드가 없기 때문이다. package main import \"fmt\" type MyString string func (m MyString) String() string { return fmt.Sprintf(\"MyString=%s\", string(m)) } func main() { var s MyString = \"test\" fmt.Printf(\"%v\\n\", s) } 또 다른 출력 기법으로는 출력 루틴의 인수들을 직접 또 다른 유사한 루틴으로 대입하는 것이다. Printf의 시그너처는 마지막 인수로 임의적인 숫자의 파라미터가 포맷 다음에 나타날 수 있음을 명시하기 위해 타입 ...interface{}를 사용한다. // Println 함수는 fmt.Println처럼 표준 로거에 출력한다. func Println(v ...interface{}) { std.Output(2, fmt.Sprintln(v...)) // Output 함수는 (int, string) 파라미터를 받게된다. } log.Println(\"Hello\", \"世界\", 1, 2, 3, 4, 5, 6, 7, 8) // 2009/11/10 23:00:00 Hello 世界 1 2 3 4 5 6 7 8 Sprintln을 부르는 중첩된 호출안에 v 다음에 오는 ...는 컴파일러에게 v를 인수 리스트로 취급하라고 말하는 것이고; 그렇지 않은 경우는 v를 하나의 slice 인수로 대입한다. ... 파라미터는 특정한 타입을 가질 수도 있는데, 예로 integer 리스트에서 최소값을 선택하는 함수인 min에 대한 ...int를 살펴보자 func Min(a ...int) int { min := int(^uint(0) \u0026gt; \u0026gt; 1) // wtf???? for _, i := range a { if i \u003c min { min = i } } return min } ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:8","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Append go에 내장되어있는 append 함수의 signature는 다음과 같다. // slice는 func append(slice []T, elements ...T) []T 기본적인 사용법 x := []int{1,2,3} x = append(x, 4, 5, 6) fmt.Println(x) slice 끼리 append x := []int{1,2,3} y := []int{4,5,6} x = append(x, y...) fmt.Println(x) ","date":"2022-02-07","objectID":"/ch02_go_basic/:7:9","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Initialization ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Constants 상수는 -함수 내에서 지역적으로 정의된 상수조차도- 컴파일할 때 생성되며, 아래 중 하나가 되어야 한다. 숫자(number) 문자(rune) 문자열(string) 참/거짓(boolean) 상수를 정의하는 표현식은 컴파일 타임에 실행가능한 constant expression이어야 한다. 예를 들어 1\u003c\u003c3은 상수 표현식이지만 math.Sin(math.Pi/4)는 상수 표현식이 아니다. math 패키지의 Sin 함수에 대한 호출이 런타임 시에만 가능하기 때문이다. type ByteSize float64 const ( _ = iota // 공백 식별자를 이용해서 값인 0을 무시 KB ByteSize = 1 \u003c\u003c (10 * iota) MB GB TB PB EB ZB YB ) func (b ByteSize) String() string { switch { case b \u003e= YB: return fmt.Sprintf(\"%.2fYB\", b/YB) case b \u003e= ZB: return fmt.Sprintf(\"%.2fZB\", b/ZB) case b \u003e= EB: return fmt.Sprintf(\"%.2fEB\", b/EB) case b \u003e= PB: return fmt.Sprintf(\"%.2fPB\", b/PB) case b \u003e= TB: return fmt.Sprintf(\"%.2fTB\", b/TB) case b \u003e= GB: return fmt.Sprintf(\"%.2fGB\", b/GB) case b \u003e= MB: return fmt.Sprintf(\"%.2fMB\", b/MB) case b \u003e= KB: return fmt.Sprintf(\"%.2fKB\", b/KB) } return fmt.Sprintf(\"%.2fB\", b) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Variables 변수의 초기화는 상수와 같은 방식이지만, 초기화는 런타임에 계산되는 일반적인 표현식이어도 된다. var ( home = os.Getenv(\"HOME\") user = os.Getenv(\"USER\") gopath = os.Getenv(\"GOPATH\") ) ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"init() 최종적으로, 각 소스파일은 필요한 어떤 상태든지 셋업하기 위해서 각자의 init 함수를 정의할 수 있다. 여기서 “최종적으로” 라는 말은 정말로 마지막을 가리킨다: init 함수는 모든 임포트된 패키지들이 초기화되고 패키지 내의 모든 변수 선언이 평가된 이후에 호출된다. 선언의 형태로 표현할 수 없는 것들을 초기화하는 것 외에도, init 함수는 실제 프로그램의 실행이 일어나기 전에 프로그램의 상태를 검증하고 올바르게 복구하는데 자주 사용된다. init init 함수는 매개변수를 가지지 않으며, 각 파일은 여러 개의 init 함수를 가질 수 있다 func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath may be overridden by --gopath flag on command line. flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-02-07","objectID":"/ch02_go_basic/:8:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Methods ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Pointer vs Value 이전에 만들었던 append 함수와 비교하며 새로운 append 함수를 정의해보자. 들어가기 앞서 앞전에 만들었던 Append 부터 다시 살펴보자 func Append(slice, data []byte) []byte { l := len(slice) if l + len(data) \u003e cap(slice) { // 재할당의 경우 doubleLength := (l+len(data))*2 newSlice := make([]byte, doubleLength) // copy 함수는 사전에 선언되어 있고 어떤 slice 타입에도 사용될 수 있다. copy(newSlice, slice) slice = newSlice } slice = slice[0: l + len(data)] copy(slice[1:], data) return slice } 자 이제 append함수를 슬라이스의 메서드로 재정의 하는 방법 type ByteSlice []byte func (slice ByteSlice) Append(data []byte) []byte { ... 이전과 동일 ... } 위와 같이 할 경우, 값을 return해서 재할당 시켜줘야한다. 이를 피하기 위해 포인터를 사용할 수도 있다. func (p *ByteSlice) Append(data []byte) { slice := *p // 함수 내용은 위와 같지만, return이 없다. *p = slice } 마지막으로 표준 write 메서드 처럼 구현을 해보면 더 멋진 코드를 만들 수 있다. func (p *ByteSlice) Write(data []byte) (n int, err error) { slice := *p // 내용은 위와 같다. *p = slice return len(data), nil } 타입 *ByteSlice는 표준 인터페이스 io.Writer를 따르게되며, 다루기가 편해진다. 예를 들면, 다음처럼 ByteSlice에 값을 넣을 수 있다. var b ByteSlice fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) fmt.Fprintf(\u0026b, \"This hour has %d days\\n\", 7) ByteSlice의 주소만 넘긴 이유는, 오직 포인터 타입인 *ByteSlice만이 io.Writer 인터페이스를 만족시키기 때문이다. 리시버로 포인터를 쓸 것인가 값을 쓸 것인가에 대한 규칙은 값을 사용하는 메서드는 포인터와 값에서 모두 사용할 수 있으며, 포인터 메서드의 경우 포인터에서만 사용이 가능하다는 것이다. 이러한 규칙은 포인터 메서드는 리시버를 변형시킬 수 있는데 메서드를 값에서 호출하게 되면 값의 복사본을 받기 때문에 원래값을 변형할 수 없기 때문에 생겨났다. Go언어는 이러한 실수(값에서 포인터 메서드를 실행하는 일)를 허용하지 않는다. 하지만 편리한 예외도 있다. 주소를 얻을 수 있는 값의 경우에, Go언어는 포인터 메서드를 값 위에서 실행할 경우 자동으로 주소 연산을 넣어준다. 위의 예시에서, 변수 b는 주소로 접근이 가능하기 때문에 단순히 b.Write만으로 Write메서드를 호출할 수 있다. 컴파일러는 이것을 (\u0026b).Write로 재작성할 것이다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:9:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface Go언어의 인터페이스는 객체의 행위(behavior)를 지정해 주는 하나의 방법이다: 만약 어떤 객체가 정해진 행동를 할 수 있다면 호환되는 타입으로 쓸 수 있다는 뜻이다. (Duck typing, Go는 런타임에 duck typing하는 파이썬과 달리 Compile time duck typing이 가능하므로, 성능의 문제가 없다) 인터페이스의 이름(명사)은 보통 메서드(동사)에서 파생된다: Write 메서드를 구현하면 io.Writer가 인터페이스의 이름이 되는 경우. 타입은 복수개의 인터페이스를 구현할 수 있다. sort.Interface 와 Stringer 두개의 interface를 구현하는 타입의 예시를 보자면 아래와 같다. sort.Interface type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } Stringer type Stringer interface { String() string } sort.Interface와 Stringer를 만족하는 type type Sequence []int // sort.Interface func (s Sequence) Len() int { return len(s) } func (s Sequence) Less(i, j int) bool { return s[i] \u003c s[j] } func (s Sequence) Swap(i, j int) { s[i], s[j] = s[j], s[i] } // Stringer func (s Sequence) String() string { sort.Sort(s) // Sequence 타입은 []int와 네이밍 외에는 모두같은 타입이기 때문에 변환 가능하다. return fmt.Sprint([]int(s)) // type converted (Sequence -\u003e []int) } 위의 코드의 Len(), Less(), Swap() 함수는 실제로, sort.Sort()에 들어가는 sort.Interface를 만족시키기 위해 사용하기 위해 작성된 메서드들이다. 그러므로 아래와 같이 간단하게 코드를 간소화 시킬 수 있다. type Sequence []int func (s Sequence) String() string { sort.IntSlice(s).Sort() return fmt.Spring([]int(s)) } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interface conversions and type assertions 타입 스위치는 Interface conversions(변환)의 한 형태이다: 인터페이스를 받았을 때, switch문의 각 case에 맞게 타입 변환을 한다 아래 예제는 fmt.Printf가 타입 스위치를 써서 어떻게 주어진 값을 string으로 변환시키는 지를 단순화된 버전으로 보여 주고 있다. 만약에 값이 이미 string인 경우는 인터페이스가 잡고 있는 실제 string 값을 원하고, 그렇지 않고 값이 String 메서드를 가지고 있을 경우는 메서드를 실행한 결과를 원한다. type Stringer interface { String() string } var value interface{} switch str := value.(type) { case string: return str case Stringer: return str.String() } 오로지 한 타입만에만 관심이 있는 경우는 어떨까? 만약 주어진 값이 string을 저장하는 걸 알고 있고 그냥 그 string 값을 추출하고자 한다면? 단 하나의 case만을 갖는 타입 스위치면 해결 할 수 있지만 타입 단언 표현을 쓸 수도 있다. Type Assertion(타입 단언)은 인테페이스 값을 가지고 지정된 명확한 타입의 값을 추출한다. 문법은 타입 스위치를 열 때와 비슷하지만 type 키워드 대신 명확한 타입을 사용한다 //value.(typeName) str := value.(string) 여기에서 typeName은 static type이다. 만약 위의 예시에서 value가 string 타입을 가지고 있지 않을 경우, 프로그램은 런타임 에러를 내고 죽는다. 이런 참사에 대비하기 위해서, “comma, ok” 관용구를 사용하여 안전하게 값이 string인지 검사 해야 한다. str, ok := value.(string) if ok { fmt.Printf(\"string value is: %q\\n\", str) } else { fmt.Printf(\"value is not a string\\n\") } 아래는 위에서 보여준 타입 스위치와 동일한 기능을 하는 if-else문 예시이다. if str, ok := value.(string); ok { return str } else if str, ok := value.(Stringer); ok { return str.String() } ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:1","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Generality 만약 어떤 타입이 오로지 인터페이스를 구현하기 위해서만 존재한다면, 즉 인터페이스외 어떤 메서드도 외부에 노츨시키지 않은 경우, 타입 자체를 노출 시킬 필요가 없다. 그런 경우에, constructor는 구현 타입보다는 인터페이스 값을 반환해야 한다. 설명에 좋은 예시가 있어 인용하자면 Quote 각종 crypto 패키지내의 스트리밍 cipher 알고리즘들을, 이들이 연결해 쓰는 block cipher들로 부터 분리시킬 수 있다. crypto/cipher 패키지내 Block 인터페이스는 한 block의 데이터를 암호화하는 block cipher의 행위를 정의한다. 그런 다음, bufio 패키지에서 유추해 볼 수 있듯이, Block 인터페이스를 구현하는 cipher 패키지들은, Stream 인터페이스로 대표되는 스트리밍 cipher들을 건설할 때, block 암호화의 자세한 내용을 알지 못하더라도, 사용될 수 있다. type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) } type Stream interface { XORKeyStream(dst, src []byte) } block cipher를 스트리밍 cipher로 바꾸어 주는 카운터 모드 (CTR) 스트림의 정의가 있다. 주의해야할 점은 input과 output이 모두 interface 타입이다. // NewCTR은 카운더 모드로 주어진 Block을 이용하여 암호화하고/해독하는 스트림을 반환한다. // iv의 길이는 Block의 block 크기와 같아야 한다. func NewCTR(block Block, iv []byte) Stream ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:2","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Interfaces and methods Quote Since almost anything can have methods attached, almost anything can satisfy an interface. 거의 모든 것에 메서드를 첨부할 수 있다는 말은 거의 모든 것이 인터페이스를 만족 시킬 수 있다는 말이기도 합니다. 심지어 함수에도 메서드를 첨부시킬 수 있다. 대표적인 예가 http 패키지이다. type Handler interface { ServeHTTP(ResponseWriter, *Request) } ... // 단순한 카운터 서버. type Counter int func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) { *ctr++ fmt.Fprintf(w, \"counter = %d\\n\", *ctr) } ... import \"net/http\" ... ctr := new(Counter) http.Handle(\"/counter\", ctr) ... // 채널이 매 방문마다 알린다. // (아마 이 채널에는 버퍼를 사용해야 할 것이다.) type Chan chan *http.Request func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) { ch \u003c- req fmt.Fprint(w, \"notification sent\") } // 마지막으로, 서버를 구동할 때 사용한 명령줄 인수들을 /args에 보여주려는 경우를 상상해 보자. // 명령줄 인수를 출력하는 함수를 쓰는 것은 간단하다. func ArgServer() { fmt.Println(os.Args) } 이것을 어떻게 HTTP 서버로 바꿀 수 있을까? 어떤 타입에다가 값은 무시하면서 ArgServer를 메서드로 만들 수 있을 것이다. 하지만 더 좋은 방법이 있다. 포인터와 인터페이스만 빼고는 어떤 타입에도 메서드를 정의할 수 있는 사실을 이용해서, 함수에 메서드를 쓸 수 있다. http 패키지에 다음과 같은 코드가 있다: // HandlerFunc는 어뎁터로써 평범한 함수를 HTTP handler로 쓸 수 있게 해 준다. // 만약에 f가 적절한 함수 signature를 가지면, // HandlerFunc(f)는 f를 부르는 Handler 객체인 것이다. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, req). func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) { f(w, req) } HandlerFunc는 ServeHTTP라는 매서드를 같는 타입으로, 이 타입의 값은 HTTP request에 서비스를 제공한다. 메서드의 구현을 한번 살펴 보자. 리시버는 함수, f이고 메서드가 f를 부른다. 이상해 보일 수도 있지만, 리시버가 채널이고 메서드가 채널에 데이터를 보내는 예와 비교해도 크게 다르지 않다. ","date":"2022-02-07","objectID":"/ch02_go_basic/:10:3","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"The blank identifier https://gosudaweb.gitbooks.io/effective-go-in-korean/content/the_blank_identifier.html ","date":"2022-02-07","objectID":"/ch02_go_basic/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"conclustion [2022-02-08T19:21:29+09:00] effective go로 공부하니까, 문서가 정말 좋긴한데, 예상보다 몇시간은 더 걸렸던 것 같습니다. 하지만 양질의 정보를 이렇게 빠르게 읽을 수 있어서 유익한 시간인 것 같네요. - 끝 -","date":"2022-02-07","objectID":"/ch02_go_basic/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.2 Go Basic","uri":"/ch02_go_basic/"},{"categories":["go"],"content":"Go at Google: Language Design in the Service of Software Engineering 를 기반으로Go에 녹아있는 배경/철학을 분석합니다. 이후 사용되는 필드들을 정리하고 학습에 도움되는 best practice 레퍼런스들을 정리합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"tl;dr Go is a compiled, concurrent, garbage-collected, statically typed language developed at Google ","date":"2022-02-05","objectID":"/ch01_go_design/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Introduction 웹 서비스가 많아지고 컴퓨터 환경이 발전하면서 관리해야 할 코드와 서비스가 많아졌고 이를 효율적으로 관리하기 위해 go는 만들어졌습니다. 공식문서의 go 디자인 레퍼런스를 발견해, 이를 토대로 분석글을 작성합니다.Go at Google: Language Design in the Service of Software Engineering 추가로 FAQ 를 참조하였습니다. go를 개발한 이유 The Go programming language was conceived in late 2007 … 중략 … mostly C++, Java, and Python, had been created … 중략 … We were not alone in our concerns. After many years with a pretty quiet landscape for programming languages, Go was among the first of several new languages—Rust, Elixir, Swift, and more—that have made programming language development an active, almost mainstream field again. … 중략 … The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on. Moreover, the scale has changed: today’s server programs comprise tens of millions of lines of code, are worked on by hundreds or even thousands of programmers, and are updated literally every day. To make matters worse, build times, even on large compilation clusters, have stretched to many minutes, even hours. go는 2007년에 만들어졌습니다. 이 당시의 언어로써는 다음과 같은 문제들을 해결하기 어려웠기 때문에 go를 개발하기 시작했다고 보입니다. multicore processors 고려 개발자들의 수요 증가(코드의 scale 증가 -\u003e 깔끔한 코드 니즈 증가) 서버 scale increase build time too long 이때는 참고로 Rust, Elixir, Swift 같은 대안 언어들이 없었다고 합니다. go 디자인 목표 Go was designed and developed to make working in this environment more productive. Besides its better-known aspects such as built-in concurrency and garbage collection, Go’s design considerations include rigorous dependency management, the adaptability of software architecture as systems grow, and robustness across the boundaries between components. built-in concurrency garbage collection dependency management adaptability of software architecture google at go The goals of the Go project were to eliminate the slowness and clumsiness of software development at Google, and thereby to make the process more productive and scalable. The language was designed by and for people who write—and read and debug and maintain—large software systems. 구글의 현존하는 수많은 legacy 코드들과 앞으로 늘어날 코드들을 효율적으로 관리하기 위해서 go를 개발하기 시작했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Pain points 아래는 go를 만들 때 고려되었던 pain point들입니다. slow builds uncontrolled dependencies each programmer using a different subset of the language poor program understanding (code hard to read, poorly documented, and so on) duplication of effort cost of updates version skew difficulty of writing automatic tools cross-language builds ","date":"2022-02-05","objectID":"/ch01_go_design/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"c.f go는 왜 { }를 사용하나요? 안정성과 신뢰성을 위해 python style indentation 편의성을 포기하고 {}를 그래도 도입함. go는 왜 중괄호를 사용하나요? Our position is therefore that, although spaces for indentation is nice for small programs, it doesn’t scale well, and the bigger and more heterogeneous the code base, the more trouble it can cause. It is better to forgo convenience for safety and dependability, so Go has brace-bounded blocks. 구글이 가진 노하우에 따르면 작은 프로그램에서는 python의 indentation이 좋지만, 코드 기반이 클수록 \u0026 cross-language build 환경에서는 python 스타일이 좋지 않기 때문에 { }를 그대로 쓰기로 결정했다고 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:4:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Dependencies in Go go가 의존성을 대하는 전략에 대해서 정리합니다. 아래와 같은 c의 guard기능으로 인해 불필요하게 의존성을 읽어들이는 현상이 발생했습니다. /* Large copyright and licensing notice */ #ifndef _SYS_STAT_H_ #define _SYS_STAT_H_ /* Types and other definitions */ #endif Note The first step to making Go scale, dependency-wise, is that the language defines that unused dependencies are a compile-time error (not a warning, an error). … 중략 … This guarantees by construction that the dependency tree for any Go program is precise, that it has no extraneous edges. That, in turn, guarantees that no extra code will be compiled when building the program, which minimizes compilation time. 구글 같이 코드 베이스가 많은 경우, 빌드타임이 오래걸리는 것은 업무의 효율성을 떨어뜨리기 때문에 go에서는 사용하지 않는 dependency들에 대해서 compile-time error를 뱉어내도록 하고 있습니다. 더 나아가서 go는 include of include file와 같은 상황에도 효율적인 전략을 취하고 있습니다. package A imports package B; package B imports package C; package A does not import package C 다음과 같이 A에서 B를 직접 참조하고, C는 간접적으로 참조하는 상황이 있을 때, go 컴파일러는 2가지 전략을 취합니다. C -\u003e B -\u003e A 순으로 compile한다. A에서 B를 참조할 때, 컴파일 시 생성된 B Object 파일에 B public interface가 영향받을 dependency들의 type information을 넣어둔다. Note In other words, when B is compiled, the generated object file includes type information for all dependencies of B that affect the public interface of B. 예를 들어서 A에서 B안에 들어있는 I/O package를 import하고, B안에 들어있는 I/O 패키지는 C에 정의되어있는 buffered I/O를 사용해서 구현(implementation)되어있을 때, C -\u003e B -\u003e A 순으로 컴파일되면서 link됩니다. 이때 A가 컴파일될 때 컴파일러는 B의 Object file을 읽어(주의! 소스코드를 읽는게 아님)들이는데, 이때 해당 파일에는 A에서 import B를 실행할 때 컴파일러에 필요한 필요한 모든 타입 정보가 들어있습니다. This is, of course, reminiscent of the Plan 9 C (as opposed to ANSI C) approach to dependency management, except that, in effect, the compiler writes the header file when the Go source file is compiled 이런 종속성 관리 접근 방식은 Plan 9 C(ANSI C와 반대) 접근 방식과 유사하며, 단 실제로 Go 소스 파일이 컴파일될 때 컴파일러가 헤더 파일을 작성해 준다는 점만 다릅니다. Note To make compilation even more efficient, the object file is arranged so the export data is the first thing in the file, so the compiler can stop reading as soon as it reaches the end of that section. 참고로 컴파일 할 때 고언어 컴파일러는 export할 data를 Object file 맨 앞단에 위치시켜서 export 해줄 정보만 빠르게 찾아볼 수 있도록 구현되어 있다고 합니다. Note Go places the export data in the object file; some languages require the author to write or the compiler to generate a second file with that information. That’s twice as many files to open. In Go there is only one file to open to import a package. Also, the single file approach means that the export data (or header file, in C/C++) can never go out of date relative to the object file. 또한 export data를 object파일에 위치시키기 때문에 import package시킬 때, 컴파일러는 파일 당 하나의 object 파일만 읽어들이면 되며 부가적으로 관리해야 할 포인트가 하나로 줄어든다는 장점이 있습니다. Note Another feature of the Go dependency graph is that it has no cycles. …중략… The lack of circular imports causes occasional annoyance but keeps the tree clean, forcing a clear demarcation between packages. As with many of the design decisions in Go, it forces the programmer to think earlier about a larger-scale issue (in this case, package boundaries) that if left until later may never be addressed satisfactorily. 마지막으로 go언어는 circular import(= cyclic import)를 컴파일 타임에 에러를 내 줌으로써 효율적인 package boundaries에 대해서 개발자가 고민할 수 있도록 해줍니다. 이런 방식들을 통해 go는 기존 언어보다 획기적으로 build time을 줄일 수 있었습니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:5:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Packages Note It’s important to recognize that package paths are unique, but there is no such requirement for package names. The path must uniquely identify the package to be imported, while the name is just a convention for how clients of the package can refer to its contents. The package name need not be unique and can be overridden in each importing source file by providing a local identifier in the import clause. These two imports both reference packages that call themselves package log, but to import them in a single source file one must be (locally) renamed: package의 path는 unique해야 합니다. package name은 unique할 필요없으며, 중복 될 경우 이를 사용하는(import) 영역에서 naming을 override해서 사용합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:6:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"remote package 개인적으로 신기했던 부분인데, go에서는 import 해주는 package path가 url이 될 수도 있습니다. 예를 들어서 github에서 doozer 패키지를 가져오고 싶으면 아래와 같이 해주면 됩니다. $ go get github.com/4ad/doozer // Shell command to fetch package import \"github.com/4ad/doozer\" // Doozer client's import statement var client doozer.Conn // Client's use of package 이렇게 한번 fetch(package를 install)해주면 그 다음부터는 일반적인 package와 마찬가지로 import 해주면 됩니다. 이런 방식을 도입함으로써 explicit하게 dependencies들을 보여줄 수 있게 되었습니다. Note Also, the allocation of the space of import paths is delegated to URLs, which makes the naming of packages decentralized and therefore scalable, in contrast to centralized registries used by other languages. 또한 URL로 allocation of the space of import paths가 위임됨으로써, package의 naming이 decentralized \u0026 scalable하게 만들었습니다. (저는 allocation of the space of import paths라는 뜻을 url의 unique한 장점을 package path로 그대로 가져와서 global하게 unique한 decentralized system을 만들었다고 이해했습니다.) ","date":"2022-02-05","objectID":"/ch01_go_design/:7:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Syntax Go was therefore designed with clarity and tooling in mind, and has a clean syntax. go declaration(선언) 문법중에서 C 스타일 프로그래머들을 놀라게 하는 부분이 있습니다. go style var fn func([]int) int type T struct { a, b int } c style int (*fn)(int[]); struct T { int a, b; } The declared name appears before the type and there are more keywords. 이런 Declarations introduced by keyword 문법은 Pascal에 더 가깝다고 합니다. 이를 통해 개발자는 더 수월하게 코드 분석이 가능하며, type syntax를 가지는 것이 C언어 같이 expression syntax 보다 컴퓨터가 parsing 성능에 상당히 더 유리하다고 합니다. go는 type syntax라는 문법을 추가해서 코드가 늘어나지만, 이를 통해 모호성을 제거하였습니다. 단 편의를 위해 go에서는 var 키워드를 삭제하고 :=라는 키워드를 관용적으로 사용합니다. var buf *bytes.Buffer = bytes.NewBuffer(x) // explicit buf := bytes.NewBuffer(x) // derived 마지막으로 Go에서는 default function arguments를 의도적으로 누락시켰습니다. 기본 인자가 가지는 모호성으로 코드를 사용하는 부분이 명시적이지 못할 경우가 많다는 단점이 있기 때문입니다. 물론 같은 네이밍을 가질 함수가 가질 수 있는 모든 interface(function signature)를 구현해줘야 한다는 단점을 가지긴합니다. 아래는 go에서 함수 / 메서드를 표현하는 방법입니다. 코트린 처럼 fun을 키워드로 가졌으면 더 좋았을 것 같네요. func Abs(x T) float64 // function declaration func (x T) Abs() float64 // method declaration go는 first-class function / closures를 지원합니다. negativeAbs := func(x T) float64 { return -Abs(x)} // lambda go는 multiple value return이 가능합니다. func ReadByte() (c byte, err error) c, err := ReadByte() if err != nil { ... } Note Those functions all need separate names, too, which makes it clear which combinations exist, as well as encouraging more thought about naming, a critical aspect of clarity and readability. 엇? java 처럼 오버로딩을 하는게 아니라 signature 바뀔때마다 모두 새로운 함수명을 만들어줘야한다는 의미일까요? 아무튼 go는 clarity를 가장 최우선으로 두는 것 같습니다. Tip 개인적으로 default argument가 사라진 건 너무 좋은 것 같은게, python기준으로 함수가 여기저기 많이 사용될수록 default argument 때문에 불필요하게 사용되는 모든 코드들을 뒤져야 할 때가 많았습니다. 예를 들어 def create_person(name, age=30): if age \u003c 30: ... else: ... 이런 함수가 있고 이 함수 관련해서 에러가 나면 create_person를 호출하는 모든 코드들을 다 뒤져봐야 할 경우가 있었습니다. 특히 mongodb처럼 데이터의 스키마가 고정되지 않은 데이터를 함수의 dto로 받는 경우에는 정말 짜증납니다. (kotlin migration 과정에서 엄청 스트레스를 줬던 콘 mcard…) ","date":"2022-02-05","objectID":"/ch01_go_design/:8:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Naming Go에서는 신기하게도 visibility of an identifier를 대소문자로 구별합니다. (타 언어에서는 private / public따위의 키워드를 씀) name as visibility identifier Go the name itself carries the information: the case of the initial letter of the identifier determines the visibility. If the initial character is an upper case letter, the identifier is exported (public); otherwise it is not: upper case initial letter: Name is visible to clients of package otherwise: name (or _Name) is not visible to clients of package 이런 rule은 모든 곳에 적용됩니다. variables types functions methods constants fields 이런 특이한 전략을 취한데에는 naming으로 visibility를 관리하는 것이 identifier에 비해 더욱 깔끔한 Public api관리에 도움되는 전략이라고 판단한 google의 노하우가 반영되었다고 합니다. 개인적으로는 코드 검색을 할 때, identifier를 가지고 검색하면 관련 identifier 리스트들을 한번에 확인이 가능한 반면 네이밍으로 visibility를 관리하면 정확한 네이밍을 알아야 가능하다는 점에서 솔직히 별로 인 것 같습니다. scope hierarchy Another simplification is that Go has a very compact scope hierarchy: universe (predeclared identifiers such as int and string) package (all the source files of a package live at the same scope) file (for package import renames only) function block naming scope There is no scope for name space or class or other wrapping construct. Names come from very few places in Go, and all names follow the same scope hierarchy: at any given location in the source, an identifier denotes exactly one language object, independent of how it is used. (The only exception is statement labels, the targets of break statements and the like; they always have function scope.) …중략… top-level predefined names such as int, (the first component of) every name is always declared in the current package. go에서는 일부 예외(statement labels, argets of break statements는 function scope)를 제외하면 naming은 package scope로 관리됩니다. package scope로 naming이 관리되는 이유 exported name to a package can never break a client of that package. The naming rules decouple packages, providing scaling, clarity, and robustness. function / method 오버로딩 불가능 method lookup is always by name only, not by signature (type) of the method. In other words, a single type can never have two methods with the same name java와 달리 go에서는 function signature만 다르고 네이밍이 같은 메서드 / 함수를 만드는 것은 불가능합니다. 개발자가 네이밍을 좀 더 신경써야 된다는 불편함은 있겠지만, 개인적으로 더 깔끔하게 함수들을 관리할 수 있는 방법이라고 생각되네요 (왠지 function naming관련된 convention tip들이 있을 것 같음) effective go about Functions ","date":"2022-02-05","objectID":"/ch01_go_design/:9:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Semantics go는 기본적으로 c와 많이 닮아 있지만, modern언어에 익숙한 개발자들을 위해 몇가지 차이점을 두었습니다. there is no pointer arithmetic there are no implicit numeric conversions array bounds are always checked there are no type aliases (after type X int, X and int are distinct types not aliases) ++ and – are statements not expressions assignment is not an expression it is legal (encouraged even) to take the address of a stack variable 아래는 C, C++, and even Java와 비교했을 때, 크게 변화한 부분입니다. (참고로 go 초기 개발자인 Robert Griesemer. Java hotspot compiler(JVM)을 개발했었습니다. ) concurrency gc interface type reflection type switches ","date":"2022-02-05","objectID":"/ch01_go_design/:10:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Concurrency Go is not purely memory safe in the presence of concurrency. Sharing is legal and passing a pointer over a channel is idiomatic (and efficient). Go는 Communicating sequential processes, CSP 의 first-class channel개념을 가져왔습니다. (which is about message passing via channels in concurrent system) Don't communicate by sharing memory, share memory by communicating Some concurrency and functional programming experts are disappointed that Go does not take a write-once approach to value semantics in the context of concurrent computation, that Go is not more like Erlang for example. Again, the reason is largely about familiarity and suitability for the problem domain. Go’s concurrent features work well in a context familiar to most programmers. Go enables simple, safe concurrent programming but does not forbid bad programming. We compensate by convention, training programmers to think about message passing as a version of ownership control. Go는 concurrency context에 write-once 접근을 하지 않습니다. 이는 의도적으로 bad programming을 막지 않은 것인데요, convention으로 이런 bad practice를 방지하고, 프로그래머들이 message passing에 대해서 더 생각하도록 유도하기 위함이라고 합니다. 이런 철학은 go의 motto에서도 드러나 있습니다. “Don’t communicate by sharing memory, share memory by communicating.” ","date":"2022-02-05","objectID":"/ch01_go_design/:11:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Garbage collection go는 jvm 개발자가 있어서 그런지 c / c++ / rust와 달리 gc를 가져왔습니다. interior pointer The X.buf field in the example above lives within the struct but it is legal to capture the address of this inner field, for instance to pass it to an I/O routine. In Java, as in many garbage-collected languages, it is not possible to construct an interior pointer like this, but in Go it is idiomatic. java와 비교해 interior pointers(interior pointers to objects allocated in the heap) 기능을 추가해 커스텀하게 gc 기능이 동작하도록 적용했다고 합니다. interior 디자인이 끼칠 영향 This design point affects which collection algorithms can be used, and may make them more difficult, but after careful thought we decided that it was necessary to allow interior pointers because of the benefits to the programmer and the ability to reduce pressure on the (perhaps harder to implement) collector. … 중략 … The garbage collector remains an active area of development. The current design is a parallel mark-and-sweep collector and there remain opportunities to improve its performance or perhaps even its design. (The language specification does not mandate any particular implementation of the collector.) Still, if the programmer takes care to use memory wisely, the current implementation works well for production use. 듣기로는 gc기능이 퍼포먼스 이슈가 있어 Discord에서는 기존에 go로 짜여있는 코드들을 rust로 옮겼다고 하네요. ","date":"2022-02-05","objectID":"/ch01_go_design/:12:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Composition not inheritance there is no type hierarchy go에는 기존 oop 언어들과 달리 type hierarchy가 없습니다. interface In Go an interface is just a set of methods …중략… All data types that implement these methods satisfy this interface implicitly; there is no implements declaration. That said, interface satisfaction is statically checked at compile time so despite this decoupling interfaces are type-safe. 자바와 달리 고의 interface는 behavior만 정의하며 subclassing이 없으므로 상속이란 개념이 존재하지 않습니다. 대신 composition(embedding)을 활용한다고 합니다. subclassing vsv subtyping go에는 subclassing이 없다고 하는데요, subclassing이 무엇인지 그리고 subtyping 또한 무엇인지 비교해보겠습니다. 서브클래싱은 구현되어 있는 클래스를 상속하는 것 서브타이핑은 정의되어 있는 인터페이스를 구현하는 것 먼저 좀 더 Subclassing이란 ? Superr Class에 구현된 코드와 내부 표현 구조를 Sub Class(하위 클래스)가 이어받는 기능을 뜻합니다. 클래스 inheritance라고도 불리며, 이를 통해 하위클래스에서 슈퍼 클래스에 구현된 코드의 재사용이 가능합니다. 그렇기 때문에 sub class는 overriding을 통해 같은 이름의 비슷하지만 커스텀한 행동들을 정의할 수 있습니다. 이와 달리 Subtying이란, Super Type의 객체가 수행할 행동(behavior only)의 약속(프로토콜, api)를 Sub Type이 이어 받습니다. 행동들을 공통된 타입으로 묶어 runtime에 super type의 객체의 타입으로 sub type을 대체가능하도록 합니다. 이를 통해 프로그램 변경에 대한 영향을 최소화 할 수 있습니다. 즉 core한 behavior들을 공통적으로 관리 가능합니다. go가 inheritance를 버린 이유 that the behavior of data can be generalized independently of the representation of that data. The model works best when the behavior (method set) is fixed, but once you subclass a type and add a method, the behaviors are no longer identical. If instead the set of behaviors is fixed, such as in Go’s statically defined interfaces, the uniformity of behavior enables data and programs to be composed uniformly, orthogonally, and safely. 이런 전략을 취했던 이유는 behavior가 fix되어 코드가 작성되면 data representation을 담당하는 model이 works best한다는 철학이 녹아들어있다고 합니다. TODO: 글을 읽다보니 composition에 대해서는 어느정도 이해가 되는데, 이런 철학이 왜 고려되어야 하는지가 정확하게 와닫지는 않는 것 같아서 나머지 부분은 실제 코드를 만져보고 다시 읽어보려고 합니다. Composition not inheritance ","date":"2022-02-05","objectID":"/ch01_go_design/:13:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Errors Go에는 일반적인 의미의 예외 기능이 없습니다. 즉, 오류 처리와 관련된 제어 구조가 없습니다. go가 error를 보는 방식 Errors are just values and programs compute with them as they would compute with values of any other type go가 error를 value로 취급하는 첫번째 이유 First, there is nothing truly exceptional about errors in computer programs. For instance, the inability to open a file is a common issue that does not deserve special linguistic constructs; if and return are fine. f, err := os.Open(fileName) if err != nil { return err } go 철학에서는 error를 특별한 예외라고 생각할 필요가 전혀 없다고 생각하기 떄문입니다. 그냥 value가 return되고 if 분기로 이를 핸들링해주면 그만이라고 주장합니다. go가 error를 value로 취급하는 두번째 이유 There is no question the resulting code can be longer, but the clarity and simplicity of such code offsets its verbosity. Explicit error checking forces the programmer to think about errors—and deal with them—when they arise. 결과 코드가 더 길어질 수 있다는 점에는 의심의 여지가 없지만 그러한 코드의 명확성과 단순성은 장황함을 상쇄합니다. 명시적 오류 검사는 프로그래머가 오류에 대해 생각하고 오류가 발생할 때 처리하도록 합니다. ","date":"2022-02-05","objectID":"/ch01_go_design/:14:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"Useful references Go at Google: Language Design in the Service of Software Engineering golang cheat sheet gin ","date":"2022-02-05","objectID":"/ch01_go_design/:15:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"conclustion 이상으로 go의 디자인 철학에 대해서 분석해보았습니다. 개인적으로 하루정도를 투자하려 했지만, 실제로는 와닿지 않는 내용들 때문에 시간이 조금 더 지체되었던 것 같네요 (소요시간: 대략 2일) - 끝 -","date":"2022-02-05","objectID":"/ch01_go_design/:16:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.1 Go Language Design","uri":"/ch01_go_design/"},{"categories":["go"],"content":"새로운 언어를 공부하다보면, 생각보다 기초를 공부하는 시간이 소모적이라는 생각이 들어 조금 더 효율적인 학습방법을 정리해보고 싶어 글로 남겨둡니다. 최근 오픈소스에 기여하고 싶다는 생각이 점점 커지다 보니, 이직 전에 golang에 더 익숙해지고 싶다는 생각을 하게되었습니다. 또 혹시 새로운 프로젝트의 백엔드 웹 서버를 만들어야 될 수도 있어, 이 프로젝트 또한 go와 gin을 사용해 개발해보고 싶다는 생각들이 변곡점을 이루면서 변곡점(變曲點, inflection point) 부랴부랴 나는 어떻게 Go 언어를 배웠나 를 토대로 계획해본 go 학습 계획입니다. ","date":"2022-02-05","objectID":"/go_study_plan/:0:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"tl;dr 영상에서 니꼬가 새로운 언어를 학습하는 합리적인 방법을 공유해주고 있는데요, 정리하면 다음과 같습니다. 공식문서 기초 문법 익숙한 언어들과 비교 (✍️ python과 공통점 차이점 비교글 작성) ASAP code (✍️ graph Tree관련 1문제) 튜토리얼 (✍️ best practice copy) 나만의 프로젝트 (✍️ migration tidify) ","date":"2022-02-05","objectID":"/go_study_plan/:1:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"Go plan 가장 먼저 공식문서에서는 언어가 등장한 배경과 철학을 분석합니다. 또한 어떤 필드에서 해당 언어가 사용되는지를 파악하여 커뮤니티의 특성과 채용/이직에 대한 목표를 세울수 있습니다. 마지막으로 해당 언어가 사용되는 레퍼런스를 리서치합니다. 공식문서 언어 철학 who used (사용 필드/커뮤니티 분석) best practice 레퍼런스 리서치 1의 과정에서 배경지식을 얻었다면, 기초문법을 빠르게 훓어봅니다. 익숙하지 않은 키워드들만 terminology로 정리해보는 것도 좋고, cheatsheet를 훑어보는 것 또한 좋은 방법이라 생각합니다. 기초 문법 키워드 위주로 최대한 빠르게 이후 익숙한 언어와 비교해보면서, 기존의 정보들과 link를 만들어갑니다. 이 방법은 기억력 측면에서 유용한 방법이라 생각합니다. 익숙한 언어들과 비교 equvalance 3의 과정에서 공통/차이점을 훝어 보았다면 바로 기초문법들을 사용해서 코드를 작성해봅니다. 익숙한 graph(tree)관련 알고리즘을 풀어보면 class를 사용해볼 수 있어서 유리할 것 같습니다. code ASAP 2-3에서 배운 문법 활용 기초 문법을 빠르게 쳐보았다면 best practice를 분석해봅니다. 튜토리얼 1에서 찾은 best practice 또는 유명한 오픈소스 / 튜토리얼 fork 후 일부분 로컬에서 재조립 마지막으로 나만의 프로젝트를 빠르게 만들어봅니다. 프로젝트의 규모는 TODO 따위의 간단한 crud 비즈니스 로직을 가진 주제면 더 좋을 것 같습니다. 저의 경우에는 tidify 프로젝트가 가장 비슷한 규모라고 생각되어 tidify 프로젝트를 migration 해보는 걸 목표로 해보고 싶습니다. 하지만 현실적인 시간을 고려해서 tidify가 부담스럽다면 (gin프레임워크를 따로 배우는 시간이 필요) 간단한 TODO 프로젝트 만드는 걸 1차 목표로 진행해보겠습니다. 나만의 프로젝트 최대한 익숙한 프로젝트 주제 i.g TODO 또는 기존 프로젝트 migration ","date":"2022-02-05","objectID":"/go_study_plan/:2:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":["go"],"content":"conclustion 개인적으로 계획을 세우는 걸 좋아하지만, 금방 싫증을 느끼다 보니 더 현실적이고 체계적으로 계획을 세우고 싶은 니즈가 생겼던 것 같습니다. 이렇게 6가지 순서를 진행하는데 제게 가장 맞는 방법은 스피드라고 생각이 됩니다. 저 같은 경우는 흥미가 빨리 바뀌기 때문에 해당 과정을 일주일동안 해보는 걸 목표로 잡고 진행해볼까 생각합니다. 1~4: 1일 5: 2일 6: 4일 총 일주일 과정을 목표로 기록해보겠습니다. - 끝 -","date":"2022-02-05","objectID":"/go_study_plan/:3:0","tags":["dev","go"],"title":"[일주일 만에 배우는 GO] CH.0 Go study plan","uri":"/go_study_plan/"},{"categories":[""],"content":"Hardhat를 통해 local에서 스마트 컨트랙트를 작성해본 뒤, contract를 upgrade시켜봅니다. 이후 rinkeby 테스트넷에 proxy 컨트랙트를 배포해보고, verify시켜봅니다. 환경에 사용된 레포는 github link 입니다. hardhat과 openzeppelin 환경에서 간단한 Upgradable contract를 생성해봅니다. ","date":"2022-02-02","objectID":"/hardhat/:0:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"setup 먼저 프로젝트 환경을 로컬에서 세팅해줍니다. ","date":"2022-02-02","objectID":"/hardhat/:1:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"init $ yarn init -y $ yarn add hardhat --dev $ yarn add @openzeppelin/hardhat-upgrades --dev 테스트는 다음과 같이 할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:1","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"test $ npx hardhat test ","date":"2022-02-02","objectID":"/hardhat/:1:2","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy 로컬에서 ganache같은 내부 노드를 실행할 수 있습니다. $ npx hardhat node 로컬에서 이제 배포를 해봅시다. deploy $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgrade.deploy.js SimpleStorageUpgrade deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 런타임에 콘솔에서 붙어서 제대로 배포되었는지 검증해봅니다. check $ npx hardhat console --network localhost Welcome to Node.js v14.15.1. Type \".help\" for more information. \u003e const f = await ethers.getContractFactory(\"SimpleStorageUpgrade\") undefined \u003e const ssu = await f.attach(\"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0\") undefined \u003e ssu.address '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0' \u003e (await ssu.get()).toString() '500' \u003e let tx = await ssu.set(1000) undefined \u003e (await ssu.get()).toString() '1000' 다음과 같이 활용하면 스마트 컨트랙트를 upgrade 시켜줄 수 있습니다. upgrade contract version $ npx hardhat run --network localhost ./scripts/SimpleStorageUpgradeV2.deploy.js Compiling 1 file with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade version 2 deployed to: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 ","date":"2022-02-02","objectID":"/hardhat/:1:3","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy to remote network hardhat docs 이제 실제 remote 환경에서 배포해보겠습니다. hardhat.config.js require(\"dotenv\").config(); // yarn add dotenv // ... 중략 ... module.exports = { networks: { rinkeby: { url: `https://eth-rinkeby.alchemyapi.io/v2/${process.env.ALCHEMY_API_KEY}`, // 0x20CE8B2190949f48F5D32d5BbbfE7E3760811F61 accounts: [process.env.TEST_ACCOUNT_PRIVATE_KEY], }, }, solidity: \"0.8.4\", etherscan: { apiKey: process.env.ETHERSCAN_API_KEY, }, }; ALCHEMY_API_KEY: alchemy 에서 demo app을 생성하게 될 경우 view key를 하면 확인가능합니다. TEST_ACCOUNT_PRIVATE_KEY: metamask에서 rinkeby 네트워크에 계정을 생성한 뒤 아래와 같이 비공개키 export를 누르면 확인 가능합니다. ETHERSCAN_API_KEY register etherscan 에서 회원 가입을 한 뒤 create etherscan api key 에서 My API Keys \u003e + Add해주어서 얻어줍니다. 추가로 rinkeby faucet 에 들어가게되면 address 기반으로 rinkeby 계정에 이더를 넣어줄 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:1:4","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"deploy remote blockchain network rinkeby network (test-net) $ npx hardhat run --network rinkeby ./scripts/SimpleStorageUpgrade.deploy.js Downloading compiler 0.8.4 Compiling 3 files with 0.8.4 Solidity compilation finished successfully SimpleStorageUpgrade deployed to: 0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 테스트넷이기 때문에 약간의 시간이 소요됩니다. (약 30초) 이후 deploy된 address는 rinkeby etherscan 에서 확인가능합니다. https://rinkeby.etherscan.io/address/0xCe93de7572e3346F1f91Ad39ce06e8F6c6312b69 proxy contract check The implementation contract at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 does not seem to be verified. 아직 implementation이 검증되지 않았다고 뜬다. 이렇게 proxy가 아닌 implementation contract를 검증해주기 위해서는 아래와 같이 추가 작업해주면 됩니다. ","date":"2022-02-02","objectID":"/hardhat/:2:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":[""],"content":"verify implementation docs 먼저 hardhat에서 제공해주는 etherscan 의존성을 설치해줍니다. $ yarn add @nomiclabs/hardhat-etherscan --dev 이후 아래 명령어를 통해서, 로컬의 deploy된 컨트랙트와 실제 rinkeby에 배포된 컨트랙트를 비교해서 검증해주는 로직을 타줍니다. //npx hardhat verify --network rinkeby \"\u003c리모트 배포된 implementation address\u003e\" $ npx hardhat verify --network rinkeby \"0x92a949706c10fd221b9a073f4284b4bdbc47e6d7\" Compiling 3 files with 0.8.4 Solidity compilation finished successfully Compiling 1 file with 0.8.4 Successfully submitted source code for contract contracts/SimpleStorageUpgrade.sol:SimpleStorageUpgrade at 0x92a949706c10fd221b9a073f4284b4bdbc47e6d7 for verification on the block explorer. Waiting for verification result... Successfully verified contract SimpleStorageUpgrade on Etherscan. https://rinkeby.etherscan.io/address/0x92a949706c10fd221b9a073f4284b4bdbc47e6d7#code 이상으로 배포된 컨트랙트 에서 정상적으로 배포된 컨트랙트를 확인할 수 있습니다. ","date":"2022-02-02","objectID":"/hardhat/:3:0","tags":["dev"],"title":"Hardhat","uri":"/hardhat/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH03] 이더리움 기초를 정리합니다. 인용글들은 원문 을 참조하였습니다. Note An Ethereum client is a software application that implements the Ethereum specification and communicates over the peer-to-peer network with other Ethereum clients … 중략 … Ethereum is defined by a formal specification called the “Yellow Paper” (see [references]). 이더리움 클라이언트는 sw application으로 yellowpaper 에 명시된 ethereum spec들을 만족시키는 구현체입니다. p2p network상에서 서로 통신하며 이더리움 생태계를 이끌어갑니다. This is in contrast to, for example, Bitcoin, which is not defined in any formal way. ","date":"2022-01-29","objectID":"/ch03_eth_client/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Ethereum Networks Note There exist a variety of Ethereum-based networks that largely conform to the formal specification defined in the Ethereum Yellow Paper … 중략 … Among these Ethereum-based networks are Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin, and many others. Yellow Paper에 기제된 스펙을 기반으로 구현된 Ethereum based 네트워크들은 많이 존재합니다. (Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin…) 대부분 프로토콜 수준에서는 호환되지만, 각 네트워크 마다 세세한 부분에서 다른 점들이 존재하기 때문에 이더리움 클라이언트 maintainers들이 각 네트워크를 지원하기 위해 약간씩의 코드 변경작업이 필요합니다. 이 때문에 모든 버전의 이더리움 클라이언트 소프트웨어가 모든 이더리움 기반 블록체인을 실행하는 것은 아닙니다. 책에서 소개하는 대표적인 Ethereum protocol 구현체는 다음과 같습니다. Parity, written in Rust Geth, written in Go cpp-ethereum, written in C++ 현재는 aleth라고 레포가 되어있으며 deprecated됨 pyethereum, written in Python 현재는 py-evm로 관리되고 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Should I Run a Full Node? The health, resilience, and censorship resistance of blockchains depend on them having many independently operated and geographically dispersed full nodes. Each full node can help other new nodes obtain the block data to bootstrap their operation, as well as offering the operator an authoritative and independent verification of all transactions and contracts. 글을 읽고 보니, 이더리움에서 말하는 Node와 Client개념이 헷갈려 먼저 정리하고 들어가겠습니다. Client vs Node 공식문서 에 따르면 Node 분산된 이더리움 네트워크 컴퓨터들에서 동작하는 소프트웨어를 지칭합니다. “Node” refers to a running piece of client software. features: verify blocks, transaction data Types full node: block 전부 copy light node: header만 copy archive node Client 사용자들의 컴퓨터에서 node를 실행할 수 있도록 하는 application을 뜻합니다 node는 piece of client입니다. A client is an implementation of Ethereum that verifies all transactions in each block, keeping the network secure and the data accurate. Note Full client Full clients store the entire Ethereum blockchain; a process that can take several days to synchronize and requires a huge amount of disk space – over 1 Terabyte to be exact, according to the latest figures. Full clients allow connected nodes to perform all tasks on the network, including mining, transaction and block-header validation and running smart contracts. Light client Ethereum clients may be implemented in full or in part. The above overview gives an explanation of how a “full” client works, however it is important to know that you don’t always need to run a full client. Typically when data storage and speed are at issue, developers will elect to use what are called “light clients.” Light clients offer a subset of the functionality of a full client. Light clients can provide faster speeds and free up data storage availability because, unlike the full clients, they do not store the full Ethereum blockchain. The scope of a light client’s functionality is tailored toward the goals of the Ethereum client. For example, light clients are frequently used for private keys and Ethereum address management within a wallet. Additionally, they tend to handle smart contract interactions and transaction broadcasts. Other uses for remote clients include web3 instances within JavaScript objects, dapp browsers and retrieving exchange rate data. Remote client There is a third type of client called a remote client which is similar to a light client. The main difference being, a remote client does not store its own copy of the blockchain, nor does it validate transactions or block headers. Instead, remote clients fully rely on a full or light client to provide them with access to the Ethereum blockchain network. These types of clients are predominantly used as a wallet for sending and receiving transactions. The terms “remote client” and “wallet” are used interchangeably, though there are some differences. Usually, a remote client offers an API (such as the web3.js API) in addition to the transaction functionality of a wallet 참고로 remote client라는 용어와 wallet은 interchangeably하게 사용되는데, 둘의 미묘한 차이점으로는 remote client는 api(such as web3.js)를 제공한다는 점이다. remote client = wallet + api Ethereum remote clients do not validate block headers or transactions. They entirely trust a full client to give them access to the blockchain, and hence lose significant security and anonymity guarantees. 이더리움 remote clients는 light client 처럼 block header 검증하지 않습니다. 이 덕분에 local hw 스펙을 줄일 수 있으나, 외부 full client들에게 depend한다는 특징이 있습니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"The JSON-RPC interface 왜 JSON-RPC를 사용할까? 글을 읽다가 왜 이더리움은 json-rpc를 사용하는지 궁금해서 찾아보게 되었습니다. REST와 json-rpc의 차이점에 대해서 정리하겠습니다. JSON-RPC: tcp base로 원격/로컬 프로세스 procedure(함수)에 직접 접근하는 방식 over tcp only single endpoint crud외 표현 가능 REST over http(s) crud(http method)를 벗어난 표현에 제한적이다. rpc는 소스코드 \u003e idl(interface definition language) \u003e rpcgen\u003e stub 코드 생성 \u003e rpc runtime을 통한 packet 통신 (tcp L4) 과정을 통해서 서버와 클라이언트간 통신을 하게 만듭니다. http(L7)보다 더 낮은 레벨(L4)에서 동작하기 때문에 기능이 덜 할 수 있지만, 제약이 덜합니다. ","date":"2022-01-29","objectID":"/ch03_eth_client/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"Conclusion 뭔가 3장은 내심 겉할기 식의 설명들이 많았던 것 같습니다. rpc-json을 굳이 쓰는 이유도 없었고 client와 node에 대한 설명도 크게 와닿지 않은 것 같아 답답하네요. 예를 들면 full client를 실행하는 방법을 알려주면서, full client를 사용자가 왜 운용해야하는지를 light client와 비교하는 핵심이 빠진 느낌이 듭니다. (full client를 사용해야지 reward가 들어오는 걸까요..? 좀 더 공부가 필요하네요) - 끝 - ","date":"2022-01-29","objectID":"/ch03_eth_client/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH03] Ethereum Client","uri":"/ch03_eth_client/"},{"categories":["blockchain"],"content":"이번장에서는 [마스터링 이더리움 CH02] 이더리움 기초를 정리합니다. 인용글들은 원문 을 참조하였습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"tl;dr 이번 챕터에서는 실제 solidity코드를 작성한 뒤, 실제 eth를 전송하고 회수하는 contract를 테스트넷에 배포해보겠습니다. 이를 위해 크게 3가지를 다루게 됩니다. 가장 먼저 Metamask wallet을 생성하고, Ropsten test network기반의 faucet으로 부터 ether를 받습니다. 그 뒤 faucet contract코드를 solidity로 작성한 뒤 Remix를 활용해 EVM-bytecode로 compile한 뒤 Faucet contract on Ropsten 네트워크로 등록합니다. (이때 withdraw() 함수를 추가) 마지막으로 Faucet contract address로 ether를 보낸 뒤, withdraw()를 실행해 봅니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Ether Currency Units 이더 화폐 단위 이더리움의 화폐 단위는 ether(이더)라고 불리며, ETH 심볼을 사용합니다. 또한 이더의 최소 단위는 wei(웨이)라고 불립니다. $$ 10^{18} wei = 1 ETH $$ 이더리움 내부에서는 항상 웨이를 부호 없는 정수를 사용합니다. Ethereum’s currency unit is called ether, identified also as “ETH” or with the symbols Ξ (from the Greek letter “Xi” that looks like a stylized capital E) or, less often, ♦ ","date":"2022-01-28","objectID":"/ch02_eth_basic/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Choosing an Ethereum Wallet 이더리움 지갑이란 이더리움 계정을 관리하는 데 사용되는 소프트웨어 애플리케이션이라고 생각하시면 됩니다. In short, an Ethereum wallet is your gateway to the Ethereum system. It holds your keys and can create and broadcast transactions on your behalf. 사용자의 개인키를 보관 사용자를 대신하여 트랜잭션 생성 및 브로드캐스트 시행 이더리움 공식 홈페이지 의 정의에 따르면 지갑을 아래와 같이 정의 내리고 있습니다. Quote 지갑은 이더를 전송할 수 있고 보유할 수도 있는 애플리케이션입니다. 또한 이더리움 디앱에서도 사용할 수 있습니다. 또한 현재(2022.01.28)기준으로 아래 지갑들을 추천합니다. 메타마스크(MetaMask) iOS와 Android용 브라우저 확장 프로그램 및 모바일 지갑 마이크립토(MyCrypto) 웹 기반 지갑 트러스트월렛(TrustWallet) iOS와 Android용 모바일 지갑 마이이더월렛(MyEtherWallet) 클라이언트 측 지갑 오페라(Opera) 지갑이 통합된 주요 브라우저 지갑의 대표주자인 Metamask와 TrustWallet를 trust wallet vs metamask 글을 토대로 요약 정리 해보겠습니다. Trust Wallet Metamask Cost Free Free Desktop Software Yes Yes Mobile App Yes No Built-in exchange Yes (Kyber Network and Web3 browser) No NFT Support Yes No Staking Options Yes No Available Cryptocurrencies Bitcoin, BNB, and all ERC20 Tokens All ERC-20 Tokens Security Medium Medium Compatible with hardware wallets No Yes 아직 어떤게 더 좋아보이는지는 모르겠지만, 개인적으로 metamask에 개발 레퍼런스가 더 많이 있는 것 같아, 메타마스크를 사용해볼 예정입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Wallet Metamask with Ropsten test network Chrome extension에 MetaMask를 치면 메타마스크 애플리케이션을 크롬에 추가할 수 있습니다. 메타마스크 익스텐션 설치 및 가입이 끝났다는 전제하에 설명을 진행하도록 하겠습니다. 테스트를 하기 위해 Ropsten테스트 네트워크로 설정해줍니다. “구매\"를 누르고 “포시트(수도꼭지)테스트\"에서 [Ether 얻기]를 눌러줍니다. 이 경우 아래와 같이 새로운 웹페이지가 열립니다. Faucet 파우셋(Faucet)이란 수도꼭지란 뜻으로 코인 무료 지급 하는곳 으로 사용되고 있다. 이더리움 생태계에서는 대표적으로 Ropsten, Kovan이 존재합니다. 새 웹페이지에서 request 1 ether from faucet(초록 버튼)을 클릭하게 되면 자신의 address로 1eth가 들어오게 됩니다. 몇 초간의 대기 시간이 지나면, 이더 지급이 완료된 transaction을 확인할 수 있습니다. 이 때 트랜잭션 링크를 누르게 되면 아래와 같은 EtherScan 링크로 이동 되고, 트랜잭션 상세내용을 확인하실 수 있습니다. 다음과 같이 faucet으로 돌려보내기 또한 가능합니다. 참고로 test 네트워크도 마찬가지로 gas비를 받는데요, 이는 real 이더 메인넷과 동일한 환경을 제공하기 위해서 입니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Introducing the World Computer 지금까지 이더리움 지갑에 대해서 살펴보았습니다. 앞서 이야기 하였듯 이더리움은 cryptocurrency 기능외에도 튜링 complete한 하나의 컴퓨터입니다. Ether는 smart contract를 사용하기 위해 소모되는 payment의 개념이며, 이런 smart contract프로그램은 emplated computer called Ethereum Virtual Machine(EVM)위에서 동작합니다. The EVM is a global singleton, meaning that it operates as if it were a global, single-instance computer, running everywhere. Each node on the Ethereum network runs a local copy of the EVM to validate contract execution, while the Ethereum blockchain records the changing state of this world computer as it processes transactions and smart contracts. EVM 요약 Global singleton Each node validate broadcasted contracts execution Ethereum blockchain records changing state. (tx, smart contract) ","date":"2022-01-28","objectID":"/ch02_eth_basic/:5:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Externally Owned Accounts (EOAs) and Contracts 이더리움에는 2가지 타입의 account가 존재합니다. EOA Contract Account The type of account you created in the MetaMask wallet is called an externally owned account (EOA). 먼저 EOA란 사용자를 대변하는 account입니다. Externally owned accounts are those that have a private key; having the private key means control over access to funds or contracts. EOA는 사용자의 private key를 소유하고 있으며, 이는 contract 또는 account의 코인에 접근 권한이 있다는 뜻입니다. Has private key Has address Simple EOA can’t have smart contract code That other type of account is a contract account. A contract account has smart contract code, which a simple EOA can’t have. Furthermore, a contract account does not have a private key. Instead, it is owned (and controlled) by the logic of its smart contract code: the software program recorded on the Ethereum blockchain at the contract account’s creation and executed by the EVM Contract Account는 스마트 컨트랙트의 주소에 해당되며, 스마트 컨트랙트가 블록에 포함되어 배포될때 해당 스마트 컨트랙트에 대한 주소가 생성이 되며, 이 주소를 통해서 메세지 전송이나 특정함수를 실행 할 수 있습니다. Has smart Contract Has address Does not have private key Owned by smart contract itself However, when a transaction destination is a contract address, it causes that contract to run in the EVM, using the transaction, and the transaction’s data, as its input. In addition to ether, transactions can contain data indicating which specific function in the contract to run and what parameters to pass to that function. In this way, transactions can call functions within contracts. 트랜잭션의 destination이 contract address일 경우, 이는 트랜잭션을 통해 컨트랙트가 EVM에서 실행되도록 트리거 합니다. 트랜잭션 안에는 특정 contract function안에 어떤 parameter가 전달되는지를 기록함으로 써 특정 위치의 contract의 함수가 어떤 인자를 가지고 실행해야 할지를 지정할 수 있습니다. Private key가 없다는 의미 Note that because a contract account does not have a private key, it cannot initiate a transaction. Only EOAs can initiate transactions, but contracts can react to transactions by calling other contracts, building complex execution paths. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:6:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"A Simple Contract: A Test Ether Faucet // SPDX-License-Identifier: CC-BY-SA-4.0 // Version of Solidity compiler this program was written for pragma solidity 0.6.4; // Our first contract is a faucet! contract Faucet { // Accept any incoming amount receive() external payable {} // receive는 키워드 // Give out ether to anyone who asks function withdraw(uint withdraw_amount) public { // Limit withdrawal amount require(withdraw_amount \u003c= 100000000000000000); // Send the amount to the address that requested it msg.sender.transfer(withdraw_amount); } } receive() external payable {} // receive는 키워드 solidity 0.6 버전 이후 fallback기능은 2가지로 나눠지게 되었습니다. receive() external payable — for empty calldata (and any value) fallback() external payable — when no other function matches (not even the receive function). Optionally payable. Tip fallback a.k.a default function이라고도 불리며, 이름 그대로 대비책 함수입니다. 특징 먼저 무기명 함수, 이름이 없는 함수입니다. external 필수 payable 필수 왜 쓰는가 ? 스마트 컨트랙이 이더를 받을 수 있게 한다. 이더 받고 난 후 어떠한 행동을 취하게 할 수 있다. call함수로 없는 함수가 불려질때, 어떠한 행동을 취하게 할 수 있다. msg.sender.transfer(withdraw_amount); msg object는 one of the inputs로 모든 contracts가 접근 가능한 객체입니다. transaction이 실행되도록 trigger 시킨 주체를 의미합니다. 또한 attribute인 sender는 sender address of the transaction를 의미합니다. 마지막으로 transfer()는 built-in 함수로 ether를 current contract -\u003e 누군가.transfer()의 누군가에게 전달하는 것을 의미하며 이 코드에서 누군가는 address of the sender입니다. 즉 코드를 한줄로 설명하면 contract --eth--\u003e msg.sender로 작동해라는 명령어 입니다. This meas transfer ether from current contract to the sender of the msg that triggered this contract execution ","date":"2022-01-28","objectID":"/ch02_eth_basic/:7:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Compiling the Faucet Contract 자 이제 우리가 처음 작성한 스마트 컨트랙트 코드를 Solidity Compiler를 통해 EVM bytecode로 변환을 하여 EVM에서 실행 될 수 있도록 만들어보겠습니다. Solidity Compiler로는 대표적으로 아래의 것들이 있습니다. 저희는 이 중 solidity 공식문서에서 권유하는 Remix IDE를 사용해보겠습니다. We recommend Remix for small contracts and for quickly learning Solidity. 참고로 대안으로 급부상하고 있는 Hardhat 이라는 개발환경 또한 존재합니다. web3.js 대신 (ethers.js )를 default로 사용함. Remix에서 코드를 작성한 뒤, Remix 좌측 2번째 탭을 클릭한 뒤, 적절한 compiler 버전(이번 예제는 0.6.4)를 설정해주고 compile Faucet.sol 버튼을 클릭해주면 아래와 같은 화면을 볼 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:8:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Creating the Contract on the Blockchain Now, we need to “register” the contract on the Ethereum blockchain. 이제 robsten test 네트워크에 생성해준 contract를 등록해보겠습니다. Registering a contract on the blockchain involves creating a special transaction whose destination is the address 0x0000000000000000000000000000000000000000, also known as the zero address. The zero address is a special address that tells the Ether‐ eum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask. 자 Remix의 3번째 탭(DEPLOY \u0026 RUN TRANSACTIONS)을 클릭하여 아래와 같이 세팅해줍니다. Account는 앞서 metamask에서 계정을 생성해주었다면 remix에서 metamask 요청페이지를 열어주어, 계정을 연결시켜줄 것입니다. 여기에서 “Deploy\"버튼을 누르게 되면 이렇게 Deployed Contract가 등록요청하는 metamask 창이 열리고 확인을 누릅니다. 확인을 눌러주면 Remix상에서 contract가 생성된 것을 보실 수 있습니다. 우측의 copy버튼을 눌러 Contract address를 복사해서 etherscan에서 확인해보겠습니다. 생성한 컨트렉트 에서 보여지듯이 잘 생성된 것을 확인하실 수 있습니다. 자 그럼 1eth를 해당 컨트랙트로 보내보겠습니다. metamask를 통해서 이더를 보낸뒤, etherscan을 통해서 확인해보면 정상적으로 value 1eth가 전송된 것을 확인할 수 있습니다. 자 이제 튜토리얼의 마지막 단계인 0.1eth를 회수 해보겠습니다. Remix의 버튼에 “100000000000000000” (10*17 wei = 0.1eth)를 기입하고 withdraw버튼을 클릭해줍니다. etherscan을 통해서 보면 다음과 같이 0.1 eth를 전송한 트랜잭션을 확인할 수 있습니다. ","date":"2022-01-28","objectID":"/ch02_eth_basic/:9:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Conclusion 이상으로 마스터링 이더리움 ch02인 기초적인 이더리움에 대해서 정리해보았습니다. 개인적으로 스마트 컨트랙트가 어떻게 배포되는 지 궁금했었는데 staging 개념으로 테스트를 해볼 수 있는 테스트넷이 있다는 점과, 실제 컨트랙트를 배포해서 metamask 계정과 연동해서 동작시켜볼 수 있었던 점이 재밌었던 것 같습니다. - 끝 - ","date":"2022-01-28","objectID":"/ch02_eth_basic/:10:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH02] Ethereum Basics","uri":"/ch02_eth_basic/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-21","objectID":"/ch03/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Quote 나만의 좀비 덱을 만들어보자. ","date":"2022-01-21","objectID":"/ch03/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"[ch03] Advanced Solidity Concepts 챕터3를 통과하게 되면 나만의 좀비 덱 을 가지게 됩니다. ","date":"2022-01-21","objectID":"/ch03/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Ownable Contracts external function으로 setter를 열어두게 되면, 아무나 내 컨트랙트 안의 state variable을 수정할 수 있게 되는 보안적인 이슈가 생기게 된다. 이를 대처하기 위해 주로 사용하는 방식은 contract를 ownable하게 만들어 특별한 권리를 가지는 특정 소유자가 있음을 지정할 수 있다. /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } function Ownable()는 Constructor(생성자)입니다. 컨트랙트와 동일한 이름을 가졌으며 default로 제공되어 특별한 작업을 할 게 아니라면 생략가능합니다. 생성자는 컨트랙트 생성시 단 한번만 실행됩니다. modifier onlyOwner()에서 modifier는 function modifier(함수 제어자)입니다. 함수에 대한 접근을 제어하기 위해 사용되는 함수의 일종으로, 보통 함수 실행 전 요구사항 충족여부를 확인하는 데 사용됩니다. 예시의 onlyOwner() 함수는 컨트랙트의 소유자에 한해서만 해당 함수를 실행할 수 있도록 하기 위해 제어해주는 기능을 해줍니다. 즉 transferOwnership(소유권 이전) 함수는 onlyOwner 조건을 만족시킬 때만 실행됩니다. _ 키워드는 쉽게 modifier 검사를 마친 뒤, 실행 될 함수가 들어가게 된다 생각하면 됩니다. indexed 키워드에 대해서는 추후에 더 알아보겠습니다. ","date":"2022-01-21","objectID":"/ch03/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas 이더리움 DApp이 사용하는 연료 솔리디티에서는 사용자들이 만든 DApp의 함수를 실행할 때마다 Gas라 불리는 화폐(ETH, 이더)를 지불해야합니다. 엄밀히 말해서는 사용자가 ETH(이더)를 이용해 Gas를 구매한다. Gas비는 연산비용에 따라 다릅니다. 즉 함수의 로직이 얼마나 복잡한지에 따라 연산이 소모되는 gas cost가 상승합니다. 이런 시스템이기 때문에 코드 최적화가 암묵적으로 강제된다 할 수 있습니다. 가스는 함수를 실행하는 사용자들이 실제 돈을 쓰기 때문에 코드 최적화가 되지 않았다면 당연히 많은 사용자들이 생성한 코드를 사용하지 않게 됩니다. Gas가필요한이유 이더리움 진영에서는 이더림움을 World Computer라고 소개합니다. 전세계에 퍼져있는 개별 노드들이 누군가가 만든 함수를 실행할 때 네트워크 상의 모든 노드 각각이 함수의 output을 검증하기 위해 그 함수를 실행해야 합니다. 이더리움은 Turing complete하기 때문에 무한 루프와 같이 컴퓨팅 자원을 많이 소모되는 코드가 악의적으로 생성된다면 이더리움이라는 하나의 컴퓨터에 악영향을 끼칠것입니다. 이런 이유로 이더리움 개발자들은 연산 처리에 각각 비용을 할당했으며 사용자들은 space / time complexity에 비례하여 gas를 지불해야 합니다. 추가로 크립토 좀비에 따르면 side-chain에서는 반드시 gas를 지불하지는 않는다고 하네요, Loom Network를 사용하는 크립토 좀비가 대표적인 예시라고 합니다. 이더리움 메인넷에서 롤 같은 게임을 직접 돌리게 되면 말도 안되게 엄청 높은 가스 비용이 들테니까요. 하지만 다른 합의 알고리즘을 가진 사이드체인에서는 가능하다고 합니다. ","date":"2022-01-21","objectID":"/ch03/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Gas비 절약법 기본적으로 uint256이 아닌 uint8과 같은하위 타입들로 저장소를 절약하는 것은 아무런 이득이 없다고 합니다. 왜냐면 솔리디티에서 uint의 크기에 상관없이 256bit 저장공간을 미리 잡아두기 때문입니다. 단 struct 안에서 uint를 사용한다면 더 작은 크기를 사용할 때, storage 절약이 가능하다고 합니다. struct NormalStruct { uint a; uint b; uint c; } struct MiniMe { uint32 a; uint32 b; uint c; } // `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용하게 됩니다. NormalStruct normal = NormalStruct(10, 20, 30); MiniMe mini = MiniMe(10, 20, 30); 이런 이유로, 구조체 안에서는 가능한 작은 크기의 정수 타입을 쓰는 것이 좋다고 할 수 있습니다.또한 동일한 데이터 타입은 하나로 묶어놓는 것이 좋습니다. 즉 구조체에서 서로 가까이 있도록 선언하면 솔리디티에서 사용하는 저장 공간을 최소화해줍니다. 예를 들면, uint c; uint32 a; uint32 b;라는 필드로 구성된 구조체가 uint32 a; uint c; uint32 b; 필드로 구성된 구조체보다 uint32 필드들이 묶여있기 때문에 가스를 덜 소모합니다. ","date":"2022-01-21","objectID":"/ch03/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Time Units Solidity provides some native units for dealing with time. now now를 사용하게 되면 unix timestamp(1970년 1월 1일부터 지금까지의 초 단위 합)을 uint256타입으로 얻을 수 있습니다. 참고로 unix time은 전통적으로 32bit로 저장되는데 이 경우 Year 2038 문제가 발생할 것입니다. 만약 우리 DApp이 2038년까지 운영되길 원한다면 어쩔 수 없이 64bit를 써야하지만, trade of로 유저들은 저장하는데 더 많은 gas를 소모하게 됩니다. 2038년_문제 year 2038 problem 란? POSIX 시간 표기법은 시간을 1970년 1월 1일 자정 UTC 이후 경과된 초 시간을 이용하여 표현하는데,대부분의 32비트 시스템에서 초 시간을 저장하는 데 이용되는 time_t 자료 형식은 부호 있는 32비트 정수형이다. 즉 이 형식을 이용하여 나타낼 수 있는 최후의 시각은 1970년 1월 1일 자정에서 정확히 2147483647초가 지난 2038년 1월 19일 화요일 03:14:07 UTC이다. 이 시각 이후의 시각은 범위를 초과하여 내부적으로 음수로 표현되며, 프로그램의 이상 작동을 유발하는데, 왜냐하면 이러한 값은 2038년 대신 프로그램의 구현 방법에 따라 1970년 또는 1901년을 가리키기 때문입니다. uint lastUpdated; // `lastUpdated`를 `now`로 설정 function updateTimestamp() public { lastUpdated = now; } // 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환 function fiveMinutesHavePassed() public view returns (bool) { return (now \u003e= (lastUpdated + 5 minutes)); } ","date":"2022-01-21","objectID":"/ch03/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Passing structs as arguments 솔리디티에서는 private 또는 internal 함수의 인자로서 구조체의 storage 포인터를 전달할 수 있습니다. 이때 구조체는 포인터타입이며, 솔리디티에서는 이를 storage pointer라고 부르고 있습니다. 문득 memory pointer명칭도 존재하는지 찾아보니 서치하지 못한걸 보면 storage pointer라는 명칭만 있는 것 같습니다. storage pointer라는 명칭을 처음 접해서 개념을 정리하기 위해서 이곳저곳을 찾다, Storage Pointers in Solidity 라는 글을 읽었습니다. 이해한 부분까지 정리해보면 struct타입은 기본적으로 pointer 타입인 것고 이를 function에서 local variable로 참조해서 사용하면 storage형태로 저장되는 것 같습니다. 아래의 코드를 보면 contract FirstSurprise { struct Camper { bool isHappy; } mapping(uint =\u003e Camper) public campers; function setHappy(uint index) public { campers[index].isHappy = true; } function surpriseOne(uint index) public { Camper c = campers[index]; c.isHappy = false; } } setHappy를 통하지 않고도, surpriseOne()의 Camper c = campers[index] c가 storage pointer타입이기 때문에 side-effect가 생길 수 있다는 점이 핵심인 듯합니다. 최근에 이런 목소리를 반영해서 solidity compiler는 이런 상황일 때 아래와 같은 warning을 띄워준다고 합니다. Variable is declared as storage pointer. Use explicit “storage” keyword to silence this warning. 이런 맥락에서 크립토 좀비에서는 구조체를 함수의 인자로 전달하면 storage pointer라고 설명하고 있으며, 아래와 같이 함수 인자에 명시적으로 storage를 쓰도록 하고 있습니다. function _doStuff(Zombie storage _zombie) internal { // _zombie로 할 수 있는 것들을 처리 } 그럼 이런 배경지식을 기억한채 다시 좀비로 넘어와보겠습니다. 우리는 좀비들이 끊임없이 kitty를 먹고 증식하는 것을 막기 위해서 feedAndMultiply에 다음 제약조건을 추가해보려고 합니다. 먹이를 먹으면 좀비가 재사용 대기에 들어간다. 좀비는 재사용 대기 시간이 지날 때까지 고양이들을 먹을 수 없다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner { kittyContract = KittyInterface(_address); } function _triggerCooldown(Zombie storage _zombie) internal { _zombie.readyTime = uint32(now + cooldownTime); } function _isReady(Zombie storage _zombie) internal view returns (bool) { return (_zombie.readyTime \u003c= now); } function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; require(_isReady(myZombie)); // 새로 추가 된정보 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; } _createZombie(\"NoName\", newDna); _triggerCooldown(myZombie); // 새로 추가 된정보 } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 우선 Zombie storage pointer를 인자로 받는 _isReady(), _triggerCooldown()함수를 만듭니다. _isReady(): 좀비가 재사용 대기시간을 넘겼는지 확인 _triggerCooldown(): 좀비가 kitty와 조합(eat) 되었다면, 좀비의 readyTimed을 now + cooldownTime(1일)로 업데이트 해줍니다. 이후 좀비에게 먹이를 공급하는 feedAndMultiply()함수에 아무나 접근하지 못하도록 internal로 함수를 지정해줍니다. ","date":"2022-01-21","objectID":"/ch03/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Function modifiers with arguments 앞서 modifier onlyOwner같은 커스텀 function modifier를 보았는데, 이에 더해 function modifier에 argument를 넣어주는 법을 배워봅시다. // usrId =\u003e age mapping mapping (uint =\u003e uint) public age; modifier olderThan(uint _age, uint _userId) { require(age[_userId] \u003e= _age); _; } function buyCigarette(uint _userId) public olderthan(19, _userId) { 🚬() } 위의 코드는 담배를 판매하는 간단한 contract입니다. functio nmodifier의 인자로 나이와 userId를 제공하여 나이를 검사를 구현해주었습니다. 이 기능을 활용하여 우리의 zombie에게 level 속성을 부여해보고, 속성에 따라서 아래와 같은 능력치 제한을 두는 modifier를 만들어보겠습니다. 레벨 2 이상인 좀비인 경우, 사용자들은 그 좀비의 이름을 바꿀 수 있네. 레벨 20 이상인 좀비인 경우, 사용자들은 그 좀비에게 임의의 DNA를 줄 수 있네. zombieHelper.sol pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { modifier aboveLevel(uint _level, uint _zombieId) { require(zombies[_zombieId].level \u003e= _level); _; } function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; } function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) { require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; } } ","date":"2022-01-21","objectID":"/ch03/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Saving Gas With ‘View’ Functions View functions don’t cost gas view 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않는다. 블록체인에 상태를 기록한다는 것은, 모든 single node들에게 트랜잭션이 추가되어야 한다는 것을 의미합니다. 하지만 반대로 view / pure function의 경우 블록체인 상에 어떤 것도 수정하지 않기 때문에 gas 소모가 없습니다. 만약 web3.js에게 view function를 호출해달라 요청하는 것은 실제로는 로컬 이더리움 노드에 query만 날리면 되기 때문에 가스 소모가 없게 됩니다. Warning 앞부분 설명을 보다보니 문득 view function gas가 들지 않는다면, view function을 infinite 호출하게되면 이더리움 망가뜨릴수 있지 않을까하는 생각에 검색하게 되었고 확인해보니 pure / view function은 internally call 해주게 되면 gas비가 든다고 한다. 즉 크립토좀비가 이번 세션에서 설명하는 것은 blockchain 외부(i.g web3.js)에서 호출하면 free gas cost라는 의미이다. Pure and view functions still cost gas if they are called internally from another function. They are only free if they are called externally, from outside of the blockchain. This View/Pure Gas usage - Cost gas if called internally by another function? goes into greater depth on this topic. 자세히 보니 크립토 좀비의 참고에도 아래와 같은 hint가 작성되어있네요. (데헷 😧) Tip 만약 view 함수가 동일 컨트랙트 내에 있는, view 함수가 아닌 다른 함수에서 내부적으로 호출될 경우, 여전히 가스를 소모할 것이네. 이것은 다른 함수가 이더리움에 트랜잭션을 생성하고, 이는 모든 개별 노드에서 검증되어야 하기 때문이네. 그러니 view 함수는 외부에서 호출됐을 때에만 무료라네. 이제 우리의 좀비 DApp에 사용자의 전체 좀비 군대를 볼 수 있는 메소드를 추가해보자. getZombiesByOwner()라는 네이밍에 external view function으로 만들어 보겠습니다. Declaring arrays in memory 솔리디티에서 storage에 write하는 것은 비싼 연산 중 하나입니다. 이더리움은 World computer이기 때문에 main-net기준으로 storage를 사용할 경우, 연결되어 있는 전세계 수많은 node들에 update를 시키게 되기 때문이죠. 이러다 보니 대부분의 프로그래밍 언어가 크기가 상당한 collection에 각각 접근( O(N) )하는 것을 지양하는 것과 달리, 솔리디티는 그 접근이 external view함수라면 storage를 쓰는 것보다 memoery를 써서 각각 element에 접근하는 것이 더 저렴한 방법입니다. (이는 gas비 때문인데, 훗날 이더리움 가격이 떨어진다면 달라질지도) Tip 생각해보니 실제로 storage에 write하는 것은 O(N) * per_gas_cost는 아닌것 같네요. 만약 1만명이 사용하는 contract라고 가정했을 떄 N=element갯수라면, gas_cost = (O(N) * 하나의_write_연산에_사용되는_gas_cost) * 10000이 되기 때문에 만약 1만명이 아닌 사용하고자 하는 사람의 숫자가 많아진다면, 즉 if 10000 \u003e= storage's element size라면 N의 정의가 달라지게 될 것 같습니다. Storage에 아무것도 쓰지 않고도 함수 안에서 새로운 배열을 만들기 위해서는 memory키워드를 사용하면 됩니다. 이는 storage배열을 직접 업데이트하는 것보다 gas_cost 측면에서 훨씬 (크립토 좀비에 따르면) 저렴하다고 합니다. 그러므로 collection을 storage로 관리하지 말고 memory로 전환하여 관리합시다. pragma solidity ^0.4.19; import \"./zombiefeeding.sol\"; contract ZombieHelper is ZombieFeeding { ... 중략 ... function getZombiesByOwner(address _owner) external view returns(uint[]) { uint[] memory result = new uint[](ownerZombieCount[_owner]); return result; } } ","date":"2022-01-21","objectID":"/ch03/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies03] Advanced Solidity Concepts","uri":"/ch03/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-20","objectID":"/ch02/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Quote 좀비에게 먹이를 주어서 조합이 가능하게 해보자. ","date":"2022-01-20","objectID":"/ch02/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"[ch02] Zombies Attack Their Victims 이번 장을 마치면 다음과 같은 고양이를 먹은 좀비를 생성할 수 있다. ","date":"2022-01-20","objectID":"/ch02/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Mappings and Addresses 이더리움 블록체인은 은행계좌와 같은 account를 사용해서 유저를 식별합니다. 이때 각 account들은 이더리움 블록체인상의 coin인 ether를 단위로 balance를 가지게 됩니다. 이를 통화를 통해 각 계정은 송금/인출 등의 은행과 같은 기능들을 할 수 있습니다. 이를 위해 이더리움에서 각 계정은 은행 계좌 번호와 같은 address를 가지고 있으며, 여기서 말하는 address는 EOA(Extenally Owned Account)의 address입니다. 보통은 EOA간의 메세지는 이더를 보내지만, EOA는 컨트랙트 어카운트에 메세지를 보내 해당 코드를 실행 시킬 수 도 있습니다. Mapping은 기본적으로 python의 dict와 같은 key-value 저장소입니다. contract ZombieFactory { ... mapping (uint =\u003e address) public zombieToOwner; mapping (address =\u003e uint) ownerZombieCount; ... } ","date":"2022-01-20","objectID":"/ch02/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Msg.sender solidity에는 모든 함수에서 이용 가능한 특정 전역 변수들이 있는데, 그 중의 하나가 현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소를 가리키는 msg.sender이다. Tip solidity에서 함수 실행은 항상 external caller(외부 호출자)가 시작하며, 컨트랙트는 외부에서 함수를 호출 하기 전까지 블록체인 상에서 아무것도 하지 않는다. 즉 스마트 컨트랙트는 msg.sender(호출자)가 항상 존재합니다. mapping (address =\u003e uint) favoriteNumber; function setMyNumber(uint _myNumber) public { favoriteNumber[msg.sender] = _myNumber; } function getMyNumber() public view returns (uint) { return favoriteNumber[msg.sender]; } ","date":"2022-01-20","objectID":"/ch02/:1:2","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Require 특정 조건이 True가 아닐 경우, 에러를 발생시키고 함수를 벗어나게 됩니다. function sayHiToLeoo(string _name) public returns (string) { // solidity는 고유의 스트링 비교 기능이 없다. 그러므로 keccak256 해시값을 // 비교해 스트링이 같은 값인지 판단하는 코드 require(keccak256(_name) == keccak256(\"Leoo.j\")); return \"Hi\"; } ","date":"2022-01-20","objectID":"/ch02/:1:3","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Inheritance contract Animal { function cry() public returns (string) { return \"Default cry\"; } } contract Dog is Animal { function cry() public returns (string) { return \"Bark\"; } } ","date":"2022-01-20","objectID":"/ch02/:1:4","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Import 파일들로 코드를 분리하고, 다른 파일에 있는 코드를 불러오고 싶을 때, 솔리디티는 import라는 keyword를 사용합니다. import \"./someothercontract.sol\"; // SomeOtherContract contract newContract is SomeOtherContract { } ","date":"2022-01-20","objectID":"/ch02/:1:5","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Storage vs Memory solidity가 변수를 저장할 수 있는 공간에는 2가지 종류가 있습니다. storage memory Storage는 블록체인 상에 영구적으로 저장되는 변수들입니다. state variable(함수 외부에 선언된 변수)인 경우 초기 설정상 Storage로 관리되어 블록체인 상에 영구적으로 저장됩니다. 이와 반대로 함수 내부에 선언된 변수는 memory로 자동 선언되어 함수 호출 종료시 사라지게 됩니다. 단 명시적으로 storage, memory 키워드들을 사용해주어야 하는 상황이 존재하는데, 바로 함수 내에서 struct, 배열을 처리할 때 입니다. contract SandwichFactory { struct Sandwich { string name; string status; } Sandwich[] sandwiches; // state variable (storage) function eat(uint _idx) public { string defaultState = \"NOT EATEN\"; // implicit memory Sandwich storage mySandwich = sandwiches[_idx]; // arr should explict Sandwich memory anotherSandwich = sandwiches[_idx + 1]; sandwiches[_idx + 1] = anotherSandwich; } } pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract ZombieFeeding is ZombieFactory { function feedAndMultiply(uint _zombieId, uint _targetDna) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; } } ","date":"2022-01-20","objectID":"/ch02/:1:6","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"Extra Function Visibility solidity에는 public과 private 이외에도 internal과 external이라는 함수 접근 제어자가 있다. internal 상속하는 컨트랙트에서도 접근 가능 (java protected와 비슷해 보임?) 나머지는 private과 동의 external 컨트랙트 바깥에서만 호출 될 수 있음 컨트랙트 내의 다른 함수에 의해 호출될 수 없다. 나머지는 public과 동의 internal은 상속하는 컨트랙트에서도 접근 가능하다는 점을 제외하면 private과 같다. 느낌 상 java의 protected와 유사해 보이며, state variable은 default로 internal 접근자를 가진다. external은 함수가 컨트랙트 바깥에서만 호출 될 수 있고 컨트랙트 내의 다른 함수에 의해서 호출 될 수 없다는 부분만 제외하면 public과 같다. contract Sandwich { uint private sandwichesEaten = 0; function eat() internal { sandwichesEaten++; } } contract BLT is Sandwich { uint private baconSandwichesEaten = 0; function eatWithBacon() public returns (string) { baconSandwichesEaten++; // eat 함수가 internal로 선언되었기 때문에 여기서 호출이 가능하다 eat(); } } ","date":"2022-01-20","objectID":"/ch02/:1:7","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"interface 블록체인 상에서, 다른 컨트랙트와 상호작용을 하고 싶다면 Interface를 정의해야 합니다. contract LuckyNumber { mapping(address =\u003e uint) numbers; function setNum(uint _num) public { numbers[msg.sender] = _num; } function getNum(address _myAddress) public view returns (uint) { return numbers[_myAddress]; } } 예를 들어 다음과 같은 외부 컨트랙트가 있다고 가정 할 때, 우리는 다음과 같은 interface를 만들 수 있습니다. // 예시에서는 contract NumberInterface {}를 사용한다. interface NumberInterface { function getNum(address _myAddress) public view returns (uint); } 크립토 좀비에 제공된 예시에서는 contract NumberInterface {}를 사용하고 있는데, interface키워드가 추가 된 것인지 아니면 contract보다 interface가 제약조건이 많기 때문에 간단하게 contract로 구현했는지 모르겠지만, 좀 더 명확한 표현이 좋아서 예제를 변경하였습니다. 실제 interface 사용은 다음과 같습니다. contract MyContract { address NumberInterfaceAddress = 0xab38... // ^ 이더리움상의 FavoriteNumber 컨트랙트 주소이다 NumberInterface numberContract = NumberInterface(NumberInterfaceAddress) // 이제 `numberContract`는 다른 컨트랙트를 가리키고 있다. function someFunction() public { // 이제 `numberContract`가 가리키고 있는 컨트랙트에서 `getNum` 함수를 호출할 수 있다: uint num = numberContract.getNum(msg.sender); // ...그리고 여기서 `num`으로 무언가를 할 수 있다 } } interface라는 키워드는 아래와 같은 제약조건이 있습니다. 다른 Contract로 부터 상속받을 수 없습니다, 하지만 다른 interface로부터는 상속받을 수 있습니다. 모든 function들은 public, external이어야 합니다. constructor를 선언할 수 없습니다. variable를 선언할 수 없습니다. struct를 선언할 수 없습니다. enum를 선언할 수 없습니다. 내부에는 추상함수, 즉 함수 시그니처만 존재합니다. Interfaces cannot have any functions implemented ","date":"2022-01-20","objectID":"/ch02/:1:8","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["blockchain"],"content":"summary 최종적으로 다음과 같은 코드가 만들어집니다. pragma solidity ^0.4.19; import \"./zombiefactory.sol\"; contract KittyInterface { function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes ); } contract ZombieFeeding is ZombieFactory { address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public { require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) { newDna = newDna - newDna % 100 + 99; // 끝에 2자리를 99로 변경한다. } _createZombie(\"NoName\", newDna); } function feedOnKitty(uint _zombieId, uint _kittyId) public { uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); } } 요구사항 고양이 좀비(kitty zombie)는 DNA 마지막 2자리로 99를 갖는다고 가정한다. 그러면 우리 코드에서는 만약(if) 좀비가 고양이에서 생성되면 좀비 DNA의 마지막 2자리를 99로 설정한다. 자바스크립트와 web3.js를 활용하여 우리의 컨트랙트와 상호작용하는 예시 var abi = /* abi generated by the compiler */ var ZombieFeedingContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFeeding = ZombieFeedingContract.at(contractAddress) // 우리 좀비의 ID와 타겟 고양이 ID를 가지고 있다고 가정하면 let zombieId = 1; let kittyId = 1; // 크립토키티의 이미지를 얻기 위해 웹 API에 쿼리를 할 필요가 있다. // 이 정보는 블록체인이 아닌 크립토키티 웹 서버에 저장되어 있다. // 모든 것이 블록체인에 저장되어 있으면 서버가 다운되거나 크립토키티 API가 바뀌는 것이나 // 크립토키티 회사가 크립토좀비를 싫어해서 고양이 이미지를 로딩하는 걸 막는 등을 걱정할 필요가 없다 ;) let apiUrl = \"https://api.cryptokitties.co/kitties/\" + kittyId $.get(apiUrl, function(data) { let imgUrl = data.image_url // 이미지를 제시하기 위해 무언가를 한다 }) // 유저가 고양이를 클릭할 때: $(\".kittyImage\").click(function(e) { // 우리 컨트랙트의 `feedOnKitty` 메소드를 호출한다 ZombieFeeding.feedOnKitty(zombieId, kittyId) }) // 우리의 컨트랙트에서 발생 가능한 NewZombie 이벤트에 귀를 기울여서 이벤트 발생 시 이벤트를 제시할 수 있도록 한다: ZombieFactory.NewZombie(function(error, result) { if (error) return // 이 함수는 레슨 1에서와 같이 좀비를 제시한다: generateZombie(result.zombieId, result.name, result.dna) }) ","date":"2022-01-20","objectID":"/ch02/:1:9","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies02] Zombies Attack Their Victims","uri":"/ch02/"},{"categories":["ros"],"content":"ros2 Foxy 실행에 필요한 개발 환경을 ubuntu, vm환경에 세팅해봅니다. ","date":"2022-01-18","objectID":"/ch02_setup/:0:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup zsh sudo apt-get install zsh chsh -s /usr/bin/zsh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" .zshrc update ZSH_THEME=\"Theme_Name\" 4. powerlevel10k install https://github.com/romkatv/powerlevel10k#meslo-nerd-font-patched-for-powerlevel10k install fonts wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf wget https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf update fonts terminal vscode install powerlevel10k git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k Set ZSH_THEME=“powerlevel10k/powerlevel10k” in ~/.zshrc. plugins git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\ ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting plugins=( # other plugins... zsh-autosuggestions ) 최종 ~/.basrc 파일 # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac # don't put duplicate lines or lines starting with space in the history. # See bash(1) for more options HISTCONTROL=ignoreboth # append to the history file, don't overwrite it shopt -s histappend # for setting history length see HISTSIZE and HISTFILESIZE in bash(1) HISTSIZE=1000 HISTFILESIZE=2000 # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # If set, the pattern \"**\" used in a pathname expansion context will # match all files and zero or more directories and subdirectories. #shopt -s globstar # make less more friendly for non-text input files, see lesspipe(1) [ -x /usr/bin/lesspipe ] \u0026\u0026 eval \"$(SHELL=/bin/sh lesspipe)\" # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] \u0026\u0026 [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, unless we know we \"want\" color) case \"$TERM\" in xterm-color|*-256color) color_prompt=yes;; esac # uncomment for a colored prompt, if the terminal has the capability; turned # off by default to not distract the user: the focus in a terminal window # should be on the output of commands, not on the prompt #force_color_prompt=yes if [ -n \"$force_color_prompt\" ]; then if [ -x /usr/bin/tput ] \u0026\u0026 tput setaf 1 \u003e\u0026/dev/null; then # We have color support; assume it's compliant with Ecma-48 # (ISO/IEC-6429). (Lack of such support is extremely rare, and such # a case would tend to support setf rather than setaf.) color_prompt=yes else color_prompt= fi fi if [ \"$color_prompt\" = yes ]; then PS1='${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' else PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi unset color_prompt force_color_prompt # If this is an xterm set the title to user@host:dir case \"$TERM\" in xterm*|rxvt*) PS1=\"\\[\\e]0;${debian_chroot:+($debian_chroot)}\\u@\\h: \\w\\a\\]$PS1\" ;; *) ;; esac # enable color support of ls and also add handy aliases if [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors \u0026\u0026 eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -b)\" alias ls='ls --color=auto' #alias dir='dir --color=auto' #alias vdir='vdir --color=auto' alias grep='grep --color=auto' alias fgrep='fgrep --color=auto' alias egrep='egrep --color=auto' fi # colored GCC warnings and errors #export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01' # some more ls aliases alias ll='ls -alF' alias la=","date":"2022-01-18","objectID":"/ch02_setup/:1:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"Setup workspace 먼저 ros를 실행하기 위해서는 workspace가 필요합니다. 필요한 작업공간을 만들어 보겠습니다. # ros2-sandbox on vmware $ colcon build $ echo 'source /home/leoo/shared/ros2-sandbox/install/setup.bash' \u003e\u003e ~/.bashrc sudo ros2를 하니 command not found가 나왔다. 만약 sudo를 써야 한다면, $ sudo echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e /root/.bashrc \u0026\u0026 sudo reboot host디렉토리를 mount 해버리니, .bashrc에서 commad가 permission denied되었다. 그러므로 매번 vmware에서는 sudo -i를 해주고, /root 디렉토리에 symlink를 생성해주자(편리함)s $ sudo -i # 생성하지 않았다면 $ ln -s /home/leoo/shared/ros2-sandbox ros2-sandbox $ cd ros2-sandbox ","date":"2022-01-18","objectID":"/ch02_setup/:2:0","tags":["dev"],"title":"[ch02] Ros2 개발 환경 setup","uri":"/ch02_setup/"},{"categories":["ros"],"content":"ros2 Foxy를 mac pro 로컬 환경에 설치해봅니다. ","date":"2022-01-18","objectID":"/ch01_install/:0:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"1. tl;dr 실행환경: virtualbox(ubuntu 20.04) mount: 현재 디렉토리 코드작성 vm vs code에서 실행 host에서 코드 작성을 하려하였으나, lint와 링크 기능이 제대로 동작하지 않음 ","date":"2022-01-18","objectID":"/ch01_install/:1:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2. setup on virtual box (✅) setup mac like keyboard on virtual box 최종적으로 성공한 방식은 vm에 ubuntu를 설치해서 foxy를 실행하는 방식입니다. 아래 절차를 거쳐 세팅을 진행하였습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.1. ubuntu iso download 가장 먼저 ubuntu iso 이미지를 다운 받습니다. https://mirror.kakao.com/ubuntu-releases/focal/ 에서 ubuntu 20.04 lts download ","date":"2022-01-18","objectID":"/ch01_install/:2:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.2. vritualbox download 다음으로 virtualbox 를 최신버전으로 다운 받습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.3. virtual box 셋업 가장 먼저 설치한 iso를 연결해줍니다. 2.3.1. iso 등록 다음으로 아래 스펙으로 virtualbox를 세팅해줍니다. mem: 8192MB HDD: 30 GB 키보드 / 드래그앤 드롭 Bidirectional 설정 2.3.2. 일반 \u003e 기본 2.3.3. 일반 \u003e 고급 2.3.4. 시스템 \u003e 마더보드 2.3.5. 시스템 \u003e 프로세서 2.3.6. 디스플레이 2.3.7. 공유폴더 설정 2.3.8. 전체 설정 여기까지 기본적인 ubuntu 설정이 완료되었습니다. 다음으로 ubuntu 자체 설정을 해주겠습니다. ","date":"2022-01-18","objectID":"/ch01_install/:2:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.4. ubuntu install ubuntu는 한글설정 / 맥북 키보드 shortcut 설정 / zsh 등, 처음 세팅하게 되면 설정해주어야 할 것들이 존재합니다. 가장 먼저는 apt 저장소를 카카오 미러 로 변경해주세요. (이렇게 하면 더 빠르게 apt 설치가 가능합니다.) virtual box cmd right로 변경 [키보드 세팅(mac like)] $ sudo apt-get install keyboard-configuration $ sudo dpkg-reconfigure keyboard-configuration # select macbook pro(intel) # MacIntosh # English # English (Macintosh) # Both Alt keys # No compose key # Terminal preference에서 copy \u0026 paste 설정 mount host folder(소스코드) to ubuntu # 이건 임시이며, 항상 mount시키고 싶다면, vmware에 공유 폴더 설정해주어야 한다. $ sudo mount -t vboxsf ros2-sandbox /home/leoo/shared/ros2-sandbox/ ","date":"2022-01-18","objectID":"/ch01_install/:2:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.5. install ros dependencies $ sudo apt update $ sudo apt install build-essential gcc make perl dkms $ sudo apt update \u0026\u0026 sudo apt upgrade $ sudo apt install terminator $ sudo add-apt-repository universe $ sudo apt-get update $ sudo apt-get install python3-pip ","date":"2022-01-18","objectID":"/ch01_install/:2:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"2.6. install ros2 binary $ locale # check for UTF-8 $ sudo apt update \u0026\u0026 sudo apt install locales $ sudo locale-gen en_US en_US.UTF-8 $ sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 $ export LANG=en_US.UTF-8 $ locale # verify settings $ sudo apt update \u0026\u0026 sudo apt install curl gnupg2 lsb-release $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg $ echo \"deb [arch=$(dpkg --print-architecture)signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs)main\" | sudo tee /etc/apt/sources.list.d/ros2.list \u003e /dev/null $ sudo apt update $ sudo apt install ros-foxy-desktop $ echo 'source /opt/ros/foxy/setup.bash' \u003e\u003e ~/.bashrc $ sudo apt install python3-argcomplete 만약 이렇게 세팅하였을 때 자신의 vm이 너무 느리다고 판단 된다면 vm 설정방법 을 참고해주세요. 지금까지 세팅을 완료하였으면 예쁘게 동작하는 vm을 보실 수 있습니다. :) 2.6.1. vm에서 동작하는 화면 ","date":"2022-01-18","objectID":"/ch01_install/:2:6","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"3. setup with Docker (🚫) docker 설치 refs Host로 설정하는 방식이 실패하여, 그 다음으로 선택한 방식입니다. 도커를 사용한 방식은 문제없이 동작하였지만, 추후 터미널을 여러개 띄워 네트워크 통신이 많아지는 걸 고려하면, 추가적으로 설정해야 할 부분들이 많아 보였습니다. 추가로 문서 또한 리눅스 문서들이 많으므로 vm ware 사용 $ docker pull osrf/ros:noetic-desktop-full-buster $ brew install socat # https://www.cyberciti.biz/faq/apple-osx-mountain-lion-mavericks-install-xquartz-server/ $ brew install --cask xquartz $ sudo reboot # xquartz 보안 설정 모두 열어주기 host 터미널에서 아래 명령어 실행 # ip 확인 후 xhost에 추가 $ ip=$(ifconfig en0 | grep inet | awk '$1==\"inet\" {print $2}') $ xhost + $ip # 컨테이너 생성 $ docker run -it -e DISPLAY=$ip:0 --name ros osrf/ros:noetic-desktop-full-buster ","date":"2022-01-18","objectID":"/ch01_install/:3:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4. setup on Host (🚫) This was failed 이 방식은 맥북에 바로 설치하는 방식으로 mac os에 ros에 필요한 dependencies들을 바로 추가해주었습니다. ","date":"2022-01-18","objectID":"/ch01_install/:4:0","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.1. Pre-Install ROS2 on mac $ brew doctor $ softwareupdate --all --install --force $ sudo rm -rf /Library/Developer/CommandLineTools $ sudo xcode-select --install $ brew link kubernetes-cli $ brew link python@3.9 $ echo 'export PATH=\"/usr/local/sbin:$PATH\"' \u003e\u003e ~/.zshrc ","date":"2022-01-18","objectID":"/ch01_install/:4:1","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.2. Install ROS2 on mac brew install python@3.8 brew unlink python \u0026\u0026 brew link --force python@3.8 echo 'export PATH=\"/usr/local/opt/python@3.8/bin:$PATH\"' \u003e\u003e ~/.zshrc export LDFLAGS=\"-L/usr/local/opt/python@3.8/lib\" export PKG_CONFIG_PATH=\"/usr/local/opt/python@3.8/lib/pkgconfig\" brew install asio tinyxml2 tinyxml eigen pcre poco brew install openssl \u0026\u0026 echo \"export OPENSSL_ROOT_DIR=$(brew --prefix openssl)\" \u003e\u003e ~/.zshrc brew install qt freetype assimp sip pyqt5 brew install console_bridge log4cxx spdlog cunit graphviz python3 -m pip install pygraphviz pydot catkin_pkg empy ifcfg lark-parser lxml netifaces numpy pyparsing pyyaml setuptools argcomplete pip3 install -U colcon-common-extensions # OpenCV는 필수는 아닙니다. 설치시 시간이 엄청 오래 걸리니 고민해보세요. brew install opencv ","date":"2022-01-18","objectID":"/ch01_install/:4:2","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.3. Download ROS Foxy Binary # https://github.com/ros2/ros2/releases mkdir -p ~/ros2_foxy cd ~/ros2_foxy tar xf ~/Downloads/ros2-foxy-20211013-macos-amd64.tar.bz2 ","date":"2022-01-18","objectID":"/ch01_install/:4:3","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.4. Check installed $ . ~/ros2_foxy/ros2-osx/local_setup.zsh ","date":"2022-01-18","objectID":"/ch01_install/:4:4","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["ros"],"content":"4.5. Error $ . ~/ros2_foxy/ros2-osx/local_setup.zsh [connext_cmake_module] Warning: The location at which Connext was found when the workspace was built [[/Applications/rti_connext_dds-5.3.1]] does not point to a valid directory, and the NDDSHOME environment variable has not been set. Support for Connext will not be available. csrutil disable로 시도해보았지만 실패 ros2 바이너리 버전을 낮춰서 시도해보았지만 역시 실패 big sur과 맞지 않는 source code에러가 있는 듯하다. 아래는 host에 설치하기 위해서 참조했던 문서들입니다. 공식 how-to-install-ros2-foxy-on-macos building-ros2-on-macos-big-sur-m1 ","date":"2022-01-18","objectID":"/ch01_install/:4:5","tags":["dev"],"title":"[ch01] Ros2 Foxy install","uri":"/ch01_install/"},{"categories":["blockchain"],"content":"이번장에서는 Mastering Ethereum과 김혐남님의 세미나 내용 을 기반으로 이더리움이란 무엇인가에 대해서 정리합니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"tl;dr Ethereum is a Blockchain Platform. 이더리움을 블록체인 생태계에서 포지션을 생각한다면 플랫폼으로 구분할 수 있습니다. Ethereum is “the world computer” 이더리움 진영에서 내새우는 정의는 (합의를 기반으로 동작하는) World Computer입니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:0:1","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"1. What is Ethereum Quote Ethereum is often described as “the world computer” 이더리움 진영에서 정의하는 이더리움이란 (탈 중앙화된) 월드 컴퓨터입니다. World와 Computer에 집중해본다면, World라는 단어처럼 이더리움은 “전세계를 하나로 묶어줄 수 있는 connection\"을 제공해주어야 할 것으로 보입니다. 묶어준 다는 점에서 p2p 네트워크가 필요해 보입니다. Computer라는 단어는 program, 그리고 이 프로그램을 개발할 수 있는 language가 필요해 보입니다. 또한 그 프로그램은 decentralized 성격을 가져야 하기 때문에, 일반 프로그램과 비교해 특별한 성질을 가질 것으로 보입니다. Ethereum is an open source with globally decentralized computing infrastructure that executes programs called smart contracts. It uses a blockchain to synchronize and store the system’s state changes. smart contract라는 특별한 program을 사용해 globally decentralized computing infrastructure 이면서도, 하나의 world computer 즉 state가 sync되는 시스템을 구현합니다. Tip Ethereum is a deterministic but practically unbounded state machine, Which means consisting of a globally accessible singleton state and a virtual machine. p2p로 퍼져있으면서도, 하나의 컴퓨터로 동작하기 위해서 스마트 컨트랙트는 globally accessible singleton state와 virtual machine 개념이 존재합니다. It uses a blockchain to synchronize and store the system’s state changes, along with a cryptocurrency called ether to meter and constrain execution resource costs. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:1:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"2. Compared to Bitcoin in common p2p network connecting participants. to synchronize PoW they uses Byzantine fault-tolerant consensus algorithm. uses cryptographic primitives hashes digital signatures digital currency Tip PoW(proof of work) is a form of adding new blocks of transactions to a cryptocurrency’s blockchain. in contrast Ethereum’s purpose is not primarily to be a digital currency payment network. ether is intended as a utility currency to pay for use of the Ethereum platform as the world computer. Bitcoin’s Script language is intentionally constrained to simple true/false evaluation of spending conditions, but ethereum’s language is Turing complete Tip A Turing complete system means a system in which a program can be written that will find an answer (although with no guarantees regarding runtime or memory). So, if somebody says “my new thing is Turing Complete” that means in principle (although often not in practice) it could be used to solve any computation problem. 프로그래밍 언어는 이와 비슷하게 Turing complete하다 왜냐하면 프로그램이 실행될 충분한 메모리와 시간이 주어진다면 특정 computational problem을 풀어낼 수 있기 때문이다. 김혐남님의 말을 빌리자면, 이더리움을 간단히 블록체인의 플랫폼이라 소개합니다. 블록체인 플랫폼이 되려다보니 이더리움은 블록체인 튜링 완전 프로그래밍이 가능해야 했고, Turing Complete해지니 application을 만들 수 있게 되었고, 이 앱은 block chain 위에서 실행되니 블록체인의 특성을 지닌 앱이 될 수 있었습니다. 이더리움은 이런 블록체인의 기능을 플랫폼처럼 추상화 시켜, 참여하는 개발자들이 쉽게 블록체인의 특성을 지닌 애플리케이션을 개발할 수 있도록 도와줍니다. ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:2:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"3. Components of a Blockchain The components of an open, public blockchain are: A peer-to-peer (P2P) network connecting participants and propagating transactions and blocks of verified transactions, based on a standardized “gossip” protocol Messages, in the form of transactions, representing state transitions A set of consensus rules, governing what constitutes a transaction and what makes for a valid state transition A state machine that processes transactions according to the consensus rules A chain of cryptographically secured blocks that acts as a journal of all the verified and accepted state transitions A consensus algorithm that decentralizes control over the blockchain, by forcing participants to cooperate in the enforcement of the consensus rules A game-theoretically sound incentivization scheme (e.g., proof-of-work costs plus block rewards) to economically secure the state machine in an open environment One or more open source software implementations of the above (“clients”) ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:3:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"4. The Birth of Ethereum 이더리움 창립자들은 프로그래밍을 통해 다양한 애플리케이션을 지원할 수 있는 특정 목적에 국한되지 않는 블록체인에 대해 생각하고 있었다. 이 생각은 이더리움과 같은 범용 블록체인을 사용하여 개발자가 피어투피어 네트워크, 블록체인, 합의 알고리즘 등의 기본 메커니즘을 구현하지 않고도, 특정 애플리케이션을 프로그래밍할 수 있다는 것이다. 이더리움 플랫폼은 세부사항을 추상화하고 탈중앙화 블록체인 애플리케이션을 위한 결정적이고 안전한 프로그래밍 환경을 제공한다. 이더리움은 범용 블록체인(=블록체인 플랫폼)으로서 위치하고 있다는 것을 확인할 수 있습니다. 탈중앙화의 첫 번째 대상은 ‘가치의 이동’입니다. 디파이라 불리는 탈중앙 금융이 블록체인의 성공적인 킬러 앱이 될 수 있는 이유는 바로 가치의 이동에서 찾을 수 있습니다. 블록체인이 왜 탈중앙화할 수 밖에 없었는지를 고민해 보면 정보의 이동이 아닌 핵심은 가치의 이동이 필요했기 때문입니다. The original blockchain, namely Bitcoin’s blockchain, tracks the state of units of bitcoin and their ownership. You can think of Bitcoin as a distributed consensus state machine, where transactions cause a global state transition, altering the ownership of coins. The state transitions are constrained by the rules of consensus, allowing all participants to (eventually) converge on a common (consensus) state of the system, after several blocks are mined. Ethereum answers the question: “What if we could track any arbitrary state and program the state machine to create a world-wide computer operating under consensus?” ","date":"2022-01-15","objectID":"/ch01_what_is_ethereum/:4:0","tags":["dev","ethereum"],"title":"[마스터링 이더리움 CH01] 이더리움이란 무엇인가","uri":"/ch01_what_is_ethereum/"},{"categories":["blockchain"],"content":"Learn Solidity step by step","date":"2022-01-14","objectID":"/ch01/","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Quote 크립토 좀비 에서 Solidity를 학습해보자. ","date":"2022-01-14","objectID":"/ch01/:0:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"[ch01] Making the Zombie Factory 챕터1을 통과하게 되면 나만의 좀비 를 가질 수 있다. :) 솔리디티 코드는 Contract안에 싸여져 있다. 컨트랙트는 이더리움 app의 기본 구성 요소로, 모든 변수/함수는 하나의 컨트랙트안에 속해 있어야 한다. 즉 컨트랙트는 모든 프로젝트의 시작 지점이라고 할 수 있다. contract ZombieFactory { } 모든 솔리디티 코드는 솔리디티의 버전을 선언 해주어야 한다. 이를 통해 새로운 컴파일러 버전이 나오더라도 코드가 깨지지 않도록 한다. pragma solidity ^0.4.19; contract ZombieFactory { } 솔리디티에서 state variable는 컨트랙트 저장소에 영구적으로 저장된다. 즉 이더리움 블록체인에 기록이 된다. uint는 unsigned 즉 부호가 없는 정수로, 음이 아닌 정수이다. (\u003c-\u003e int) uint는 uint256를 의미하며, 256비트 정수를 표현한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } 솔리디티는 c++과 마찬가지롤 struct를 제공한다. pragma solidity ^0.4.19; contract ZombieFactory { uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; } array안에 크기를 주지 않으면 동적할당 가능하다. // 2개의 원소를 담을 수 있는 고정 길이의 배열: uint[2] fixedArray; // 또다른 고정 배열으로 5개의 스트링을 담을 수 있다: string[5] stringArray; // 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다: uint[] dynamicArray; public으로 배열을 선언할 수 있으며 솔리디티는 이런 배열을 위해 getter 메소드를 자동적으로 생성해준다. Person[] public people; 함수의 경우 param명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례이다. 마찬가지로 private 함수명 또한 _를 쓰는 것이 convention이다. function _createZombie(string _name, uint _dna) private { } function createRandomZombie(string _name) public { } 참고로 솔리디티에서 함수는 기본적으로 public이다. 누구나 또는 다른 컨트랙트가 나의 컨트랙트 함수를 호출하고 코드를 실행할 수 있다. 솔라디티는 함수가 데이터를 read만 하고 state change를 하지 않을 때 view 함수를 사용한다. function sayHello() public view returns (string) { } 또한 pure 함수도 가지고 있는데, 이는 함수가 앱에서 어떤 데이터도 접근하지 않는(read, write둘다 하지 x) 것을 의미한다. function _multiply(uint a, uint b) private pure returns (uint) { return a * b; } 이더리움은 SHA3의 버전 중 하나인 keccak256를 내장 해시 함수로 가지고 있다. 해시 함수는 기본적으로 입력 스트링을 랜덤 256bit 16진수로 매핑한다. Question 블록체인에서 안전한 의사 난수 발생기는 어려운 문제라고 한다고 하는데 hash collision과 관련해서 어렵다고 하는 걸까? 아니면 안전하다고 하는게 Oracle?과 관련이 있는 걸까? //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5 keccak256(\"aaaab\"); //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9 keccak256(\"aaaac\"); event는 생성한 컨트랙트가 블록체인 상에서 앱에 접근하는 사용자 layer에서 액션이 발생했을 때, 통신하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는지 “listen\"하며, 그 이벤트가 발생하면 action을 취한다. // 이벤트를 선언한다 event IntegersAdded(uint x, uint y, uint result); function add(uint _x, uint _y) public { uint result = _x + _y; // 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다: IntegersAdded(_x, _y, result); return result; } ","date":"2022-01-14","objectID":"/ch01/:1:0","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["blockchain"],"content":"Summary 지금까지의 과정을 정리하면 아래와 같은 코드가 최종적으로 만들어진다. pragma solidity ^0.4.19; contract ZombieFactory { event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie { string name; uint dna; } Zombie[] public zombies; function _createZombie(string _name, uint _dna) private { uint id = zombies.push(Zombie(_name, _dna)) - 1; // push returns length NewZombie(id, _name, _dna); } function _generateRandomDna(string _str) private view returns (uint) { uint rand = uint(keccak256(_str)); return rand % dnaModulus; } function createRandomZombie(string _name) public { uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); } } // 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다: var abi = /* abi generated by the compiler */ var ZombieFactoryContract = web3.eth.contract(abi) var contractAddress = /* our contract address on Ethereum after deploying */ var ZombieFactory = ZombieFactoryContract.at(contractAddress) // `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다. // 일종의 이벤트 리스너가 텍스트 입력값을 취한다: $(\"#ourButton\").click(function(e) { var name = $(\"#nameInput\").val() // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다: ZombieFactory.createRandomZombie(name) }) // `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다 var event = ZombieFactory.NewZombie(function(error, result) { if (error) return generateZombie(result.zombieId, result.name, result.dna) }) // 좀비 DNA 값을 받아서 이미지를 업데이트한다 function generateZombie(id, name, dna) { let dnaStr = String(dna) // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다 while (dnaStr.length \u003c 16) dnaStr = \"0\" + dnaStr let zombieDetails = { // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여 // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. // 이를 기초로 \"head1.png\"에서 \"head7.png\" 중 하나의 이미지를 불러온다: headChoice: dnaStr.substring(0, 2) % 7 + 1, // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다: eyeChoice: dnaStr.substring(2, 4) % 11 + 1, // 셔츠 타입에는 6가지가 있다: shirtChoice: dnaStr.substring(4, 6) % 6 + 1, // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 \"filter: hue-rotate\"를 이용하여 아래와 같이 업데이트된다: skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360), eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360), clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360), zombieName: name, zombieDescription: \"A Level 1 CryptoZombie\", } return zombieDetails } ","date":"2022-01-14","objectID":"/ch01/:1:1","tags":["solidity","dev","crptozombies"],"title":"[Cryptozombies01] Making the Zombie Factory","uri":"/ch01/"},{"categories":["algorithm"],"content":"Sorting algorithms","date":"2022-01-12","objectID":"/sorting/","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":" Let’s summary list of Sorting Algorithms ","date":"2022-01-12","objectID":"/sorting/:0:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"tl;dr index sorting name time space description 1 Bubble O(n^2) O(1) 루프당 max가 가장 뒤, swap O(n^2) 2 Selection O(n^2) O(1) 루프당 min 맨 앞, swap O(n) 3 Insertion O(n^2) O(1) I까지 sort 보장, 정렬이 어느정도 되어있다면 사용할 것 4 Merge O(nlogn) O(n) nlogn 알고리즘 중 유일한 stable 5 Heap O(nlogn) O(1) insert(O(logn) * n개 원소, space가 1이 포인트 6 Quick O(nlogn) O(n) piv기준 작으면 left 크거나 같으면 right,balanced partition을 위해 random piv를 해준다. ","date":"2022-01-12","objectID":"/sorting/:1:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Bubble Sort ","date":"2022-01-12","objectID":"/sorting/:2:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Selection Sort ","date":"2022-01-12","objectID":"/sorting/:3:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Insertion Sort 이미 정렬된 상태라면 O(n)의 빠른 속도를 보인다. 정렬된 상태에서 빠른 이유는 각 insert마다 1번의 비교만 하면 되기 때문이다. reversed를 사용하면 insert시 arr re-arrange를 방지 가능하다. 단점: 삽입을 하게 되면 데이터가 하나씩 뒤로 밀려야 되기 때문에 배열이 길어질수록 효율이 떨어진다. 개인적으로 input()받을 때 insertionSort를 사용하면 입력과 정렬을 동시에 할 수 있어서 더욱 효율적인 것 같다. def insertion_sort(arr): n = len(arr) for i in range(1, n): val = arr[i] j = i - 1 if arr[j] \u003c val: continue while j \u003e= 0 and val \u003c arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = val return arr ","date":"2022-01-12","objectID":"/sorting/:4:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Merge Sort def merge_sort(arr): def merge(left, right): l = r = 0 result = [] while l \u003c len(left) and r \u003c len(right): if left[l] \u003c right[r]: result.append(left[l]) l+=1 else: result.append(right[r]) r+=1 return result + left[l:] + right[r:] # 나머지 (left over) if len(arr) \u003c= 1: return arr mid = len(arr) // 2 return merge(merge_sort(arr[:mid]), merge_sort(arr[mid:])) ","date":"2022-01-12","objectID":"/sorting/:5:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Heap Sort ","date":"2022-01-12","objectID":"/sorting/:6:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"Quick Sort 성능을 생각하면 piv를 random으로 찾아야 한다. from __future__ import annotations def quick_sort(arr: list[int]) -\u003e list[int]: if len(arr) \u003c= 1: return arr piv = arr[0] others = arr[1:] left = [v for v in others if v \u003c= piv] right = [v for v in others if v \u003e piv] return quick_sort(left) + [piv] + quick_sort(right) ","date":"2022-01-12","objectID":"/sorting/:7:0","tags":["algorithm","dev","interview"],"title":"Sorting algorithms","uri":"/sorting/"},{"categories":["algorithm"],"content":"About Binary Search and BST","date":"2022-01-08","objectID":"/binary_search/","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":" Binary Search와 BST에 대해서 정리합니다. Binary Search는 divide conquer의 일종으로 검색 범위를 binary하게 줄여나가면서 원하는 데이터를 검색하는 알고리즘입니다. def binary_search(sorted_arr, target): n = len(sorted_arr) if n == 0: return -1 low, high = 0, n-1 while low \u003c=high: mid = (low + high) // 2 if sorted_arr[mid] == target: return mid if sorted_arr[mid] \u003e target: high = mid -1 else: low = mid + 1 return -1 # low == high + 1 == mid 눈여겨 봐야할 포인트는 다음 2가지이다. 검색 대상이 되는 arr가 sorted되어있다. while의 조건으로 low \u003c= high 등호가 들어있다. 검색의 범위 element가 2개로 좁혀졌을 때 // 2 연산에 의해서 왼쪽만 탐색이 될 텐데, 찾아야하는 값이 우측 값에 존재한다면 low와 high가 같아야만(low == high == mid) 검색이 가능하다. ","date":"2022-01-08","objectID":"/binary_search/:0:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search 특징 retrieve Time complexity: O(log N) retrieve Space complexity: O(1) 삽입 / 삭제 불가 ","date":"2022-01-08","objectID":"/binary_search/:1:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Binary Search Tree (BST) n= number of elements, h = tree height 들어가기 앞서, ratsgo 를 참조하여 정리했음을 알려드립니다. 이진 탐색 트리란 Binary Search와 Linked list를 결합한 자료구조 입니다. 특히 Binary Search의 탐색 속도(O(log n)) 와 링크드리스트의 삽입/삭제 O(1)의 장점을 결합했다는 특징이 있습니다. 참고로 binary search는 삽입/삭제가 불가하며, 링크드리스트는 탐색 속도가 O(n)이라는 단점들이 있습니다. BST는 서로의 장점을 사용해 각각의 단점을 O(h)로 보완합니다. ","date":"2022-01-08","objectID":"/binary_search/:2:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"주요 특징 left.val \u003c root \u003c right.val inorder traverse(중위 순회)시 결과가 정렬된 리스트가 주어진다. left -\u003e node -\u003e right 구성하는 노드에서 중복된 노드가 없어야 한다. (unique 보장) 노드 끼리 우선순위 대소 비교가 가능해야 한다. retrieve, insert, delete의 계산복잡성은 모두 𝑂(ℎ) ","date":"2022-01-08","objectID":"/binary_search/:2:1","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"기본 데이터 형태 class Node: def __init__(self, val): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root: Optional[Node] = None def set_root(self, val): self.root = Node(val) ","date":"2022-01-08","objectID":"/binary_search/:2:2","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"retrieve / find Time Complexity: O(h) 탐색 대상과 root를 비교하여 left / right를 찾아나간다. 이 경우 Binary Search와 비슷하게 O(h) 시간 복잡도를 가진다. (아래와 같은 극단적 불균형 트리인 경우이면서, min/max값을 탐색한다면 O(n)) def find(self, val): node = self.find_node(self.root, val): return True if node else False def find_node(self, node, val) -\u003e Optional[Node]: if not node: return None elif val == node.val: return node elif val \u003c node.val: return self.find_node(node.left, val) else: return self.find_node(node.right, val) ","date":"2022-01-08","objectID":"/binary_search/:2:3","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"insert Time Complexity: O(h) O(logn)이 아닌 이유는 비대칭(Unbalanced Binary Tree)인 경우 tree의 높이가 n까지도 가능하기 때문이다. (sorted arr를 차례대로 insert 시킬경우) 이를 해결하기 위해서는 BF(balance factor)를 사용해 balance를 맞추는 AVL 또는 B-같은 트리를 사용해야 한다. def insert(self, val): if not self.root: self.set_root(val) else: self.insert_node(self.root, val) def insert_node(self, node, val): if val \u003c= node.val: if node.left: self.insert_node(node.left, val) else: node.left = Node(val) elif val \u003e node.val: if node.right: self.insert_node(node.right, val) else: node.right = Node(val) Tip AVL 트리는 rotation을 사용해 tree의 insert / delete 시 balance를 맞춘다. 그러므로 검색의 경우 항상 O(log n)을 보장한다. 특별한 점은 single rotation, double rotation을 통해서 tree의 balance를 맞추어 주는데 자세한 설명 을 참조하세요 ","date":"2022-01-08","objectID":"/binary_search/:2:4","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"delete Time Complexity: O(h) 삭제는 총 3가지 경우가 존재합니다. leaf node (자식노드가 없는 경우) -\u003e 그냥 제거 자식노드가 하나 존재하는 경우 -\u003e 제거 후, 자식 노드를 삭제된 노드의 부모로 연결 자식노드가 둘 존재하는 경우 이 경우에는 predecessor 또는 successor를 삭제할 노드와 위치를 뒤 바꾼 다음, 1와 2의 삭제 방법을 사용하면 됩니다. (참고로 successor와 predecessor는 자식노드가 1개 또는 없는 경우 밖에 존재하지 않습니다.) predecessor로 제거, successor로 제거 둘다 가능 합니다. Tip predecessor: 삭제 대상 노드의 왼쪽 서브트리 가운데 최대값 successor: 삭제 대상 노드의 오른쪽 서브트리 가운데 최소값 그림 기준으로 16을 inorder traverse를 해보면 다음과 같습니다. 4, 10, 13, 16, 20, 22, 25, 28, 30, 42 이때, predecessor(13), successor(20)가 됩니다. # delete 방법 (d = 삭제 대상 노드의 레벨) 1. 삭제 대상 노드의 오른쪽 서브트리를 찾는다. 2. successor(1에서 찾은 서브트리의 최소값) 노드를 찾는다. 3. 2에서 찾은 successor의 값을 삭제 대상 노드에 복사한다. 4. successor 노드를 삭제한다. 가장 계산이 복잡한 자식 노드가 둘 모두 존재하는 경우의 시간 복잡도를 분서해보겠습니다. 1에서 d레벨(트리 높이) 만큼 이동을 해주어야 하며, 2에서 최대 h-d 레벨(트리높이)만큼 이동해주어야 합니다. 3과 4의 연산은 계산에서 제외한다면 O(d + h -d) =\u003e O(h)가 만들어집니다. e.g) 간단히 가장 복잡할 것 같은 root를 지운다 가정하였을 때, d = 1, h = h이므로 O(1 + h - 1)이 됩니다. ","date":"2022-01-08","objectID":"/binary_search/:2:5","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"traverse (inorder) Time Complexity: O(n) 위의 그림의 경우 1 -\u003e 3 -\u003e 5 -\u003e 7 -\u003e 8 -\u003e 10로 순회 가능하다. def traverse(self): return self.traverse_node(self.root) def traverse_node(self, node): result = [] if node.left: result.extend(self.traverse_node(node.left)) if node: result.extend([node.val]) if node.right: result.extend(self.traverse_node(node.right)) return result ","date":"2022-01-08","objectID":"/binary_search/:2:6","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["algorithm"],"content":"Conclusion 이상으로 binary search와 bst에 대하여 알아 보았습니다. 관련해서 leetcode문제는 binary search 에 정리를 해두었습니다. - 끝 - ","date":"2022-01-08","objectID":"/binary_search/:3:0","tags":["algorithm","dev"],"title":"Binary Search and BST","uri":"/binary_search/"},{"categories":["dev"],"content":"All Basic Computer Science","date":"2022-01-06","objectID":"/interview/","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":" Let’s prepare basic computer science interview questions. ","date":"2022-01-06","objectID":"/interview/:0:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Operating System … ","date":"2022-01-06","objectID":"/interview/:1:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Network ","date":"2022-01-06","objectID":"/interview/:2:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일 키워드: dhcp, dns, nat, isp, 3-way / 4-way handshake, ssl (ssl handshake) 가장 먼저 브라우저가 url에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. OS는 DNS Lookup을 수행합니다. 룩업 과정은 etc/hosts \u003e DNS Cache \u003e Cache가 없을 경우 dns server로 ip를 얻어옵니다. DNS server로 ip request 이때 DNS server IP는 1차적으로 isp(internet service provider, ex kt, skt…)가 제공하는 정보들이 dhcp에 의해 컴퓨터에 세팅됩니다. dhcp는 wifi를 쓸 경우, 공유기에 연결되어있는 gateway ip와 router의 NAT을 통해 사설 ip(private ip)를 할당 받으며, 외부 통신을 할 경우 router의 Public ip을 사용합니다. ISP에 의해 세팅되어 있는 dns server로 아래 형식의 요청을 보내어, 도메인에 매핑된 ip를 받아옵니다. - from: router ip(nat ip) - to: 받아온 ip - 게이트웨이 ip : wifi이면 공유기 연결 게이트웨이 ip / 스마트폰이면 자체 ip 루트 도메인서버에서부터 서브도메인 서버순으로 dns query 이제 DNS Server로 DNS Query를 요청하게 되면 DNS 서버는 Root name server에 해당 도메인을 질의하고, .com name server의 ip를 받아오게 됩니다. 그 후 .com 네임 서버에 도메인 Query하게되면 google.com의 ip주소를 받고 최종적으로 www.google.com의 ip를 받아오게 됩니다. pc는 최종 서버 ip로 HTTP Request를 보낸다. 3-way handshake syn \u003e ack, syn \u003e ack 4-way handshake fin \u003e ack(close wait) \u003e fin(last_ack) \u003e ack tls/ssl 좀 더 자세한 과정 설명 # RSA 키 교환 알고리즘 1. client hello (protocol version, 암호 알고리즘, 압축 방식, 클라 난수) 2. server hello (세션 ID, ca 인증서, 서버난수) 3. verify ca and get public key 4. 클라는 난수(pre master secret) 생성 후 public key로 암호화 후 서버 전달 5. 클라 세션키 생성 및 서버는 난수를 private key로 복호화 하여 대칭키(세션 키) 생성 6. 클라는 세션키(대칭키)로 암호화한 fin message를 서버로 전달 7. 서버 또한 세션키로 암호화한 fin message를 전달 8. 이후 세션키를 통해 통신 계속 진행 ","date":"2022-01-06","objectID":"/interview/:2:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"TCP vs UDP TCP UDP 연결방식 연결형서비스 비 연결형 서비스 패킷 교환 방식 가상 회선 방식 데이터그램 방식 전송 순서 전송 순서 보장 전송 순서가 바뀔 수 있음 수신 여부 확인 수신 여부를 확인함 수신 여부를 확인하지 않음 통신 방식 1:1 통신만 가능 1:1 / 1:N / N:N 통신 모두 가능 신뢰성 높음 낮음 속도 느림 빠름 ","date":"2022-01-06","objectID":"/interview/:2:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Web Socket Handshake web socket mdn 클라와 서버가 서로 TCP/IP 4계층 레이어에서 통신한다. 즉 conneciton을 들고 있다. http 요청 이후, upgrade요청 한다. ping을 지속적으로 쏴서, health-check ","date":"2022-01-06","objectID":"/interview/:2:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"로드 밸런싱(Load Balancing) 로드 밸런싱이란 여러 서버에게 균등하게 트래픽을 분산 시켜주는 것이다. nginx의 경우 기본적으로 라운드 로빈 방식으로 동작합니다. scale-out scale-up ","date":"2022-01-06","objectID":"/interview/:2:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Nginx가 10k problem을 해결한 방식 기존 방식은 request당 하나의 process 또는 thread를 사용해서 요청들을 처리했습니다. 이에 반해 nginx는 worker pool을 두고 request가 들어올 때 마다, async하게 worker(default cpu 당 1)에게 task를 위임합니다. 이렇게 하게 될 경우 process/thread에 비해, pcb/tcb를 만드는데 들어가는 비용을 줄일 수 있으며 또한 사용자의 요청이 많아질 경우, 상대적으로 context switching에 사용되는 비용을 줄일 수 있습니다. 마지막으로 os가 스케쥴링에 들어가는 비용이 줄어듭니다. 즉 지정된 갯수의 미리생성된 process(thread) 워커를 사용함으로써, 기존의 request가 늘어날 때마다, os 리소스가 급격히 늘어나는 것을 방지하여, 이에 대한 side effect(스케쥴링, context-switching등에 대한 오버헤드를 막아줍니다.) 또한 워커에 필요한 리소스들을 미리 생성해두기 때문에 Process 생성에 들어가는 오버헤드를 줄여줍니다. ","date":"2022-01-06","objectID":"/interview/:2:5","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Database ","date":"2022-01-06","objectID":"/interview/:3:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB 트랜잭션이란? 트랜잭션은 데이터베이스의 데이터를 조작하는 논리적인 작업의 단위(unit of work)입니다. 트랜잭션은 ACID Atomicity all or nothing (rollback) db transaction, rollback으로 보장 Consistency transaction이 commit 되어도 DB의 여러 제약 조건에 맞는 상태를 보장하는 성질이다. 송금하는 사람의 계좌 잔고가 0보다 작아지면 안 된다. Isolation transaction이 진행되는 중간 상태의 데이터를 다른 transaction이 볼 수 없도록 보장하는 성질이다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데 받는 사람의 계좌에 돈이 아직 들어가지 않은 DB 상황을 다른 transaction이 읽으면 안 된다. lock으로 구현 Durability transaction이 Commit했을 경우 해당 결과가 영구적으로 적용됨을 보장하는 성질이다 ","date":"2022-01-06","objectID":"/interview/:3:1","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"트랜잭션과 lock에 대해서 isolation과 연결 지어 설명해주세요 DB엔진은 ACID 원칙을 희생하여 동시성을 얻을 수 있는 방법을 제공합니다. Row level lock shared lock: read lock exclusive lock: write lock Record lock s lock: read index lock x lock: write index lock Gap lock: db index record의 gap에 걸리는 lock (gap = db에 실제 record가 없는 부분) lock은 모두 transaction이 commit 되거나 rollback 될 때 함께 unlock Consistent read Isolation https://s1107.tistory.com/45 http://labs.brandi.co.kr/2019/06/19/hansj.html https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/ index https://idea-sketch.tistory.com/43?category=547413 https://idea-sketch.tistory.com/45 ","date":"2022-01-06","objectID":"/interview/:3:2","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"DB index에 대해 설명해주세요 https://idea-sketch.tistory.com/43?category=547413 ","date":"2022-01-06","objectID":"/interview/:3:3","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"todo dirty read, Non-Repeatable Read, Phantom Read optimistic lock, pessimistic lock slow query Index ","date":"2022-01-06","objectID":"/interview/:3:4","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Software Engineering ","date":"2022-01-06","objectID":"/interview/:4:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Design Pattern ","date":"2022-01-06","objectID":"/interview/:5:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Language ","date":"2022-01-06","objectID":"/interview/:6:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["dev"],"content":"Computer Architecture","date":"2022-01-06","objectID":"/interview/:7:0","tags":["dev","cs","interview"],"title":"All Basic Computer Science","uri":"/interview/"},{"categories":["algorithm"],"content":"About DFS and BFS","date":"2022-01-06","objectID":"/dfs_bfs/","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":" 간단하게 bfs와 dfs를 python으로 구현해보고, 상황별 장단점을 분석해본다. ","date":"2022-01-06","objectID":"/dfs_bfs/:0:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1. Graph Traverse ","date":"2022-01-06","objectID":"/dfs_bfs/:1:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.1. BFS from collections import deque graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } def bfs(start_node=\"5\"): queue = deque([start_node,]) visited = set() while queue: node = queue.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: queue.appendleft(neighbor) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:1","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.2. DFS graph = { '5' : ['3','7'], '3' : ['2', '4'], '7' : ['8'], '2' : [], '4' : ['8'], '8' : [] } # 5 8 7 3 4 2 def dfs(start_node=\"5\"): stack = [start_node,] visited = set() while stack: node = stack.pop() if node in visited:continue visited.add(node) for neighbor in graph[node]: stack.append(neighbor) def recursive_dfs(node=\"5\", visited = set()): visited.add(node) for neighbor in graph[node]: if neighbor in visited: continue recursive_dfs(neighbor, visited) ","date":"2022-01-06","objectID":"/dfs_bfs/:1:2","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"1.3. BFS vs DFS 문제 유형별로 어떤 알고리즘이 더 유리한지 서술합니다.  : impossible  : good and possible  : bad but possible index Problem BFS DFS 1 그래프의 모든 정점을 방문 하는 문제 2 각 경로 마다 특징을 저장해둬야 하는 문제 3 최단 거리 문제 4 문제의 그래프가 매우 클 경우 5 검색 시작 지점과 원하는 대상이 가까이 있을 경우 단순히 모든 node 방문이라면 둘 모두 사용가능합니다. a-\u003eb로 가는 경로를 구할 때, 경로 안에서 같은 숫자가 x번 이상 없어야 하는 경우, dfs는 함수의 인자에 local 변수들을 좀 더 손 쉽게 줄 수 있는 반면, queue를 활용하는 bfs는 상태를 기억하기 좀 더 까다롭다. 물론 queue에 node를 넣을 때, local state를 같이 넣어주면 되긴 하지만, 이는 명시적이지 못하므로 dfs가 더 유리하다 생각된다. bfs의 경우 level(e.g 이동 count, tree의 level, ) 단위로 확장되기 때문에 목적지에 도착하는 순간 return한 값이 최소 이동거리가 되지만, dfs의 경우에는 깊이 있게 하나씩 파니까 상대적으로 bfs보다 오래 걸린다. Python의 경우 하나의 리스트가 가질 수 있는 Py_ssize_t는 536870912인 반면, 함수에 대한 메모리 제한은 두지 않고 있다. 그러므로 queue를 이용해서 구현하는 bfs의 경우 그래프가 크다면, 제한이 있는 반면 recursive function으로 구현한 dfs한정(stack으로 구현한 경우 동일한 문제발생)해서 function call stack을 사용해서 메모리 관리를 하기 때문에 상대적으로 더 큰 그래프 탐색에 사용될 수 있다. 3.의 경우와 같은 원리이다. ","date":"2022-01-06","objectID":"/dfs_bfs/:1:3","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"Conclusion 필자는 왠만하면 bfs를 좀 더 선호하는 경향이 있는데, 과거의 경험을 떠올려 보면, (정확하게 기억은 나지 않지만) path가 연속적으로 이어져야하는 로직에서 bfs가 불편했던 것 같다. DFS의 경우에는 처음부터 끝까지 연속적으로 탐색하기 때문에 비교적 쉽게 구현이 되었는데, BFS는 spread 하면서 이동하기 때문에 해당 상황에서 불리 했던 것 같다. dfs, bfs를 언제 써야하는지 개인적으로 헷갈렸었는데 표로 정리하고 나니 나중에도 유용하게 볼 것 같다. - 끝 - ","date":"2022-01-06","objectID":"/dfs_bfs/:2:0","tags":["algorithm","dev"],"title":"DFS and BFS","uri":"/dfs_bfs/"},{"categories":["algorithm"],"content":"About Binary Tree","date":"2022-01-06","objectID":"/binary_tree/","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":" Binary Tree관련 알고리즘들을 학습하고 정리합니다. ","date":"2022-01-06","objectID":"/binary_tree/:0:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Binary Tree child \u003e 2면 안된다. parent \u003e 1이면 안된다. root(부모가 없는 노드)는 한개만 존재해야 한다. array로 구현하면 편의를 위해 0인덱스를 비워둔다. parent = child % 2 lchild = parent * 2 rchild = parent * 2 + 1 ","date":"2022-01-06","objectID":"/binary_tree/:1:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap max heap, min heap (등호도 고려된다.) 대소 관계는 부모-자녀 간에만 고려된다. left child 먼저 삽입된다. (즉 leaf 중에 left 없이 right가 있는 경우는 없다.) ","date":"2022-01-06","objectID":"/binary_tree/:2:0","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap insert 인덱스 마지막에 새로운 요소 append (if parent is exist) 부모와 대소 비교 하여 exchange. (아래 -\u003e 위 heapify) ","date":"2022-01-06","objectID":"/binary_tree/:2:1","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap pop root pop 힙의 마지막 element를 root로 이동 힙 재구성 (= 위 -\u003e 아래 heapify) (if child exist) l, r 비교하여 현재 노드가 작다면 exchange (max heap 기준) 재귀적으로 반복 ","date":"2022-01-06","objectID":"/binary_tree/:2:2","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["algorithm"],"content":"Heap sort O(n + n*logn) =\u003e O(nlogn) Max heap 구성(O(n)) 루트와 말단 노드 교체 후 heapify (O(nlogn)) O(logn) = 트리 최대 높이 = heapify시 depth n = 모든 노드들에 대하여 검사 ","date":"2022-01-06","objectID":"/binary_tree/:2:3","tags":["algorithm","dev"],"title":"Binary Tree","uri":"/binary_tree/"},{"categories":["todo"],"content":" This article is a simple list of todos that I will write to blog in my future. ","date":"2022-01-02","objectID":"/todo/:0:0","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1. TODO LIST ","date":"2022-01-02","objectID":"/todo/:1:0","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.1. Plan 21년 회고 22년 목표 ","date":"2022-01-02","objectID":"/todo/:1:1","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.2. Diary 나는 누구이고, 지금 어디에 존재하는가? 오쇼 글귀 정리 과거 네이버 / 커스텀 블로그 / 일기 글 migration 지금 나에겐 가치없는 글. ","date":"2022-01-02","objectID":"/todo/:1:2","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.3. Server Dev hugo 블로그 구축기 kotlin 공부했던 글 정리 우선순위가 떨어진다. c++ 7장까지 들었던 글 정리 kotlin in action ","date":"2022-01-02","objectID":"/todo/:1:3","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.4. Block chain binance academy gall dcinside 이더리움 크립토 좀비 디파이 로드맵 book: Mastering bitcoin, Mastering etherium web3.0 coin: 폴리곤, 폴카닷, 루나 etc coin: 솔라나 ","date":"2022-01-02","objectID":"/todo/:1:4","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.5. Startup 온라인 전자담배 도매부터 판매까지 사업자 등록 도매 물품 구매 사이트 도메인 등록 및 사이트 운영 사이트 관련 홍보 및 상품 소개 글 작성 및 크롤러 확보 결제 시스템 부착 상품 관련 법률사항 검토 및 사이트 명시 Honestly, 판매전까지의 모든 단계를 완성. 즉 판매를 실패했다. 이유는 이직이 되어서도 있고, 친구와 내 가치관이 달라서 준비하는 과정과 업무 분배에 있어서 명확학지 않았다. 2022년을 마무리하며 돌아보니, 그때는 내가 멋져보이고 싶었고, 돈을 빨리 벌고 싶었던 것 같다. ","date":"2022-01-02","objectID":"/todo/:1:5","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["todo"],"content":"1.6. Phrase 내 어록 쓰기 ","date":"2022-01-02","objectID":"/todo/:1:6","tags":["todo","diary"],"title":"2022 Todo List","uri":"/todo/"},{"categories":["hugo"],"content":"Hugo로 블로그 만들기","date":"2022-01-02","objectID":"/initial_hugo/","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":" This article describes a series of technical steps to building this serious blog using the hugo framework . 사실 Hugo는 20년도에 혼자 제주도 여행을 가면서, 생각을 정리하고 싶어서 눈여겨 봤던 프레임워크이다. 당시 go를 공부하고 있었기 때문에 go로 만들어진 프레임워크라는 점에서 호감 +99점을 받았고, 이름이 다른 프레임워크들에 비해서 짧다는 장점이 있다. 🤔 Gatsby는 무슨 왁스 이름같고, Jekyll는 스펠링도 어렵고 사실 어떻게 발음해야 될지도 잘 모를정도로 이름이 못생김 이 블로그는 hugo와 LoveIt 을 사용해 만들었다. keywords Hugo LoveIt git submodule github workflows shell script ","date":"2022-01-02","objectID":"/initial_hugo/:0:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1. Pre-Init Blog MacBook Pro (16-inch, 2019) Big Sur ","date":"2022-01-02","objectID":"/initial_hugo/:1:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.1. Install hugo install hugo docs # Install brew $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # download hugo $ brew install hugo # check hugo is successfully downloaded $ hugo version ","date":"2022-01-02","objectID":"/initial_hugo/:1:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.2. Select hugo templaate github에서 hugo를 검색하고, star많은 순으로 정렬 겉보기 이쁘다고 무턱대고 템플릿 가져다 쓰면, 아마 빠른시일 안에 블로그를 포기할 것임.. 1k 넘는 레포 중에서 이쁜거 찾는다. 검색 카테고리 기능 dark/light mode 댓글 기능 추천하는 테마들은 다음과 같다. ✅ https://github.com/dillonzq/LoveIt 👍 https://github.com/zzossig/hugo-theme-zzo https://github.com/luizdepra/hugo-coder https://github.com/adityatelange/hugo-PaperMod ","date":"2022-01-02","objectID":"/initial_hugo/:1:2","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"1.3. Generate your profile image 프로필 이미지 생성한 곳 이말년 스타일 프로필 이미지 필자는 프로필 사진에 cartoonize를 써보고 싶어서 github에서 ML 모델 위주로 검색했는데 원하는 곳을 찾지 못해서 대안으로 여기 를 사용 하게 되었다. 이말년 그림체로 프로필 만들고 싶은데 뭔가 해줘야 할게 많아서 포기… 누가 online 서버 만들어주면 좋겠다…🥺 기타 작품들 열정적인 스터디원들 ","date":"2022-01-02","objectID":"/initial_hugo/:1:3","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2. Init Blog 자 본격적으로 블로그 만들어보자. ","date":"2022-01-02","objectID":"/initial_hugo/:2:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"2.1. Generate Blog 먼저 블로그용 폴더를 만들고 템플릿을 submodule로 추가해보자. # hugo new site \u003cYOUR FOLDER NAME\u003e $ hugo new site love $ cd love $ git init $ git branch -M main # git remote add origin \u003cYOUR ROOT REPOSITORY\u003e $ git remote add origin https://github.com/minkj1992/love.git # git submodule add \u003cTHEME REPOSITORY\u003e themes/\u003cTHEME_NAME\u003e $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # + 사내 계정이라 config 변경 $ git config user.email minkj1992@gmail.com $ git config user.name \"minkj1992\" 필자의 경우 github page를 사용해서 블로그를 운영할 것이기 때문에, 미리 생성했던 YOUR_ID.github.io레포지토리를 submodule로 등록한다. # git submodule add \u003cYOUR_ID.github.io\u003e public $ git submodule add https://github.com/minkj1992/minkj1992.github.io public Warning $ git submodule add \u003cYOUR_ID.github.io\u003e public 명령어를 칠 때, 꼭 public을 디렉토리로 넣어주어야 한다! hugo는 스태틱 파일들을 public/ 디렉토리로 빌드해주고, 우리의 *.github.io는 블로그의 스태틱 파일들을 가지고 있어야 하니까 :) LoveIt config.toml 의 example config.toml을 참조해서, 본인의 블로그 루트 디렉토리에 config.toml을 생성하고 필요한 설정들을 추가해주자. $ cp ./themes/LoveIt/exampleSite/config.toml ./config.toml # if you want to add image to site home $ mkdir -p assets/images # after this command, paste your profile \u0026 log image to images and change config.toml # (OPTIONAL) If you want to change css font-famiully and size, customize scss file. $ touch assets/_override.scss 자 이제 첫 글을 작성해보자. 주의할점은 draft:false가 되어있어야 hugo를 github page 배포했을 때, 깨지지 않고 배포 된다. # *.md draft must be falsed! $ hugo new posts/initial_post.md 글을 작성했다면, 로컬에서 실행시켜보자 (hot-reload적용 됨) 참고로 commit이 안되서, 실행이 안된다고 하니 이쯤에서 우선 커밋 먼저 해준다. (fatal: your current branch 'main' does not have any commits yet) $ git add . \u0026\u0026 git commit -m\"Initial commit\" # hot reload debug run server $ hugo server -D 정상적으로 블로그가 동작하는걸 확인했다면 배포를 해보자. 배포는 아래 과정을 거쳐 진행된다. hugo build ($ hugo) ./public commit \u0026 push (submodule e.g minkj1992.github.io) root repository push 먼저 hugo를 빌드하면 public/ 디렉토리에 파일들이 추가 된다. 추가된 파이들을 public의 remote로 push해주고, root 레포지토리로 돌아가서 push 해주면 된다. 필자는 아래의 스크립트를 사용해서 해당 과정을 진행해주고 있다. 2.1.1. git-push.sh #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32m I Love Leoo.j \\033[0m\\n\" printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" printf \"\\033[0;32mBuild the project.\\033[0m\\n\" hugo -D # hugo -t timeline # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\033[0;32m Go To Public folder \\033[0m\\n\" cd public printf \"\\033[0;32m Setting for submodule commit \\033[0m\\n\" git config --local user.name \"minkj1992\" git config --local user.email \"minkj1992@gmail.com\" git submodule update --init --recursive printf \"\\033[0;32m Add changes to git. \\033[0m\\n\" git add . printf \"\\033[0;32m Commit changes.. \\033[0m\\n\" msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" printf \"\\033[0;32m Push blog(presentation) source and build repos. \\033[0m\\n\" git push origin main printf \"\\033[0;32m Come Back up to the Project Root \\033[0m\\n\" cd .. echo $pwd printf \"\\033[0;32m root repository Commit \u0026 Push. \\033[0m\\n\" git add . msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" git push origin main shell을 만들었다면, 이제 배포 해보자. $ sh git-push.sh \u003cCOMMIT_MSG\u003e Tip 만약 github action을 사용하고 싶다면, https://github.com/minkj1992/love/blob/main/.github/samples/gh-pages.sample 를 사용 해보라. (단 secrets.PERSONAL_TOKEN은 github setting에서 ENV등록해 주어야 함) git hook을 쓰면 커밋이 편하긴 하지만, 개인적으로는 hook을 쓰면 로컬의 public/ 디렉토리의 git 버저닝이 관리되지 않고 있는게 눈에 거슬려서 shell을 사용 중이다. ","date":"2022-01-02","objectID":"/initial_hugo/:2:1","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["hugo"],"content":"3. Conclusion Nexters에서 2021년 회고글 작성하는 모임에 참석해서, 많은 개발자 분들이 notion으로 글을 정리하는 것에 자극 받아서, 바로 블로그를 만들게 되었는데 개인적으로 만족스럽다. 생각보다 에러 잡는데 시간을 많이 지체한 것 같고, github hook부분 기능을 잘 몰라 커스터마이징 하고 싶어 이것 저것 만져보다가 토요일 하루가 꼬박 걸렸는데 이 글을 읽는 여러분은 제가 했던 삽질을 경험하지 않길 바란다. - 끝 - ","date":"2022-01-02","objectID":"/initial_hugo/:3:0","tags":["hugo","blog","LoveIt"],"title":"Let's create blog with Hugo","uri":"/initial_hugo/"},{"categories":["Markdown"],"content":"This article shows the basic Markdown syntax and format.","date":"2022-01-01","objectID":"/first_post/","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":" This article offers a sample of basic Markdown syntax that can be used in Hugo content files. Note This article is a shameful copy of the great Grav original page . If you want to know about the extented Markdown syntax of LoveIt theme, please read extended Markdown syntax page . Let’s face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages. Markdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it. Some of the key benefits are: Markdown is simple to learn, with minimal extra characters, so it’s also quicker to write content. Less chance of errors when writing in Markdown. Produces valid XHTML output. Keeps the content and the visual display separate, so you cannot mess up the look of your site. Write in any text editor or Markdown application you like. Markdown is a joy to use! John Gruber, the author of Markdown, puts it like this: The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email. – John Gruber Without further delay, let us go over the main elements of Markdown and what the resulting HTML looks like! Tip  Bookmark this page for easy future reference! ","date":"2022-01-01","objectID":"/first_post/:0:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"1. Headings Headings from h2 through h6 are constructed with a # for each level: ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading The HTML looks like this: \u003ch2\u003eh2 Heading\u003c/h2\u003e \u003ch3\u003eh3 Heading\u003c/h3\u003e \u003ch4\u003eh4 Heading\u003c/h4\u003e \u003ch5\u003eh5 Heading\u003c/h5\u003e \u003ch6\u003eh6 Heading\u003c/h6\u003e Heading IDs To add a custom heading ID, enclose the custom ID in curly braces on the same line as the heading: ### A Great Heading {#custom-id} The HTML looks like this: \u003ch3 id=\"custom-id\"\u003eA Great Heading\u003c/h3\u003e ","date":"2022-01-01","objectID":"/first_post/:1:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"2. Comments Comments should be HTML compatible. \u003c!-- This is a comment --\u003e Comment below should NOT be seen: ","date":"2022-01-01","objectID":"/first_post/:2:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"3. Horizontal Rules The HTML \u003chr\u003e element is for creating a “thematic break” between paragraph-level elements. In Markdown, you can create a \u003chr\u003e with any of the following: ___: three consecutive underscores ---: three consecutive dashes ***: three consecutive asterisks The rendered output looks like this: ","date":"2022-01-01","objectID":"/first_post/:3:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"4. Body Copy Body copy written as normal, plain text will be wrapped with \u003cp\u003e\u003c/p\u003e tags in the rendered HTML. So this body copy: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. The HTML looks like this: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e A line break can be done with one blank line. ","date":"2022-01-01","objectID":"/first_post/:4:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"5. Inline HTML If you need a certain HTML tag (with a class) you can simply use HTML: Paragraph in Markdown. \u003cdiv class=\"class\"\u003e This is \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Paragraph in Markdown. ","date":"2022-01-01","objectID":"/first_post/:5:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6. Emphasis ","date":"2022-01-01","objectID":"/first_post/:6:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.1. Bold For emphasizing a snippet of text with a heavier font-weight. The following snippet of text is rendered as bold text. **rendered as bold text** __rendered as bold text__ The HTML looks like this: \u003cstrong\u003erendered as bold text\u003c/strong\u003e ","date":"2022-01-01","objectID":"/first_post/:6:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.2. Italics For emphasizing a snippet of text with italics. The following snippet of text is rendered as italicized text. *rendered as italicized text* _rendered as italicized text_ The HTML looks like this: \u003cem\u003erendered as italicized text\u003c/em\u003e ","date":"2022-01-01","objectID":"/first_post/:6:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.3. Strikethrough In GFMGitHub flavored Markdown you can do strikethroughs. ~~Strike through this text.~~ The rendered output looks like this: Strike through this text. The HTML looks like this: \u003cdel\u003eStrike through this text.\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"6.4. Combination Bold, italics, and strikethrough can be used in combination. ***bold and italics*** ~~**strikethrough and bold**~~ ~~*strikethrough and italics*~~ ~~***bold, italics and strikethrough***~~ The rendered output looks like this: bold and italics strikethrough and bold strikethrough and italics bold, italics and strikethrough The HTML looks like this: \u003cem\u003e\u003cstrong\u003ebold and italics\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003estrikethrough and bold\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003estrikethrough and italics\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003ebold, italics and strikethrough\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2022-01-01","objectID":"/first_post/:6:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"7. Blockquotes For quoting blocks of content from another source within your document. Add \u003e before any text you want to quote: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The rendered output looks like this: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The HTML looks like this: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e Blockquotes can also be nested: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. The rendered output looks like this: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2022-01-01","objectID":"/first_post/:7:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8. Lists ","date":"2022-01-01","objectID":"/first_post/:8:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.1. Unordered A list of items in which the order of the items does not explicitly matter. You may use any of the following symbols to denote bullets for each list item: * valid bullet - valid bullet + valid bullet For example: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2022-01-01","objectID":"/first_post/:8:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.2. Ordered A list of items in which the order of items does explicitly matter. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem The HTML looks like this: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e Tip If you just use 1. for each number, Markdown will automatically number each item. For example: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem The rendered output looks like this: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2022-01-01","objectID":"/first_post/:8:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"8.3. Task Lists Task lists allow you to create a list of items with checkboxes. To create a task list, add dashes (-) and brackets with a space ([ ]) before task list items. To select a checkbox, add an x in between the brackets ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media The rendered output looks like this: Write the press release Update the website Contact the media ","date":"2022-01-01","objectID":"/first_post/:8:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9. Code ","date":"2022-01-01","objectID":"/first_post/:9:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.1. Inline Code Wrap inline snippets of code with `. In this example, `\u003csection\u003e\u003c/section\u003e` should be wrapped as **code**. The rendered output looks like this: In this example, \u003csection\u003e\u003c/section\u003e should be wrapped as code. The HTML looks like this: \u003cp\u003e In this example, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e should be wrapped with \u003cstrong\u003ecode\u003c/strong\u003e. \u003c/p\u003e ","date":"2022-01-01","objectID":"/first_post/:9:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.2. Indented Code Or indent several lines of code by at least four spaces, as in: // Some comments line 1 of code line 2 of code line 3 of code The rendered output looks like this: // Some comments line 1 of code line 2 of code line 3 of code The HTML looks like this: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.3. Block Fenced Code Use “fences” ``` to block in multiple lines of code with a language attribute. ```markdown Sample text here... ``` The HTML looks like this: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2022-01-01","objectID":"/first_post/:9:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"9.4. Syntax Highlighting GFMGitHub Flavored Markdown also supports syntax highlighting. To activate it, simply add the file extension of the language you want to use directly after the first code “fence”, ```js, and syntax highlighting will automatically be applied in the rendered HTML. For example, to apply syntax highlighting to JavaScript code: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` The rendered output looks like this: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Note Syntax highlighting page in Hugo Docs introduces more about syntax highlighting, including highlight shortcode. ","date":"2022-01-01","objectID":"/first_post/:9:4","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"10. Tables Tables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. The HTML looks like this: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e Right or center aligned text Adding a colon on the right side of the dashes below any heading will right align text for that column. Adding colons on both sides of the dashes below any heading will center align text for that column. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2022-01-01","objectID":"/first_post/:10:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11. Links ","date":"2022-01-01","objectID":"/first_post/:11:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.1. Basic Link \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) The rendered output looks like this (hover over the link, there is no tooltip): https://assemble.io contact@revolunet.com Assemble The HTML looks like this: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:1","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.2. Add a Title [Upstage](https://github.com/upstage/ \"Visit Upstage!\") The rendered output looks like this (hover over the link, there should be a tooltip): Upstage The HTML looks like this: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2022-01-01","objectID":"/first_post/:11:2","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"11.3. Named Anchors Named anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) will jump to these sections: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. Note The specific placement of the anchor tag seems to be arbitrary. They are placed inline here since it seems to be unobtrusive, and it works. ","date":"2022-01-01","objectID":"/first_post/:11:3","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"12. Footnotes Footnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page. To create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially. Add the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables. This is a digital footnote[^1]. This is a footnote with \"label\"[^label] [^1]: This is a digital footnote [^label]: This is a footnote with \"label\" This is a digital footnote1. This is a footnote with “label”2 ","date":"2022-01-01","objectID":"/first_post/:12:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"},{"categories":["Markdown"],"content":"13. Images Images have a similar syntax to links but include a preceding exclamation point. ![Minion](https://octodex.github.com/images/minion.png) or: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat Like links, images also have a footnote style syntax: ![Alt text][id] The DojocatAlt text \" The Dojocat With a reference later in the document defining the URL location: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" This is a digital footnote ↩︎ This is a footnote with “label” ↩︎ ","date":"2022-01-01","objectID":"/first_post/:13:0","tags":["Markdown","HTML"],"title":"Initial Post","uri":"/first_post/"}]